/* 鸡肋
int CEpollWrap::add_client(string ip, unsigned int port)
{
	if(m_epollFD < 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "epoll not created");
		return -1;
	}

	CTcpClientSocket s;
	int ret = s.init();
	if(ret < 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "CTcpClientSocket::init %s", s.errmsg());
		return -1;
	}

	//先阻塞连接，在开始epoll之前就发现问题的好。
	ret = s.connect(ip, port);
	if(ret < 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "CTcpClientSocket::connect %s", s.errmsg());
		return -1;
	}

	ret = s.set_nonblock();
	if(ret < 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "CTcpClientSocket::set_nonblock %s", s.errmsg());
		return -1;
	}

	int fd = s.get_socket();

	//epoll加入
	if(add_event(fd, EPOLLIN|EPOLLOUT) < 0)
		return -1;

	FDINFO info;
	info.fd = fd;
	info.type = TYPE_CLIENT;
	info.sessionID.tcpaddr.ip = s.getSK()->sin_addr.s_addr;
	info.sessionID.tcpaddr.port = s.getSK()->sin_port;
	info.sessionID.tcpaddr.seq = m_seq++;
	info.state = 1;//已经连接上的
	m_mapFD[fd] = info; //插入到map中

	s.pass_socket();//临时对象不再管理这个fd

	return 0;
}


int CEpollWrap::add_other_fd(int fd)
{
	if(m_epollFD < 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "epoll not created");
		return -1;
	}


	int flags = fcntl(fd, F_GETFL, 0);
	if(flags < 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "fcntl(F_GETFL) %d(%s)", errno, strerror(errno));
		return -1;
	}

	if(fcntl(fd, F_SETFL, flags | O_NONBLOCK) < 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "fcntl(F_SETFL, %d) %d(%s)", flags, errno, strerror(errno));
		return -1;
	}

	//epoll加入
	if(add_event(fd, EPOLLIN|EPOLLOUT) < 0)
		return -1;

	FDINFO info;
	info.fd = fd;
	info.type = TYPE_CLIENT;
	info.sessionID.id = m_seq++;
	info.state = 0;
	m_mapFD[fd] = info; //插入到map中

	return 0;
}
*/

/*
int CEpollWrap::client_reconnect(FDINFO* pinfo)
{
	CTcpClientSocket s;
	int ret = s.init();
	if(ret < 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "CTcpClientSocket::init %s", s.errmsg());
		return -1;
	}

	ret = s.set_nonblock();
	if(ret < 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "CTcpClientSocket::set_nonblock %s", s.errmsg());
		return -1;
	}

	int fd = s.get_socket();

	//非阻塞的connect
	sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_port = pinfo->sessionID.tcpaddr.port;
	addr.sin_addr.s_addr =  pinfo->sessionID.tcpaddr.ip;
	int state = 0;
	int ret = connect(fd, (sockaddr*)&addr, sizeof(addr));
	if(ret == 0)
	{
		state = 1;
	}
	if(ret < 0 && errno!=EINPROGRESS)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "connect()  %d(%s)", errno, strerror(errno));
		return -1;
	}

	//替换新的fd
	//删
	epoll_event ignored;
	if(epoll_ctl(m_epollFD, EPOLL_CTL_DEL, fd, &ignored) < 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "epoll_ctl(EPOLL_CTL_DEL)  %d(%s)", errno, strerror(errno));
		return -1;
	}
	close(pinfo->fd);
	m_mapFD.erase(pinfo->fd);

	//加
	if(add_event(fd, EPOLLIN|EPOLLOUT) < 0)
	{
		return -1;
	}
	
	FDINFO info;
	info.fd = fd;
	info.type = TYPE_CLIENT;
	info.sessionID.tcpaddr.ip = addr.sin_addr.s_addr;
	info.sessionID.tcpaddr.port = addr.sin_port;
	info.sessionID.tcpaddr.seq = m_seq++;
	info.state = state; 

	m_mapFD[fd] = info; //插入到map中

	s.pass_socket();//临时对象不再管理这个fd
	
	return 0;
}

int CEpollWrap::check_connected(FDINFO* pinfo)
{
	int iErr = -1;
	int iErrLen = sizeof(iErr);
	int ret = getsockopt(pinfo->fd, SOL_SOCKET, SO_ERROR, (char *)&iErr, (socklen_t*)&iErrLen);
	if(ret != 0)
	{
		snprintf(m_errmsg, sizeof(m_errmsg), "getsockopt()=%d fail Err(%d,%s)", ret, errno, strerror(errno));
		return -1;
	}
	else
	{
		if(iErr!= 0)
		{
			snprintf(m_errmsg, sizeof(m_errmsg), "connect(%d,%s)", iErr, strerror(iErr));
			return -1;
		}
	}

	return 0;
}
*/