// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: inner_cmd.proto

#ifndef PROTOBUF_inner_5fcmd_2eproto__INCLUDED
#define PROTOBUF_inner_5fcmd_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "CmdGroup.pb.h"
#include "UserSync.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_inner_5fcmd_2eproto();
void protobuf_AssignDesc_inner_5fcmd_2eproto();
void protobuf_ShutdownFile_inner_5fcmd_2eproto();

class RsyncLogicStatus;
class RsyncLogicStatus_CentreInfo;
class Rsync2GlobalCB;
class InnerCDKEYReq;
class InnerCDKEYResp;
class InnerQueryBeforeRegReq;
class InnerQueryBeforeReqResp;
class Multicast;
class UserInfoReportReq;
class ServerBroadcastReq;
class ServerBroadcastResp;

enum UserInfoReportReq_ActType {
  UserInfoReportReq_ActType_REGIST = 0
};
bool UserInfoReportReq_ActType_IsValid(int value);
const UserInfoReportReq_ActType UserInfoReportReq_ActType_ActType_MIN = UserInfoReportReq_ActType_REGIST;
const UserInfoReportReq_ActType UserInfoReportReq_ActType_ActType_MAX = UserInfoReportReq_ActType_REGIST;
const int UserInfoReportReq_ActType_ActType_ARRAYSIZE = UserInfoReportReq_ActType_ActType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserInfoReportReq_ActType_descriptor();
inline const ::std::string& UserInfoReportReq_ActType_Name(UserInfoReportReq_ActType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserInfoReportReq_ActType_descriptor(), value);
}
inline bool UserInfoReportReq_ActType_Parse(
    const ::std::string& name, UserInfoReportReq_ActType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserInfoReportReq_ActType>(
    UserInfoReportReq_ActType_descriptor(), name, value);
}
enum ServerBroadcastResp_Result {
  ServerBroadcastResp_Result_OK = 0,
  ServerBroadcastResp_Result_FAIL = -1
};
bool ServerBroadcastResp_Result_IsValid(int value);
const ServerBroadcastResp_Result ServerBroadcastResp_Result_Result_MIN = ServerBroadcastResp_Result_FAIL;
const ServerBroadcastResp_Result ServerBroadcastResp_Result_Result_MAX = ServerBroadcastResp_Result_OK;
const int ServerBroadcastResp_Result_Result_ARRAYSIZE = ServerBroadcastResp_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerBroadcastResp_Result_descriptor();
inline const ::std::string& ServerBroadcastResp_Result_Name(ServerBroadcastResp_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerBroadcastResp_Result_descriptor(), value);
}
inline bool ServerBroadcastResp_Result_Parse(
    const ::std::string& name, ServerBroadcastResp_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerBroadcastResp_Result>(
    ServerBroadcastResp_Result_descriptor(), name, value);
}
// ===================================================================

class RsyncLogicStatus_CentreInfo : public ::google::protobuf::Message {
 public:
  RsyncLogicStatus_CentreInfo();
  virtual ~RsyncLogicStatus_CentreInfo();

  RsyncLogicStatus_CentreInfo(const RsyncLogicStatus_CentreInfo& from);

  inline RsyncLogicStatus_CentreInfo& operator=(const RsyncLogicStatus_CentreInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RsyncLogicStatus_CentreInfo& default_instance();

  void Swap(RsyncLogicStatus_CentreInfo* other);

  // implements Message ----------------------------------------------

  RsyncLogicStatus_CentreInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RsyncLogicStatus_CentreInfo& from);
  void MergeFrom(const RsyncLogicStatus_CentreInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string centre_ip = 7;
  inline bool has_centre_ip() const;
  inline void clear_centre_ip();
  static const int kCentreIpFieldNumber = 7;
  inline const ::std::string& centre_ip() const;
  inline void set_centre_ip(const ::std::string& value);
  inline void set_centre_ip(const char* value);
  inline void set_centre_ip(const char* value, size_t size);
  inline ::std::string* mutable_centre_ip();
  inline ::std::string* release_centre_ip();
  inline void set_allocated_centre_ip(::std::string* centre_ip);

  // optional int32 centre_port = 8;
  inline bool has_centre_port() const;
  inline void clear_centre_port();
  static const int kCentrePortFieldNumber = 8;
  inline ::google::protobuf::int32 centre_port() const;
  inline void set_centre_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RsyncLogicStatus.CentreInfo)
 private:
  inline void set_has_centre_ip();
  inline void clear_has_centre_ip();
  inline void set_has_centre_port();
  inline void clear_has_centre_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* centre_ip_;
  ::google::protobuf::int32 centre_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static RsyncLogicStatus_CentreInfo* default_instance_;
};
// -------------------------------------------------------------------

class RsyncLogicStatus : public ::google::protobuf::Message {
 public:
  RsyncLogicStatus();
  virtual ~RsyncLogicStatus();

  RsyncLogicStatus(const RsyncLogicStatus& from);

  inline RsyncLogicStatus& operator=(const RsyncLogicStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RsyncLogicStatus& default_instance();

  void Swap(RsyncLogicStatus* other);

  // implements Message ----------------------------------------------

  RsyncLogicStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RsyncLogicStatus& from);
  void MergeFrom(const RsyncLogicStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RsyncLogicStatus_CentreInfo CentreInfo;

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // repeated int32 idx = 3;
  inline int idx_size() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 3;
  inline ::google::protobuf::int32 idx(int index) const;
  inline void set_idx(int index, ::google::protobuf::int32 value);
  inline void add_idx(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      idx() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_idx();

  // required string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required int32 max_client = 5;
  inline bool has_max_client() const;
  inline void clear_max_client();
  static const int kMaxClientFieldNumber = 5;
  inline ::google::protobuf::int32 max_client() const;
  inline void set_max_client(::google::protobuf::int32 value);

  // required int32 cur_client = 6;
  inline bool has_cur_client() const;
  inline void clear_cur_client();
  static const int kCurClientFieldNumber = 6;
  inline ::google::protobuf::int32 cur_client() const;
  inline void set_cur_client(::google::protobuf::int32 value);

  // repeated .RsyncLogicStatus.CentreInfo centre_list = 7;
  inline int centre_list_size() const;
  inline void clear_centre_list();
  static const int kCentreListFieldNumber = 7;
  inline const ::RsyncLogicStatus_CentreInfo& centre_list(int index) const;
  inline ::RsyncLogicStatus_CentreInfo* mutable_centre_list(int index);
  inline ::RsyncLogicStatus_CentreInfo* add_centre_list();
  inline const ::google::protobuf::RepeatedPtrField< ::RsyncLogicStatus_CentreInfo >&
      centre_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::RsyncLogicStatus_CentreInfo >*
      mutable_centre_list();

  // optional int32 max_reg = 9;
  inline bool has_max_reg() const;
  inline void clear_max_reg();
  static const int kMaxRegFieldNumber = 9;
  inline ::google::protobuf::int32 max_reg() const;
  inline void set_max_reg(::google::protobuf::int32 value);

  // optional int32 cur_reg = 10;
  inline bool has_cur_reg() const;
  inline void clear_cur_reg();
  static const int kCurRegFieldNumber = 10;
  inline ::google::protobuf::int32 cur_reg() const;
  inline void set_cur_reg(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RsyncLogicStatus)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_max_client();
  inline void clear_has_max_client();
  inline void set_has_cur_client();
  inline void clear_has_cur_client();
  inline void set_has_max_reg();
  inline void clear_has_max_reg();
  inline void set_has_cur_reg();
  inline void clear_has_cur_reg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > idx_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 max_client_;
  ::std::string* version_;
  ::google::protobuf::RepeatedPtrField< ::RsyncLogicStatus_CentreInfo > centre_list_;
  ::google::protobuf::int32 cur_client_;
  ::google::protobuf::int32 max_reg_;
  ::google::protobuf::int32 cur_reg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static RsyncLogicStatus* default_instance_;
};
// -------------------------------------------------------------------

class Rsync2GlobalCB : public ::google::protobuf::Message {
 public:
  Rsync2GlobalCB();
  virtual ~Rsync2GlobalCB();

  Rsync2GlobalCB(const Rsync2GlobalCB& from);

  inline Rsync2GlobalCB& operator=(const Rsync2GlobalCB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rsync2GlobalCB& default_instance();

  void Swap(Rsync2GlobalCB* other);

  // implements Message ----------------------------------------------

  Rsync2GlobalCB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rsync2GlobalCB& from);
  void MergeFrom(const Rsync2GlobalCB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // repeated int32 idx = 3;
  inline int idx_size() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 3;
  inline ::google::protobuf::int32 idx(int index) const;
  inline void set_idx(int index, ::google::protobuf::int32 value);
  inline void add_idx(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      idx() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_idx();

  // required string globalcb_ip = 4;
  inline bool has_globalcb_ip() const;
  inline void clear_globalcb_ip();
  static const int kGlobalcbIpFieldNumber = 4;
  inline const ::std::string& globalcb_ip() const;
  inline void set_globalcb_ip(const ::std::string& value);
  inline void set_globalcb_ip(const char* value);
  inline void set_globalcb_ip(const char* value, size_t size);
  inline ::std::string* mutable_globalcb_ip();
  inline ::std::string* release_globalcb_ip();
  inline void set_allocated_globalcb_ip(::std::string* globalcb_ip);

  // required int32 globalcb_port = 5;
  inline bool has_globalcb_port() const;
  inline void clear_globalcb_port();
  static const int kGlobalcbPortFieldNumber = 5;
  inline ::google::protobuf::int32 globalcb_port() const;
  inline void set_globalcb_port(::google::protobuf::int32 value);

  // optional string globalcb_ip_2 = 6;
  inline bool has_globalcb_ip_2() const;
  inline void clear_globalcb_ip_2();
  static const int kGlobalcbIp2FieldNumber = 6;
  inline const ::std::string& globalcb_ip_2() const;
  inline void set_globalcb_ip_2(const ::std::string& value);
  inline void set_globalcb_ip_2(const char* value);
  inline void set_globalcb_ip_2(const char* value, size_t size);
  inline ::std::string* mutable_globalcb_ip_2();
  inline ::std::string* release_globalcb_ip_2();
  inline void set_allocated_globalcb_ip_2(::std::string* globalcb_ip_2);

  // optional int32 globalcb_port_2 = 7;
  inline bool has_globalcb_port_2() const;
  inline void clear_globalcb_port_2();
  static const int kGlobalcbPort2FieldNumber = 7;
  inline ::google::protobuf::int32 globalcb_port_2() const;
  inline void set_globalcb_port_2(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Rsync2GlobalCB)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_globalcb_ip();
  inline void clear_has_globalcb_ip();
  inline void set_has_globalcb_port();
  inline void clear_has_globalcb_port();
  inline void set_has_globalcb_ip_2();
  inline void clear_has_globalcb_ip_2();
  inline void set_has_globalcb_port_2();
  inline void clear_has_globalcb_port_2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > idx_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 globalcb_port_;
  ::std::string* globalcb_ip_;
  ::std::string* globalcb_ip_2_;
  ::google::protobuf::int32 globalcb_port_2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static Rsync2GlobalCB* default_instance_;
};
// -------------------------------------------------------------------

class InnerCDKEYReq : public ::google::protobuf::Message {
 public:
  InnerCDKEYReq();
  virtual ~InnerCDKEYReq();

  InnerCDKEYReq(const InnerCDKEYReq& from);

  inline InnerCDKEYReq& operator=(const InnerCDKEYReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerCDKEYReq& default_instance();

  void Swap(InnerCDKEYReq* other);

  // implements Message ----------------------------------------------

  InnerCDKEYReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerCDKEYReq& from);
  void MergeFrom(const InnerCDKEYReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cdkey = 1;
  inline bool has_cdkey() const;
  inline void clear_cdkey();
  static const int kCdkeyFieldNumber = 1;
  inline const ::std::string& cdkey() const;
  inline void set_cdkey(const ::std::string& value);
  inline void set_cdkey(const char* value);
  inline void set_cdkey(const char* value, size_t size);
  inline ::std::string* mutable_cdkey();
  inline ::std::string* release_cdkey();
  inline void set_allocated_cdkey(::std::string* cdkey);

  // @@protoc_insertion_point(class_scope:InnerCDKEYReq)
 private:
  inline void set_has_cdkey();
  inline void clear_has_cdkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cdkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static InnerCDKEYReq* default_instance_;
};
// -------------------------------------------------------------------

class InnerCDKEYResp : public ::google::protobuf::Message {
 public:
  InnerCDKEYResp();
  virtual ~InnerCDKEYResp();

  InnerCDKEYResp(const InnerCDKEYResp& from);

  inline InnerCDKEYResp& operator=(const InnerCDKEYResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerCDKEYResp& default_instance();

  void Swap(InnerCDKEYResp* other);

  // implements Message ----------------------------------------------

  InnerCDKEYResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerCDKEYResp& from);
  void MergeFrom(const InnerCDKEYResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:InnerCDKEYResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static InnerCDKEYResp* default_instance_;
};
// -------------------------------------------------------------------

class InnerQueryBeforeRegReq : public ::google::protobuf::Message {
 public:
  InnerQueryBeforeRegReq();
  virtual ~InnerQueryBeforeRegReq();

  InnerQueryBeforeRegReq(const InnerQueryBeforeRegReq& from);

  inline InnerQueryBeforeRegReq& operator=(const InnerQueryBeforeRegReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerQueryBeforeRegReq& default_instance();

  void Swap(InnerQueryBeforeRegReq* other);

  // implements Message ----------------------------------------------

  InnerQueryBeforeRegReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerQueryBeforeRegReq& from);
  void MergeFrom(const InnerQueryBeforeRegReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional int32 act_id = 3;
  inline bool has_act_id() const;
  inline void clear_act_id();
  static const int kActIdFieldNumber = 3;
  inline ::google::protobuf::int32 act_id() const;
  inline void set_act_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:InnerQueryBeforeRegReq)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_act_id();
  inline void clear_has_act_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* account_;
  ::google::protobuf::int32 act_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static InnerQueryBeforeRegReq* default_instance_;
};
// -------------------------------------------------------------------

class InnerQueryBeforeReqResp : public ::google::protobuf::Message {
 public:
  InnerQueryBeforeReqResp();
  virtual ~InnerQueryBeforeReqResp();

  InnerQueryBeforeReqResp(const InnerQueryBeforeReqResp& from);

  inline InnerQueryBeforeReqResp& operator=(const InnerQueryBeforeReqResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerQueryBeforeReqResp& default_instance();

  void Swap(InnerQueryBeforeReqResp* other);

  // implements Message ----------------------------------------------

  InnerQueryBeforeReqResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerQueryBeforeReqResp& from);
  void MergeFrom(const InnerQueryBeforeReqResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 real_money = 2;
  inline bool has_real_money() const;
  inline void clear_real_money();
  static const int kRealMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 real_money() const;
  inline void set_real_money(::google::protobuf::int32 value);

  // optional int32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 vip = 4;
  inline bool has_vip() const;
  inline void clear_vip();
  static const int kVipFieldNumber = 4;
  inline ::google::protobuf::int32 vip() const;
  inline void set_vip(::google::protobuf::int32 value);

  // optional int32 czfl = 5;
  inline bool has_czfl() const;
  inline void clear_czfl();
  static const int kCzflFieldNumber = 5;
  inline ::google::protobuf::int32 czfl() const;
  inline void set_czfl(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:InnerQueryBeforeReqResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_real_money();
  inline void clear_has_real_money();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_vip();
  inline void clear_has_vip();
  inline void set_has_czfl();
  inline void clear_has_czfl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 real_money_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 vip_;
  ::google::protobuf::int32 czfl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static InnerQueryBeforeReqResp* default_instance_;
};
// -------------------------------------------------------------------

class Multicast : public ::google::protobuf::Message {
 public:
  Multicast();
  virtual ~Multicast();

  Multicast(const Multicast& from);

  inline Multicast& operator=(const Multicast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Multicast& default_instance();

  void Swap(Multicast* other);

  // implements Message ----------------------------------------------

  Multicast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Multicast& from);
  void MergeFrom(const Multicast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string recv_list = 1;
  inline int recv_list_size() const;
  inline void clear_recv_list();
  static const int kRecvListFieldNumber = 1;
  inline const ::std::string& recv_list(int index) const;
  inline ::std::string* mutable_recv_list(int index);
  inline void set_recv_list(int index, const ::std::string& value);
  inline void set_recv_list(int index, const char* value);
  inline void set_recv_list(int index, const char* value, size_t size);
  inline ::std::string* add_recv_list();
  inline void add_recv_list(const ::std::string& value);
  inline void add_recv_list(const char* value);
  inline void add_recv_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& recv_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_recv_list();

  // required int32 cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);

  // optional .GroupUpdate group_update = 3;
  inline bool has_group_update() const;
  inline void clear_group_update();
  static const int kGroupUpdateFieldNumber = 3;
  inline const ::GroupUpdate& group_update() const;
  inline ::GroupUpdate* mutable_group_update();
  inline ::GroupUpdate* release_group_update();
  inline void set_allocated_group_update(::GroupUpdate* group_update);

  // optional string msg_buff = 4;
  inline bool has_msg_buff() const;
  inline void clear_msg_buff();
  static const int kMsgBuffFieldNumber = 4;
  inline const ::std::string& msg_buff() const;
  inline void set_msg_buff(const ::std::string& value);
  inline void set_msg_buff(const char* value);
  inline void set_msg_buff(const char* value, size_t size);
  inline ::std::string* mutable_msg_buff();
  inline ::std::string* release_msg_buff();
  inline void set_allocated_msg_buff(::std::string* msg_buff);

  // optional .UserSync user_sync = 5;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 5;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:Multicast)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_group_update();
  inline void clear_has_group_update();
  inline void set_has_msg_buff();
  inline void clear_has_msg_buff();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> recv_list_;
  ::GroupUpdate* group_update_;
  ::std::string* msg_buff_;
  ::UserSync* user_sync_;
  ::google::protobuf::int32 cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static Multicast* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoReportReq : public ::google::protobuf::Message {
 public:
  UserInfoReportReq();
  virtual ~UserInfoReportReq();

  UserInfoReportReq(const UserInfoReportReq& from);

  inline UserInfoReportReq& operator=(const UserInfoReportReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoReportReq& default_instance();

  void Swap(UserInfoReportReq* other);

  // implements Message ----------------------------------------------

  UserInfoReportReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoReportReq& from);
  void MergeFrom(const UserInfoReportReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserInfoReportReq_ActType ActType;
  static const ActType REGIST = UserInfoReportReq_ActType_REGIST;
  static inline bool ActType_IsValid(int value) {
    return UserInfoReportReq_ActType_IsValid(value);
  }
  static const ActType ActType_MIN =
    UserInfoReportReq_ActType_ActType_MIN;
  static const ActType ActType_MAX =
    UserInfoReportReq_ActType_ActType_MAX;
  static const int ActType_ARRAYSIZE =
    UserInfoReportReq_ActType_ActType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActType_descriptor() {
    return UserInfoReportReq_ActType_descriptor();
  }
  static inline const ::std::string& ActType_Name(ActType value) {
    return UserInfoReportReq_ActType_Name(value);
  }
  static inline bool ActType_Parse(const ::std::string& name,
      ActType* value) {
    return UserInfoReportReq_ActType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .UserInfoReportReq.ActType act_type = 1 [default = REGIST];
  inline bool has_act_type() const;
  inline void clear_act_type();
  static const int kActTypeFieldNumber = 1;
  inline ::UserInfoReportReq_ActType act_type() const;
  inline void set_act_type(::UserInfoReportReq_ActType value);

  // optional string user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional string nick_name = 3;
  inline bool has_nick_name() const;
  inline void clear_nick_name();
  static const int kNickNameFieldNumber = 3;
  inline const ::std::string& nick_name() const;
  inline void set_nick_name(const ::std::string& value);
  inline void set_nick_name(const char* value);
  inline void set_nick_name(const char* value, size_t size);
  inline ::std::string* mutable_nick_name();
  inline ::std::string* release_nick_name();
  inline void set_allocated_nick_name(::std::string* nick_name);

  // optional int32 sex = 4;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 4;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional int64 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:UserInfoReportReq)
 private:
  inline void set_has_act_type();
  inline void clear_has_act_type();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_nick_name();
  inline void clear_has_nick_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_id_;
  int act_type_;
  ::google::protobuf::int32 sex_;
  ::std::string* nick_name_;
  ::google::protobuf::int64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static UserInfoReportReq* default_instance_;
};
// -------------------------------------------------------------------

class ServerBroadcastReq : public ::google::protobuf::Message {
 public:
  ServerBroadcastReq();
  virtual ~ServerBroadcastReq();

  ServerBroadcastReq(const ServerBroadcastReq& from);

  inline ServerBroadcastReq& operator=(const ServerBroadcastReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerBroadcastReq& default_instance();

  void Swap(ServerBroadcastReq* other);

  // implements Message ----------------------------------------------

  ServerBroadcastReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerBroadcastReq& from);
  void MergeFrom(const ServerBroadcastReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 btype = 1;
  inline bool has_btype() const;
  inline void clear_btype();
  static const int kBtypeFieldNumber = 1;
  inline ::google::protobuf::int32 btype() const;
  inline void set_btype(::google::protobuf::int32 value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional string target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // optional int32 limit = 4;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 4;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // optional int64 begintime = 5;
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBegintimeFieldNumber = 5;
  inline ::google::protobuf::int64 begintime() const;
  inline void set_begintime(::google::protobuf::int64 value);

  // optional int64 endtime = 6;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 6;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // optional string gmuser = 11;
  inline bool has_gmuser() const;
  inline void clear_gmuser();
  static const int kGmuserFieldNumber = 11;
  inline const ::std::string& gmuser() const;
  inline void set_gmuser(const ::std::string& value);
  inline void set_gmuser(const char* value);
  inline void set_gmuser(const char* value, size_t size);
  inline ::std::string* mutable_gmuser();
  inline ::std::string* release_gmuser();
  inline void set_allocated_gmuser(::std::string* gmuser);

  // optional string gmkey = 12;
  inline bool has_gmkey() const;
  inline void clear_gmkey();
  static const int kGmkeyFieldNumber = 12;
  inline const ::std::string& gmkey() const;
  inline void set_gmkey(const ::std::string& value);
  inline void set_gmkey(const char* value);
  inline void set_gmkey(const char* value, size_t size);
  inline ::std::string* mutable_gmkey();
  inline ::std::string* release_gmkey();
  inline void set_allocated_gmkey(::std::string* gmkey);

  // optional int32 fd = 21;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 21;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // optional int32 session = 22;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 22;
  inline ::google::protobuf::int32 session() const;
  inline void set_session(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ServerBroadcastReq)
 private:
  inline void set_has_btype();
  inline void clear_has_btype();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_gmuser();
  inline void clear_has_gmuser();
  inline void set_has_gmkey();
  inline void clear_has_gmkey();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  ::google::protobuf::int32 btype_;
  ::google::protobuf::int32 limit_;
  ::std::string* target_;
  ::google::protobuf::int64 begintime_;
  ::google::protobuf::int64 endtime_;
  ::std::string* gmuser_;
  ::std::string* gmkey_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int32 session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static ServerBroadcastReq* default_instance_;
};
// -------------------------------------------------------------------

class ServerBroadcastResp : public ::google::protobuf::Message {
 public:
  ServerBroadcastResp();
  virtual ~ServerBroadcastResp();

  ServerBroadcastResp(const ServerBroadcastResp& from);

  inline ServerBroadcastResp& operator=(const ServerBroadcastResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerBroadcastResp& default_instance();

  void Swap(ServerBroadcastResp* other);

  // implements Message ----------------------------------------------

  ServerBroadcastResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerBroadcastResp& from);
  void MergeFrom(const ServerBroadcastResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ServerBroadcastResp_Result Result;
  static const Result OK = ServerBroadcastResp_Result_OK;
  static const Result FAIL = ServerBroadcastResp_Result_FAIL;
  static inline bool Result_IsValid(int value) {
    return ServerBroadcastResp_Result_IsValid(value);
  }
  static const Result Result_MIN =
    ServerBroadcastResp_Result_Result_MIN;
  static const Result Result_MAX =
    ServerBroadcastResp_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    ServerBroadcastResp_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return ServerBroadcastResp_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return ServerBroadcastResp_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return ServerBroadcastResp_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ServerBroadcastResp.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::ServerBroadcastResp_Result result() const;
  inline void set_result(::ServerBroadcastResp_Result value);

  // optional int32 fd = 21;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 21;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // optional int64 session = 22;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 22;
  inline ::google::protobuf::int64 session() const;
  inline void set_session(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ServerBroadcastResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int result_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int64 session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_inner_5fcmd_2eproto();
  friend void protobuf_AssignDesc_inner_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_inner_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static ServerBroadcastResp* default_instance_;
};
// ===================================================================


// ===================================================================

// RsyncLogicStatus_CentreInfo

// optional string centre_ip = 7;
inline bool RsyncLogicStatus_CentreInfo::has_centre_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RsyncLogicStatus_CentreInfo::set_has_centre_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RsyncLogicStatus_CentreInfo::clear_has_centre_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RsyncLogicStatus_CentreInfo::clear_centre_ip() {
  if (centre_ip_ != &::google::protobuf::internal::kEmptyString) {
    centre_ip_->clear();
  }
  clear_has_centre_ip();
}
inline const ::std::string& RsyncLogicStatus_CentreInfo::centre_ip() const {
  return *centre_ip_;
}
inline void RsyncLogicStatus_CentreInfo::set_centre_ip(const ::std::string& value) {
  set_has_centre_ip();
  if (centre_ip_ == &::google::protobuf::internal::kEmptyString) {
    centre_ip_ = new ::std::string;
  }
  centre_ip_->assign(value);
}
inline void RsyncLogicStatus_CentreInfo::set_centre_ip(const char* value) {
  set_has_centre_ip();
  if (centre_ip_ == &::google::protobuf::internal::kEmptyString) {
    centre_ip_ = new ::std::string;
  }
  centre_ip_->assign(value);
}
inline void RsyncLogicStatus_CentreInfo::set_centre_ip(const char* value, size_t size) {
  set_has_centre_ip();
  if (centre_ip_ == &::google::protobuf::internal::kEmptyString) {
    centre_ip_ = new ::std::string;
  }
  centre_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RsyncLogicStatus_CentreInfo::mutable_centre_ip() {
  set_has_centre_ip();
  if (centre_ip_ == &::google::protobuf::internal::kEmptyString) {
    centre_ip_ = new ::std::string;
  }
  return centre_ip_;
}
inline ::std::string* RsyncLogicStatus_CentreInfo::release_centre_ip() {
  clear_has_centre_ip();
  if (centre_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = centre_ip_;
    centre_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RsyncLogicStatus_CentreInfo::set_allocated_centre_ip(::std::string* centre_ip) {
  if (centre_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete centre_ip_;
  }
  if (centre_ip) {
    set_has_centre_ip();
    centre_ip_ = centre_ip;
  } else {
    clear_has_centre_ip();
    centre_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 centre_port = 8;
inline bool RsyncLogicStatus_CentreInfo::has_centre_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RsyncLogicStatus_CentreInfo::set_has_centre_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RsyncLogicStatus_CentreInfo::clear_has_centre_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RsyncLogicStatus_CentreInfo::clear_centre_port() {
  centre_port_ = 0;
  clear_has_centre_port();
}
inline ::google::protobuf::int32 RsyncLogicStatus_CentreInfo::centre_port() const {
  return centre_port_;
}
inline void RsyncLogicStatus_CentreInfo::set_centre_port(::google::protobuf::int32 value) {
  set_has_centre_port();
  centre_port_ = value;
}

// -------------------------------------------------------------------

// RsyncLogicStatus

// required string ip = 1;
inline bool RsyncLogicStatus::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RsyncLogicStatus::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RsyncLogicStatus::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RsyncLogicStatus::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RsyncLogicStatus::ip() const {
  return *ip_;
}
inline void RsyncLogicStatus::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RsyncLogicStatus::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RsyncLogicStatus::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RsyncLogicStatus::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RsyncLogicStatus::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RsyncLogicStatus::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 2;
inline bool RsyncLogicStatus::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RsyncLogicStatus::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RsyncLogicStatus::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RsyncLogicStatus::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RsyncLogicStatus::port() const {
  return port_;
}
inline void RsyncLogicStatus::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// repeated int32 idx = 3;
inline int RsyncLogicStatus::idx_size() const {
  return idx_.size();
}
inline void RsyncLogicStatus::clear_idx() {
  idx_.Clear();
}
inline ::google::protobuf::int32 RsyncLogicStatus::idx(int index) const {
  return idx_.Get(index);
}
inline void RsyncLogicStatus::set_idx(int index, ::google::protobuf::int32 value) {
  idx_.Set(index, value);
}
inline void RsyncLogicStatus::add_idx(::google::protobuf::int32 value) {
  idx_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RsyncLogicStatus::idx() const {
  return idx_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RsyncLogicStatus::mutable_idx() {
  return &idx_;
}

// required string version = 4;
inline bool RsyncLogicStatus::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RsyncLogicStatus::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RsyncLogicStatus::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RsyncLogicStatus::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& RsyncLogicStatus::version() const {
  return *version_;
}
inline void RsyncLogicStatus::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RsyncLogicStatus::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RsyncLogicStatus::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RsyncLogicStatus::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* RsyncLogicStatus::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RsyncLogicStatus::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 max_client = 5;
inline bool RsyncLogicStatus::has_max_client() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RsyncLogicStatus::set_has_max_client() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RsyncLogicStatus::clear_has_max_client() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RsyncLogicStatus::clear_max_client() {
  max_client_ = 0;
  clear_has_max_client();
}
inline ::google::protobuf::int32 RsyncLogicStatus::max_client() const {
  return max_client_;
}
inline void RsyncLogicStatus::set_max_client(::google::protobuf::int32 value) {
  set_has_max_client();
  max_client_ = value;
}

// required int32 cur_client = 6;
inline bool RsyncLogicStatus::has_cur_client() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RsyncLogicStatus::set_has_cur_client() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RsyncLogicStatus::clear_has_cur_client() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RsyncLogicStatus::clear_cur_client() {
  cur_client_ = 0;
  clear_has_cur_client();
}
inline ::google::protobuf::int32 RsyncLogicStatus::cur_client() const {
  return cur_client_;
}
inline void RsyncLogicStatus::set_cur_client(::google::protobuf::int32 value) {
  set_has_cur_client();
  cur_client_ = value;
}

// repeated .RsyncLogicStatus.CentreInfo centre_list = 7;
inline int RsyncLogicStatus::centre_list_size() const {
  return centre_list_.size();
}
inline void RsyncLogicStatus::clear_centre_list() {
  centre_list_.Clear();
}
inline const ::RsyncLogicStatus_CentreInfo& RsyncLogicStatus::centre_list(int index) const {
  return centre_list_.Get(index);
}
inline ::RsyncLogicStatus_CentreInfo* RsyncLogicStatus::mutable_centre_list(int index) {
  return centre_list_.Mutable(index);
}
inline ::RsyncLogicStatus_CentreInfo* RsyncLogicStatus::add_centre_list() {
  return centre_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RsyncLogicStatus_CentreInfo >&
RsyncLogicStatus::centre_list() const {
  return centre_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::RsyncLogicStatus_CentreInfo >*
RsyncLogicStatus::mutable_centre_list() {
  return &centre_list_;
}

// optional int32 max_reg = 9;
inline bool RsyncLogicStatus::has_max_reg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RsyncLogicStatus::set_has_max_reg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RsyncLogicStatus::clear_has_max_reg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RsyncLogicStatus::clear_max_reg() {
  max_reg_ = 0;
  clear_has_max_reg();
}
inline ::google::protobuf::int32 RsyncLogicStatus::max_reg() const {
  return max_reg_;
}
inline void RsyncLogicStatus::set_max_reg(::google::protobuf::int32 value) {
  set_has_max_reg();
  max_reg_ = value;
}

// optional int32 cur_reg = 10;
inline bool RsyncLogicStatus::has_cur_reg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RsyncLogicStatus::set_has_cur_reg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RsyncLogicStatus::clear_has_cur_reg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RsyncLogicStatus::clear_cur_reg() {
  cur_reg_ = 0;
  clear_has_cur_reg();
}
inline ::google::protobuf::int32 RsyncLogicStatus::cur_reg() const {
  return cur_reg_;
}
inline void RsyncLogicStatus::set_cur_reg(::google::protobuf::int32 value) {
  set_has_cur_reg();
  cur_reg_ = value;
}

// -------------------------------------------------------------------

// Rsync2GlobalCB

// required int32 port = 2;
inline bool Rsync2GlobalCB::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rsync2GlobalCB::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rsync2GlobalCB::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rsync2GlobalCB::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Rsync2GlobalCB::port() const {
  return port_;
}
inline void Rsync2GlobalCB::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// repeated int32 idx = 3;
inline int Rsync2GlobalCB::idx_size() const {
  return idx_.size();
}
inline void Rsync2GlobalCB::clear_idx() {
  idx_.Clear();
}
inline ::google::protobuf::int32 Rsync2GlobalCB::idx(int index) const {
  return idx_.Get(index);
}
inline void Rsync2GlobalCB::set_idx(int index, ::google::protobuf::int32 value) {
  idx_.Set(index, value);
}
inline void Rsync2GlobalCB::add_idx(::google::protobuf::int32 value) {
  idx_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Rsync2GlobalCB::idx() const {
  return idx_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Rsync2GlobalCB::mutable_idx() {
  return &idx_;
}

// required string globalcb_ip = 4;
inline bool Rsync2GlobalCB::has_globalcb_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rsync2GlobalCB::set_has_globalcb_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rsync2GlobalCB::clear_has_globalcb_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rsync2GlobalCB::clear_globalcb_ip() {
  if (globalcb_ip_ != &::google::protobuf::internal::kEmptyString) {
    globalcb_ip_->clear();
  }
  clear_has_globalcb_ip();
}
inline const ::std::string& Rsync2GlobalCB::globalcb_ip() const {
  return *globalcb_ip_;
}
inline void Rsync2GlobalCB::set_globalcb_ip(const ::std::string& value) {
  set_has_globalcb_ip();
  if (globalcb_ip_ == &::google::protobuf::internal::kEmptyString) {
    globalcb_ip_ = new ::std::string;
  }
  globalcb_ip_->assign(value);
}
inline void Rsync2GlobalCB::set_globalcb_ip(const char* value) {
  set_has_globalcb_ip();
  if (globalcb_ip_ == &::google::protobuf::internal::kEmptyString) {
    globalcb_ip_ = new ::std::string;
  }
  globalcb_ip_->assign(value);
}
inline void Rsync2GlobalCB::set_globalcb_ip(const char* value, size_t size) {
  set_has_globalcb_ip();
  if (globalcb_ip_ == &::google::protobuf::internal::kEmptyString) {
    globalcb_ip_ = new ::std::string;
  }
  globalcb_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Rsync2GlobalCB::mutable_globalcb_ip() {
  set_has_globalcb_ip();
  if (globalcb_ip_ == &::google::protobuf::internal::kEmptyString) {
    globalcb_ip_ = new ::std::string;
  }
  return globalcb_ip_;
}
inline ::std::string* Rsync2GlobalCB::release_globalcb_ip() {
  clear_has_globalcb_ip();
  if (globalcb_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalcb_ip_;
    globalcb_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Rsync2GlobalCB::set_allocated_globalcb_ip(::std::string* globalcb_ip) {
  if (globalcb_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete globalcb_ip_;
  }
  if (globalcb_ip) {
    set_has_globalcb_ip();
    globalcb_ip_ = globalcb_ip;
  } else {
    clear_has_globalcb_ip();
    globalcb_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 globalcb_port = 5;
inline bool Rsync2GlobalCB::has_globalcb_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rsync2GlobalCB::set_has_globalcb_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rsync2GlobalCB::clear_has_globalcb_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rsync2GlobalCB::clear_globalcb_port() {
  globalcb_port_ = 0;
  clear_has_globalcb_port();
}
inline ::google::protobuf::int32 Rsync2GlobalCB::globalcb_port() const {
  return globalcb_port_;
}
inline void Rsync2GlobalCB::set_globalcb_port(::google::protobuf::int32 value) {
  set_has_globalcb_port();
  globalcb_port_ = value;
}

// optional string globalcb_ip_2 = 6;
inline bool Rsync2GlobalCB::has_globalcb_ip_2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Rsync2GlobalCB::set_has_globalcb_ip_2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Rsync2GlobalCB::clear_has_globalcb_ip_2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Rsync2GlobalCB::clear_globalcb_ip_2() {
  if (globalcb_ip_2_ != &::google::protobuf::internal::kEmptyString) {
    globalcb_ip_2_->clear();
  }
  clear_has_globalcb_ip_2();
}
inline const ::std::string& Rsync2GlobalCB::globalcb_ip_2() const {
  return *globalcb_ip_2_;
}
inline void Rsync2GlobalCB::set_globalcb_ip_2(const ::std::string& value) {
  set_has_globalcb_ip_2();
  if (globalcb_ip_2_ == &::google::protobuf::internal::kEmptyString) {
    globalcb_ip_2_ = new ::std::string;
  }
  globalcb_ip_2_->assign(value);
}
inline void Rsync2GlobalCB::set_globalcb_ip_2(const char* value) {
  set_has_globalcb_ip_2();
  if (globalcb_ip_2_ == &::google::protobuf::internal::kEmptyString) {
    globalcb_ip_2_ = new ::std::string;
  }
  globalcb_ip_2_->assign(value);
}
inline void Rsync2GlobalCB::set_globalcb_ip_2(const char* value, size_t size) {
  set_has_globalcb_ip_2();
  if (globalcb_ip_2_ == &::google::protobuf::internal::kEmptyString) {
    globalcb_ip_2_ = new ::std::string;
  }
  globalcb_ip_2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Rsync2GlobalCB::mutable_globalcb_ip_2() {
  set_has_globalcb_ip_2();
  if (globalcb_ip_2_ == &::google::protobuf::internal::kEmptyString) {
    globalcb_ip_2_ = new ::std::string;
  }
  return globalcb_ip_2_;
}
inline ::std::string* Rsync2GlobalCB::release_globalcb_ip_2() {
  clear_has_globalcb_ip_2();
  if (globalcb_ip_2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalcb_ip_2_;
    globalcb_ip_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Rsync2GlobalCB::set_allocated_globalcb_ip_2(::std::string* globalcb_ip_2) {
  if (globalcb_ip_2_ != &::google::protobuf::internal::kEmptyString) {
    delete globalcb_ip_2_;
  }
  if (globalcb_ip_2) {
    set_has_globalcb_ip_2();
    globalcb_ip_2_ = globalcb_ip_2;
  } else {
    clear_has_globalcb_ip_2();
    globalcb_ip_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 globalcb_port_2 = 7;
inline bool Rsync2GlobalCB::has_globalcb_port_2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Rsync2GlobalCB::set_has_globalcb_port_2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Rsync2GlobalCB::clear_has_globalcb_port_2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Rsync2GlobalCB::clear_globalcb_port_2() {
  globalcb_port_2_ = 0;
  clear_has_globalcb_port_2();
}
inline ::google::protobuf::int32 Rsync2GlobalCB::globalcb_port_2() const {
  return globalcb_port_2_;
}
inline void Rsync2GlobalCB::set_globalcb_port_2(::google::protobuf::int32 value) {
  set_has_globalcb_port_2();
  globalcb_port_2_ = value;
}

// -------------------------------------------------------------------

// InnerCDKEYReq

// required string cdkey = 1;
inline bool InnerCDKEYReq::has_cdkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerCDKEYReq::set_has_cdkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerCDKEYReq::clear_has_cdkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerCDKEYReq::clear_cdkey() {
  if (cdkey_ != &::google::protobuf::internal::kEmptyString) {
    cdkey_->clear();
  }
  clear_has_cdkey();
}
inline const ::std::string& InnerCDKEYReq::cdkey() const {
  return *cdkey_;
}
inline void InnerCDKEYReq::set_cdkey(const ::std::string& value) {
  set_has_cdkey();
  if (cdkey_ == &::google::protobuf::internal::kEmptyString) {
    cdkey_ = new ::std::string;
  }
  cdkey_->assign(value);
}
inline void InnerCDKEYReq::set_cdkey(const char* value) {
  set_has_cdkey();
  if (cdkey_ == &::google::protobuf::internal::kEmptyString) {
    cdkey_ = new ::std::string;
  }
  cdkey_->assign(value);
}
inline void InnerCDKEYReq::set_cdkey(const char* value, size_t size) {
  set_has_cdkey();
  if (cdkey_ == &::google::protobuf::internal::kEmptyString) {
    cdkey_ = new ::std::string;
  }
  cdkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InnerCDKEYReq::mutable_cdkey() {
  set_has_cdkey();
  if (cdkey_ == &::google::protobuf::internal::kEmptyString) {
    cdkey_ = new ::std::string;
  }
  return cdkey_;
}
inline ::std::string* InnerCDKEYReq::release_cdkey() {
  clear_has_cdkey();
  if (cdkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cdkey_;
    cdkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InnerCDKEYReq::set_allocated_cdkey(::std::string* cdkey) {
  if (cdkey_ != &::google::protobuf::internal::kEmptyString) {
    delete cdkey_;
  }
  if (cdkey) {
    set_has_cdkey();
    cdkey_ = cdkey;
  } else {
    clear_has_cdkey();
    cdkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InnerCDKEYResp

// required int32 ret = 1;
inline bool InnerCDKEYResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerCDKEYResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerCDKEYResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerCDKEYResp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 InnerCDKEYResp::ret() const {
  return ret_;
}
inline void InnerCDKEYResp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// InnerQueryBeforeRegReq

// required string name = 1;
inline bool InnerQueryBeforeRegReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerQueryBeforeRegReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerQueryBeforeRegReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerQueryBeforeRegReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InnerQueryBeforeRegReq::name() const {
  return *name_;
}
inline void InnerQueryBeforeRegReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InnerQueryBeforeRegReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InnerQueryBeforeRegReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InnerQueryBeforeRegReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* InnerQueryBeforeRegReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InnerQueryBeforeRegReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 2;
inline bool InnerQueryBeforeRegReq::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InnerQueryBeforeRegReq::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InnerQueryBeforeRegReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InnerQueryBeforeRegReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& InnerQueryBeforeRegReq::account() const {
  return *account_;
}
inline void InnerQueryBeforeRegReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void InnerQueryBeforeRegReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void InnerQueryBeforeRegReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InnerQueryBeforeRegReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* InnerQueryBeforeRegReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InnerQueryBeforeRegReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 act_id = 3;
inline bool InnerQueryBeforeRegReq::has_act_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InnerQueryBeforeRegReq::set_has_act_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InnerQueryBeforeRegReq::clear_has_act_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InnerQueryBeforeRegReq::clear_act_id() {
  act_id_ = 0;
  clear_has_act_id();
}
inline ::google::protobuf::int32 InnerQueryBeforeRegReq::act_id() const {
  return act_id_;
}
inline void InnerQueryBeforeRegReq::set_act_id(::google::protobuf::int32 value) {
  set_has_act_id();
  act_id_ = value;
}

// -------------------------------------------------------------------

// InnerQueryBeforeReqResp

// required int32 result = 1;
inline bool InnerQueryBeforeReqResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerQueryBeforeReqResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerQueryBeforeReqResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerQueryBeforeReqResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 InnerQueryBeforeReqResp::result() const {
  return result_;
}
inline void InnerQueryBeforeReqResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 real_money = 2;
inline bool InnerQueryBeforeReqResp::has_real_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InnerQueryBeforeReqResp::set_has_real_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InnerQueryBeforeReqResp::clear_has_real_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InnerQueryBeforeReqResp::clear_real_money() {
  real_money_ = 0;
  clear_has_real_money();
}
inline ::google::protobuf::int32 InnerQueryBeforeReqResp::real_money() const {
  return real_money_;
}
inline void InnerQueryBeforeReqResp::set_real_money(::google::protobuf::int32 value) {
  set_has_real_money();
  real_money_ = value;
}

// optional int32 money = 3;
inline bool InnerQueryBeforeReqResp::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InnerQueryBeforeReqResp::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InnerQueryBeforeReqResp::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InnerQueryBeforeReqResp::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 InnerQueryBeforeReqResp::money() const {
  return money_;
}
inline void InnerQueryBeforeReqResp::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 vip = 4;
inline bool InnerQueryBeforeReqResp::has_vip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InnerQueryBeforeReqResp::set_has_vip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InnerQueryBeforeReqResp::clear_has_vip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InnerQueryBeforeReqResp::clear_vip() {
  vip_ = 0;
  clear_has_vip();
}
inline ::google::protobuf::int32 InnerQueryBeforeReqResp::vip() const {
  return vip_;
}
inline void InnerQueryBeforeReqResp::set_vip(::google::protobuf::int32 value) {
  set_has_vip();
  vip_ = value;
}

// optional int32 czfl = 5;
inline bool InnerQueryBeforeReqResp::has_czfl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InnerQueryBeforeReqResp::set_has_czfl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InnerQueryBeforeReqResp::clear_has_czfl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InnerQueryBeforeReqResp::clear_czfl() {
  czfl_ = 0;
  clear_has_czfl();
}
inline ::google::protobuf::int32 InnerQueryBeforeReqResp::czfl() const {
  return czfl_;
}
inline void InnerQueryBeforeReqResp::set_czfl(::google::protobuf::int32 value) {
  set_has_czfl();
  czfl_ = value;
}

// -------------------------------------------------------------------

// Multicast

// repeated string recv_list = 1;
inline int Multicast::recv_list_size() const {
  return recv_list_.size();
}
inline void Multicast::clear_recv_list() {
  recv_list_.Clear();
}
inline const ::std::string& Multicast::recv_list(int index) const {
  return recv_list_.Get(index);
}
inline ::std::string* Multicast::mutable_recv_list(int index) {
  return recv_list_.Mutable(index);
}
inline void Multicast::set_recv_list(int index, const ::std::string& value) {
  recv_list_.Mutable(index)->assign(value);
}
inline void Multicast::set_recv_list(int index, const char* value) {
  recv_list_.Mutable(index)->assign(value);
}
inline void Multicast::set_recv_list(int index, const char* value, size_t size) {
  recv_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Multicast::add_recv_list() {
  return recv_list_.Add();
}
inline void Multicast::add_recv_list(const ::std::string& value) {
  recv_list_.Add()->assign(value);
}
inline void Multicast::add_recv_list(const char* value) {
  recv_list_.Add()->assign(value);
}
inline void Multicast::add_recv_list(const char* value, size_t size) {
  recv_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Multicast::recv_list() const {
  return recv_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Multicast::mutable_recv_list() {
  return &recv_list_;
}

// required int32 cmd = 2;
inline bool Multicast::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Multicast::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Multicast::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Multicast::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 Multicast::cmd() const {
  return cmd_;
}
inline void Multicast::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional .GroupUpdate group_update = 3;
inline bool Multicast::has_group_update() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Multicast::set_has_group_update() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Multicast::clear_has_group_update() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Multicast::clear_group_update() {
  if (group_update_ != NULL) group_update_->::GroupUpdate::Clear();
  clear_has_group_update();
}
inline const ::GroupUpdate& Multicast::group_update() const {
  return group_update_ != NULL ? *group_update_ : *default_instance_->group_update_;
}
inline ::GroupUpdate* Multicast::mutable_group_update() {
  set_has_group_update();
  if (group_update_ == NULL) group_update_ = new ::GroupUpdate;
  return group_update_;
}
inline ::GroupUpdate* Multicast::release_group_update() {
  clear_has_group_update();
  ::GroupUpdate* temp = group_update_;
  group_update_ = NULL;
  return temp;
}
inline void Multicast::set_allocated_group_update(::GroupUpdate* group_update) {
  delete group_update_;
  group_update_ = group_update;
  if (group_update) {
    set_has_group_update();
  } else {
    clear_has_group_update();
  }
}

// optional string msg_buff = 4;
inline bool Multicast::has_msg_buff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Multicast::set_has_msg_buff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Multicast::clear_has_msg_buff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Multicast::clear_msg_buff() {
  if (msg_buff_ != &::google::protobuf::internal::kEmptyString) {
    msg_buff_->clear();
  }
  clear_has_msg_buff();
}
inline const ::std::string& Multicast::msg_buff() const {
  return *msg_buff_;
}
inline void Multicast::set_msg_buff(const ::std::string& value) {
  set_has_msg_buff();
  if (msg_buff_ == &::google::protobuf::internal::kEmptyString) {
    msg_buff_ = new ::std::string;
  }
  msg_buff_->assign(value);
}
inline void Multicast::set_msg_buff(const char* value) {
  set_has_msg_buff();
  if (msg_buff_ == &::google::protobuf::internal::kEmptyString) {
    msg_buff_ = new ::std::string;
  }
  msg_buff_->assign(value);
}
inline void Multicast::set_msg_buff(const char* value, size_t size) {
  set_has_msg_buff();
  if (msg_buff_ == &::google::protobuf::internal::kEmptyString) {
    msg_buff_ = new ::std::string;
  }
  msg_buff_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Multicast::mutable_msg_buff() {
  set_has_msg_buff();
  if (msg_buff_ == &::google::protobuf::internal::kEmptyString) {
    msg_buff_ = new ::std::string;
  }
  return msg_buff_;
}
inline ::std::string* Multicast::release_msg_buff() {
  clear_has_msg_buff();
  if (msg_buff_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_buff_;
    msg_buff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Multicast::set_allocated_msg_buff(::std::string* msg_buff) {
  if (msg_buff_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_buff_;
  }
  if (msg_buff) {
    set_has_msg_buff();
    msg_buff_ = msg_buff;
  } else {
    clear_has_msg_buff();
    msg_buff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .UserSync user_sync = 5;
inline bool Multicast::has_user_sync() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Multicast::set_has_user_sync() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Multicast::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Multicast::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& Multicast::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* Multicast::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* Multicast::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void Multicast::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// UserInfoReportReq

// optional .UserInfoReportReq.ActType act_type = 1 [default = REGIST];
inline bool UserInfoReportReq::has_act_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoReportReq::set_has_act_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoReportReq::clear_has_act_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoReportReq::clear_act_type() {
  act_type_ = 0;
  clear_has_act_type();
}
inline ::UserInfoReportReq_ActType UserInfoReportReq::act_type() const {
  return static_cast< ::UserInfoReportReq_ActType >(act_type_);
}
inline void UserInfoReportReq::set_act_type(::UserInfoReportReq_ActType value) {
  assert(::UserInfoReportReq_ActType_IsValid(value));
  set_has_act_type();
  act_type_ = value;
}

// optional string user_id = 2;
inline bool UserInfoReportReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoReportReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoReportReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoReportReq::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& UserInfoReportReq::user_id() const {
  return *user_id_;
}
inline void UserInfoReportReq::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void UserInfoReportReq::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void UserInfoReportReq::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoReportReq::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* UserInfoReportReq::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoReportReq::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nick_name = 3;
inline bool UserInfoReportReq::has_nick_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfoReportReq::set_has_nick_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfoReportReq::clear_has_nick_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfoReportReq::clear_nick_name() {
  if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
    nick_name_->clear();
  }
  clear_has_nick_name();
}
inline const ::std::string& UserInfoReportReq::nick_name() const {
  return *nick_name_;
}
inline void UserInfoReportReq::set_nick_name(const ::std::string& value) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(value);
}
inline void UserInfoReportReq::set_nick_name(const char* value) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(value);
}
inline void UserInfoReportReq::set_nick_name(const char* value, size_t size) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoReportReq::mutable_nick_name() {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  return nick_name_;
}
inline ::std::string* UserInfoReportReq::release_nick_name() {
  clear_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_name_;
    nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoReportReq::set_allocated_nick_name(::std::string* nick_name) {
  if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_name_;
  }
  if (nick_name) {
    set_has_nick_name();
    nick_name_ = nick_name;
  } else {
    clear_has_nick_name();
    nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sex = 4;
inline bool UserInfoReportReq::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfoReportReq::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfoReportReq::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfoReportReq::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 UserInfoReportReq::sex() const {
  return sex_;
}
inline void UserInfoReportReq::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional int64 time = 5;
inline bool UserInfoReportReq::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfoReportReq::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfoReportReq::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfoReportReq::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 UserInfoReportReq::time() const {
  return time_;
}
inline void UserInfoReportReq::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// ServerBroadcastReq

// optional int32 btype = 1;
inline bool ServerBroadcastReq::has_btype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerBroadcastReq::set_has_btype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerBroadcastReq::clear_has_btype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerBroadcastReq::clear_btype() {
  btype_ = 0;
  clear_has_btype();
}
inline ::google::protobuf::int32 ServerBroadcastReq::btype() const {
  return btype_;
}
inline void ServerBroadcastReq::set_btype(::google::protobuf::int32 value) {
  set_has_btype();
  btype_ = value;
}

// optional string message = 2;
inline bool ServerBroadcastReq::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerBroadcastReq::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerBroadcastReq::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerBroadcastReq::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ServerBroadcastReq::message() const {
  return *message_;
}
inline void ServerBroadcastReq::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ServerBroadcastReq::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ServerBroadcastReq::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerBroadcastReq::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ServerBroadcastReq::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerBroadcastReq::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target = 3;
inline bool ServerBroadcastReq::has_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerBroadcastReq::set_has_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerBroadcastReq::clear_has_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerBroadcastReq::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& ServerBroadcastReq::target() const {
  return *target_;
}
inline void ServerBroadcastReq::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void ServerBroadcastReq::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void ServerBroadcastReq::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerBroadcastReq::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* ServerBroadcastReq::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerBroadcastReq::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 limit = 4;
inline bool ServerBroadcastReq::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerBroadcastReq::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerBroadcastReq::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerBroadcastReq::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 ServerBroadcastReq::limit() const {
  return limit_;
}
inline void ServerBroadcastReq::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int64 begintime = 5;
inline bool ServerBroadcastReq::has_begintime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerBroadcastReq::set_has_begintime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerBroadcastReq::clear_has_begintime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerBroadcastReq::clear_begintime() {
  begintime_ = GOOGLE_LONGLONG(0);
  clear_has_begintime();
}
inline ::google::protobuf::int64 ServerBroadcastReq::begintime() const {
  return begintime_;
}
inline void ServerBroadcastReq::set_begintime(::google::protobuf::int64 value) {
  set_has_begintime();
  begintime_ = value;
}

// optional int64 endtime = 6;
inline bool ServerBroadcastReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerBroadcastReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerBroadcastReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerBroadcastReq::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 ServerBroadcastReq::endtime() const {
  return endtime_;
}
inline void ServerBroadcastReq::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional string gmuser = 11;
inline bool ServerBroadcastReq::has_gmuser() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerBroadcastReq::set_has_gmuser() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServerBroadcastReq::clear_has_gmuser() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServerBroadcastReq::clear_gmuser() {
  if (gmuser_ != &::google::protobuf::internal::kEmptyString) {
    gmuser_->clear();
  }
  clear_has_gmuser();
}
inline const ::std::string& ServerBroadcastReq::gmuser() const {
  return *gmuser_;
}
inline void ServerBroadcastReq::set_gmuser(const ::std::string& value) {
  set_has_gmuser();
  if (gmuser_ == &::google::protobuf::internal::kEmptyString) {
    gmuser_ = new ::std::string;
  }
  gmuser_->assign(value);
}
inline void ServerBroadcastReq::set_gmuser(const char* value) {
  set_has_gmuser();
  if (gmuser_ == &::google::protobuf::internal::kEmptyString) {
    gmuser_ = new ::std::string;
  }
  gmuser_->assign(value);
}
inline void ServerBroadcastReq::set_gmuser(const char* value, size_t size) {
  set_has_gmuser();
  if (gmuser_ == &::google::protobuf::internal::kEmptyString) {
    gmuser_ = new ::std::string;
  }
  gmuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerBroadcastReq::mutable_gmuser() {
  set_has_gmuser();
  if (gmuser_ == &::google::protobuf::internal::kEmptyString) {
    gmuser_ = new ::std::string;
  }
  return gmuser_;
}
inline ::std::string* ServerBroadcastReq::release_gmuser() {
  clear_has_gmuser();
  if (gmuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gmuser_;
    gmuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerBroadcastReq::set_allocated_gmuser(::std::string* gmuser) {
  if (gmuser_ != &::google::protobuf::internal::kEmptyString) {
    delete gmuser_;
  }
  if (gmuser) {
    set_has_gmuser();
    gmuser_ = gmuser;
  } else {
    clear_has_gmuser();
    gmuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gmkey = 12;
inline bool ServerBroadcastReq::has_gmkey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServerBroadcastReq::set_has_gmkey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServerBroadcastReq::clear_has_gmkey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServerBroadcastReq::clear_gmkey() {
  if (gmkey_ != &::google::protobuf::internal::kEmptyString) {
    gmkey_->clear();
  }
  clear_has_gmkey();
}
inline const ::std::string& ServerBroadcastReq::gmkey() const {
  return *gmkey_;
}
inline void ServerBroadcastReq::set_gmkey(const ::std::string& value) {
  set_has_gmkey();
  if (gmkey_ == &::google::protobuf::internal::kEmptyString) {
    gmkey_ = new ::std::string;
  }
  gmkey_->assign(value);
}
inline void ServerBroadcastReq::set_gmkey(const char* value) {
  set_has_gmkey();
  if (gmkey_ == &::google::protobuf::internal::kEmptyString) {
    gmkey_ = new ::std::string;
  }
  gmkey_->assign(value);
}
inline void ServerBroadcastReq::set_gmkey(const char* value, size_t size) {
  set_has_gmkey();
  if (gmkey_ == &::google::protobuf::internal::kEmptyString) {
    gmkey_ = new ::std::string;
  }
  gmkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerBroadcastReq::mutable_gmkey() {
  set_has_gmkey();
  if (gmkey_ == &::google::protobuf::internal::kEmptyString) {
    gmkey_ = new ::std::string;
  }
  return gmkey_;
}
inline ::std::string* ServerBroadcastReq::release_gmkey() {
  clear_has_gmkey();
  if (gmkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gmkey_;
    gmkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerBroadcastReq::set_allocated_gmkey(::std::string* gmkey) {
  if (gmkey_ != &::google::protobuf::internal::kEmptyString) {
    delete gmkey_;
  }
  if (gmkey) {
    set_has_gmkey();
    gmkey_ = gmkey;
  } else {
    clear_has_gmkey();
    gmkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fd = 21;
inline bool ServerBroadcastReq::has_fd() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServerBroadcastReq::set_has_fd() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServerBroadcastReq::clear_has_fd() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServerBroadcastReq::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 ServerBroadcastReq::fd() const {
  return fd_;
}
inline void ServerBroadcastReq::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int32 session = 22;
inline bool ServerBroadcastReq::has_session() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ServerBroadcastReq::set_has_session() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ServerBroadcastReq::clear_has_session() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ServerBroadcastReq::clear_session() {
  session_ = 0;
  clear_has_session();
}
inline ::google::protobuf::int32 ServerBroadcastReq::session() const {
  return session_;
}
inline void ServerBroadcastReq::set_session(::google::protobuf::int32 value) {
  set_has_session();
  session_ = value;
}

// -------------------------------------------------------------------

// ServerBroadcastResp

// required .ServerBroadcastResp.Result result = 1;
inline bool ServerBroadcastResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerBroadcastResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerBroadcastResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerBroadcastResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::ServerBroadcastResp_Result ServerBroadcastResp::result() const {
  return static_cast< ::ServerBroadcastResp_Result >(result_);
}
inline void ServerBroadcastResp::set_result(::ServerBroadcastResp_Result value) {
  assert(::ServerBroadcastResp_Result_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional int32 fd = 21;
inline bool ServerBroadcastResp::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerBroadcastResp::set_has_fd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerBroadcastResp::clear_has_fd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerBroadcastResp::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 ServerBroadcastResp::fd() const {
  return fd_;
}
inline void ServerBroadcastResp::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int64 session = 22;
inline bool ServerBroadcastResp::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerBroadcastResp::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerBroadcastResp::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerBroadcastResp::clear_session() {
  session_ = GOOGLE_LONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::int64 ServerBroadcastResp::session() const {
  return session_;
}
inline void ServerBroadcastResp::set_session(::google::protobuf::int64 value) {
  set_has_session();
  session_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UserInfoReportReq_ActType>() {
  return ::UserInfoReportReq_ActType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerBroadcastResp_Result>() {
  return ::ServerBroadcastResp_Result_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_inner_5fcmd_2eproto__INCLUDED
