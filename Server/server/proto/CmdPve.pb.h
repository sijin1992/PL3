// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdPve.proto

#ifndef PROTOBUF_CmdPve_2eproto__INCLUDED
#define PROTOBUF_CmdPve_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "AirShip.pb.h"
#include "Item.pb.h"
#include "UserSync.pb.h"
#include "Home.pb.h"
#include "UserInfo.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdPve_2eproto();
void protobuf_AssignDesc_CmdPve_2eproto();
void protobuf_ShutdownFile_CmdPve_2eproto();

class PveReq;
class PveResp;
class PVEGetRewardReq;
class PVEGetRewardResp;
class UpgradeTechReq;
class UpgradeTechResp;
class GetTechnologyReq;
class GetTechnologyResp;
class SpeedUpTechnologyReq;
class SpeedUpTechnologyResp;

// ===================================================================

class PveReq : public ::google::protobuf::Message {
 public:
  PveReq();
  virtual ~PveReq();

  PveReq(const PveReq& from);

  inline PveReq& operator=(const PveReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PveReq& default_instance();

  void Swap(PveReq* other);

  // implements Message ----------------------------------------------

  PveReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PveReq& from);
  void MergeFrom(const PveReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 checkpoint_id = 1;
  inline bool has_checkpoint_id() const;
  inline void clear_checkpoint_id();
  static const int kCheckpointIdFieldNumber = 1;
  inline ::google::protobuf::int32 checkpoint_id() const;
  inline void set_checkpoint_id(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required int32 star = 4;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 4;
  inline ::google::protobuf::int32 star() const;
  inline void set_star(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PveReq)
 private:
  inline void set_has_checkpoint_id();
  inline void clear_has_checkpoint_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_star();
  inline void clear_has_star();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 checkpoint_id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 star_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPve_2eproto();
  friend void protobuf_AssignDesc_CmdPve_2eproto();
  friend void protobuf_ShutdownFile_CmdPve_2eproto();

  void InitAsDefaultInstance();
  static PveReq* default_instance_;
};
// -------------------------------------------------------------------

class PveResp : public ::google::protobuf::Message {
 public:
  PveResp();
  virtual ~PveResp();

  PveResp(const PveResp& from);

  inline PveResp& operator=(const PveResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PveResp& default_instance();

  void Swap(PveResp* other);

  // implements Message ----------------------------------------------

  PveResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PveResp& from);
  void MergeFrom(const PveResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated .AirShip attack_list = 4;
  inline int attack_list_size() const;
  inline void clear_attack_list();
  static const int kAttackListFieldNumber = 4;
  inline const ::AirShip& attack_list(int index) const;
  inline ::AirShip* mutable_attack_list(int index);
  inline ::AirShip* add_attack_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
      attack_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
      mutable_attack_list();

  // repeated .AirShip hurter_list = 5;
  inline int hurter_list_size() const;
  inline void clear_hurter_list();
  static const int kHurterListFieldNumber = 5;
  inline const ::AirShip& hurter_list(int index) const;
  inline ::AirShip* mutable_hurter_list(int index);
  inline ::AirShip* add_hurter_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
      hurter_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
      mutable_hurter_list();

  // optional int32 char_exp_bonus = 6;
  inline bool has_char_exp_bonus() const;
  inline void clear_char_exp_bonus();
  static const int kCharExpBonusFieldNumber = 6;
  inline ::google::protobuf::int32 char_exp_bonus() const;
  inline void set_char_exp_bonus(::google::protobuf::int32 value);

  // optional int32 ship_exp_bonus = 7;
  inline bool has_ship_exp_bonus() const;
  inline void clear_ship_exp_bonus();
  static const int kShipExpBonusFieldNumber = 7;
  inline ::google::protobuf::int32 ship_exp_bonus() const;
  inline void set_ship_exp_bonus(::google::protobuf::int32 value);

  // optional int32 level_gold_bonus = 8;
  inline bool has_level_gold_bonus() const;
  inline void clear_level_gold_bonus();
  static const int kLevelGoldBonusFieldNumber = 8;
  inline ::google::protobuf::int32 level_gold_bonus() const;
  inline void set_level_gold_bonus(::google::protobuf::int32 value);

  // optional int32 level_point_bonus = 9;
  inline bool has_level_point_bonus() const;
  inline void clear_level_point_bonus();
  static const int kLevelPointBonusFieldNumber = 9;
  inline ::google::protobuf::int32 level_point_bonus() const;
  inline void set_level_point_bonus(::google::protobuf::int32 value);

  // required int32 checkpoint_id = 10;
  inline bool has_checkpoint_id() const;
  inline void clear_checkpoint_id();
  static const int kCheckpointIdFieldNumber = 10;
  inline ::google::protobuf::int32 checkpoint_id() const;
  inline void set_checkpoint_id(::google::protobuf::int32 value);

  // repeated .Pair get_item_list = 11;
  inline int get_item_list_size() const;
  inline void clear_get_item_list();
  static const int kGetItemListFieldNumber = 11;
  inline const ::Pair& get_item_list(int index) const;
  inline ::Pair* mutable_get_item_list(int index);
  inline ::Pair* add_get_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
      get_item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Pair >*
      mutable_get_item_list();

  // @@protoc_insertion_point(class_scope:PveResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_char_exp_bonus();
  inline void clear_has_char_exp_bonus();
  inline void set_has_ship_exp_bonus();
  inline void clear_has_ship_exp_bonus();
  inline void set_has_level_gold_bonus();
  inline void clear_has_level_gold_bonus();
  inline void set_has_level_point_bonus();
  inline void clear_has_level_point_bonus();
  inline void set_has_checkpoint_id();
  inline void clear_has_checkpoint_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::RepeatedPtrField< ::AirShip > attack_list_;
  ::google::protobuf::RepeatedPtrField< ::AirShip > hurter_list_;
  ::google::protobuf::int32 char_exp_bonus_;
  ::google::protobuf::int32 ship_exp_bonus_;
  ::google::protobuf::int32 level_gold_bonus_;
  ::google::protobuf::int32 level_point_bonus_;
  ::google::protobuf::RepeatedPtrField< ::Pair > get_item_list_;
  ::google::protobuf::int32 checkpoint_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPve_2eproto();
  friend void protobuf_AssignDesc_CmdPve_2eproto();
  friend void protobuf_ShutdownFile_CmdPve_2eproto();

  void InitAsDefaultInstance();
  static PveResp* default_instance_;
};
// -------------------------------------------------------------------

class PVEGetRewardReq : public ::google::protobuf::Message {
 public:
  PVEGetRewardReq();
  virtual ~PVEGetRewardReq();

  PVEGetRewardReq(const PVEGetRewardReq& from);

  inline PVEGetRewardReq& operator=(const PVEGetRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PVEGetRewardReq& default_instance();

  void Swap(PVEGetRewardReq* other);

  // implements Message ----------------------------------------------

  PVEGetRewardReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PVEGetRewardReq& from);
  void MergeFrom(const PVEGetRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 copy_id = 1;
  inline bool has_copy_id() const;
  inline void clear_copy_id();
  static const int kCopyIdFieldNumber = 1;
  inline ::google::protobuf::int32 copy_id() const;
  inline void set_copy_id(::google::protobuf::int32 value);

  // required int32 score_id = 2;
  inline bool has_score_id() const;
  inline void clear_score_id();
  static const int kScoreIdFieldNumber = 2;
  inline ::google::protobuf::int32 score_id() const;
  inline void set_score_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PVEGetRewardReq)
 private:
  inline void set_has_copy_id();
  inline void clear_has_copy_id();
  inline void set_has_score_id();
  inline void clear_has_score_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 copy_id_;
  ::google::protobuf::int32 score_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPve_2eproto();
  friend void protobuf_AssignDesc_CmdPve_2eproto();
  friend void protobuf_ShutdownFile_CmdPve_2eproto();

  void InitAsDefaultInstance();
  static PVEGetRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class PVEGetRewardResp : public ::google::protobuf::Message {
 public:
  PVEGetRewardResp();
  virtual ~PVEGetRewardResp();

  PVEGetRewardResp(const PVEGetRewardResp& from);

  inline PVEGetRewardResp& operator=(const PVEGetRewardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PVEGetRewardResp& default_instance();

  void Swap(PVEGetRewardResp* other);

  // implements Message ----------------------------------------------

  PVEGetRewardResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PVEGetRewardResp& from);
  void MergeFrom(const PVEGetRewardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:PVEGetRewardResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPve_2eproto();
  friend void protobuf_AssignDesc_CmdPve_2eproto();
  friend void protobuf_ShutdownFile_CmdPve_2eproto();

  void InitAsDefaultInstance();
  static PVEGetRewardResp* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeTechReq : public ::google::protobuf::Message {
 public:
  UpgradeTechReq();
  virtual ~UpgradeTechReq();

  UpgradeTechReq(const UpgradeTechReq& from);

  inline UpgradeTechReq& operator=(const UpgradeTechReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeTechReq& default_instance();

  void Swap(UpgradeTechReq* other);

  // implements Message ----------------------------------------------

  UpgradeTechReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpgradeTechReq& from);
  void MergeFrom(const UpgradeTechReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tech_id = 1;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 1;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UpgradeTechReq)
 private:
  inline void set_has_tech_id();
  inline void clear_has_tech_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tech_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPve_2eproto();
  friend void protobuf_AssignDesc_CmdPve_2eproto();
  friend void protobuf_ShutdownFile_CmdPve_2eproto();

  void InitAsDefaultInstance();
  static UpgradeTechReq* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeTechResp : public ::google::protobuf::Message {
 public:
  UpgradeTechResp();
  virtual ~UpgradeTechResp();

  UpgradeTechResp(const UpgradeTechResp& from);

  inline UpgradeTechResp& operator=(const UpgradeTechResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeTechResp& default_instance();

  void Swap(UpgradeTechResp* other);

  // implements Message ----------------------------------------------

  UpgradeTechResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpgradeTechResp& from);
  void MergeFrom(const UpgradeTechResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 tech_id = 3;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 3;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // optional int32 upgrade_begin_time = 4;
  inline bool has_upgrade_begin_time() const;
  inline void clear_upgrade_begin_time();
  static const int kUpgradeBeginTimeFieldNumber = 4;
  inline ::google::protobuf::int32 upgrade_begin_time() const;
  inline void set_upgrade_begin_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UpgradeTechResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_tech_id();
  inline void clear_has_tech_id();
  inline void set_has_upgrade_begin_time();
  inline void clear_has_upgrade_begin_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 tech_id_;
  ::google::protobuf::int32 upgrade_begin_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPve_2eproto();
  friend void protobuf_AssignDesc_CmdPve_2eproto();
  friend void protobuf_ShutdownFile_CmdPve_2eproto();

  void InitAsDefaultInstance();
  static UpgradeTechResp* default_instance_;
};
// -------------------------------------------------------------------

class GetTechnologyReq : public ::google::protobuf::Message {
 public:
  GetTechnologyReq();
  virtual ~GetTechnologyReq();

  GetTechnologyReq(const GetTechnologyReq& from);

  inline GetTechnologyReq& operator=(const GetTechnologyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTechnologyReq& default_instance();

  void Swap(GetTechnologyReq* other);

  // implements Message ----------------------------------------------

  GetTechnologyReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTechnologyReq& from);
  void MergeFrom(const GetTechnologyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tech_id = 1;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 1;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GetTechnologyReq)
 private:
  inline void set_has_tech_id();
  inline void clear_has_tech_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tech_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPve_2eproto();
  friend void protobuf_AssignDesc_CmdPve_2eproto();
  friend void protobuf_ShutdownFile_CmdPve_2eproto();

  void InitAsDefaultInstance();
  static GetTechnologyReq* default_instance_;
};
// -------------------------------------------------------------------

class GetTechnologyResp : public ::google::protobuf::Message {
 public:
  GetTechnologyResp();
  virtual ~GetTechnologyResp();

  GetTechnologyResp(const GetTechnologyResp& from);

  inline GetTechnologyResp& operator=(const GetTechnologyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTechnologyResp& default_instance();

  void Swap(GetTechnologyResp* other);

  // implements Message ----------------------------------------------

  GetTechnologyResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTechnologyResp& from);
  void MergeFrom(const GetTechnologyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional bool hasUpgrade = 3;
  inline bool has_hasupgrade() const;
  inline void clear_hasupgrade();
  static const int kHasUpgradeFieldNumber = 3;
  inline bool hasupgrade() const;
  inline void set_hasupgrade(bool value);

  // @@protoc_insertion_point(class_scope:GetTechnologyResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_hasupgrade();
  inline void clear_has_hasupgrade();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  bool hasupgrade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPve_2eproto();
  friend void protobuf_AssignDesc_CmdPve_2eproto();
  friend void protobuf_ShutdownFile_CmdPve_2eproto();

  void InitAsDefaultInstance();
  static GetTechnologyResp* default_instance_;
};
// -------------------------------------------------------------------

class SpeedUpTechnologyReq : public ::google::protobuf::Message {
 public:
  SpeedUpTechnologyReq();
  virtual ~SpeedUpTechnologyReq();

  SpeedUpTechnologyReq(const SpeedUpTechnologyReq& from);

  inline SpeedUpTechnologyReq& operator=(const SpeedUpTechnologyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedUpTechnologyReq& default_instance();

  void Swap(SpeedUpTechnologyReq* other);

  // implements Message ----------------------------------------------

  SpeedUpTechnologyReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeedUpTechnologyReq& from);
  void MergeFrom(const SpeedUpTechnologyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tech_id = 1;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 1;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SpeedUpTechnologyReq)
 private:
  inline void set_has_tech_id();
  inline void clear_has_tech_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tech_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPve_2eproto();
  friend void protobuf_AssignDesc_CmdPve_2eproto();
  friend void protobuf_ShutdownFile_CmdPve_2eproto();

  void InitAsDefaultInstance();
  static SpeedUpTechnologyReq* default_instance_;
};
// -------------------------------------------------------------------

class SpeedUpTechnologyResp : public ::google::protobuf::Message {
 public:
  SpeedUpTechnologyResp();
  virtual ~SpeedUpTechnologyResp();

  SpeedUpTechnologyResp(const SpeedUpTechnologyResp& from);

  inline SpeedUpTechnologyResp& operator=(const SpeedUpTechnologyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedUpTechnologyResp& default_instance();

  void Swap(SpeedUpTechnologyResp* other);

  // implements Message ----------------------------------------------

  SpeedUpTechnologyResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeedUpTechnologyResp& from);
  void MergeFrom(const SpeedUpTechnologyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:SpeedUpTechnologyResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPve_2eproto();
  friend void protobuf_AssignDesc_CmdPve_2eproto();
  friend void protobuf_ShutdownFile_CmdPve_2eproto();

  void InitAsDefaultInstance();
  static SpeedUpTechnologyResp* default_instance_;
};
// ===================================================================


// ===================================================================

// PveReq

// required int32 checkpoint_id = 1;
inline bool PveReq::has_checkpoint_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PveReq::set_has_checkpoint_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PveReq::clear_has_checkpoint_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PveReq::clear_checkpoint_id() {
  checkpoint_id_ = 0;
  clear_has_checkpoint_id();
}
inline ::google::protobuf::int32 PveReq::checkpoint_id() const {
  return checkpoint_id_;
}
inline void PveReq::set_checkpoint_id(::google::protobuf::int32 value) {
  set_has_checkpoint_id();
  checkpoint_id_ = value;
}

// required int32 type = 2;
inline bool PveReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PveReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PveReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PveReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PveReq::type() const {
  return type_;
}
inline void PveReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 result = 3;
inline bool PveReq::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PveReq::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PveReq::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PveReq::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PveReq::result() const {
  return result_;
}
inline void PveReq::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required int32 star = 4;
inline bool PveReq::has_star() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PveReq::set_has_star() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PveReq::clear_has_star() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PveReq::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 PveReq::star() const {
  return star_;
}
inline void PveReq::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
}

// -------------------------------------------------------------------

// PveResp

// required int32 result = 1;
inline bool PveResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PveResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PveResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PveResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PveResp::result() const {
  return result_;
}
inline void PveResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PveResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PveResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PveResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PveResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PveResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* PveResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PveResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PveResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// required int32 type = 3;
inline bool PveResp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PveResp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PveResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PveResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PveResp::type() const {
  return type_;
}
inline void PveResp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated .AirShip attack_list = 4;
inline int PveResp::attack_list_size() const {
  return attack_list_.size();
}
inline void PveResp::clear_attack_list() {
  attack_list_.Clear();
}
inline const ::AirShip& PveResp::attack_list(int index) const {
  return attack_list_.Get(index);
}
inline ::AirShip* PveResp::mutable_attack_list(int index) {
  return attack_list_.Mutable(index);
}
inline ::AirShip* PveResp::add_attack_list() {
  return attack_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
PveResp::attack_list() const {
  return attack_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
PveResp::mutable_attack_list() {
  return &attack_list_;
}

// repeated .AirShip hurter_list = 5;
inline int PveResp::hurter_list_size() const {
  return hurter_list_.size();
}
inline void PveResp::clear_hurter_list() {
  hurter_list_.Clear();
}
inline const ::AirShip& PveResp::hurter_list(int index) const {
  return hurter_list_.Get(index);
}
inline ::AirShip* PveResp::mutable_hurter_list(int index) {
  return hurter_list_.Mutable(index);
}
inline ::AirShip* PveResp::add_hurter_list() {
  return hurter_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
PveResp::hurter_list() const {
  return hurter_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
PveResp::mutable_hurter_list() {
  return &hurter_list_;
}

// optional int32 char_exp_bonus = 6;
inline bool PveResp::has_char_exp_bonus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PveResp::set_has_char_exp_bonus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PveResp::clear_has_char_exp_bonus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PveResp::clear_char_exp_bonus() {
  char_exp_bonus_ = 0;
  clear_has_char_exp_bonus();
}
inline ::google::protobuf::int32 PveResp::char_exp_bonus() const {
  return char_exp_bonus_;
}
inline void PveResp::set_char_exp_bonus(::google::protobuf::int32 value) {
  set_has_char_exp_bonus();
  char_exp_bonus_ = value;
}

// optional int32 ship_exp_bonus = 7;
inline bool PveResp::has_ship_exp_bonus() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PveResp::set_has_ship_exp_bonus() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PveResp::clear_has_ship_exp_bonus() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PveResp::clear_ship_exp_bonus() {
  ship_exp_bonus_ = 0;
  clear_has_ship_exp_bonus();
}
inline ::google::protobuf::int32 PveResp::ship_exp_bonus() const {
  return ship_exp_bonus_;
}
inline void PveResp::set_ship_exp_bonus(::google::protobuf::int32 value) {
  set_has_ship_exp_bonus();
  ship_exp_bonus_ = value;
}

// optional int32 level_gold_bonus = 8;
inline bool PveResp::has_level_gold_bonus() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PveResp::set_has_level_gold_bonus() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PveResp::clear_has_level_gold_bonus() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PveResp::clear_level_gold_bonus() {
  level_gold_bonus_ = 0;
  clear_has_level_gold_bonus();
}
inline ::google::protobuf::int32 PveResp::level_gold_bonus() const {
  return level_gold_bonus_;
}
inline void PveResp::set_level_gold_bonus(::google::protobuf::int32 value) {
  set_has_level_gold_bonus();
  level_gold_bonus_ = value;
}

// optional int32 level_point_bonus = 9;
inline bool PveResp::has_level_point_bonus() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PveResp::set_has_level_point_bonus() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PveResp::clear_has_level_point_bonus() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PveResp::clear_level_point_bonus() {
  level_point_bonus_ = 0;
  clear_has_level_point_bonus();
}
inline ::google::protobuf::int32 PveResp::level_point_bonus() const {
  return level_point_bonus_;
}
inline void PveResp::set_level_point_bonus(::google::protobuf::int32 value) {
  set_has_level_point_bonus();
  level_point_bonus_ = value;
}

// required int32 checkpoint_id = 10;
inline bool PveResp::has_checkpoint_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PveResp::set_has_checkpoint_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PveResp::clear_has_checkpoint_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PveResp::clear_checkpoint_id() {
  checkpoint_id_ = 0;
  clear_has_checkpoint_id();
}
inline ::google::protobuf::int32 PveResp::checkpoint_id() const {
  return checkpoint_id_;
}
inline void PveResp::set_checkpoint_id(::google::protobuf::int32 value) {
  set_has_checkpoint_id();
  checkpoint_id_ = value;
}

// repeated .Pair get_item_list = 11;
inline int PveResp::get_item_list_size() const {
  return get_item_list_.size();
}
inline void PveResp::clear_get_item_list() {
  get_item_list_.Clear();
}
inline const ::Pair& PveResp::get_item_list(int index) const {
  return get_item_list_.Get(index);
}
inline ::Pair* PveResp::mutable_get_item_list(int index) {
  return get_item_list_.Mutable(index);
}
inline ::Pair* PveResp::add_get_item_list() {
  return get_item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
PveResp::get_item_list() const {
  return get_item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Pair >*
PveResp::mutable_get_item_list() {
  return &get_item_list_;
}

// -------------------------------------------------------------------

// PVEGetRewardReq

// required int32 copy_id = 1;
inline bool PVEGetRewardReq::has_copy_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVEGetRewardReq::set_has_copy_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVEGetRewardReq::clear_has_copy_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVEGetRewardReq::clear_copy_id() {
  copy_id_ = 0;
  clear_has_copy_id();
}
inline ::google::protobuf::int32 PVEGetRewardReq::copy_id() const {
  return copy_id_;
}
inline void PVEGetRewardReq::set_copy_id(::google::protobuf::int32 value) {
  set_has_copy_id();
  copy_id_ = value;
}

// required int32 score_id = 2;
inline bool PVEGetRewardReq::has_score_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PVEGetRewardReq::set_has_score_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PVEGetRewardReq::clear_has_score_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PVEGetRewardReq::clear_score_id() {
  score_id_ = 0;
  clear_has_score_id();
}
inline ::google::protobuf::int32 PVEGetRewardReq::score_id() const {
  return score_id_;
}
inline void PVEGetRewardReq::set_score_id(::google::protobuf::int32 value) {
  set_has_score_id();
  score_id_ = value;
}

// -------------------------------------------------------------------

// PVEGetRewardResp

// required int32 result = 1;
inline bool PVEGetRewardResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVEGetRewardResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVEGetRewardResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVEGetRewardResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PVEGetRewardResp::result() const {
  return result_;
}
inline void PVEGetRewardResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PVEGetRewardResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PVEGetRewardResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PVEGetRewardResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PVEGetRewardResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PVEGetRewardResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* PVEGetRewardResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PVEGetRewardResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PVEGetRewardResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// UpgradeTechReq

// required int32 tech_id = 1;
inline bool UpgradeTechReq::has_tech_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeTechReq::set_has_tech_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeTechReq::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeTechReq::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 UpgradeTechReq::tech_id() const {
  return tech_id_;
}
inline void UpgradeTechReq::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// -------------------------------------------------------------------

// UpgradeTechResp

// required int32 result = 1;
inline bool UpgradeTechResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeTechResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeTechResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeTechResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UpgradeTechResp::result() const {
  return result_;
}
inline void UpgradeTechResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool UpgradeTechResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeTechResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeTechResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeTechResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& UpgradeTechResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* UpgradeTechResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* UpgradeTechResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void UpgradeTechResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 tech_id = 3;
inline bool UpgradeTechResp::has_tech_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpgradeTechResp::set_has_tech_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpgradeTechResp::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpgradeTechResp::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 UpgradeTechResp::tech_id() const {
  return tech_id_;
}
inline void UpgradeTechResp::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// optional int32 upgrade_begin_time = 4;
inline bool UpgradeTechResp::has_upgrade_begin_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpgradeTechResp::set_has_upgrade_begin_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpgradeTechResp::clear_has_upgrade_begin_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpgradeTechResp::clear_upgrade_begin_time() {
  upgrade_begin_time_ = 0;
  clear_has_upgrade_begin_time();
}
inline ::google::protobuf::int32 UpgradeTechResp::upgrade_begin_time() const {
  return upgrade_begin_time_;
}
inline void UpgradeTechResp::set_upgrade_begin_time(::google::protobuf::int32 value) {
  set_has_upgrade_begin_time();
  upgrade_begin_time_ = value;
}

// -------------------------------------------------------------------

// GetTechnologyReq

// required int32 tech_id = 1;
inline bool GetTechnologyReq::has_tech_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTechnologyReq::set_has_tech_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTechnologyReq::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTechnologyReq::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 GetTechnologyReq::tech_id() const {
  return tech_id_;
}
inline void GetTechnologyReq::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// -------------------------------------------------------------------

// GetTechnologyResp

// required int32 result = 1;
inline bool GetTechnologyResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTechnologyResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTechnologyResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTechnologyResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GetTechnologyResp::result() const {
  return result_;
}
inline void GetTechnologyResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GetTechnologyResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTechnologyResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTechnologyResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTechnologyResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GetTechnologyResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GetTechnologyResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GetTechnologyResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GetTechnologyResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional bool hasUpgrade = 3;
inline bool GetTechnologyResp::has_hasupgrade() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetTechnologyResp::set_has_hasupgrade() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetTechnologyResp::clear_has_hasupgrade() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetTechnologyResp::clear_hasupgrade() {
  hasupgrade_ = false;
  clear_has_hasupgrade();
}
inline bool GetTechnologyResp::hasupgrade() const {
  return hasupgrade_;
}
inline void GetTechnologyResp::set_hasupgrade(bool value) {
  set_has_hasupgrade();
  hasupgrade_ = value;
}

// -------------------------------------------------------------------

// SpeedUpTechnologyReq

// required int32 tech_id = 1;
inline bool SpeedUpTechnologyReq::has_tech_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedUpTechnologyReq::set_has_tech_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedUpTechnologyReq::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedUpTechnologyReq::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 SpeedUpTechnologyReq::tech_id() const {
  return tech_id_;
}
inline void SpeedUpTechnologyReq::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// -------------------------------------------------------------------

// SpeedUpTechnologyResp

// required int32 result = 1;
inline bool SpeedUpTechnologyResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedUpTechnologyResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedUpTechnologyResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedUpTechnologyResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 SpeedUpTechnologyResp::result() const {
  return result_;
}
inline void SpeedUpTechnologyResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SpeedUpTechnologyResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeedUpTechnologyResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeedUpTechnologyResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeedUpTechnologyResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SpeedUpTechnologyResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SpeedUpTechnologyResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SpeedUpTechnologyResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SpeedUpTechnologyResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdPve_2eproto__INCLUDED
