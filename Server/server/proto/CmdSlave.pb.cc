// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdSlave.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CmdSlave.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* SlaveSyncDataReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveSyncDataReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveSyncDataResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveSyncDataResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveSyncDataResp_SlaveSyncDataRet_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SlaveGetResReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveGetResReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveGetResResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveGetResResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveGetResResp_SlaveGetResRet_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SlaveFreeReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveFreeReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveFreeResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveFreeResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveFreeResp_SlaveFreeRet_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SlaveShowReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveShowReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveShowResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveShowResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveShowResp_SlaveShowRet_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SlaveWorkReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveWorkReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveWorkResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveWorkResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveWorkResp_SlaveWorkRet_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SlaveFawnOnReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveFawnOnReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveFawnOnResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveFawnOnResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveFawnOnResp_SlaveFawnOnRet_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SlaveHelpReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveHelpReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveHelpResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveHelpResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveHelpResp_SlaveHelpRet_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SlaveSearchReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveSearchReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveSearchResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveSearchResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveSearchResp_SlaveSearchRet_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SlaveAddTimesReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveAddTimesReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveAddTimesResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveAddTimesResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveAddTimesResp_SlaveAddTimesRet_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SlaveAttackReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveAttackReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveAttackResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveAttackResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveAttackResp_SlaveAttackRet_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_CmdSlave_2eproto() {
  protobuf_AddDesc_CmdSlave_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CmdSlave.proto");
  GOOGLE_CHECK(file != NULL);
  SlaveSyncDataReq_descriptor_ = file->message_type(0);
  static const int SlaveSyncDataReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSyncDataReq, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSyncDataReq, user_name_list_),
  };
  SlaveSyncDataReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveSyncDataReq_descriptor_,
      SlaveSyncDataReq::default_instance_,
      SlaveSyncDataReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSyncDataReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSyncDataReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveSyncDataReq));
  SlaveSyncDataResp_descriptor_ = file->message_type(1);
  static const int SlaveSyncDataResp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSyncDataResp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSyncDataResp, user_sync_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSyncDataResp, slave_data_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSyncDataResp, info_list_),
  };
  SlaveSyncDataResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveSyncDataResp_descriptor_,
      SlaveSyncDataResp::default_instance_,
      SlaveSyncDataResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSyncDataResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSyncDataResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveSyncDataResp));
  SlaveSyncDataResp_SlaveSyncDataRet_descriptor_ = SlaveSyncDataResp_descriptor_->enum_type(0);
  SlaveGetResReq_descriptor_ = file->message_type(2);
  static const int SlaveGetResReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveGetResReq, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveGetResReq, slave_name_),
  };
  SlaveGetResReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveGetResReq_descriptor_,
      SlaveGetResReq::default_instance_,
      SlaveGetResReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveGetResReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveGetResReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveGetResReq));
  SlaveGetResResp_descriptor_ = file->message_type(3);
  static const int SlaveGetResResp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveGetResResp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveGetResResp, user_sync_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveGetResResp, res_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveGetResResp, exp_),
  };
  SlaveGetResResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveGetResResp_descriptor_,
      SlaveGetResResp::default_instance_,
      SlaveGetResResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveGetResResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveGetResResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveGetResResp));
  SlaveGetResResp_SlaveGetResRet_descriptor_ = SlaveGetResResp_descriptor_->enum_type(0);
  SlaveFreeReq_descriptor_ = file->message_type(4);
  static const int SlaveFreeReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFreeReq, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFreeReq, slave_name_),
  };
  SlaveFreeReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveFreeReq_descriptor_,
      SlaveFreeReq::default_instance_,
      SlaveFreeReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFreeReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFreeReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveFreeReq));
  SlaveFreeResp_descriptor_ = file->message_type(5);
  static const int SlaveFreeResp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFreeResp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFreeResp, user_sync_),
  };
  SlaveFreeResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveFreeResp_descriptor_,
      SlaveFreeResp::default_instance_,
      SlaveFreeResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFreeResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFreeResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveFreeResp));
  SlaveFreeResp_SlaveFreeRet_descriptor_ = SlaveFreeResp_descriptor_->enum_type(0);
  SlaveShowReq_descriptor_ = file->message_type(6);
  static const int SlaveShowReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveShowReq, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveShowReq, slave_name_),
  };
  SlaveShowReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveShowReq_descriptor_,
      SlaveShowReq::default_instance_,
      SlaveShowReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveShowReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveShowReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveShowReq));
  SlaveShowResp_descriptor_ = file->message_type(7);
  static const int SlaveShowResp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveShowResp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveShowResp, user_sync_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveShowResp, get_item_list_),
  };
  SlaveShowResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveShowResp_descriptor_,
      SlaveShowResp::default_instance_,
      SlaveShowResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveShowResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveShowResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveShowResp));
  SlaveShowResp_SlaveShowRet_descriptor_ = SlaveShowResp_descriptor_->enum_type(0);
  SlaveWorkReq_descriptor_ = file->message_type(8);
  static const int SlaveWorkReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveWorkReq, slave_name_),
  };
  SlaveWorkReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveWorkReq_descriptor_,
      SlaveWorkReq::default_instance_,
      SlaveWorkReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveWorkReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveWorkReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveWorkReq));
  SlaveWorkResp_descriptor_ = file->message_type(9);
  static const int SlaveWorkResp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveWorkResp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveWorkResp, user_sync_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveWorkResp, get_item_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveWorkResp, note_info_),
  };
  SlaveWorkResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveWorkResp_descriptor_,
      SlaveWorkResp::default_instance_,
      SlaveWorkResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveWorkResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveWorkResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveWorkResp));
  SlaveWorkResp_SlaveWorkRet_descriptor_ = SlaveWorkResp_descriptor_->enum_type(0);
  SlaveFawnOnReq_descriptor_ = file->message_type(10);
  static const int SlaveFawnOnReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFawnOnReq, type_),
  };
  SlaveFawnOnReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveFawnOnReq_descriptor_,
      SlaveFawnOnReq::default_instance_,
      SlaveFawnOnReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFawnOnReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFawnOnReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveFawnOnReq));
  SlaveFawnOnResp_descriptor_ = file->message_type(11);
  static const int SlaveFawnOnResp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFawnOnResp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFawnOnResp, user_sync_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFawnOnResp, get_item_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFawnOnResp, note_info_),
  };
  SlaveFawnOnResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveFawnOnResp_descriptor_,
      SlaveFawnOnResp::default_instance_,
      SlaveFawnOnResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFawnOnResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveFawnOnResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveFawnOnResp));
  SlaveFawnOnResp_SlaveFawnOnRet_descriptor_ = SlaveFawnOnResp_descriptor_->enum_type(0);
  SlaveHelpReq_descriptor_ = file->message_type(12);
  static const int SlaveHelpReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveHelpReq, type_),
  };
  SlaveHelpReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveHelpReq_descriptor_,
      SlaveHelpReq::default_instance_,
      SlaveHelpReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveHelpReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveHelpReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveHelpReq));
  SlaveHelpResp_descriptor_ = file->message_type(13);
  static const int SlaveHelpResp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveHelpResp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveHelpResp, user_sync_),
  };
  SlaveHelpResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveHelpResp_descriptor_,
      SlaveHelpResp::default_instance_,
      SlaveHelpResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveHelpResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveHelpResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveHelpResp));
  SlaveHelpResp_SlaveHelpRet_descriptor_ = SlaveHelpResp_descriptor_->enum_type(0);
  SlaveSearchReq_descriptor_ = file->message_type(14);
  static const int SlaveSearchReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSearchReq, type_),
  };
  SlaveSearchReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveSearchReq_descriptor_,
      SlaveSearchReq::default_instance_,
      SlaveSearchReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSearchReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSearchReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveSearchReq));
  SlaveSearchResp_descriptor_ = file->message_type(15);
  static const int SlaveSearchResp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSearchResp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSearchResp, user_sync_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSearchResp, info_list_),
  };
  SlaveSearchResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveSearchResp_descriptor_,
      SlaveSearchResp::default_instance_,
      SlaveSearchResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSearchResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveSearchResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveSearchResp));
  SlaveSearchResp_SlaveSearchRet_descriptor_ = SlaveSearchResp_descriptor_->enum_type(0);
  SlaveAddTimesReq_descriptor_ = file->message_type(16);
  static const int SlaveAddTimesReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAddTimesReq, type_),
  };
  SlaveAddTimesReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveAddTimesReq_descriptor_,
      SlaveAddTimesReq::default_instance_,
      SlaveAddTimesReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAddTimesReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAddTimesReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveAddTimesReq));
  SlaveAddTimesResp_descriptor_ = file->message_type(17);
  static const int SlaveAddTimesResp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAddTimesResp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAddTimesResp, user_sync_),
  };
  SlaveAddTimesResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveAddTimesResp_descriptor_,
      SlaveAddTimesResp::default_instance_,
      SlaveAddTimesResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAddTimesResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAddTimesResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveAddTimesResp));
  SlaveAddTimesResp_SlaveAddTimesRet_descriptor_ = SlaveAddTimesResp_descriptor_->enum_type(0);
  SlaveAttackReq_descriptor_ = file->message_type(18);
  static const int SlaveAttackReq_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackReq, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackReq, user_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackReq, lineup_),
  };
  SlaveAttackReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveAttackReq_descriptor_,
      SlaveAttackReq::default_instance_,
      SlaveAttackReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveAttackReq));
  SlaveAttackResp_descriptor_ = file->message_type(19);
  static const int SlaveAttackResp_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, user_sync_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, attack_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, hurter_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, event_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, iswin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, iscatch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, get_item_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, req_),
  };
  SlaveAttackResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SlaveAttackResp_descriptor_,
      SlaveAttackResp::default_instance_,
      SlaveAttackResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveAttackResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SlaveAttackResp));
  SlaveAttackResp_SlaveAttackRet_descriptor_ = SlaveAttackResp_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CmdSlave_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveSyncDataReq_descriptor_, &SlaveSyncDataReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveSyncDataResp_descriptor_, &SlaveSyncDataResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveGetResReq_descriptor_, &SlaveGetResReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveGetResResp_descriptor_, &SlaveGetResResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveFreeReq_descriptor_, &SlaveFreeReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveFreeResp_descriptor_, &SlaveFreeResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveShowReq_descriptor_, &SlaveShowReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveShowResp_descriptor_, &SlaveShowResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveWorkReq_descriptor_, &SlaveWorkReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveWorkResp_descriptor_, &SlaveWorkResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveFawnOnReq_descriptor_, &SlaveFawnOnReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveFawnOnResp_descriptor_, &SlaveFawnOnResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveHelpReq_descriptor_, &SlaveHelpReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveHelpResp_descriptor_, &SlaveHelpResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveSearchReq_descriptor_, &SlaveSearchReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveSearchResp_descriptor_, &SlaveSearchResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveAddTimesReq_descriptor_, &SlaveAddTimesReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveAddTimesResp_descriptor_, &SlaveAddTimesResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveAttackReq_descriptor_, &SlaveAttackReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SlaveAttackResp_descriptor_, &SlaveAttackResp::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CmdSlave_2eproto() {
  delete SlaveSyncDataReq::default_instance_;
  delete SlaveSyncDataReq_reflection_;
  delete SlaveSyncDataResp::default_instance_;
  delete SlaveSyncDataResp_reflection_;
  delete SlaveGetResReq::default_instance_;
  delete SlaveGetResReq_reflection_;
  delete SlaveGetResResp::default_instance_;
  delete SlaveGetResResp_reflection_;
  delete SlaveFreeReq::default_instance_;
  delete SlaveFreeReq_reflection_;
  delete SlaveFreeResp::default_instance_;
  delete SlaveFreeResp_reflection_;
  delete SlaveShowReq::default_instance_;
  delete SlaveShowReq_reflection_;
  delete SlaveShowResp::default_instance_;
  delete SlaveShowResp_reflection_;
  delete SlaveWorkReq::default_instance_;
  delete SlaveWorkReq_reflection_;
  delete SlaveWorkResp::default_instance_;
  delete SlaveWorkResp_reflection_;
  delete SlaveFawnOnReq::default_instance_;
  delete SlaveFawnOnReq_reflection_;
  delete SlaveFawnOnResp::default_instance_;
  delete SlaveFawnOnResp_reflection_;
  delete SlaveHelpReq::default_instance_;
  delete SlaveHelpReq_reflection_;
  delete SlaveHelpResp::default_instance_;
  delete SlaveHelpResp_reflection_;
  delete SlaveSearchReq::default_instance_;
  delete SlaveSearchReq_reflection_;
  delete SlaveSearchResp::default_instance_;
  delete SlaveSearchResp_reflection_;
  delete SlaveAddTimesReq::default_instance_;
  delete SlaveAddTimesReq_reflection_;
  delete SlaveAddTimesResp::default_instance_;
  delete SlaveAddTimesResp_reflection_;
  delete SlaveAttackReq::default_instance_;
  delete SlaveAttackReq_reflection_;
  delete SlaveAttackResp::default_instance_;
  delete SlaveAttackResp_reflection_;
}

void protobuf_AddDesc_CmdSlave_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_Item_2eproto();
  ::protobuf_AddDesc_AirShip_2eproto();
  ::protobuf_AddDesc_Slave_2eproto();
  ::protobuf_AddDesc_UserSync_2eproto();
  ::protobuf_AddDesc_PvpInfo_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016CmdSlave.proto\032\nItem.proto\032\rAirShip.pr"
    "oto\032\013Slave.proto\032\016UserSync.proto\032\rPvpInf"
    "o.proto\"8\n\020SlaveSyncDataReq\022\014\n\004type\030\001 \002("
    "\005\022\026\n\016user_name_list\030\002 \003(\t\"\336\001\n\021SlaveSyncD"
    "ataResp\0223\n\006result\030\001 \002(\0162#.SlaveSyncDataR"
    "esp.SlaveSyncDataRet\022\034\n\tuser_sync\030\002 \001(\0132"
    "\t.UserSync\022#\n\017slave_data_list\030\003 \003(\0132\n.Sl"
    "aveData\022\"\n\tinfo_list\030\004 \003(\0132\017.SlaveBriefI"
    "nfo\"-\n\020SlaveSyncDataRet\022\006\n\002OK\020\000\022\021\n\004FAIL\020"
    "\377\377\377\377\377\377\377\377\377\001\"2\n\016SlaveGetResReq\022\014\n\004type\030\001 \002"
    "(\005\022\022\n\nslave_name\030\002 \002(\t\"\306\001\n\017SlaveGetResRe"
    "sp\022/\n\006result\030\001 \002(\0162\037.SlaveGetResResp.Sla"
    "veGetResRet\022\034\n\tuser_sync\030\002 \001(\0132\t.UserSyn"
    "c\022\013\n\003res\030\003 \003(\005\022\013\n\003exp\030\004 \001(\005\"J\n\016SlaveGetR"
    "esRet\022\006\n\002OK\020\000\022\021\n\004FAIL\020\377\377\377\377\377\377\377\377\377\001\022\020\n\014NOT_"
    "MY_SLAVE\020\001\022\013\n\007CD_TIME\020\002\"0\n\014SlaveFreeReq\022"
    "\014\n\004type\030\001 \002(\005\022\022\n\nslave_name\030\002 \002(\t\"\255\001\n\rSl"
    "aveFreeResp\022+\n\006result\030\001 \002(\0162\033.SlaveFreeR"
    "esp.SlaveFreeRet\022\034\n\tuser_sync\030\002 \001(\0132\t.Us"
    "erSync\"Q\n\014SlaveFreeRet\022\006\n\002OK\020\000\022\021\n\004FAIL\020\377"
    "\377\377\377\377\377\377\377\377\001\022\020\n\014NOT_MY_SLAVE\020\001\022\024\n\020FREE_SLAV"
    "E_ERROR\020\002\"0\n\014SlaveShowReq\022\014\n\004type\030\001 \002(\005\022"
    "\022\n\nslave_name\030\002 \002(\t\"\224\002\n\rSlaveShowResp\022+\n"
    "\006result\030\001 \002(\0162\033.SlaveShowResp.SlaveShowR"
    "et\022\034\n\tuser_sync\030\002 \001(\0132\t.UserSync\022\034\n\rget_"
    "item_list\030\003 \003(\0132\005.Pair\"\231\001\n\014SlaveShowRet\022"
    "\006\n\002OK\020\000\022\021\n\004FAIL\020\377\377\377\377\377\377\377\377\377\001\022\020\n\014NOT_MY_SLA"
    "VE\020\001\022\014\n\010NO_MONEY\020\002\022\017\n\013STATE_ERROR\020\003\022\016\n\nT"
    "YPE_ERROR\020\004\022\r\n\tNO_MASTER\020\005\022\021\n\rWATCH_NUM_"
    "MAX\020\006\022\013\n\007WATCHED\020\007\"\"\n\014SlaveWorkReq\022\022\n\nsl"
    "ave_name\030\001 \002(\t\"\345\001\n\rSlaveWorkResp\022+\n\006resu"
    "lt\030\001 \002(\0162\033.SlaveWorkResp.SlaveWorkRet\022\034\n"
    "\tuser_sync\030\002 \001(\0132\t.UserSync\022\034\n\rget_item_"
    "list\030\003 \003(\0132\005.Pair\022!\n\tnote_info\030\004 \001(\0132\016.S"
    "laveNoteInfo\"H\n\014SlaveWorkRet\022\006\n\002OK\020\000\022\021\n\004"
    "FAIL\020\377\377\377\377\377\377\377\377\377\001\022\020\n\014NOT_MY_SLAVE\020\001\022\013\n\007CD_"
    "TIME\020\002\"\036\n\016SlaveFawnOnReq\022\014\n\004type\030\001 \002(\005\"\352"
    "\001\n\017SlaveFawnOnResp\022/\n\006result\030\001 \002(\0162\037.Sla"
    "veFawnOnResp.SlaveFawnOnRet\022\034\n\tuser_sync"
    "\030\002 \001(\0132\t.UserSync\022\034\n\rget_item_list\030\003 \003(\013"
    "2\005.Pair\022!\n\tnote_info\030\004 \001(\0132\016.SlaveNoteIn"
    "fo\"G\n\016SlaveFawnOnRet\022\006\n\002OK\020\000\022\021\n\004FAIL\020\377\377\377"
    "\377\377\377\377\377\377\001\022\r\n\tNO_MASTER\020\001\022\013\n\007CD_TIME\020\002\"\034\n\014S"
    "laveHelpReq\022\014\n\004type\030\001 \002(\005\"\266\001\n\rSlaveHelpR"
    "esp\022+\n\006result\030\001 \002(\0162\033.SlaveHelpResp.Slav"
    "eHelpRet\022\034\n\tuser_sync\030\002 \001(\0132\t.UserSync\"Z"
    "\n\014SlaveHelpRet\022\006\n\002OK\020\000\022\021\n\004FAIL\020\377\377\377\377\377\377\377\377\377"
    "\001\022\r\n\tNO_MASTER\020\001\022\013\n\007CD_TIME\020\002\022\023\n\017SEND_LI"
    "ST_EMPTY\020\003\"\036\n\016SlaveSearchReq\022\014\n\004type\030\001 \002"
    "(\005\"\334\001\n\017SlaveSearchResp\022/\n\006result\030\001 \002(\0162\037"
    ".SlaveSearchResp.SlaveSearchRet\022\034\n\tuser_"
    "sync\030\002 \001(\0132\t.UserSync\022\"\n\tinfo_list\030\003 \003(\013"
    "2\017.SlaveBriefInfo\"V\n\016SlaveSearchRet\022\006\n\002O"
    "K\020\000\022\021\n\004FAIL\020\377\377\377\377\377\377\377\377\377\001\022\t\n\005EMPTY\020\001\022\016\n\nHAS"
    "_MASTER\020\002\022\016\n\nERROR_TYPE\020\003\" \n\020SlaveAddTim"
    "esReq\022\014\n\004type\030\001 \002(\005\"\243\001\n\021SlaveAddTimesRes"
    "p\0223\n\006result\030\001 \002(\0162#.SlaveAddTimesResp.Sl"
    "aveAddTimesRet\022\034\n\tuser_sync\030\002 \001(\0132\t.User"
    "Sync\";\n\020SlaveAddTimesRet\022\006\n\002OK\020\000\022\021\n\004FAIL"
    "\020\377\377\377\377\377\377\377\377\377\001\022\014\n\010NO_MONEY\020\001\"A\n\016SlaveAttack"
    "Req\022\014\n\004type\030\001 \002(\005\022\021\n\tuser_name\030\002 \002(\t\022\016\n\006"
    "lineup\030\003 \003(\005\"\271\004\n\017SlaveAttackResp\022/\n\006resu"
    "lt\030\001 \002(\0162\037.SlaveAttackResp.SlaveAttackRe"
    "t\022\034\n\tuser_sync\030\002 \001(\0132\t.UserSync\022\035\n\013attac"
    "k_list\030\003 \003(\0132\010.AirShip\022\035\n\013hurter_list\030\004 "
    "\003(\0132\010.AirShip\022\036\n\nevent_list\030\005 \003(\0132\n.Even"
    "tInfo\022\r\n\005isWin\030\006 \001(\010\022\017\n\007isCatch\030\007 \001(\010\022\034\n"
    "\rget_item_list\030\010 \003(\0132\005.Pair\022\034\n\003req\030\t \001(\013"
    "2\017.SlaveAttackReq\"\234\002\n\016SlaveAttackRet\022\006\n\002"
    "OK\020\000\022\021\n\004FAIL\020\377\377\377\377\377\377\377\377\377\001\022\014\n\010NO_EMEMY\020\001\022\017\n"
    "\013ATTACK_SELF\020\002\022\016\n\nERROR_TYPE\020\003\022\016\n\nHAS_MA"
    "STER\020\004\022\014\n\010NO_TIMES\020\005\022\013\n\007CD_TIME\020\006\022\014\n\010NO_"
    "SHIPS\020\007\022\016\n\nNO_DURABLE\020\010\022\n\n\006FIXING\020\t\022\024\n\020N"
    "OT_SLAVE_MASTER\020\n\022\r\n\tMAX_SLAVE\020\013\022\r\n\tNO_M"
    "ASTER\020\014\022\r\n\tHAS_SLAVE\020\r\022\013\n\007SHOWING\020\016\022\017\n\013C"
    "ATCH_ERROR\020\017\022\n\n\006OUTING\020\020", 3024);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CmdSlave.proto", &protobuf_RegisterTypes);
  SlaveSyncDataReq::default_instance_ = new SlaveSyncDataReq();
  SlaveSyncDataResp::default_instance_ = new SlaveSyncDataResp();
  SlaveGetResReq::default_instance_ = new SlaveGetResReq();
  SlaveGetResResp::default_instance_ = new SlaveGetResResp();
  SlaveFreeReq::default_instance_ = new SlaveFreeReq();
  SlaveFreeResp::default_instance_ = new SlaveFreeResp();
  SlaveShowReq::default_instance_ = new SlaveShowReq();
  SlaveShowResp::default_instance_ = new SlaveShowResp();
  SlaveWorkReq::default_instance_ = new SlaveWorkReq();
  SlaveWorkResp::default_instance_ = new SlaveWorkResp();
  SlaveFawnOnReq::default_instance_ = new SlaveFawnOnReq();
  SlaveFawnOnResp::default_instance_ = new SlaveFawnOnResp();
  SlaveHelpReq::default_instance_ = new SlaveHelpReq();
  SlaveHelpResp::default_instance_ = new SlaveHelpResp();
  SlaveSearchReq::default_instance_ = new SlaveSearchReq();
  SlaveSearchResp::default_instance_ = new SlaveSearchResp();
  SlaveAddTimesReq::default_instance_ = new SlaveAddTimesReq();
  SlaveAddTimesResp::default_instance_ = new SlaveAddTimesResp();
  SlaveAttackReq::default_instance_ = new SlaveAttackReq();
  SlaveAttackResp::default_instance_ = new SlaveAttackResp();
  SlaveSyncDataReq::default_instance_->InitAsDefaultInstance();
  SlaveSyncDataResp::default_instance_->InitAsDefaultInstance();
  SlaveGetResReq::default_instance_->InitAsDefaultInstance();
  SlaveGetResResp::default_instance_->InitAsDefaultInstance();
  SlaveFreeReq::default_instance_->InitAsDefaultInstance();
  SlaveFreeResp::default_instance_->InitAsDefaultInstance();
  SlaveShowReq::default_instance_->InitAsDefaultInstance();
  SlaveShowResp::default_instance_->InitAsDefaultInstance();
  SlaveWorkReq::default_instance_->InitAsDefaultInstance();
  SlaveWorkResp::default_instance_->InitAsDefaultInstance();
  SlaveFawnOnReq::default_instance_->InitAsDefaultInstance();
  SlaveFawnOnResp::default_instance_->InitAsDefaultInstance();
  SlaveHelpReq::default_instance_->InitAsDefaultInstance();
  SlaveHelpResp::default_instance_->InitAsDefaultInstance();
  SlaveSearchReq::default_instance_->InitAsDefaultInstance();
  SlaveSearchResp::default_instance_->InitAsDefaultInstance();
  SlaveAddTimesReq::default_instance_->InitAsDefaultInstance();
  SlaveAddTimesResp::default_instance_->InitAsDefaultInstance();
  SlaveAttackReq::default_instance_->InitAsDefaultInstance();
  SlaveAttackResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CmdSlave_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CmdSlave_2eproto {
  StaticDescriptorInitializer_CmdSlave_2eproto() {
    protobuf_AddDesc_CmdSlave_2eproto();
  }
} static_descriptor_initializer_CmdSlave_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int SlaveSyncDataReq::kTypeFieldNumber;
const int SlaveSyncDataReq::kUserNameListFieldNumber;
#endif  // !_MSC_VER

SlaveSyncDataReq::SlaveSyncDataReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveSyncDataReq::InitAsDefaultInstance() {
}

SlaveSyncDataReq::SlaveSyncDataReq(const SlaveSyncDataReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveSyncDataReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveSyncDataReq::~SlaveSyncDataReq() {
  SharedDtor();
}

void SlaveSyncDataReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SlaveSyncDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveSyncDataReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveSyncDataReq_descriptor_;
}

const SlaveSyncDataReq& SlaveSyncDataReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveSyncDataReq* SlaveSyncDataReq::default_instance_ = NULL;

SlaveSyncDataReq* SlaveSyncDataReq::New() const {
  return new SlaveSyncDataReq;
}

void SlaveSyncDataReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  user_name_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveSyncDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name_list;
        break;
      }

      // repeated string user_name_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_user_name_list()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->user_name_list(this->user_name_list_size() - 1).data(),
            this->user_name_list(this->user_name_list_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveSyncDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // repeated string user_name_list = 2;
  for (int i = 0; i < this->user_name_list_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->user_name_list(i).data(), this->user_name_list(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->user_name_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveSyncDataReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  // repeated string user_name_list = 2;
  for (int i = 0; i < this->user_name_list_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->user_name_list(i).data(), this->user_name_list(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->user_name_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveSyncDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated string user_name_list = 2;
  total_size += 1 * this->user_name_list_size();
  for (int i = 0; i < this->user_name_list_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->user_name_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveSyncDataReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveSyncDataReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveSyncDataReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveSyncDataReq::MergeFrom(const SlaveSyncDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_name_list_.MergeFrom(from.user_name_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveSyncDataReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveSyncDataReq::CopyFrom(const SlaveSyncDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveSyncDataReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveSyncDataReq::Swap(SlaveSyncDataReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    user_name_list_.Swap(&other->user_name_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveSyncDataReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveSyncDataReq_descriptor_;
  metadata.reflection = SlaveSyncDataReq_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveSyncDataResp_SlaveSyncDataRet_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveSyncDataResp_SlaveSyncDataRet_descriptor_;
}
bool SlaveSyncDataResp_SlaveSyncDataRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp::OK;
const SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp::FAIL;
const SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp::SlaveSyncDataRet_MIN;
const SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp::SlaveSyncDataRet_MAX;
const int SlaveSyncDataResp::SlaveSyncDataRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveSyncDataResp::kResultFieldNumber;
const int SlaveSyncDataResp::kUserSyncFieldNumber;
const int SlaveSyncDataResp::kSlaveDataListFieldNumber;
const int SlaveSyncDataResp::kInfoListFieldNumber;
#endif  // !_MSC_VER

SlaveSyncDataResp::SlaveSyncDataResp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveSyncDataResp::InitAsDefaultInstance() {
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
}

SlaveSyncDataResp::SlaveSyncDataResp(const SlaveSyncDataResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveSyncDataResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveSyncDataResp::~SlaveSyncDataResp() {
  SharedDtor();
}

void SlaveSyncDataResp::SharedDtor() {
  if (this != default_instance_) {
    delete user_sync_;
  }
}

void SlaveSyncDataResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveSyncDataResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveSyncDataResp_descriptor_;
}

const SlaveSyncDataResp& SlaveSyncDataResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveSyncDataResp* SlaveSyncDataResp::default_instance_ = NULL;

SlaveSyncDataResp* SlaveSyncDataResp::New() const {
  return new SlaveSyncDataResp;
}

void SlaveSyncDataResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  slave_data_list_.Clear();
  info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveSyncDataResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveSyncDataResp.SlaveSyncDataRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveSyncDataResp_SlaveSyncDataRet_IsValid(value)) {
            set_result(static_cast< ::SlaveSyncDataResp_SlaveSyncDataRet >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_slave_data_list;
        break;
      }

      // repeated .SlaveData slave_data_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_data_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_slave_data_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_slave_data_list;
        if (input->ExpectTag(34)) goto parse_info_list;
        break;
      }

      // repeated .SlaveBriefInfo info_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_info_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_info_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveSyncDataResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveSyncDataResp.SlaveSyncDataRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_sync(), output);
  }

  // repeated .SlaveData slave_data_list = 3;
  for (int i = 0; i < this->slave_data_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->slave_data_list(i), output);
  }

  // repeated .SlaveBriefInfo info_list = 4;
  for (int i = 0; i < this->info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->info_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveSyncDataResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .SlaveSyncDataResp.SlaveSyncDataRet result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_sync(), target);
  }

  // repeated .SlaveData slave_data_list = 3;
  for (int i = 0; i < this->slave_data_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->slave_data_list(i), target);
  }

  // repeated .SlaveBriefInfo info_list = 4;
  for (int i = 0; i < this->info_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->info_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveSyncDataResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveSyncDataResp.SlaveSyncDataRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .SlaveData slave_data_list = 3;
  total_size += 1 * this->slave_data_list_size();
  for (int i = 0; i < this->slave_data_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->slave_data_list(i));
  }

  // repeated .SlaveBriefInfo info_list = 4;
  total_size += 1 * this->info_list_size();
  for (int i = 0; i < this->info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->info_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveSyncDataResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveSyncDataResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveSyncDataResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveSyncDataResp::MergeFrom(const SlaveSyncDataResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  slave_data_list_.MergeFrom(from.slave_data_list_);
  info_list_.MergeFrom(from.info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveSyncDataResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveSyncDataResp::CopyFrom(const SlaveSyncDataResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveSyncDataResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < slave_data_list_size(); i++) {
    if (!this->slave_data_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < info_list_size(); i++) {
    if (!this->info_list(i).IsInitialized()) return false;
  }
  return true;
}

void SlaveSyncDataResp::Swap(SlaveSyncDataResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    slave_data_list_.Swap(&other->slave_data_list_);
    info_list_.Swap(&other->info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveSyncDataResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveSyncDataResp_descriptor_;
  metadata.reflection = SlaveSyncDataResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveGetResReq::kTypeFieldNumber;
const int SlaveGetResReq::kSlaveNameFieldNumber;
#endif  // !_MSC_VER

SlaveGetResReq::SlaveGetResReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveGetResReq::InitAsDefaultInstance() {
}

SlaveGetResReq::SlaveGetResReq(const SlaveGetResReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveGetResReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveGetResReq::~SlaveGetResReq() {
  SharedDtor();
}

void SlaveGetResReq::SharedDtor() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  if (this != default_instance_) {
  }
}

void SlaveGetResReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveGetResReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveGetResReq_descriptor_;
}

const SlaveGetResReq& SlaveGetResReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveGetResReq* SlaveGetResReq::default_instance_ = NULL;

SlaveGetResReq* SlaveGetResReq::New() const {
  return new SlaveGetResReq;
}

void SlaveGetResReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_slave_name()) {
      if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
        slave_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveGetResReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slave_name;
        break;
      }

      // required string slave_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_slave_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->slave_name().data(), this->slave_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveGetResReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required string slave_name = 2;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->slave_name().data(), this->slave_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->slave_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveGetResReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  // required string slave_name = 2;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->slave_name().data(), this->slave_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->slave_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveGetResReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required string slave_name = 2;
    if (has_slave_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->slave_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveGetResReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveGetResReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveGetResReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveGetResReq::MergeFrom(const SlaveGetResReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_slave_name()) {
      set_slave_name(from.slave_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveGetResReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveGetResReq::CopyFrom(const SlaveGetResReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveGetResReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SlaveGetResReq::Swap(SlaveGetResReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(slave_name_, other->slave_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveGetResReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveGetResReq_descriptor_;
  metadata.reflection = SlaveGetResReq_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveGetResResp_SlaveGetResRet_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveGetResResp_SlaveGetResRet_descriptor_;
}
bool SlaveGetResResp_SlaveGetResRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::OK;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::FAIL;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::NOT_MY_SLAVE;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::CD_TIME;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::SlaveGetResRet_MIN;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::SlaveGetResRet_MAX;
const int SlaveGetResResp::SlaveGetResRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveGetResResp::kResultFieldNumber;
const int SlaveGetResResp::kUserSyncFieldNumber;
const int SlaveGetResResp::kResFieldNumber;
const int SlaveGetResResp::kExpFieldNumber;
#endif  // !_MSC_VER

SlaveGetResResp::SlaveGetResResp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveGetResResp::InitAsDefaultInstance() {
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
}

SlaveGetResResp::SlaveGetResResp(const SlaveGetResResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveGetResResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  exp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveGetResResp::~SlaveGetResResp() {
  SharedDtor();
}

void SlaveGetResResp::SharedDtor() {
  if (this != default_instance_) {
    delete user_sync_;
  }
}

void SlaveGetResResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveGetResResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveGetResResp_descriptor_;
}

const SlaveGetResResp& SlaveGetResResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveGetResResp* SlaveGetResResp::default_instance_ = NULL;

SlaveGetResResp* SlaveGetResResp::New() const {
  return new SlaveGetResResp;
}

void SlaveGetResResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    exp_ = 0;
  }
  res_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveGetResResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveGetResResp.SlaveGetResRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveGetResResp_SlaveGetResRet_IsValid(value)) {
            set_result(static_cast< ::SlaveGetResResp_SlaveGetResRet >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_res;
        break;
      }

      // repeated int32 res = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_res:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_res())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_res())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_res;
        if (input->ExpectTag(32)) goto parse_exp;
        break;
      }

      // optional int32 exp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveGetResResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveGetResResp.SlaveGetResRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_sync(), output);
  }

  // repeated int32 res = 3;
  for (int i = 0; i < this->res_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->res(i), output);
  }

  // optional int32 exp = 4;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->exp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveGetResResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .SlaveGetResResp.SlaveGetResRet result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_sync(), target);
  }

  // repeated int32 res = 3;
  for (int i = 0; i < this->res_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->res(i), target);
  }

  // optional int32 exp = 4;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->exp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveGetResResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveGetResResp.SlaveGetResRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 exp = 4;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

  }
  // repeated int32 res = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->res_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->res(i));
    }
    total_size += 1 * this->res_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveGetResResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveGetResResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveGetResResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveGetResResp::MergeFrom(const SlaveGetResResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  res_.MergeFrom(from.res_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveGetResResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveGetResResp::CopyFrom(const SlaveGetResResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveGetResResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void SlaveGetResResp::Swap(SlaveGetResResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    res_.Swap(&other->res_);
    std::swap(exp_, other->exp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveGetResResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveGetResResp_descriptor_;
  metadata.reflection = SlaveGetResResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveFreeReq::kTypeFieldNumber;
const int SlaveFreeReq::kSlaveNameFieldNumber;
#endif  // !_MSC_VER

SlaveFreeReq::SlaveFreeReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveFreeReq::InitAsDefaultInstance() {
}

SlaveFreeReq::SlaveFreeReq(const SlaveFreeReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveFreeReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveFreeReq::~SlaveFreeReq() {
  SharedDtor();
}

void SlaveFreeReq::SharedDtor() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  if (this != default_instance_) {
  }
}

void SlaveFreeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveFreeReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveFreeReq_descriptor_;
}

const SlaveFreeReq& SlaveFreeReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveFreeReq* SlaveFreeReq::default_instance_ = NULL;

SlaveFreeReq* SlaveFreeReq::New() const {
  return new SlaveFreeReq;
}

void SlaveFreeReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_slave_name()) {
      if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
        slave_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveFreeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slave_name;
        break;
      }

      // required string slave_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_slave_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->slave_name().data(), this->slave_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveFreeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required string slave_name = 2;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->slave_name().data(), this->slave_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->slave_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveFreeReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  // required string slave_name = 2;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->slave_name().data(), this->slave_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->slave_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveFreeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required string slave_name = 2;
    if (has_slave_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->slave_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveFreeReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveFreeReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveFreeReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveFreeReq::MergeFrom(const SlaveFreeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_slave_name()) {
      set_slave_name(from.slave_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveFreeReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveFreeReq::CopyFrom(const SlaveFreeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveFreeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SlaveFreeReq::Swap(SlaveFreeReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(slave_name_, other->slave_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveFreeReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveFreeReq_descriptor_;
  metadata.reflection = SlaveFreeReq_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveFreeResp_SlaveFreeRet_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveFreeResp_SlaveFreeRet_descriptor_;
}
bool SlaveFreeResp_SlaveFreeRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::OK;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::FAIL;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::NOT_MY_SLAVE;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::FREE_SLAVE_ERROR;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::SlaveFreeRet_MIN;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::SlaveFreeRet_MAX;
const int SlaveFreeResp::SlaveFreeRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveFreeResp::kResultFieldNumber;
const int SlaveFreeResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

SlaveFreeResp::SlaveFreeResp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveFreeResp::InitAsDefaultInstance() {
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
}

SlaveFreeResp::SlaveFreeResp(const SlaveFreeResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveFreeResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveFreeResp::~SlaveFreeResp() {
  SharedDtor();
}

void SlaveFreeResp::SharedDtor() {
  if (this != default_instance_) {
    delete user_sync_;
  }
}

void SlaveFreeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveFreeResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveFreeResp_descriptor_;
}

const SlaveFreeResp& SlaveFreeResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveFreeResp* SlaveFreeResp::default_instance_ = NULL;

SlaveFreeResp* SlaveFreeResp::New() const {
  return new SlaveFreeResp;
}

void SlaveFreeResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveFreeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveFreeResp.SlaveFreeRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveFreeResp_SlaveFreeRet_IsValid(value)) {
            set_result(static_cast< ::SlaveFreeResp_SlaveFreeRet >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveFreeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveFreeResp.SlaveFreeRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_sync(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveFreeResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .SlaveFreeResp.SlaveFreeRet result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_sync(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveFreeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveFreeResp.SlaveFreeRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveFreeResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveFreeResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveFreeResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveFreeResp::MergeFrom(const SlaveFreeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveFreeResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveFreeResp::CopyFrom(const SlaveFreeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveFreeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void SlaveFreeResp::Swap(SlaveFreeResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveFreeResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveFreeResp_descriptor_;
  metadata.reflection = SlaveFreeResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveShowReq::kTypeFieldNumber;
const int SlaveShowReq::kSlaveNameFieldNumber;
#endif  // !_MSC_VER

SlaveShowReq::SlaveShowReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveShowReq::InitAsDefaultInstance() {
}

SlaveShowReq::SlaveShowReq(const SlaveShowReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveShowReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveShowReq::~SlaveShowReq() {
  SharedDtor();
}

void SlaveShowReq::SharedDtor() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  if (this != default_instance_) {
  }
}

void SlaveShowReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveShowReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveShowReq_descriptor_;
}

const SlaveShowReq& SlaveShowReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveShowReq* SlaveShowReq::default_instance_ = NULL;

SlaveShowReq* SlaveShowReq::New() const {
  return new SlaveShowReq;
}

void SlaveShowReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_slave_name()) {
      if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
        slave_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveShowReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slave_name;
        break;
      }

      // required string slave_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_slave_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->slave_name().data(), this->slave_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveShowReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required string slave_name = 2;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->slave_name().data(), this->slave_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->slave_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveShowReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  // required string slave_name = 2;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->slave_name().data(), this->slave_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->slave_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveShowReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required string slave_name = 2;
    if (has_slave_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->slave_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveShowReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveShowReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveShowReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveShowReq::MergeFrom(const SlaveShowReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_slave_name()) {
      set_slave_name(from.slave_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveShowReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveShowReq::CopyFrom(const SlaveShowReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveShowReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SlaveShowReq::Swap(SlaveShowReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(slave_name_, other->slave_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveShowReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveShowReq_descriptor_;
  metadata.reflection = SlaveShowReq_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveShowResp_SlaveShowRet_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveShowResp_SlaveShowRet_descriptor_;
}
bool SlaveShowResp_SlaveShowRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveShowResp_SlaveShowRet SlaveShowResp::OK;
const SlaveShowResp_SlaveShowRet SlaveShowResp::FAIL;
const SlaveShowResp_SlaveShowRet SlaveShowResp::NOT_MY_SLAVE;
const SlaveShowResp_SlaveShowRet SlaveShowResp::NO_MONEY;
const SlaveShowResp_SlaveShowRet SlaveShowResp::STATE_ERROR;
const SlaveShowResp_SlaveShowRet SlaveShowResp::TYPE_ERROR;
const SlaveShowResp_SlaveShowRet SlaveShowResp::NO_MASTER;
const SlaveShowResp_SlaveShowRet SlaveShowResp::WATCH_NUM_MAX;
const SlaveShowResp_SlaveShowRet SlaveShowResp::WATCHED;
const SlaveShowResp_SlaveShowRet SlaveShowResp::SlaveShowRet_MIN;
const SlaveShowResp_SlaveShowRet SlaveShowResp::SlaveShowRet_MAX;
const int SlaveShowResp::SlaveShowRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveShowResp::kResultFieldNumber;
const int SlaveShowResp::kUserSyncFieldNumber;
const int SlaveShowResp::kGetItemListFieldNumber;
#endif  // !_MSC_VER

SlaveShowResp::SlaveShowResp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveShowResp::InitAsDefaultInstance() {
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
}

SlaveShowResp::SlaveShowResp(const SlaveShowResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveShowResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveShowResp::~SlaveShowResp() {
  SharedDtor();
}

void SlaveShowResp::SharedDtor() {
  if (this != default_instance_) {
    delete user_sync_;
  }
}

void SlaveShowResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveShowResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveShowResp_descriptor_;
}

const SlaveShowResp& SlaveShowResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveShowResp* SlaveShowResp::default_instance_ = NULL;

SlaveShowResp* SlaveShowResp::New() const {
  return new SlaveShowResp;
}

void SlaveShowResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveShowResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveShowResp.SlaveShowRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveShowResp_SlaveShowRet_IsValid(value)) {
            set_result(static_cast< ::SlaveShowResp_SlaveShowRet >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveShowResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveShowResp.SlaveShowRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_sync(), output);
  }

  // repeated .Pair get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->get_item_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveShowResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .SlaveShowResp.SlaveShowRet result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_sync(), target);
  }

  // repeated .Pair get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->get_item_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveShowResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveShowResp.SlaveShowRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .Pair get_item_list = 3;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveShowResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveShowResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveShowResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveShowResp::MergeFrom(const SlaveShowResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveShowResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveShowResp::CopyFrom(const SlaveShowResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveShowResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  return true;
}

void SlaveShowResp::Swap(SlaveShowResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveShowResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveShowResp_descriptor_;
  metadata.reflection = SlaveShowResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveWorkReq::kSlaveNameFieldNumber;
#endif  // !_MSC_VER

SlaveWorkReq::SlaveWorkReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveWorkReq::InitAsDefaultInstance() {
}

SlaveWorkReq::SlaveWorkReq(const SlaveWorkReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveWorkReq::SharedCtor() {
  _cached_size_ = 0;
  slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveWorkReq::~SlaveWorkReq() {
  SharedDtor();
}

void SlaveWorkReq::SharedDtor() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  if (this != default_instance_) {
  }
}

void SlaveWorkReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveWorkReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveWorkReq_descriptor_;
}

const SlaveWorkReq& SlaveWorkReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveWorkReq* SlaveWorkReq::default_instance_ = NULL;

SlaveWorkReq* SlaveWorkReq::New() const {
  return new SlaveWorkReq;
}

void SlaveWorkReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_name()) {
      if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
        slave_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveWorkReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string slave_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_slave_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->slave_name().data(), this->slave_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveWorkReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string slave_name = 1;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->slave_name().data(), this->slave_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->slave_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveWorkReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string slave_name = 1;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->slave_name().data(), this->slave_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->slave_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveWorkReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string slave_name = 1;
    if (has_slave_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->slave_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveWorkReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveWorkReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveWorkReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveWorkReq::MergeFrom(const SlaveWorkReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_name()) {
      set_slave_name(from.slave_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveWorkReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveWorkReq::CopyFrom(const SlaveWorkReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveWorkReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveWorkReq::Swap(SlaveWorkReq* other) {
  if (other != this) {
    std::swap(slave_name_, other->slave_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveWorkReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveWorkReq_descriptor_;
  metadata.reflection = SlaveWorkReq_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveWorkResp_SlaveWorkRet_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveWorkResp_SlaveWorkRet_descriptor_;
}
bool SlaveWorkResp_SlaveWorkRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::OK;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::FAIL;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::NOT_MY_SLAVE;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::CD_TIME;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::SlaveWorkRet_MIN;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::SlaveWorkRet_MAX;
const int SlaveWorkResp::SlaveWorkRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveWorkResp::kResultFieldNumber;
const int SlaveWorkResp::kUserSyncFieldNumber;
const int SlaveWorkResp::kGetItemListFieldNumber;
const int SlaveWorkResp::kNoteInfoFieldNumber;
#endif  // !_MSC_VER

SlaveWorkResp::SlaveWorkResp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveWorkResp::InitAsDefaultInstance() {
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
  note_info_ = const_cast< ::SlaveNoteInfo*>(&::SlaveNoteInfo::default_instance());
}

SlaveWorkResp::SlaveWorkResp(const SlaveWorkResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveWorkResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  note_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveWorkResp::~SlaveWorkResp() {
  SharedDtor();
}

void SlaveWorkResp::SharedDtor() {
  if (this != default_instance_) {
    delete user_sync_;
    delete note_info_;
  }
}

void SlaveWorkResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveWorkResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveWorkResp_descriptor_;
}

const SlaveWorkResp& SlaveWorkResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveWorkResp* SlaveWorkResp::default_instance_ = NULL;

SlaveWorkResp* SlaveWorkResp::New() const {
  return new SlaveWorkResp;
}

void SlaveWorkResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_note_info()) {
      if (note_info_ != NULL) note_info_->::SlaveNoteInfo::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveWorkResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveWorkResp.SlaveWorkRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveWorkResp_SlaveWorkRet_IsValid(value)) {
            set_result(static_cast< ::SlaveWorkResp_SlaveWorkRet >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        if (input->ExpectTag(34)) goto parse_note_info;
        break;
      }

      // optional .SlaveNoteInfo note_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_note_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_note_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveWorkResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveWorkResp.SlaveWorkRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_sync(), output);
  }

  // repeated .Pair get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->get_item_list(i), output);
  }

  // optional .SlaveNoteInfo note_info = 4;
  if (has_note_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->note_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveWorkResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .SlaveWorkResp.SlaveWorkRet result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_sync(), target);
  }

  // repeated .Pair get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->get_item_list(i), target);
  }

  // optional .SlaveNoteInfo note_info = 4;
  if (has_note_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->note_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveWorkResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveWorkResp.SlaveWorkRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .SlaveNoteInfo note_info = 4;
    if (has_note_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->note_info());
    }

  }
  // repeated .Pair get_item_list = 3;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveWorkResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveWorkResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveWorkResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveWorkResp::MergeFrom(const SlaveWorkResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_note_info()) {
      mutable_note_info()->::SlaveNoteInfo::MergeFrom(from.note_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveWorkResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveWorkResp::CopyFrom(const SlaveWorkResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveWorkResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  if (has_note_info()) {
    if (!this->note_info().IsInitialized()) return false;
  }
  return true;
}

void SlaveWorkResp::Swap(SlaveWorkResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(note_info_, other->note_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveWorkResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveWorkResp_descriptor_;
  metadata.reflection = SlaveWorkResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveFawnOnReq::kTypeFieldNumber;
#endif  // !_MSC_VER

SlaveFawnOnReq::SlaveFawnOnReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveFawnOnReq::InitAsDefaultInstance() {
}

SlaveFawnOnReq::SlaveFawnOnReq(const SlaveFawnOnReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveFawnOnReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveFawnOnReq::~SlaveFawnOnReq() {
  SharedDtor();
}

void SlaveFawnOnReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SlaveFawnOnReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveFawnOnReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveFawnOnReq_descriptor_;
}

const SlaveFawnOnReq& SlaveFawnOnReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveFawnOnReq* SlaveFawnOnReq::default_instance_ = NULL;

SlaveFawnOnReq* SlaveFawnOnReq::New() const {
  return new SlaveFawnOnReq;
}

void SlaveFawnOnReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveFawnOnReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveFawnOnReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveFawnOnReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveFawnOnReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveFawnOnReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveFawnOnReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveFawnOnReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveFawnOnReq::MergeFrom(const SlaveFawnOnReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveFawnOnReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveFawnOnReq::CopyFrom(const SlaveFawnOnReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveFawnOnReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveFawnOnReq::Swap(SlaveFawnOnReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveFawnOnReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveFawnOnReq_descriptor_;
  metadata.reflection = SlaveFawnOnReq_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveFawnOnResp_SlaveFawnOnRet_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveFawnOnResp_SlaveFawnOnRet_descriptor_;
}
bool SlaveFawnOnResp_SlaveFawnOnRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::OK;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::FAIL;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::NO_MASTER;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::CD_TIME;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::SlaveFawnOnRet_MIN;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::SlaveFawnOnRet_MAX;
const int SlaveFawnOnResp::SlaveFawnOnRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveFawnOnResp::kResultFieldNumber;
const int SlaveFawnOnResp::kUserSyncFieldNumber;
const int SlaveFawnOnResp::kGetItemListFieldNumber;
const int SlaveFawnOnResp::kNoteInfoFieldNumber;
#endif  // !_MSC_VER

SlaveFawnOnResp::SlaveFawnOnResp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveFawnOnResp::InitAsDefaultInstance() {
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
  note_info_ = const_cast< ::SlaveNoteInfo*>(&::SlaveNoteInfo::default_instance());
}

SlaveFawnOnResp::SlaveFawnOnResp(const SlaveFawnOnResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveFawnOnResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  note_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveFawnOnResp::~SlaveFawnOnResp() {
  SharedDtor();
}

void SlaveFawnOnResp::SharedDtor() {
  if (this != default_instance_) {
    delete user_sync_;
    delete note_info_;
  }
}

void SlaveFawnOnResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveFawnOnResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveFawnOnResp_descriptor_;
}

const SlaveFawnOnResp& SlaveFawnOnResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveFawnOnResp* SlaveFawnOnResp::default_instance_ = NULL;

SlaveFawnOnResp* SlaveFawnOnResp::New() const {
  return new SlaveFawnOnResp;
}

void SlaveFawnOnResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_note_info()) {
      if (note_info_ != NULL) note_info_->::SlaveNoteInfo::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveFawnOnResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveFawnOnResp.SlaveFawnOnRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveFawnOnResp_SlaveFawnOnRet_IsValid(value)) {
            set_result(static_cast< ::SlaveFawnOnResp_SlaveFawnOnRet >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        if (input->ExpectTag(34)) goto parse_note_info;
        break;
      }

      // optional .SlaveNoteInfo note_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_note_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_note_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveFawnOnResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveFawnOnResp.SlaveFawnOnRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_sync(), output);
  }

  // repeated .Pair get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->get_item_list(i), output);
  }

  // optional .SlaveNoteInfo note_info = 4;
  if (has_note_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->note_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveFawnOnResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .SlaveFawnOnResp.SlaveFawnOnRet result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_sync(), target);
  }

  // repeated .Pair get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->get_item_list(i), target);
  }

  // optional .SlaveNoteInfo note_info = 4;
  if (has_note_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->note_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveFawnOnResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveFawnOnResp.SlaveFawnOnRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .SlaveNoteInfo note_info = 4;
    if (has_note_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->note_info());
    }

  }
  // repeated .Pair get_item_list = 3;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveFawnOnResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveFawnOnResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveFawnOnResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveFawnOnResp::MergeFrom(const SlaveFawnOnResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_note_info()) {
      mutable_note_info()->::SlaveNoteInfo::MergeFrom(from.note_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveFawnOnResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveFawnOnResp::CopyFrom(const SlaveFawnOnResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveFawnOnResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  if (has_note_info()) {
    if (!this->note_info().IsInitialized()) return false;
  }
  return true;
}

void SlaveFawnOnResp::Swap(SlaveFawnOnResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(note_info_, other->note_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveFawnOnResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveFawnOnResp_descriptor_;
  metadata.reflection = SlaveFawnOnResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveHelpReq::kTypeFieldNumber;
#endif  // !_MSC_VER

SlaveHelpReq::SlaveHelpReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveHelpReq::InitAsDefaultInstance() {
}

SlaveHelpReq::SlaveHelpReq(const SlaveHelpReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveHelpReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveHelpReq::~SlaveHelpReq() {
  SharedDtor();
}

void SlaveHelpReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SlaveHelpReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveHelpReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveHelpReq_descriptor_;
}

const SlaveHelpReq& SlaveHelpReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveHelpReq* SlaveHelpReq::default_instance_ = NULL;

SlaveHelpReq* SlaveHelpReq::New() const {
  return new SlaveHelpReq;
}

void SlaveHelpReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveHelpReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveHelpReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveHelpReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveHelpReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveHelpReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveHelpReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveHelpReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveHelpReq::MergeFrom(const SlaveHelpReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveHelpReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveHelpReq::CopyFrom(const SlaveHelpReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveHelpReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveHelpReq::Swap(SlaveHelpReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveHelpReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveHelpReq_descriptor_;
  metadata.reflection = SlaveHelpReq_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveHelpResp_SlaveHelpRet_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveHelpResp_SlaveHelpRet_descriptor_;
}
bool SlaveHelpResp_SlaveHelpRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::OK;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::FAIL;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::NO_MASTER;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::CD_TIME;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::SEND_LIST_EMPTY;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::SlaveHelpRet_MIN;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::SlaveHelpRet_MAX;
const int SlaveHelpResp::SlaveHelpRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveHelpResp::kResultFieldNumber;
const int SlaveHelpResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

SlaveHelpResp::SlaveHelpResp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveHelpResp::InitAsDefaultInstance() {
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
}

SlaveHelpResp::SlaveHelpResp(const SlaveHelpResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveHelpResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveHelpResp::~SlaveHelpResp() {
  SharedDtor();
}

void SlaveHelpResp::SharedDtor() {
  if (this != default_instance_) {
    delete user_sync_;
  }
}

void SlaveHelpResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveHelpResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveHelpResp_descriptor_;
}

const SlaveHelpResp& SlaveHelpResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveHelpResp* SlaveHelpResp::default_instance_ = NULL;

SlaveHelpResp* SlaveHelpResp::New() const {
  return new SlaveHelpResp;
}

void SlaveHelpResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveHelpResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveHelpResp.SlaveHelpRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveHelpResp_SlaveHelpRet_IsValid(value)) {
            set_result(static_cast< ::SlaveHelpResp_SlaveHelpRet >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveHelpResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveHelpResp.SlaveHelpRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_sync(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveHelpResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .SlaveHelpResp.SlaveHelpRet result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_sync(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveHelpResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveHelpResp.SlaveHelpRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveHelpResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveHelpResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveHelpResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveHelpResp::MergeFrom(const SlaveHelpResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveHelpResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveHelpResp::CopyFrom(const SlaveHelpResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveHelpResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void SlaveHelpResp::Swap(SlaveHelpResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveHelpResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveHelpResp_descriptor_;
  metadata.reflection = SlaveHelpResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveSearchReq::kTypeFieldNumber;
#endif  // !_MSC_VER

SlaveSearchReq::SlaveSearchReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveSearchReq::InitAsDefaultInstance() {
}

SlaveSearchReq::SlaveSearchReq(const SlaveSearchReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveSearchReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveSearchReq::~SlaveSearchReq() {
  SharedDtor();
}

void SlaveSearchReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SlaveSearchReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveSearchReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveSearchReq_descriptor_;
}

const SlaveSearchReq& SlaveSearchReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveSearchReq* SlaveSearchReq::default_instance_ = NULL;

SlaveSearchReq* SlaveSearchReq::New() const {
  return new SlaveSearchReq;
}

void SlaveSearchReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveSearchReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveSearchReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveSearchReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveSearchReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveSearchReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveSearchReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveSearchReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveSearchReq::MergeFrom(const SlaveSearchReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveSearchReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveSearchReq::CopyFrom(const SlaveSearchReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveSearchReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveSearchReq::Swap(SlaveSearchReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveSearchReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveSearchReq_descriptor_;
  metadata.reflection = SlaveSearchReq_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveSearchResp_SlaveSearchRet_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveSearchResp_SlaveSearchRet_descriptor_;
}
bool SlaveSearchResp_SlaveSearchRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::OK;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::FAIL;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::EMPTY;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::HAS_MASTER;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::ERROR_TYPE;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::SlaveSearchRet_MIN;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::SlaveSearchRet_MAX;
const int SlaveSearchResp::SlaveSearchRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveSearchResp::kResultFieldNumber;
const int SlaveSearchResp::kUserSyncFieldNumber;
const int SlaveSearchResp::kInfoListFieldNumber;
#endif  // !_MSC_VER

SlaveSearchResp::SlaveSearchResp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveSearchResp::InitAsDefaultInstance() {
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
}

SlaveSearchResp::SlaveSearchResp(const SlaveSearchResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveSearchResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveSearchResp::~SlaveSearchResp() {
  SharedDtor();
}

void SlaveSearchResp::SharedDtor() {
  if (this != default_instance_) {
    delete user_sync_;
  }
}

void SlaveSearchResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveSearchResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveSearchResp_descriptor_;
}

const SlaveSearchResp& SlaveSearchResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveSearchResp* SlaveSearchResp::default_instance_ = NULL;

SlaveSearchResp* SlaveSearchResp::New() const {
  return new SlaveSearchResp;
}

void SlaveSearchResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveSearchResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveSearchResp.SlaveSearchRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveSearchResp_SlaveSearchRet_IsValid(value)) {
            set_result(static_cast< ::SlaveSearchResp_SlaveSearchRet >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_info_list;
        break;
      }

      // repeated .SlaveBriefInfo info_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_info_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_info_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveSearchResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveSearchResp.SlaveSearchRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_sync(), output);
  }

  // repeated .SlaveBriefInfo info_list = 3;
  for (int i = 0; i < this->info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->info_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveSearchResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .SlaveSearchResp.SlaveSearchRet result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_sync(), target);
  }

  // repeated .SlaveBriefInfo info_list = 3;
  for (int i = 0; i < this->info_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->info_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveSearchResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveSearchResp.SlaveSearchRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .SlaveBriefInfo info_list = 3;
  total_size += 1 * this->info_list_size();
  for (int i = 0; i < this->info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->info_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveSearchResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveSearchResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveSearchResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveSearchResp::MergeFrom(const SlaveSearchResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  info_list_.MergeFrom(from.info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveSearchResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveSearchResp::CopyFrom(const SlaveSearchResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveSearchResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < info_list_size(); i++) {
    if (!this->info_list(i).IsInitialized()) return false;
  }
  return true;
}

void SlaveSearchResp::Swap(SlaveSearchResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    info_list_.Swap(&other->info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveSearchResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveSearchResp_descriptor_;
  metadata.reflection = SlaveSearchResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveAddTimesReq::kTypeFieldNumber;
#endif  // !_MSC_VER

SlaveAddTimesReq::SlaveAddTimesReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveAddTimesReq::InitAsDefaultInstance() {
}

SlaveAddTimesReq::SlaveAddTimesReq(const SlaveAddTimesReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveAddTimesReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveAddTimesReq::~SlaveAddTimesReq() {
  SharedDtor();
}

void SlaveAddTimesReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SlaveAddTimesReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveAddTimesReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveAddTimesReq_descriptor_;
}

const SlaveAddTimesReq& SlaveAddTimesReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveAddTimesReq* SlaveAddTimesReq::default_instance_ = NULL;

SlaveAddTimesReq* SlaveAddTimesReq::New() const {
  return new SlaveAddTimesReq;
}

void SlaveAddTimesReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveAddTimesReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveAddTimesReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveAddTimesReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveAddTimesReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveAddTimesReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveAddTimesReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveAddTimesReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveAddTimesReq::MergeFrom(const SlaveAddTimesReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveAddTimesReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveAddTimesReq::CopyFrom(const SlaveAddTimesReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveAddTimesReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveAddTimesReq::Swap(SlaveAddTimesReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveAddTimesReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveAddTimesReq_descriptor_;
  metadata.reflection = SlaveAddTimesReq_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveAddTimesResp_SlaveAddTimesRet_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveAddTimesResp_SlaveAddTimesRet_descriptor_;
}
bool SlaveAddTimesResp_SlaveAddTimesRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::OK;
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::FAIL;
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::NO_MONEY;
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::SlaveAddTimesRet_MIN;
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::SlaveAddTimesRet_MAX;
const int SlaveAddTimesResp::SlaveAddTimesRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveAddTimesResp::kResultFieldNumber;
const int SlaveAddTimesResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

SlaveAddTimesResp::SlaveAddTimesResp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveAddTimesResp::InitAsDefaultInstance() {
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
}

SlaveAddTimesResp::SlaveAddTimesResp(const SlaveAddTimesResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveAddTimesResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveAddTimesResp::~SlaveAddTimesResp() {
  SharedDtor();
}

void SlaveAddTimesResp::SharedDtor() {
  if (this != default_instance_) {
    delete user_sync_;
  }
}

void SlaveAddTimesResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveAddTimesResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveAddTimesResp_descriptor_;
}

const SlaveAddTimesResp& SlaveAddTimesResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveAddTimesResp* SlaveAddTimesResp::default_instance_ = NULL;

SlaveAddTimesResp* SlaveAddTimesResp::New() const {
  return new SlaveAddTimesResp;
}

void SlaveAddTimesResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveAddTimesResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveAddTimesResp.SlaveAddTimesRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveAddTimesResp_SlaveAddTimesRet_IsValid(value)) {
            set_result(static_cast< ::SlaveAddTimesResp_SlaveAddTimesRet >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveAddTimesResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveAddTimesResp.SlaveAddTimesRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_sync(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveAddTimesResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .SlaveAddTimesResp.SlaveAddTimesRet result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_sync(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveAddTimesResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveAddTimesResp.SlaveAddTimesRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveAddTimesResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveAddTimesResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveAddTimesResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveAddTimesResp::MergeFrom(const SlaveAddTimesResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveAddTimesResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveAddTimesResp::CopyFrom(const SlaveAddTimesResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveAddTimesResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void SlaveAddTimesResp::Swap(SlaveAddTimesResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveAddTimesResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveAddTimesResp_descriptor_;
  metadata.reflection = SlaveAddTimesResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveAttackReq::kTypeFieldNumber;
const int SlaveAttackReq::kUserNameFieldNumber;
const int SlaveAttackReq::kLineupFieldNumber;
#endif  // !_MSC_VER

SlaveAttackReq::SlaveAttackReq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveAttackReq::InitAsDefaultInstance() {
}

SlaveAttackReq::SlaveAttackReq(const SlaveAttackReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveAttackReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveAttackReq::~SlaveAttackReq() {
  SharedDtor();
}

void SlaveAttackReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (this != default_instance_) {
  }
}

void SlaveAttackReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveAttackReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveAttackReq_descriptor_;
}

const SlaveAttackReq& SlaveAttackReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveAttackReq* SlaveAttackReq::default_instance_ = NULL;

SlaveAttackReq* SlaveAttackReq::New() const {
  return new SlaveAttackReq;
}

void SlaveAttackReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
  }
  lineup_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveAttackReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name;
        break;
      }

      // required string user_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->user_name().data(), this->user_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lineup;
        break;
      }

      // repeated int32 lineup = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lineup:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_lineup())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_lineup())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lineup;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveAttackReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required string user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->user_name().data(), this->user_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->user_name(), output);
  }

  // repeated int32 lineup = 3;
  for (int i = 0; i < this->lineup_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->lineup(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveAttackReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  // required string user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->user_name().data(), this->user_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->user_name(), target);
  }

  // repeated int32 lineup = 3;
  for (int i = 0; i < this->lineup_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->lineup(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveAttackReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required string user_name = 2;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

  }
  // repeated int32 lineup = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->lineup_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->lineup(i));
    }
    total_size += 1 * this->lineup_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveAttackReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveAttackReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveAttackReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveAttackReq::MergeFrom(const SlaveAttackReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  lineup_.MergeFrom(from.lineup_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveAttackReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveAttackReq::CopyFrom(const SlaveAttackReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveAttackReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SlaveAttackReq::Swap(SlaveAttackReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(user_name_, other->user_name_);
    lineup_.Swap(&other->lineup_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveAttackReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveAttackReq_descriptor_;
  metadata.reflection = SlaveAttackReq_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveAttackResp_SlaveAttackRet_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveAttackResp_SlaveAttackRet_descriptor_;
}
bool SlaveAttackResp_SlaveAttackRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::OK;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::FAIL;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NO_EMEMY;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::ATTACK_SELF;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::ERROR_TYPE;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::HAS_MASTER;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NO_TIMES;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::CD_TIME;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NO_SHIPS;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NO_DURABLE;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::FIXING;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NOT_SLAVE_MASTER;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::MAX_SLAVE;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NO_MASTER;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::HAS_SLAVE;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::SHOWING;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::CATCH_ERROR;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::OUTING;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::SlaveAttackRet_MIN;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::SlaveAttackRet_MAX;
const int SlaveAttackResp::SlaveAttackRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveAttackResp::kResultFieldNumber;
const int SlaveAttackResp::kUserSyncFieldNumber;
const int SlaveAttackResp::kAttackListFieldNumber;
const int SlaveAttackResp::kHurterListFieldNumber;
const int SlaveAttackResp::kEventListFieldNumber;
const int SlaveAttackResp::kIsWinFieldNumber;
const int SlaveAttackResp::kIsCatchFieldNumber;
const int SlaveAttackResp::kGetItemListFieldNumber;
const int SlaveAttackResp::kReqFieldNumber;
#endif  // !_MSC_VER

SlaveAttackResp::SlaveAttackResp()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SlaveAttackResp::InitAsDefaultInstance() {
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
  req_ = const_cast< ::SlaveAttackReq*>(&::SlaveAttackReq::default_instance());
}

SlaveAttackResp::SlaveAttackResp(const SlaveAttackResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveAttackResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  iswin_ = false;
  iscatch_ = false;
  req_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveAttackResp::~SlaveAttackResp() {
  SharedDtor();
}

void SlaveAttackResp::SharedDtor() {
  if (this != default_instance_) {
    delete user_sync_;
    delete req_;
  }
}

void SlaveAttackResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveAttackResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveAttackResp_descriptor_;
}

const SlaveAttackResp& SlaveAttackResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
  return *default_instance_;
}

SlaveAttackResp* SlaveAttackResp::default_instance_ = NULL;

SlaveAttackResp* SlaveAttackResp::New() const {
  return new SlaveAttackResp;
}

void SlaveAttackResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    iswin_ = false;
    iscatch_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::SlaveAttackReq::Clear();
    }
  }
  attack_list_.Clear();
  hurter_list_.Clear();
  event_list_.Clear();
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SlaveAttackResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveAttackResp.SlaveAttackRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveAttackResp_SlaveAttackRet_IsValid(value)) {
            set_result(static_cast< ::SlaveAttackResp_SlaveAttackRet >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_attack_list;
        break;
      }

      // repeated .AirShip attack_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attack_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_attack_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_attack_list;
        if (input->ExpectTag(34)) goto parse_hurter_list;
        break;
      }

      // repeated .AirShip hurter_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hurter_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_hurter_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_hurter_list;
        if (input->ExpectTag(42)) goto parse_event_list;
        break;
      }

      // repeated .EventInfo event_list = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_event_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_event_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_event_list;
        if (input->ExpectTag(48)) goto parse_isWin;
        break;
      }

      // optional bool isWin = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isWin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &iswin_)));
          set_has_iswin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_isCatch;
        break;
      }

      // optional bool isCatch = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isCatch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &iscatch_)));
          set_has_iscatch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_get_item_list;
        if (input->ExpectTag(74)) goto parse_req;
        break;
      }

      // optional .SlaveAttackReq req = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveAttackResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveAttackResp.SlaveAttackRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_sync(), output);
  }

  // repeated .AirShip attack_list = 3;
  for (int i = 0; i < this->attack_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->attack_list(i), output);
  }

  // repeated .AirShip hurter_list = 4;
  for (int i = 0; i < this->hurter_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->hurter_list(i), output);
  }

  // repeated .EventInfo event_list = 5;
  for (int i = 0; i < this->event_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->event_list(i), output);
  }

  // optional bool isWin = 6;
  if (has_iswin()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->iswin(), output);
  }

  // optional bool isCatch = 7;
  if (has_iscatch()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->iscatch(), output);
  }

  // repeated .Pair get_item_list = 8;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->get_item_list(i), output);
  }

  // optional .SlaveAttackReq req = 9;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->req(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SlaveAttackResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .SlaveAttackResp.SlaveAttackRet result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_sync(), target);
  }

  // repeated .AirShip attack_list = 3;
  for (int i = 0; i < this->attack_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->attack_list(i), target);
  }

  // repeated .AirShip hurter_list = 4;
  for (int i = 0; i < this->hurter_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->hurter_list(i), target);
  }

  // repeated .EventInfo event_list = 5;
  for (int i = 0; i < this->event_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->event_list(i), target);
  }

  // optional bool isWin = 6;
  if (has_iswin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->iswin(), target);
  }

  // optional bool isCatch = 7;
  if (has_iscatch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->iscatch(), target);
  }

  // repeated .Pair get_item_list = 8;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->get_item_list(i), target);
  }

  // optional .SlaveAttackReq req = 9;
  if (has_req()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->req(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SlaveAttackResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveAttackResp.SlaveAttackRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional bool isWin = 6;
    if (has_iswin()) {
      total_size += 1 + 1;
    }

    // optional bool isCatch = 7;
    if (has_iscatch()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .SlaveAttackReq req = 9;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

  }
  // repeated .AirShip attack_list = 3;
  total_size += 1 * this->attack_list_size();
  for (int i = 0; i < this->attack_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attack_list(i));
  }

  // repeated .AirShip hurter_list = 4;
  total_size += 1 * this->hurter_list_size();
  for (int i = 0; i < this->hurter_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->hurter_list(i));
  }

  // repeated .EventInfo event_list = 5;
  total_size += 1 * this->event_list_size();
  for (int i = 0; i < this->event_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->event_list(i));
  }

  // repeated .Pair get_item_list = 8;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveAttackResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SlaveAttackResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SlaveAttackResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SlaveAttackResp::MergeFrom(const SlaveAttackResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  attack_list_.MergeFrom(from.attack_list_);
  hurter_list_.MergeFrom(from.hurter_list_);
  event_list_.MergeFrom(from.event_list_);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_iswin()) {
      set_iswin(from.iswin());
    }
    if (from.has_iscatch()) {
      set_iscatch(from.iscatch());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_req()) {
      mutable_req()->::SlaveAttackReq::MergeFrom(from.req());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SlaveAttackResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveAttackResp::CopyFrom(const SlaveAttackResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveAttackResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < attack_list_size(); i++) {
    if (!this->attack_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < hurter_list_size(); i++) {
    if (!this->hurter_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < event_list_size(); i++) {
    if (!this->event_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  return true;
}

void SlaveAttackResp::Swap(SlaveAttackResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    attack_list_.Swap(&other->attack_list_);
    hurter_list_.Swap(&other->hurter_list_);
    event_list_.Swap(&other->event_list_);
    std::swap(iswin_, other->iswin_);
    std::swap(iscatch_, other->iscatch_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(req_, other->req_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SlaveAttackResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveAttackResp_descriptor_;
  metadata.reflection = SlaveAttackResp_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
