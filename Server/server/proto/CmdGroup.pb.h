// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdGroup.proto

#ifndef PROTOBUF_CmdGroup_2eproto__INCLUDED
#define PROTOBUF_CmdGroup_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Group.pb.h"
#include "UserInfo.pb.h"
#include "Item.pb.h"
#include "AirShip.pb.h"
#include "PvpInfo.pb.h"
#include "UserSync.pb.h"
#include "OtherInfo.pb.h"
#include "Planet.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdGroup_2eproto();
void protobuf_AssignDesc_CmdGroup_2eproto();
void protobuf_ShutdownFile_CmdGroup_2eproto();

class CreateGroupReq;
class CreateGroupResp;
class GetGroupReq;
class GetGroupResp;
class GroupUpdate;
class GroupUpdate_UserUpdate;
class GroupJoinConditionReq;
class GroupJoinConditionResp;
class GroupJoinReq;
class GroupJoinResp;
class GroupAllowReq;
class GroupAllowResp;
class GroupExitGroupReq;
class GroupExitGroupResp;
class GroupKickReq;
class GroupKickResp;
class GroupBroadcastReq;
class GroupBroadcastResp;
class GroupJobReq;
class GroupJobResp;
class GroupDisbandResp;
class GroupSearchReq;
class GroupSearchResp;
class GroupContributeReq;
class GroupContributeResp;
class GroupContributeCDResp;
class GroupTechLevelupReq;
class GroupTechLevelupResp;
class GroupGetTechReq;
class GroupGetTechResp;
class GroupLevelupResp;
class GroupPVEGetInfoReq;
class GroupPVEGetInfoResp;
class GroupPVEReq;
class GroupPVEResp;
class GroupPVEOKReq;
class GroupPVEOKResp;
class GroupPVEAddTimsReq;
class GroupPVEAddTimsResp;
class GroupPVERewardReq;
class GroupPVERewardResp;
class GroupRequestHelpReq;
class GroupRequestHelpResp;
class GroupHelpListResp;
class GroupHelpReq;
class GroupHelpResp;
class NewGroupUpdate;
class GroupInviteReq;
class GroupInviteResp;
class GroupWorshipReq;
class GroupWorshipResp;

enum GroupJoinResp_GroupJoinRet {
  GroupJoinResp_GroupJoinRet_OK = 0,
  GroupJoinResp_GroupJoinRet_FAIL = -1,
  GroupJoinResp_GroupJoinRet_HAS_GROUP = 999,
  GroupJoinResp_GroupJoinRet_NO_NUMS = 998,
  GroupJoinResp_GroupJoinRet_NO_TIME = 997,
  GroupJoinResp_GroupJoinRet_ERROR_TYPE = 995,
  GroupJoinResp_GroupJoinRet_DATA_ERROR = 1000,
  GroupJoinResp_GroupJoinRet_SAME_USER = 1,
  GroupJoinResp_GroupJoinRet_STATUS_ERROR = 2,
  GroupJoinResp_GroupJoinRet_NO_USER = 3,
  GroupJoinResp_GroupJoinRet_NO_POWER = 4,
  GroupJoinResp_GroupJoinRet_USER_COUNT_MAX = 5,
  GroupJoinResp_GroupJoinRet_NO_CONDITION = 6
};
bool GroupJoinResp_GroupJoinRet_IsValid(int value);
const GroupJoinResp_GroupJoinRet GroupJoinResp_GroupJoinRet_GroupJoinRet_MIN = GroupJoinResp_GroupJoinRet_FAIL;
const GroupJoinResp_GroupJoinRet GroupJoinResp_GroupJoinRet_GroupJoinRet_MAX = GroupJoinResp_GroupJoinRet_DATA_ERROR;
const int GroupJoinResp_GroupJoinRet_GroupJoinRet_ARRAYSIZE = GroupJoinResp_GroupJoinRet_GroupJoinRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupJoinResp_GroupJoinRet_descriptor();
inline const ::std::string& GroupJoinResp_GroupJoinRet_Name(GroupJoinResp_GroupJoinRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupJoinResp_GroupJoinRet_descriptor(), value);
}
inline bool GroupJoinResp_GroupJoinRet_Parse(
    const ::std::string& name, GroupJoinResp_GroupJoinRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupJoinResp_GroupJoinRet>(
    GroupJoinResp_GroupJoinRet_descriptor(), name, value);
}
enum GroupAllowResp_GroupAllowRet {
  GroupAllowResp_GroupAllowRet_OK = 0,
  GroupAllowResp_GroupAllowRet_FAIL = -1,
  GroupAllowResp_GroupAllowRet_HAS_GROUP = 999,
  GroupAllowResp_GroupAllowRet_NO_NUMS = 998,
  GroupAllowResp_GroupAllowRet_NO_TIME = 997,
  GroupAllowResp_GroupAllowRet_ERROR_TYPE = 995,
  GroupAllowResp_GroupAllowRet_DATA_ERROR = 1000,
  GroupAllowResp_GroupAllowRet_SAME_USER = 1,
  GroupAllowResp_GroupAllowRet_STATUS_ERROR = 2,
  GroupAllowResp_GroupAllowRet_NO_USER = 3,
  GroupAllowResp_GroupAllowRet_NO_POWER = 4,
  GroupAllowResp_GroupAllowRet_USER_COUNT_MAX = 5,
  GroupAllowResp_GroupAllowRet_NO_CONDITION = 6
};
bool GroupAllowResp_GroupAllowRet_IsValid(int value);
const GroupAllowResp_GroupAllowRet GroupAllowResp_GroupAllowRet_GroupAllowRet_MIN = GroupAllowResp_GroupAllowRet_FAIL;
const GroupAllowResp_GroupAllowRet GroupAllowResp_GroupAllowRet_GroupAllowRet_MAX = GroupAllowResp_GroupAllowRet_DATA_ERROR;
const int GroupAllowResp_GroupAllowRet_GroupAllowRet_ARRAYSIZE = GroupAllowResp_GroupAllowRet_GroupAllowRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupAllowResp_GroupAllowRet_descriptor();
inline const ::std::string& GroupAllowResp_GroupAllowRet_Name(GroupAllowResp_GroupAllowRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupAllowResp_GroupAllowRet_descriptor(), value);
}
inline bool GroupAllowResp_GroupAllowRet_Parse(
    const ::std::string& name, GroupAllowResp_GroupAllowRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupAllowResp_GroupAllowRet>(
    GroupAllowResp_GroupAllowRet_descriptor(), name, value);
}
enum GroupKickResp_GroupKickRet {
  GroupKickResp_GroupKickRet_OK = 0,
  GroupKickResp_GroupKickRet_FAIL = -1,
  GroupKickResp_GroupKickRet_LOCKED = -2,
  GroupKickResp_GroupKickRet_NOUSER = -3,
  GroupKickResp_GroupKickRet_NOPOWER = -4
};
bool GroupKickResp_GroupKickRet_IsValid(int value);
const GroupKickResp_GroupKickRet GroupKickResp_GroupKickRet_GroupKickRet_MIN = GroupKickResp_GroupKickRet_NOPOWER;
const GroupKickResp_GroupKickRet GroupKickResp_GroupKickRet_GroupKickRet_MAX = GroupKickResp_GroupKickRet_OK;
const int GroupKickResp_GroupKickRet_GroupKickRet_ARRAYSIZE = GroupKickResp_GroupKickRet_GroupKickRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupKickResp_GroupKickRet_descriptor();
inline const ::std::string& GroupKickResp_GroupKickRet_Name(GroupKickResp_GroupKickRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupKickResp_GroupKickRet_descriptor(), value);
}
inline bool GroupKickResp_GroupKickRet_Parse(
    const ::std::string& name, GroupKickResp_GroupKickRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupKickResp_GroupKickRet>(
    GroupKickResp_GroupKickRet_descriptor(), name, value);
}
enum GroupBroadcastResp_GroupBroadcastRet {
  GroupBroadcastResp_GroupBroadcastRet_OK = 0,
  GroupBroadcastResp_GroupBroadcastRet_FAIL = -1,
  GroupBroadcastResp_GroupBroadcastRet_DIRTY = 1,
  GroupBroadcastResp_GroupBroadcastRet_NOUSER = 2,
  GroupBroadcastResp_GroupBroadcastRet_NOPOWER = 3,
  GroupBroadcastResp_GroupBroadcastRet_NOTYPE = 4
};
bool GroupBroadcastResp_GroupBroadcastRet_IsValid(int value);
const GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp_GroupBroadcastRet_GroupBroadcastRet_MIN = GroupBroadcastResp_GroupBroadcastRet_FAIL;
const GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp_GroupBroadcastRet_GroupBroadcastRet_MAX = GroupBroadcastResp_GroupBroadcastRet_NOTYPE;
const int GroupBroadcastResp_GroupBroadcastRet_GroupBroadcastRet_ARRAYSIZE = GroupBroadcastResp_GroupBroadcastRet_GroupBroadcastRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupBroadcastResp_GroupBroadcastRet_descriptor();
inline const ::std::string& GroupBroadcastResp_GroupBroadcastRet_Name(GroupBroadcastResp_GroupBroadcastRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupBroadcastResp_GroupBroadcastRet_descriptor(), value);
}
inline bool GroupBroadcastResp_GroupBroadcastRet_Parse(
    const ::std::string& name, GroupBroadcastResp_GroupBroadcastRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupBroadcastResp_GroupBroadcastRet>(
    GroupBroadcastResp_GroupBroadcastRet_descriptor(), name, value);
}
enum GroupJobResp_GroupJobRet {
  GroupJobResp_GroupJobRet_OK = 0,
  GroupJobResp_GroupJobRet_FAIL = -1,
  GroupJobResp_GroupJobRet_NOUSER = 1,
  GroupJobResp_GroupJobRet_NOPOWER = 2,
  GroupJobResp_GroupJobRet_ERROR_JOB = 3,
  GroupJobResp_GroupJobRet_FULL_MANAGER = 4,
  GroupJobResp_GroupJobRet_SAME_JOB = 5
};
bool GroupJobResp_GroupJobRet_IsValid(int value);
const GroupJobResp_GroupJobRet GroupJobResp_GroupJobRet_GroupJobRet_MIN = GroupJobResp_GroupJobRet_FAIL;
const GroupJobResp_GroupJobRet GroupJobResp_GroupJobRet_GroupJobRet_MAX = GroupJobResp_GroupJobRet_SAME_JOB;
const int GroupJobResp_GroupJobRet_GroupJobRet_ARRAYSIZE = GroupJobResp_GroupJobRet_GroupJobRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupJobResp_GroupJobRet_descriptor();
inline const ::std::string& GroupJobResp_GroupJobRet_Name(GroupJobResp_GroupJobRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupJobResp_GroupJobRet_descriptor(), value);
}
inline bool GroupJobResp_GroupJobRet_Parse(
    const ::std::string& name, GroupJobResp_GroupJobRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupJobResp_GroupJobRet>(
    GroupJobResp_GroupJobRet_descriptor(), name, value);
}
enum GroupDisbandResp_GroupDisbandRet {
  GroupDisbandResp_GroupDisbandRet_OK = 0,
  GroupDisbandResp_GroupDisbandRet_FAIL = -1,
  GroupDisbandResp_GroupDisbandRet_LOCKED = 1,
  GroupDisbandResp_GroupDisbandRet_NOPOWER = 2,
  GroupDisbandResp_GroupDisbandRet_ERROR = 3
};
bool GroupDisbandResp_GroupDisbandRet_IsValid(int value);
const GroupDisbandResp_GroupDisbandRet GroupDisbandResp_GroupDisbandRet_GroupDisbandRet_MIN = GroupDisbandResp_GroupDisbandRet_FAIL;
const GroupDisbandResp_GroupDisbandRet GroupDisbandResp_GroupDisbandRet_GroupDisbandRet_MAX = GroupDisbandResp_GroupDisbandRet_ERROR;
const int GroupDisbandResp_GroupDisbandRet_GroupDisbandRet_ARRAYSIZE = GroupDisbandResp_GroupDisbandRet_GroupDisbandRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupDisbandResp_GroupDisbandRet_descriptor();
inline const ::std::string& GroupDisbandResp_GroupDisbandRet_Name(GroupDisbandResp_GroupDisbandRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupDisbandResp_GroupDisbandRet_descriptor(), value);
}
inline bool GroupDisbandResp_GroupDisbandRet_Parse(
    const ::std::string& name, GroupDisbandResp_GroupDisbandRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupDisbandResp_GroupDisbandRet>(
    GroupDisbandResp_GroupDisbandRet_descriptor(), name, value);
}
enum GroupPVEGetInfoResp_GroupPVEGetInfoRet {
  GroupPVEGetInfoResp_GroupPVEGetInfoRet_OK = 0,
  GroupPVEGetInfoResp_GroupPVEGetInfoRet_FAIL = -1,
  GroupPVEGetInfoResp_GroupPVEGetInfoRet_NO_GROUP = 1
};
bool GroupPVEGetInfoResp_GroupPVEGetInfoRet_IsValid(int value);
const GroupPVEGetInfoResp_GroupPVEGetInfoRet GroupPVEGetInfoResp_GroupPVEGetInfoRet_GroupPVEGetInfoRet_MIN = GroupPVEGetInfoResp_GroupPVEGetInfoRet_FAIL;
const GroupPVEGetInfoResp_GroupPVEGetInfoRet GroupPVEGetInfoResp_GroupPVEGetInfoRet_GroupPVEGetInfoRet_MAX = GroupPVEGetInfoResp_GroupPVEGetInfoRet_NO_GROUP;
const int GroupPVEGetInfoResp_GroupPVEGetInfoRet_GroupPVEGetInfoRet_ARRAYSIZE = GroupPVEGetInfoResp_GroupPVEGetInfoRet_GroupPVEGetInfoRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupPVEGetInfoResp_GroupPVEGetInfoRet_descriptor();
inline const ::std::string& GroupPVEGetInfoResp_GroupPVEGetInfoRet_Name(GroupPVEGetInfoResp_GroupPVEGetInfoRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupPVEGetInfoResp_GroupPVEGetInfoRet_descriptor(), value);
}
inline bool GroupPVEGetInfoResp_GroupPVEGetInfoRet_Parse(
    const ::std::string& name, GroupPVEGetInfoResp_GroupPVEGetInfoRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupPVEGetInfoResp_GroupPVEGetInfoRet>(
    GroupPVEGetInfoResp_GroupPVEGetInfoRet_descriptor(), name, value);
}
enum GroupPVEResp_GroupPVERet {
  GroupPVEResp_GroupPVERet_OK = 0,
  GroupPVEResp_GroupPVERet_FAIL = -1,
  GroupPVEResp_GroupPVERet_GROUP_LEVEL = 1,
  GroupPVEResp_GroupPVERet_TIME_OUT = 2,
  GroupPVEResp_GroupPVERet_WDAY = 3,
  GroupPVEResp_GroupPVERet_CHALLENGE_TIMES = 4,
  GroupPVEResp_GroupPVERet_NO_DURABEL = 5,
  GroupPVEResp_GroupPVERet_SHIP_FIXING = 6,
  GroupPVEResp_GroupPVERet_NO_STRENGTH = 7,
  GroupPVEResp_GroupPVERet_DEAD = 8,
  GroupPVEResp_GroupPVERet_NO_GROUP = 9,
  GroupPVEResp_GroupPVERet_NO_DATA = 10,
  GroupPVEResp_GroupPVERet_SHIP_OUTING = 11
};
bool GroupPVEResp_GroupPVERet_IsValid(int value);
const GroupPVEResp_GroupPVERet GroupPVEResp_GroupPVERet_GroupPVERet_MIN = GroupPVEResp_GroupPVERet_FAIL;
const GroupPVEResp_GroupPVERet GroupPVEResp_GroupPVERet_GroupPVERet_MAX = GroupPVEResp_GroupPVERet_SHIP_OUTING;
const int GroupPVEResp_GroupPVERet_GroupPVERet_ARRAYSIZE = GroupPVEResp_GroupPVERet_GroupPVERet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupPVEResp_GroupPVERet_descriptor();
inline const ::std::string& GroupPVEResp_GroupPVERet_Name(GroupPVEResp_GroupPVERet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupPVEResp_GroupPVERet_descriptor(), value);
}
inline bool GroupPVEResp_GroupPVERet_Parse(
    const ::std::string& name, GroupPVEResp_GroupPVERet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupPVEResp_GroupPVERet>(
    GroupPVEResp_GroupPVERet_descriptor(), name, value);
}
enum GroupPVEOKResp_GroupPVEOKRet {
  GroupPVEOKResp_GroupPVEOKRet_OK = 0,
  GroupPVEOKResp_GroupPVEOKRet_FAIL = -1,
  GroupPVEOKResp_GroupPVEOKRet_NO_DATA = 1,
  GroupPVEOKResp_GroupPVEOKRet_HP_LIST_ERROR0 = 2,
  GroupPVEOKResp_GroupPVEOKRet_HP_LIST_ERROR1 = 3,
  GroupPVEOKResp_GroupPVEOKRet_NO_GROUP = 4,
  GroupPVEOKResp_GroupPVEOKRet_ERROR_RESULT = 5
};
bool GroupPVEOKResp_GroupPVEOKRet_IsValid(int value);
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp_GroupPVEOKRet_GroupPVEOKRet_MIN = GroupPVEOKResp_GroupPVEOKRet_FAIL;
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp_GroupPVEOKRet_GroupPVEOKRet_MAX = GroupPVEOKResp_GroupPVEOKRet_ERROR_RESULT;
const int GroupPVEOKResp_GroupPVEOKRet_GroupPVEOKRet_ARRAYSIZE = GroupPVEOKResp_GroupPVEOKRet_GroupPVEOKRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupPVEOKResp_GroupPVEOKRet_descriptor();
inline const ::std::string& GroupPVEOKResp_GroupPVEOKRet_Name(GroupPVEOKResp_GroupPVEOKRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupPVEOKResp_GroupPVEOKRet_descriptor(), value);
}
inline bool GroupPVEOKResp_GroupPVEOKRet_Parse(
    const ::std::string& name, GroupPVEOKResp_GroupPVEOKRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupPVEOKResp_GroupPVEOKRet>(
    GroupPVEOKResp_GroupPVEOKRet_descriptor(), name, value);
}
enum GroupPVEAddTimsResp_GroupPVEAddTimsRet {
  GroupPVEAddTimsResp_GroupPVEAddTimsRet_OK = 0,
  GroupPVEAddTimsResp_GroupPVEAddTimsRet_FAIL = -1,
  GroupPVEAddTimsResp_GroupPVEAddTimsRet_NO_GROUP = 1,
  GroupPVEAddTimsResp_GroupPVEAddTimsRet_NO_DATA = 2,
  GroupPVEAddTimsResp_GroupPVEAddTimsRet_MAX_TIMES = 3,
  GroupPVEAddTimsResp_GroupPVEAddTimsRet_ERROR_TIMES = 4,
  GroupPVEAddTimsResp_GroupPVEAddTimsRet_NO_MONEY = 5
};
bool GroupPVEAddTimsResp_GroupPVEAddTimsRet_IsValid(int value);
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp_GroupPVEAddTimsRet_GroupPVEAddTimsRet_MIN = GroupPVEAddTimsResp_GroupPVEAddTimsRet_FAIL;
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp_GroupPVEAddTimsRet_GroupPVEAddTimsRet_MAX = GroupPVEAddTimsResp_GroupPVEAddTimsRet_NO_MONEY;
const int GroupPVEAddTimsResp_GroupPVEAddTimsRet_GroupPVEAddTimsRet_ARRAYSIZE = GroupPVEAddTimsResp_GroupPVEAddTimsRet_GroupPVEAddTimsRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupPVEAddTimsResp_GroupPVEAddTimsRet_descriptor();
inline const ::std::string& GroupPVEAddTimsResp_GroupPVEAddTimsRet_Name(GroupPVEAddTimsResp_GroupPVEAddTimsRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupPVEAddTimsResp_GroupPVEAddTimsRet_descriptor(), value);
}
inline bool GroupPVEAddTimsResp_GroupPVEAddTimsRet_Parse(
    const ::std::string& name, GroupPVEAddTimsResp_GroupPVEAddTimsRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupPVEAddTimsResp_GroupPVEAddTimsRet>(
    GroupPVEAddTimsResp_GroupPVEAddTimsRet_descriptor(), name, value);
}
enum GroupPVERewardResp_GroupPVERewardRet {
  GroupPVERewardResp_GroupPVERewardRet_OK = 0,
  GroupPVERewardResp_GroupPVERewardRet_FAIL = -1,
  GroupPVERewardResp_GroupPVERewardRet_NO_GROUP = 1,
  GroupPVERewardResp_GroupPVERewardRet_NO_DATA = 2,
  GroupPVERewardResp_GroupPVERewardRet_NO_INDEX = 3,
  GroupPVERewardResp_GroupPVERewardRet_NO_INDEX_DATA = 4,
  GroupPVERewardResp_GroupPVERewardRet_SMALL_DAMAGE = 5,
  GroupPVERewardResp_GroupPVERewardRet_GETTED = 6
};
bool GroupPVERewardResp_GroupPVERewardRet_IsValid(int value);
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp_GroupPVERewardRet_GroupPVERewardRet_MIN = GroupPVERewardResp_GroupPVERewardRet_FAIL;
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp_GroupPVERewardRet_GroupPVERewardRet_MAX = GroupPVERewardResp_GroupPVERewardRet_GETTED;
const int GroupPVERewardResp_GroupPVERewardRet_GroupPVERewardRet_ARRAYSIZE = GroupPVERewardResp_GroupPVERewardRet_GroupPVERewardRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupPVERewardResp_GroupPVERewardRet_descriptor();
inline const ::std::string& GroupPVERewardResp_GroupPVERewardRet_Name(GroupPVERewardResp_GroupPVERewardRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupPVERewardResp_GroupPVERewardRet_descriptor(), value);
}
inline bool GroupPVERewardResp_GroupPVERewardRet_Parse(
    const ::std::string& name, GroupPVERewardResp_GroupPVERewardRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupPVERewardResp_GroupPVERewardRet>(
    GroupPVERewardResp_GroupPVERewardRet_descriptor(), name, value);
}
enum GroupRequestHelpResp_GroupRequestHelpRet {
  GroupRequestHelpResp_GroupRequestHelpRet_OK = 0,
  GroupRequestHelpResp_GroupRequestHelpRet_FAIL = -1,
  GroupRequestHelpResp_GroupRequestHelpRet_NO_DATA = 1,
  GroupRequestHelpResp_GroupRequestHelpRet_NO_CD = 2,
  GroupRequestHelpResp_GroupRequestHelpRet_REQUESTED = 3,
  GroupRequestHelpResp_GroupRequestHelpRet_REQ_DATA_ERROR = 4,
  GroupRequestHelpResp_GroupRequestHelpRet_HELPED = 5
};
bool GroupRequestHelpResp_GroupRequestHelpRet_IsValid(int value);
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp_GroupRequestHelpRet_GroupRequestHelpRet_MIN = GroupRequestHelpResp_GroupRequestHelpRet_FAIL;
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp_GroupRequestHelpRet_GroupRequestHelpRet_MAX = GroupRequestHelpResp_GroupRequestHelpRet_HELPED;
const int GroupRequestHelpResp_GroupRequestHelpRet_GroupRequestHelpRet_ARRAYSIZE = GroupRequestHelpResp_GroupRequestHelpRet_GroupRequestHelpRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupRequestHelpResp_GroupRequestHelpRet_descriptor();
inline const ::std::string& GroupRequestHelpResp_GroupRequestHelpRet_Name(GroupRequestHelpResp_GroupRequestHelpRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupRequestHelpResp_GroupRequestHelpRet_descriptor(), value);
}
inline bool GroupRequestHelpResp_GroupRequestHelpRet_Parse(
    const ::std::string& name, GroupRequestHelpResp_GroupRequestHelpRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupRequestHelpResp_GroupRequestHelpRet>(
    GroupRequestHelpResp_GroupRequestHelpRet_descriptor(), name, value);
}
enum GroupHelpListResp_GroupHelpListRet {
  GroupHelpListResp_GroupHelpListRet_OK = 0,
  GroupHelpListResp_GroupHelpListRet_FAIL = -1
};
bool GroupHelpListResp_GroupHelpListRet_IsValid(int value);
const GroupHelpListResp_GroupHelpListRet GroupHelpListResp_GroupHelpListRet_GroupHelpListRet_MIN = GroupHelpListResp_GroupHelpListRet_FAIL;
const GroupHelpListResp_GroupHelpListRet GroupHelpListResp_GroupHelpListRet_GroupHelpListRet_MAX = GroupHelpListResp_GroupHelpListRet_OK;
const int GroupHelpListResp_GroupHelpListRet_GroupHelpListRet_ARRAYSIZE = GroupHelpListResp_GroupHelpListRet_GroupHelpListRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupHelpListResp_GroupHelpListRet_descriptor();
inline const ::std::string& GroupHelpListResp_GroupHelpListRet_Name(GroupHelpListResp_GroupHelpListRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupHelpListResp_GroupHelpListRet_descriptor(), value);
}
inline bool GroupHelpListResp_GroupHelpListRet_Parse(
    const ::std::string& name, GroupHelpListResp_GroupHelpListRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupHelpListResp_GroupHelpListRet>(
    GroupHelpListResp_GroupHelpListRet_descriptor(), name, value);
}
enum GroupHelpResp_GroupHelpRet {
  GroupHelpResp_GroupHelpRet_OK = 0,
  GroupHelpResp_GroupHelpRet_FAIL = -1,
  GroupHelpResp_GroupHelpRet_HELP_TIME_MAX = 1,
  GroupHelpResp_GroupHelpRet_NO_DATA = 2,
  GroupHelpResp_GroupHelpRet_NO_INFO_DATA = 3,
  GroupHelpResp_GroupHelpRet_NO_CD = 4,
  GroupHelpResp_GroupHelpRet_REQ_DATA_ERROR = 5
};
bool GroupHelpResp_GroupHelpRet_IsValid(int value);
const GroupHelpResp_GroupHelpRet GroupHelpResp_GroupHelpRet_GroupHelpRet_MIN = GroupHelpResp_GroupHelpRet_FAIL;
const GroupHelpResp_GroupHelpRet GroupHelpResp_GroupHelpRet_GroupHelpRet_MAX = GroupHelpResp_GroupHelpRet_REQ_DATA_ERROR;
const int GroupHelpResp_GroupHelpRet_GroupHelpRet_ARRAYSIZE = GroupHelpResp_GroupHelpRet_GroupHelpRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupHelpResp_GroupHelpRet_descriptor();
inline const ::std::string& GroupHelpResp_GroupHelpRet_Name(GroupHelpResp_GroupHelpRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupHelpResp_GroupHelpRet_descriptor(), value);
}
inline bool GroupHelpResp_GroupHelpRet_Parse(
    const ::std::string& name, GroupHelpResp_GroupHelpRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupHelpResp_GroupHelpRet>(
    GroupHelpResp_GroupHelpRet_descriptor(), name, value);
}
enum GroupInviteResp_GroupInviteRet {
  GroupInviteResp_GroupInviteRet_OK = 0,
  GroupInviteResp_GroupInviteRet_FAIL = -1,
  GroupInviteResp_GroupInviteRet_OTHER_BLACK = 1,
  GroupInviteResp_GroupInviteRet_MY_BLACK = 2,
  GroupInviteResp_GroupInviteRet_SENDED = 3,
  GroupInviteResp_GroupInviteRet_HAS_GROUP = 4,
  GroupInviteResp_GroupInviteRet_NO_POWER = 5,
  GroupInviteResp_GroupInviteRet_NO_OPEN = 6
};
bool GroupInviteResp_GroupInviteRet_IsValid(int value);
const GroupInviteResp_GroupInviteRet GroupInviteResp_GroupInviteRet_GroupInviteRet_MIN = GroupInviteResp_GroupInviteRet_FAIL;
const GroupInviteResp_GroupInviteRet GroupInviteResp_GroupInviteRet_GroupInviteRet_MAX = GroupInviteResp_GroupInviteRet_NO_OPEN;
const int GroupInviteResp_GroupInviteRet_GroupInviteRet_ARRAYSIZE = GroupInviteResp_GroupInviteRet_GroupInviteRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupInviteResp_GroupInviteRet_descriptor();
inline const ::std::string& GroupInviteResp_GroupInviteRet_Name(GroupInviteResp_GroupInviteRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupInviteResp_GroupInviteRet_descriptor(), value);
}
inline bool GroupInviteResp_GroupInviteRet_Parse(
    const ::std::string& name, GroupInviteResp_GroupInviteRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupInviteResp_GroupInviteRet>(
    GroupInviteResp_GroupInviteRet_descriptor(), name, value);
}
enum GroupWorshipResp_GroupWorshipRet {
  GroupWorshipResp_GroupWorshipRet_OK = 0,
  GroupWorshipResp_GroupWorshipRet_FAIL = -1,
  GroupWorshipResp_GroupWorshipRet_ALREADY = 1,
  GroupWorshipResp_GroupWorshipRet_NO_CONF = 2,
  GroupWorshipResp_GroupWorshipRet_NO_GROUP = 3,
  GroupWorshipResp_GroupWorshipRet_NO_RES = 4,
  GroupWorshipResp_GroupWorshipRet_GETTED = 5,
  GroupWorshipResp_GroupWorshipRet_LOW_POINT = 6,
  GroupWorshipResp_GroupWorshipRet_NO_WORSHIP = 7
};
bool GroupWorshipResp_GroupWorshipRet_IsValid(int value);
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp_GroupWorshipRet_GroupWorshipRet_MIN = GroupWorshipResp_GroupWorshipRet_FAIL;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp_GroupWorshipRet_GroupWorshipRet_MAX = GroupWorshipResp_GroupWorshipRet_NO_WORSHIP;
const int GroupWorshipResp_GroupWorshipRet_GroupWorshipRet_ARRAYSIZE = GroupWorshipResp_GroupWorshipRet_GroupWorshipRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupWorshipResp_GroupWorshipRet_descriptor();
inline const ::std::string& GroupWorshipResp_GroupWorshipRet_Name(GroupWorshipResp_GroupWorshipRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupWorshipResp_GroupWorshipRet_descriptor(), value);
}
inline bool GroupWorshipResp_GroupWorshipRet_Parse(
    const ::std::string& name, GroupWorshipResp_GroupWorshipRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupWorshipResp_GroupWorshipRet>(
    GroupWorshipResp_GroupWorshipRet_descriptor(), name, value);
}
// ===================================================================

class CreateGroupReq : public ::google::protobuf::Message {
 public:
  CreateGroupReq();
  virtual ~CreateGroupReq();

  CreateGroupReq(const CreateGroupReq& from);

  inline CreateGroupReq& operator=(const CreateGroupReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateGroupReq& default_instance();

  void Swap(CreateGroupReq* other);

  // implements Message ----------------------------------------------

  CreateGroupReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateGroupReq& from);
  void MergeFrom(const CreateGroupReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nickname = 1;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional int32 icon_id = 2;
  inline bool has_icon_id() const;
  inline void clear_icon_id();
  static const int kIconIdFieldNumber = 2;
  inline ::google::protobuf::int32 icon_id() const;
  inline void set_icon_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CreateGroupReq)
 private:
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_icon_id();
  inline void clear_has_icon_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nickname_;
  ::google::protobuf::int32 icon_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static CreateGroupReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateGroupResp : public ::google::protobuf::Message {
 public:
  CreateGroupResp();
  virtual ~CreateGroupResp();

  CreateGroupResp(const CreateGroupResp& from);

  inline CreateGroupResp& operator=(const CreateGroupResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateGroupResp& default_instance();

  void Swap(CreateGroupResp* other);

  // implements Message ----------------------------------------------

  CreateGroupResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateGroupResp& from);
  void MergeFrom(const CreateGroupResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:CreateGroupResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static CreateGroupResp* default_instance_;
};
// -------------------------------------------------------------------

class GetGroupReq : public ::google::protobuf::Message {
 public:
  GetGroupReq();
  virtual ~GetGroupReq();

  GetGroupReq(const GetGroupReq& from);

  inline GetGroupReq& operator=(const GetGroupReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGroupReq& default_instance();

  void Swap(GetGroupReq* other);

  // implements Message ----------------------------------------------

  GetGroupReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetGroupReq& from);
  void MergeFrom(const GetGroupReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string groupid = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 1;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // @@protoc_insertion_point(class_scope:GetGroupReq)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GetGroupReq* default_instance_;
};
// -------------------------------------------------------------------

class GetGroupResp : public ::google::protobuf::Message {
 public:
  GetGroupResp();
  virtual ~GetGroupResp();

  GetGroupResp(const GetGroupResp& from);

  inline GetGroupResp& operator=(const GetGroupResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGroupResp& default_instance();

  void Swap(GetGroupResp* other);

  // implements Message ----------------------------------------------

  GetGroupResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetGroupResp& from);
  void MergeFrom(const GetGroupResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .OtherGroupInfo other_group_info = 3;
  inline bool has_other_group_info() const;
  inline void clear_other_group_info();
  static const int kOtherGroupInfoFieldNumber = 3;
  inline const ::OtherGroupInfo& other_group_info() const;
  inline ::OtherGroupInfo* mutable_other_group_info();
  inline ::OtherGroupInfo* release_other_group_info();
  inline void set_allocated_other_group_info(::OtherGroupInfo* other_group_info);

  // @@protoc_insertion_point(class_scope:GetGroupResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_other_group_info();
  inline void clear_has_other_group_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::OtherGroupInfo* other_group_info_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GetGroupResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupUpdate_UserUpdate : public ::google::protobuf::Message {
 public:
  GroupUpdate_UserUpdate();
  virtual ~GroupUpdate_UserUpdate();

  GroupUpdate_UserUpdate(const GroupUpdate_UserUpdate& from);

  inline GroupUpdate_UserUpdate& operator=(const GroupUpdate_UserUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupUpdate_UserUpdate& default_instance();

  void Swap(GroupUpdate_UserUpdate* other);

  // implements Message ----------------------------------------------

  GroupUpdate_UserUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupUpdate_UserUpdate& from);
  void MergeFrom(const GroupUpdate_UserUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .PlanetUser planet_user = 3;
  inline bool has_planet_user() const;
  inline void clear_planet_user();
  static const int kPlanetUserFieldNumber = 3;
  inline const ::PlanetUser& planet_user() const;
  inline ::PlanetUser* mutable_planet_user();
  inline ::PlanetUser* release_planet_user();
  inline void set_allocated_planet_user(::PlanetUser* planet_user);

  // @@protoc_insertion_point(class_scope:GroupUpdate.UserUpdate)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_planet_user();
  inline void clear_has_planet_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::UserSync* user_sync_;
  ::PlanetUser* planet_user_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupUpdate_UserUpdate* default_instance_;
};
// -------------------------------------------------------------------

class GroupUpdate : public ::google::protobuf::Message {
 public:
  GroupUpdate();
  virtual ~GroupUpdate();

  GroupUpdate(const GroupUpdate& from);

  inline GroupUpdate& operator=(const GroupUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupUpdate& default_instance();

  void Swap(GroupUpdate* other);

  // implements Message ----------------------------------------------

  GroupUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupUpdate& from);
  void MergeFrom(const GroupUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupUpdate_UserUpdate UserUpdate;

  // accessors -------------------------------------------------------

  // optional .GroupMainData group_main = 1;
  inline bool has_group_main() const;
  inline void clear_group_main();
  static const int kGroupMainFieldNumber = 1;
  inline const ::GroupMainData& group_main() const;
  inline ::GroupMainData* mutable_group_main();
  inline ::GroupMainData* release_group_main();
  inline void set_allocated_group_main(::GroupMainData* group_main);

  // optional string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // repeated .GroupUpdate.UserUpdate user_update_list = 3;
  inline int user_update_list_size() const;
  inline void clear_user_update_list();
  static const int kUserUpdateListFieldNumber = 3;
  inline const ::GroupUpdate_UserUpdate& user_update_list(int index) const;
  inline ::GroupUpdate_UserUpdate* mutable_user_update_list(int index);
  inline ::GroupUpdate_UserUpdate* add_user_update_list();
  inline const ::google::protobuf::RepeatedPtrField< ::GroupUpdate_UserUpdate >&
      user_update_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::GroupUpdate_UserUpdate >*
      mutable_user_update_list();

  // @@protoc_insertion_point(class_scope:GroupUpdate)
 private:
  inline void set_has_group_main();
  inline void clear_has_group_main();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::GroupMainData* group_main_;
  ::std::string* user_name_;
  ::google::protobuf::RepeatedPtrField< ::GroupUpdate_UserUpdate > user_update_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupUpdate* default_instance_;
};
// -------------------------------------------------------------------

class GroupJoinConditionReq : public ::google::protobuf::Message {
 public:
  GroupJoinConditionReq();
  virtual ~GroupJoinConditionReq();

  GroupJoinConditionReq(const GroupJoinConditionReq& from);

  inline GroupJoinConditionReq& operator=(const GroupJoinConditionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupJoinConditionReq& default_instance();

  void Swap(GroupJoinConditionReq* other);

  // implements Message ----------------------------------------------

  GroupJoinConditionReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupJoinConditionReq& from);
  void MergeFrom(const GroupJoinConditionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool needAllow = 1;
  inline bool has_needallow() const;
  inline void clear_needallow();
  static const int kNeedAllowFieldNumber = 1;
  inline bool needallow() const;
  inline void set_needallow(bool value);

  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 power = 3;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 3;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupJoinConditionReq)
 private:
  inline void set_has_needallow();
  inline void clear_has_needallow();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_power();
  inline void clear_has_power();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool needallow_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupJoinConditionReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupJoinConditionResp : public ::google::protobuf::Message {
 public:
  GroupJoinConditionResp();
  virtual ~GroupJoinConditionResp();

  GroupJoinConditionResp(const GroupJoinConditionResp& from);

  inline GroupJoinConditionResp& operator=(const GroupJoinConditionResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupJoinConditionResp& default_instance();

  void Swap(GroupJoinConditionResp* other);

  // implements Message ----------------------------------------------

  GroupJoinConditionResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupJoinConditionResp& from);
  void MergeFrom(const GroupJoinConditionResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupJoinConditionResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupJoinConditionResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupJoinReq : public ::google::protobuf::Message {
 public:
  GroupJoinReq();
  virtual ~GroupJoinReq();

  GroupJoinReq(const GroupJoinReq& from);

  inline GroupJoinReq& operator=(const GroupJoinReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupJoinReq& default_instance();

  void Swap(GroupJoinReq* other);

  // implements Message ----------------------------------------------

  GroupJoinReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupJoinReq& from);
  void MergeFrom(const GroupJoinReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string groupid = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 1;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupJoinReq)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupJoinReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupJoinResp : public ::google::protobuf::Message {
 public:
  GroupJoinResp();
  virtual ~GroupJoinResp();

  GroupJoinResp(const GroupJoinResp& from);

  inline GroupJoinResp& operator=(const GroupJoinResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupJoinResp& default_instance();

  void Swap(GroupJoinResp* other);

  // implements Message ----------------------------------------------

  GroupJoinResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupJoinResp& from);
  void MergeFrom(const GroupJoinResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupJoinResp_GroupJoinRet GroupJoinRet;
  static const GroupJoinRet OK = GroupJoinResp_GroupJoinRet_OK;
  static const GroupJoinRet FAIL = GroupJoinResp_GroupJoinRet_FAIL;
  static const GroupJoinRet HAS_GROUP = GroupJoinResp_GroupJoinRet_HAS_GROUP;
  static const GroupJoinRet NO_NUMS = GroupJoinResp_GroupJoinRet_NO_NUMS;
  static const GroupJoinRet NO_TIME = GroupJoinResp_GroupJoinRet_NO_TIME;
  static const GroupJoinRet ERROR_TYPE = GroupJoinResp_GroupJoinRet_ERROR_TYPE;
  static const GroupJoinRet DATA_ERROR = GroupJoinResp_GroupJoinRet_DATA_ERROR;
  static const GroupJoinRet SAME_USER = GroupJoinResp_GroupJoinRet_SAME_USER;
  static const GroupJoinRet STATUS_ERROR = GroupJoinResp_GroupJoinRet_STATUS_ERROR;
  static const GroupJoinRet NO_USER = GroupJoinResp_GroupJoinRet_NO_USER;
  static const GroupJoinRet NO_POWER = GroupJoinResp_GroupJoinRet_NO_POWER;
  static const GroupJoinRet USER_COUNT_MAX = GroupJoinResp_GroupJoinRet_USER_COUNT_MAX;
  static const GroupJoinRet NO_CONDITION = GroupJoinResp_GroupJoinRet_NO_CONDITION;
  static inline bool GroupJoinRet_IsValid(int value) {
    return GroupJoinResp_GroupJoinRet_IsValid(value);
  }
  static const GroupJoinRet GroupJoinRet_MIN =
    GroupJoinResp_GroupJoinRet_GroupJoinRet_MIN;
  static const GroupJoinRet GroupJoinRet_MAX =
    GroupJoinResp_GroupJoinRet_GroupJoinRet_MAX;
  static const int GroupJoinRet_ARRAYSIZE =
    GroupJoinResp_GroupJoinRet_GroupJoinRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupJoinRet_descriptor() {
    return GroupJoinResp_GroupJoinRet_descriptor();
  }
  static inline const ::std::string& GroupJoinRet_Name(GroupJoinRet value) {
    return GroupJoinResp_GroupJoinRet_Name(value);
  }
  static inline bool GroupJoinRet_Parse(const ::std::string& name,
      GroupJoinRet* value) {
    return GroupJoinResp_GroupJoinRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupJoinResp.GroupJoinRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupJoinResp_GroupJoinRet result() const;
  inline void set_result(::GroupJoinResp_GroupJoinRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupJoinResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupJoinResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupAllowReq : public ::google::protobuf::Message {
 public:
  GroupAllowReq();
  virtual ~GroupAllowReq();

  GroupAllowReq(const GroupAllowReq& from);

  inline GroupAllowReq& operator=(const GroupAllowReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupAllowReq& default_instance();

  void Swap(GroupAllowReq* other);

  // implements Message ----------------------------------------------

  GroupAllowReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupAllowReq& from);
  void MergeFrom(const GroupAllowReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupAllowReq)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupAllowReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupAllowResp : public ::google::protobuf::Message {
 public:
  GroupAllowResp();
  virtual ~GroupAllowResp();

  GroupAllowResp(const GroupAllowResp& from);

  inline GroupAllowResp& operator=(const GroupAllowResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupAllowResp& default_instance();

  void Swap(GroupAllowResp* other);

  // implements Message ----------------------------------------------

  GroupAllowResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupAllowResp& from);
  void MergeFrom(const GroupAllowResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupAllowResp_GroupAllowRet GroupAllowRet;
  static const GroupAllowRet OK = GroupAllowResp_GroupAllowRet_OK;
  static const GroupAllowRet FAIL = GroupAllowResp_GroupAllowRet_FAIL;
  static const GroupAllowRet HAS_GROUP = GroupAllowResp_GroupAllowRet_HAS_GROUP;
  static const GroupAllowRet NO_NUMS = GroupAllowResp_GroupAllowRet_NO_NUMS;
  static const GroupAllowRet NO_TIME = GroupAllowResp_GroupAllowRet_NO_TIME;
  static const GroupAllowRet ERROR_TYPE = GroupAllowResp_GroupAllowRet_ERROR_TYPE;
  static const GroupAllowRet DATA_ERROR = GroupAllowResp_GroupAllowRet_DATA_ERROR;
  static const GroupAllowRet SAME_USER = GroupAllowResp_GroupAllowRet_SAME_USER;
  static const GroupAllowRet STATUS_ERROR = GroupAllowResp_GroupAllowRet_STATUS_ERROR;
  static const GroupAllowRet NO_USER = GroupAllowResp_GroupAllowRet_NO_USER;
  static const GroupAllowRet NO_POWER = GroupAllowResp_GroupAllowRet_NO_POWER;
  static const GroupAllowRet USER_COUNT_MAX = GroupAllowResp_GroupAllowRet_USER_COUNT_MAX;
  static const GroupAllowRet NO_CONDITION = GroupAllowResp_GroupAllowRet_NO_CONDITION;
  static inline bool GroupAllowRet_IsValid(int value) {
    return GroupAllowResp_GroupAllowRet_IsValid(value);
  }
  static const GroupAllowRet GroupAllowRet_MIN =
    GroupAllowResp_GroupAllowRet_GroupAllowRet_MIN;
  static const GroupAllowRet GroupAllowRet_MAX =
    GroupAllowResp_GroupAllowRet_GroupAllowRet_MAX;
  static const int GroupAllowRet_ARRAYSIZE =
    GroupAllowResp_GroupAllowRet_GroupAllowRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupAllowRet_descriptor() {
    return GroupAllowResp_GroupAllowRet_descriptor();
  }
  static inline const ::std::string& GroupAllowRet_Name(GroupAllowRet value) {
    return GroupAllowResp_GroupAllowRet_Name(value);
  }
  static inline bool GroupAllowRet_Parse(const ::std::string& name,
      GroupAllowRet* value) {
    return GroupAllowResp_GroupAllowRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupAllowResp.GroupAllowRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupAllowResp_GroupAllowRet result() const;
  inline void set_result(::GroupAllowResp_GroupAllowRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupAllowResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupAllowResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupExitGroupReq : public ::google::protobuf::Message {
 public:
  GroupExitGroupReq();
  virtual ~GroupExitGroupReq();

  GroupExitGroupReq(const GroupExitGroupReq& from);

  inline GroupExitGroupReq& operator=(const GroupExitGroupReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupExitGroupReq& default_instance();

  void Swap(GroupExitGroupReq* other);

  // implements Message ----------------------------------------------

  GroupExitGroupReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupExitGroupReq& from);
  void MergeFrom(const GroupExitGroupReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupExitGroupReq)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupExitGroupReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupExitGroupResp : public ::google::protobuf::Message {
 public:
  GroupExitGroupResp();
  virtual ~GroupExitGroupResp();

  GroupExitGroupResp(const GroupExitGroupResp& from);

  inline GroupExitGroupResp& operator=(const GroupExitGroupResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupExitGroupResp& default_instance();

  void Swap(GroupExitGroupResp* other);

  // implements Message ----------------------------------------------

  GroupExitGroupResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupExitGroupResp& from);
  void MergeFrom(const GroupExitGroupResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupExitGroupResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupExitGroupResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupKickReq : public ::google::protobuf::Message {
 public:
  GroupKickReq();
  virtual ~GroupKickReq();

  GroupKickReq(const GroupKickReq& from);

  inline GroupKickReq& operator=(const GroupKickReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupKickReq& default_instance();

  void Swap(GroupKickReq* other);

  // implements Message ----------------------------------------------

  GroupKickReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupKickReq& from);
  void MergeFrom(const GroupKickReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:GroupKickReq)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupKickReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupKickResp : public ::google::protobuf::Message {
 public:
  GroupKickResp();
  virtual ~GroupKickResp();

  GroupKickResp(const GroupKickResp& from);

  inline GroupKickResp& operator=(const GroupKickResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupKickResp& default_instance();

  void Swap(GroupKickResp* other);

  // implements Message ----------------------------------------------

  GroupKickResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupKickResp& from);
  void MergeFrom(const GroupKickResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupKickResp_GroupKickRet GroupKickRet;
  static const GroupKickRet OK = GroupKickResp_GroupKickRet_OK;
  static const GroupKickRet FAIL = GroupKickResp_GroupKickRet_FAIL;
  static const GroupKickRet LOCKED = GroupKickResp_GroupKickRet_LOCKED;
  static const GroupKickRet NOUSER = GroupKickResp_GroupKickRet_NOUSER;
  static const GroupKickRet NOPOWER = GroupKickResp_GroupKickRet_NOPOWER;
  static inline bool GroupKickRet_IsValid(int value) {
    return GroupKickResp_GroupKickRet_IsValid(value);
  }
  static const GroupKickRet GroupKickRet_MIN =
    GroupKickResp_GroupKickRet_GroupKickRet_MIN;
  static const GroupKickRet GroupKickRet_MAX =
    GroupKickResp_GroupKickRet_GroupKickRet_MAX;
  static const int GroupKickRet_ARRAYSIZE =
    GroupKickResp_GroupKickRet_GroupKickRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupKickRet_descriptor() {
    return GroupKickResp_GroupKickRet_descriptor();
  }
  static inline const ::std::string& GroupKickRet_Name(GroupKickRet value) {
    return GroupKickResp_GroupKickRet_Name(value);
  }
  static inline bool GroupKickRet_Parse(const ::std::string& name,
      GroupKickRet* value) {
    return GroupKickResp_GroupKickRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupKickResp.GroupKickRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupKickResp_GroupKickRet result() const;
  inline void set_result(::GroupKickResp_GroupKickRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .GroupKickReq req = 3;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 3;
  inline const ::GroupKickReq& req() const;
  inline ::GroupKickReq* mutable_req();
  inline ::GroupKickReq* release_req();
  inline void set_allocated_req(::GroupKickReq* req);

  // @@protoc_insertion_point(class_scope:GroupKickResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::GroupKickReq* req_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupKickResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupBroadcastReq : public ::google::protobuf::Message {
 public:
  GroupBroadcastReq();
  virtual ~GroupBroadcastReq();

  GroupBroadcastReq(const GroupBroadcastReq& from);

  inline GroupBroadcastReq& operator=(const GroupBroadcastReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupBroadcastReq& default_instance();

  void Swap(GroupBroadcastReq* other);

  // implements Message ----------------------------------------------

  GroupBroadcastReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupBroadcastReq& from);
  void MergeFrom(const GroupBroadcastReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string blurb = 1;
  inline bool has_blurb() const;
  inline void clear_blurb();
  static const int kBlurbFieldNumber = 1;
  inline const ::std::string& blurb() const;
  inline void set_blurb(const ::std::string& value);
  inline void set_blurb(const char* value);
  inline void set_blurb(const char* value, size_t size);
  inline ::std::string* mutable_blurb();
  inline ::std::string* release_blurb();
  inline void set_allocated_blurb(::std::string* blurb);

  // optional string broadcast = 2;
  inline bool has_broadcast() const;
  inline void clear_broadcast();
  static const int kBroadcastFieldNumber = 2;
  inline const ::std::string& broadcast() const;
  inline void set_broadcast(const ::std::string& value);
  inline void set_broadcast(const char* value);
  inline void set_broadcast(const char* value, size_t size);
  inline ::std::string* mutable_broadcast();
  inline ::std::string* release_broadcast();
  inline void set_allocated_broadcast(::std::string* broadcast);

  // @@protoc_insertion_point(class_scope:GroupBroadcastReq)
 private:
  inline void set_has_blurb();
  inline void clear_has_blurb();
  inline void set_has_broadcast();
  inline void clear_has_broadcast();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* blurb_;
  ::std::string* broadcast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupBroadcastReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupBroadcastResp : public ::google::protobuf::Message {
 public:
  GroupBroadcastResp();
  virtual ~GroupBroadcastResp();

  GroupBroadcastResp(const GroupBroadcastResp& from);

  inline GroupBroadcastResp& operator=(const GroupBroadcastResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupBroadcastResp& default_instance();

  void Swap(GroupBroadcastResp* other);

  // implements Message ----------------------------------------------

  GroupBroadcastResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupBroadcastResp& from);
  void MergeFrom(const GroupBroadcastResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupBroadcastResp_GroupBroadcastRet GroupBroadcastRet;
  static const GroupBroadcastRet OK = GroupBroadcastResp_GroupBroadcastRet_OK;
  static const GroupBroadcastRet FAIL = GroupBroadcastResp_GroupBroadcastRet_FAIL;
  static const GroupBroadcastRet DIRTY = GroupBroadcastResp_GroupBroadcastRet_DIRTY;
  static const GroupBroadcastRet NOUSER = GroupBroadcastResp_GroupBroadcastRet_NOUSER;
  static const GroupBroadcastRet NOPOWER = GroupBroadcastResp_GroupBroadcastRet_NOPOWER;
  static const GroupBroadcastRet NOTYPE = GroupBroadcastResp_GroupBroadcastRet_NOTYPE;
  static inline bool GroupBroadcastRet_IsValid(int value) {
    return GroupBroadcastResp_GroupBroadcastRet_IsValid(value);
  }
  static const GroupBroadcastRet GroupBroadcastRet_MIN =
    GroupBroadcastResp_GroupBroadcastRet_GroupBroadcastRet_MIN;
  static const GroupBroadcastRet GroupBroadcastRet_MAX =
    GroupBroadcastResp_GroupBroadcastRet_GroupBroadcastRet_MAX;
  static const int GroupBroadcastRet_ARRAYSIZE =
    GroupBroadcastResp_GroupBroadcastRet_GroupBroadcastRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupBroadcastRet_descriptor() {
    return GroupBroadcastResp_GroupBroadcastRet_descriptor();
  }
  static inline const ::std::string& GroupBroadcastRet_Name(GroupBroadcastRet value) {
    return GroupBroadcastResp_GroupBroadcastRet_Name(value);
  }
  static inline bool GroupBroadcastRet_Parse(const ::std::string& name,
      GroupBroadcastRet* value) {
    return GroupBroadcastResp_GroupBroadcastRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupBroadcastResp.GroupBroadcastRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupBroadcastResp_GroupBroadcastRet result() const;
  inline void set_result(::GroupBroadcastResp_GroupBroadcastRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupBroadcastResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupBroadcastResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupJobReq : public ::google::protobuf::Message {
 public:
  GroupJobReq();
  virtual ~GroupJobReq();

  GroupJobReq(const GroupJobReq& from);

  inline GroupJobReq& operator=(const GroupJobReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupJobReq& default_instance();

  void Swap(GroupJobReq* other);

  // implements Message ----------------------------------------------

  GroupJobReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupJobReq& from);
  void MergeFrom(const GroupJobReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required int32 job = 2;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 2;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupJobReq)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_job();
  inline void clear_has_job();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::google::protobuf::int32 job_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupJobReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupJobResp : public ::google::protobuf::Message {
 public:
  GroupJobResp();
  virtual ~GroupJobResp();

  GroupJobResp(const GroupJobResp& from);

  inline GroupJobResp& operator=(const GroupJobResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupJobResp& default_instance();

  void Swap(GroupJobResp* other);

  // implements Message ----------------------------------------------

  GroupJobResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupJobResp& from);
  void MergeFrom(const GroupJobResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupJobResp_GroupJobRet GroupJobRet;
  static const GroupJobRet OK = GroupJobResp_GroupJobRet_OK;
  static const GroupJobRet FAIL = GroupJobResp_GroupJobRet_FAIL;
  static const GroupJobRet NOUSER = GroupJobResp_GroupJobRet_NOUSER;
  static const GroupJobRet NOPOWER = GroupJobResp_GroupJobRet_NOPOWER;
  static const GroupJobRet ERROR_JOB = GroupJobResp_GroupJobRet_ERROR_JOB;
  static const GroupJobRet FULL_MANAGER = GroupJobResp_GroupJobRet_FULL_MANAGER;
  static const GroupJobRet SAME_JOB = GroupJobResp_GroupJobRet_SAME_JOB;
  static inline bool GroupJobRet_IsValid(int value) {
    return GroupJobResp_GroupJobRet_IsValid(value);
  }
  static const GroupJobRet GroupJobRet_MIN =
    GroupJobResp_GroupJobRet_GroupJobRet_MIN;
  static const GroupJobRet GroupJobRet_MAX =
    GroupJobResp_GroupJobRet_GroupJobRet_MAX;
  static const int GroupJobRet_ARRAYSIZE =
    GroupJobResp_GroupJobRet_GroupJobRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupJobRet_descriptor() {
    return GroupJobResp_GroupJobRet_descriptor();
  }
  static inline const ::std::string& GroupJobRet_Name(GroupJobRet value) {
    return GroupJobResp_GroupJobRet_Name(value);
  }
  static inline bool GroupJobRet_Parse(const ::std::string& name,
      GroupJobRet* value) {
    return GroupJobResp_GroupJobRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupJobResp.GroupJobRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupJobResp_GroupJobRet result() const;
  inline void set_result(::GroupJobResp_GroupJobRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupJobResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupJobResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupDisbandResp : public ::google::protobuf::Message {
 public:
  GroupDisbandResp();
  virtual ~GroupDisbandResp();

  GroupDisbandResp(const GroupDisbandResp& from);

  inline GroupDisbandResp& operator=(const GroupDisbandResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupDisbandResp& default_instance();

  void Swap(GroupDisbandResp* other);

  // implements Message ----------------------------------------------

  GroupDisbandResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupDisbandResp& from);
  void MergeFrom(const GroupDisbandResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupDisbandResp_GroupDisbandRet GroupDisbandRet;
  static const GroupDisbandRet OK = GroupDisbandResp_GroupDisbandRet_OK;
  static const GroupDisbandRet FAIL = GroupDisbandResp_GroupDisbandRet_FAIL;
  static const GroupDisbandRet LOCKED = GroupDisbandResp_GroupDisbandRet_LOCKED;
  static const GroupDisbandRet NOPOWER = GroupDisbandResp_GroupDisbandRet_NOPOWER;
  static const GroupDisbandRet ERROR = GroupDisbandResp_GroupDisbandRet_ERROR;
  static inline bool GroupDisbandRet_IsValid(int value) {
    return GroupDisbandResp_GroupDisbandRet_IsValid(value);
  }
  static const GroupDisbandRet GroupDisbandRet_MIN =
    GroupDisbandResp_GroupDisbandRet_GroupDisbandRet_MIN;
  static const GroupDisbandRet GroupDisbandRet_MAX =
    GroupDisbandResp_GroupDisbandRet_GroupDisbandRet_MAX;
  static const int GroupDisbandRet_ARRAYSIZE =
    GroupDisbandResp_GroupDisbandRet_GroupDisbandRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupDisbandRet_descriptor() {
    return GroupDisbandResp_GroupDisbandRet_descriptor();
  }
  static inline const ::std::string& GroupDisbandRet_Name(GroupDisbandRet value) {
    return GroupDisbandResp_GroupDisbandRet_Name(value);
  }
  static inline bool GroupDisbandRet_Parse(const ::std::string& name,
      GroupDisbandRet* value) {
    return GroupDisbandResp_GroupDisbandRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupDisbandResp.GroupDisbandRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupDisbandResp_GroupDisbandRet result() const;
  inline void set_result(::GroupDisbandResp_GroupDisbandRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupDisbandResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupDisbandResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupSearchReq : public ::google::protobuf::Message {
 public:
  GroupSearchReq();
  virtual ~GroupSearchReq();

  GroupSearchReq(const GroupSearchReq& from);

  inline GroupSearchReq& operator=(const GroupSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupSearchReq& default_instance();

  void Swap(GroupSearchReq* other);

  // implements Message ----------------------------------------------

  GroupSearchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupSearchReq& from);
  void MergeFrom(const GroupSearchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string groupid = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 1;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // optional int32 page = 2;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 2;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // optional string group_name = 3;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 3;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // @@protoc_insertion_point(class_scope:GroupSearchReq)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_group_name();
  inline void clear_has_group_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupid_;
  ::std::string* group_name_;
  ::google::protobuf::int32 page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupSearchResp : public ::google::protobuf::Message {
 public:
  GroupSearchResp();
  virtual ~GroupSearchResp();

  GroupSearchResp(const GroupSearchResp& from);

  inline GroupSearchResp& operator=(const GroupSearchResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupSearchResp& default_instance();

  void Swap(GroupSearchResp* other);

  // implements Message ----------------------------------------------

  GroupSearchResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupSearchResp& from);
  void MergeFrom(const GroupSearchResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .GroupMainData group_list = 3;
  inline int group_list_size() const;
  inline void clear_group_list();
  static const int kGroupListFieldNumber = 3;
  inline const ::GroupMainData& group_list(int index) const;
  inline ::GroupMainData* mutable_group_list(int index);
  inline ::GroupMainData* add_group_list();
  inline const ::google::protobuf::RepeatedPtrField< ::GroupMainData >&
      group_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::GroupMainData >*
      mutable_group_list();

  // optional int32 total_page = 4;
  inline bool has_total_page() const;
  inline void clear_total_page();
  static const int kTotalPageFieldNumber = 4;
  inline ::google::protobuf::int32 total_page() const;
  inline void set_total_page(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupSearchResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_total_page();
  inline void clear_has_total_page();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 total_page_;
  ::google::protobuf::RepeatedPtrField< ::GroupMainData > group_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupSearchResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupContributeReq : public ::google::protobuf::Message {
 public:
  GroupContributeReq();
  virtual ~GroupContributeReq();

  GroupContributeReq(const GroupContributeReq& from);

  inline GroupContributeReq& operator=(const GroupContributeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupContributeReq& default_instance();

  void Swap(GroupContributeReq* other);

  // implements Message ----------------------------------------------

  GroupContributeReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupContributeReq& from);
  void MergeFrom(const GroupContributeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 tech_id = 2;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 2;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupContributeReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_tech_id();
  inline void clear_has_tech_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 tech_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupContributeReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupContributeResp : public ::google::protobuf::Message {
 public:
  GroupContributeResp();
  virtual ~GroupContributeResp();

  GroupContributeResp(const GroupContributeResp& from);

  inline GroupContributeResp& operator=(const GroupContributeResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupContributeResp& default_instance();

  void Swap(GroupContributeResp* other);

  // implements Message ----------------------------------------------

  GroupContributeResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupContributeResp& from);
  void MergeFrom(const GroupContributeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupContributeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupContributeResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupContributeCDResp : public ::google::protobuf::Message {
 public:
  GroupContributeCDResp();
  virtual ~GroupContributeCDResp();

  GroupContributeCDResp(const GroupContributeCDResp& from);

  inline GroupContributeCDResp& operator=(const GroupContributeCDResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupContributeCDResp& default_instance();

  void Swap(GroupContributeCDResp* other);

  // implements Message ----------------------------------------------

  GroupContributeCDResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupContributeCDResp& from);
  void MergeFrom(const GroupContributeCDResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupContributeCDResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupContributeCDResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupTechLevelupReq : public ::google::protobuf::Message {
 public:
  GroupTechLevelupReq();
  virtual ~GroupTechLevelupReq();

  GroupTechLevelupReq(const GroupTechLevelupReq& from);

  inline GroupTechLevelupReq& operator=(const GroupTechLevelupReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupTechLevelupReq& default_instance();

  void Swap(GroupTechLevelupReq* other);

  // implements Message ----------------------------------------------

  GroupTechLevelupReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupTechLevelupReq& from);
  void MergeFrom(const GroupTechLevelupReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tech_id = 1;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 1;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupTechLevelupReq)
 private:
  inline void set_has_tech_id();
  inline void clear_has_tech_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tech_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupTechLevelupReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupTechLevelupResp : public ::google::protobuf::Message {
 public:
  GroupTechLevelupResp();
  virtual ~GroupTechLevelupResp();

  GroupTechLevelupResp(const GroupTechLevelupResp& from);

  inline GroupTechLevelupResp& operator=(const GroupTechLevelupResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupTechLevelupResp& default_instance();

  void Swap(GroupTechLevelupResp* other);

  // implements Message ----------------------------------------------

  GroupTechLevelupResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupTechLevelupResp& from);
  void MergeFrom(const GroupTechLevelupResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupTechLevelupResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupTechLevelupResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupGetTechReq : public ::google::protobuf::Message {
 public:
  GroupGetTechReq();
  virtual ~GroupGetTechReq();

  GroupGetTechReq(const GroupGetTechReq& from);

  inline GroupGetTechReq& operator=(const GroupGetTechReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupGetTechReq& default_instance();

  void Swap(GroupGetTechReq* other);

  // implements Message ----------------------------------------------

  GroupGetTechReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupGetTechReq& from);
  void MergeFrom(const GroupGetTechReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tech_id = 1;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 1;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupGetTechReq)
 private:
  inline void set_has_tech_id();
  inline void clear_has_tech_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tech_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupGetTechReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupGetTechResp : public ::google::protobuf::Message {
 public:
  GroupGetTechResp();
  virtual ~GroupGetTechResp();

  GroupGetTechResp(const GroupGetTechResp& from);

  inline GroupGetTechResp& operator=(const GroupGetTechResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupGetTechResp& default_instance();

  void Swap(GroupGetTechResp* other);

  // implements Message ----------------------------------------------

  GroupGetTechResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupGetTechResp& from);
  void MergeFrom(const GroupGetTechResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .GroupTechnology group_tech = 3;
  inline bool has_group_tech() const;
  inline void clear_group_tech();
  static const int kGroupTechFieldNumber = 3;
  inline const ::GroupTechnology& group_tech() const;
  inline ::GroupTechnology* mutable_group_tech();
  inline ::GroupTechnology* release_group_tech();
  inline void set_allocated_group_tech(::GroupTechnology* group_tech);

  // @@protoc_insertion_point(class_scope:GroupGetTechResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_group_tech();
  inline void clear_has_group_tech();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::GroupTechnology* group_tech_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupGetTechResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupLevelupResp : public ::google::protobuf::Message {
 public:
  GroupLevelupResp();
  virtual ~GroupLevelupResp();

  GroupLevelupResp(const GroupLevelupResp& from);

  inline GroupLevelupResp& operator=(const GroupLevelupResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupLevelupResp& default_instance();

  void Swap(GroupLevelupResp* other);

  // implements Message ----------------------------------------------

  GroupLevelupResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupLevelupResp& from);
  void MergeFrom(const GroupLevelupResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupLevelupResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupLevelupResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVEGetInfoReq : public ::google::protobuf::Message {
 public:
  GroupPVEGetInfoReq();
  virtual ~GroupPVEGetInfoReq();

  GroupPVEGetInfoReq(const GroupPVEGetInfoReq& from);

  inline GroupPVEGetInfoReq& operator=(const GroupPVEGetInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPVEGetInfoReq& default_instance();

  void Swap(GroupPVEGetInfoReq* other);

  // implements Message ----------------------------------------------

  GroupPVEGetInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPVEGetInfoReq& from);
  void MergeFrom(const GroupPVEGetInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 group_boss_id = 1;
  inline bool has_group_boss_id() const;
  inline void clear_group_boss_id();
  static const int kGroupBossIdFieldNumber = 1;
  inline ::google::protobuf::int32 group_boss_id() const;
  inline void set_group_boss_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupPVEGetInfoReq)
 private:
  inline void set_has_group_boss_id();
  inline void clear_has_group_boss_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 group_boss_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupPVEGetInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVEGetInfoResp : public ::google::protobuf::Message {
 public:
  GroupPVEGetInfoResp();
  virtual ~GroupPVEGetInfoResp();

  GroupPVEGetInfoResp(const GroupPVEGetInfoResp& from);

  inline GroupPVEGetInfoResp& operator=(const GroupPVEGetInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPVEGetInfoResp& default_instance();

  void Swap(GroupPVEGetInfoResp* other);

  // implements Message ----------------------------------------------

  GroupPVEGetInfoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPVEGetInfoResp& from);
  void MergeFrom(const GroupPVEGetInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupPVEGetInfoResp_GroupPVEGetInfoRet GroupPVEGetInfoRet;
  static const GroupPVEGetInfoRet OK = GroupPVEGetInfoResp_GroupPVEGetInfoRet_OK;
  static const GroupPVEGetInfoRet FAIL = GroupPVEGetInfoResp_GroupPVEGetInfoRet_FAIL;
  static const GroupPVEGetInfoRet NO_GROUP = GroupPVEGetInfoResp_GroupPVEGetInfoRet_NO_GROUP;
  static inline bool GroupPVEGetInfoRet_IsValid(int value) {
    return GroupPVEGetInfoResp_GroupPVEGetInfoRet_IsValid(value);
  }
  static const GroupPVEGetInfoRet GroupPVEGetInfoRet_MIN =
    GroupPVEGetInfoResp_GroupPVEGetInfoRet_GroupPVEGetInfoRet_MIN;
  static const GroupPVEGetInfoRet GroupPVEGetInfoRet_MAX =
    GroupPVEGetInfoResp_GroupPVEGetInfoRet_GroupPVEGetInfoRet_MAX;
  static const int GroupPVEGetInfoRet_ARRAYSIZE =
    GroupPVEGetInfoResp_GroupPVEGetInfoRet_GroupPVEGetInfoRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupPVEGetInfoRet_descriptor() {
    return GroupPVEGetInfoResp_GroupPVEGetInfoRet_descriptor();
  }
  static inline const ::std::string& GroupPVEGetInfoRet_Name(GroupPVEGetInfoRet value) {
    return GroupPVEGetInfoResp_GroupPVEGetInfoRet_Name(value);
  }
  static inline bool GroupPVEGetInfoRet_Parse(const ::std::string& name,
      GroupPVEGetInfoRet* value) {
    return GroupPVEGetInfoResp_GroupPVEGetInfoRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupPVEGetInfoResp.GroupPVEGetInfoRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupPVEGetInfoResp_GroupPVEGetInfoRet result() const;
  inline void set_result(::GroupPVEGetInfoResp_GroupPVEGetInfoRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .GroupPVECheckpoint info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::GroupPVECheckpoint& info() const;
  inline ::GroupPVECheckpoint* mutable_info();
  inline ::GroupPVECheckpoint* release_info();
  inline void set_allocated_info(::GroupPVECheckpoint* info);

  // @@protoc_insertion_point(class_scope:GroupPVEGetInfoResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::GroupPVECheckpoint* info_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupPVEGetInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVEReq : public ::google::protobuf::Message {
 public:
  GroupPVEReq();
  virtual ~GroupPVEReq();

  GroupPVEReq(const GroupPVEReq& from);

  inline GroupPVEReq& operator=(const GroupPVEReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPVEReq& default_instance();

  void Swap(GroupPVEReq* other);

  // implements Message ----------------------------------------------

  GroupPVEReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPVEReq& from);
  void MergeFrom(const GroupPVEReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 group_boss_id = 1;
  inline bool has_group_boss_id() const;
  inline void clear_group_boss_id();
  static const int kGroupBossIdFieldNumber = 1;
  inline ::google::protobuf::int32 group_boss_id() const;
  inline void set_group_boss_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupPVEReq)
 private:
  inline void set_has_group_boss_id();
  inline void clear_has_group_boss_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 group_boss_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupPVEReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVEResp : public ::google::protobuf::Message {
 public:
  GroupPVEResp();
  virtual ~GroupPVEResp();

  GroupPVEResp(const GroupPVEResp& from);

  inline GroupPVEResp& operator=(const GroupPVEResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPVEResp& default_instance();

  void Swap(GroupPVEResp* other);

  // implements Message ----------------------------------------------

  GroupPVEResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPVEResp& from);
  void MergeFrom(const GroupPVEResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupPVEResp_GroupPVERet GroupPVERet;
  static const GroupPVERet OK = GroupPVEResp_GroupPVERet_OK;
  static const GroupPVERet FAIL = GroupPVEResp_GroupPVERet_FAIL;
  static const GroupPVERet GROUP_LEVEL = GroupPVEResp_GroupPVERet_GROUP_LEVEL;
  static const GroupPVERet TIME_OUT = GroupPVEResp_GroupPVERet_TIME_OUT;
  static const GroupPVERet WDAY = GroupPVEResp_GroupPVERet_WDAY;
  static const GroupPVERet CHALLENGE_TIMES = GroupPVEResp_GroupPVERet_CHALLENGE_TIMES;
  static const GroupPVERet NO_DURABEL = GroupPVEResp_GroupPVERet_NO_DURABEL;
  static const GroupPVERet SHIP_FIXING = GroupPVEResp_GroupPVERet_SHIP_FIXING;
  static const GroupPVERet NO_STRENGTH = GroupPVEResp_GroupPVERet_NO_STRENGTH;
  static const GroupPVERet DEAD = GroupPVEResp_GroupPVERet_DEAD;
  static const GroupPVERet NO_GROUP = GroupPVEResp_GroupPVERet_NO_GROUP;
  static const GroupPVERet NO_DATA = GroupPVEResp_GroupPVERet_NO_DATA;
  static const GroupPVERet SHIP_OUTING = GroupPVEResp_GroupPVERet_SHIP_OUTING;
  static inline bool GroupPVERet_IsValid(int value) {
    return GroupPVEResp_GroupPVERet_IsValid(value);
  }
  static const GroupPVERet GroupPVERet_MIN =
    GroupPVEResp_GroupPVERet_GroupPVERet_MIN;
  static const GroupPVERet GroupPVERet_MAX =
    GroupPVEResp_GroupPVERet_GroupPVERet_MAX;
  static const int GroupPVERet_ARRAYSIZE =
    GroupPVEResp_GroupPVERet_GroupPVERet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupPVERet_descriptor() {
    return GroupPVEResp_GroupPVERet_descriptor();
  }
  static inline const ::std::string& GroupPVERet_Name(GroupPVERet value) {
    return GroupPVEResp_GroupPVERet_Name(value);
  }
  static inline bool GroupPVERet_Parse(const ::std::string& name,
      GroupPVERet* value) {
    return GroupPVEResp_GroupPVERet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupPVEResp.GroupPVERet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupPVEResp_GroupPVERet result() const;
  inline void set_result(::GroupPVEResp_GroupPVERet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .AirShip attack_list = 3;
  inline int attack_list_size() const;
  inline void clear_attack_list();
  static const int kAttackListFieldNumber = 3;
  inline const ::AirShip& attack_list(int index) const;
  inline ::AirShip* mutable_attack_list(int index);
  inline ::AirShip* add_attack_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
      attack_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
      mutable_attack_list();

  // repeated .AirShip hurter_list = 4;
  inline int hurter_list_size() const;
  inline void clear_hurter_list();
  static const int kHurterListFieldNumber = 4;
  inline const ::AirShip& hurter_list(int index) const;
  inline ::AirShip* mutable_hurter_list(int index);
  inline ::AirShip* add_hurter_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
      hurter_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
      mutable_hurter_list();

  // repeated int32 hurter_hp_list = 5;
  inline int hurter_hp_list_size() const;
  inline void clear_hurter_hp_list();
  static const int kHurterHpListFieldNumber = 5;
  inline ::google::protobuf::int32 hurter_hp_list(int index) const;
  inline void set_hurter_hp_list(int index, ::google::protobuf::int32 value);
  inline void add_hurter_hp_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hurter_hp_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hurter_hp_list();

  // optional int32 group_boss_id = 6;
  inline bool has_group_boss_id() const;
  inline void clear_group_boss_id();
  static const int kGroupBossIdFieldNumber = 6;
  inline ::google::protobuf::int32 group_boss_id() const;
  inline void set_group_boss_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupPVEResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_group_boss_id();
  inline void clear_has_group_boss_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::AirShip > attack_list_;
  int result_;
  ::google::protobuf::int32 group_boss_id_;
  ::google::protobuf::RepeatedPtrField< ::AirShip > hurter_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hurter_hp_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupPVEResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVEOKReq : public ::google::protobuf::Message {
 public:
  GroupPVEOKReq();
  virtual ~GroupPVEOKReq();

  GroupPVEOKReq(const GroupPVEOKReq& from);

  inline GroupPVEOKReq& operator=(const GroupPVEOKReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPVEOKReq& default_instance();

  void Swap(GroupPVEOKReq* other);

  // implements Message ----------------------------------------------

  GroupPVEOKReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPVEOKReq& from);
  void MergeFrom(const GroupPVEOKReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 group_boss_id = 1;
  inline bool has_group_boss_id() const;
  inline void clear_group_boss_id();
  static const int kGroupBossIdFieldNumber = 1;
  inline ::google::protobuf::int32 group_boss_id() const;
  inline void set_group_boss_id(::google::protobuf::int32 value);

  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated int32 hurter_hp_list = 3;
  inline int hurter_hp_list_size() const;
  inline void clear_hurter_hp_list();
  static const int kHurterHpListFieldNumber = 3;
  inline ::google::protobuf::int32 hurter_hp_list(int index) const;
  inline void set_hurter_hp_list(int index, ::google::protobuf::int32 value);
  inline void add_hurter_hp_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hurter_hp_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hurter_hp_list();

  // @@protoc_insertion_point(class_scope:GroupPVEOKReq)
 private:
  inline void set_has_group_boss_id();
  inline void clear_has_group_boss_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 group_boss_id_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hurter_hp_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupPVEOKReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVEOKResp : public ::google::protobuf::Message {
 public:
  GroupPVEOKResp();
  virtual ~GroupPVEOKResp();

  GroupPVEOKResp(const GroupPVEOKResp& from);

  inline GroupPVEOKResp& operator=(const GroupPVEOKResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPVEOKResp& default_instance();

  void Swap(GroupPVEOKResp* other);

  // implements Message ----------------------------------------------

  GroupPVEOKResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPVEOKResp& from);
  void MergeFrom(const GroupPVEOKResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupPVEOKResp_GroupPVEOKRet GroupPVEOKRet;
  static const GroupPVEOKRet OK = GroupPVEOKResp_GroupPVEOKRet_OK;
  static const GroupPVEOKRet FAIL = GroupPVEOKResp_GroupPVEOKRet_FAIL;
  static const GroupPVEOKRet NO_DATA = GroupPVEOKResp_GroupPVEOKRet_NO_DATA;
  static const GroupPVEOKRet HP_LIST_ERROR0 = GroupPVEOKResp_GroupPVEOKRet_HP_LIST_ERROR0;
  static const GroupPVEOKRet HP_LIST_ERROR1 = GroupPVEOKResp_GroupPVEOKRet_HP_LIST_ERROR1;
  static const GroupPVEOKRet NO_GROUP = GroupPVEOKResp_GroupPVEOKRet_NO_GROUP;
  static const GroupPVEOKRet ERROR_RESULT = GroupPVEOKResp_GroupPVEOKRet_ERROR_RESULT;
  static inline bool GroupPVEOKRet_IsValid(int value) {
    return GroupPVEOKResp_GroupPVEOKRet_IsValid(value);
  }
  static const GroupPVEOKRet GroupPVEOKRet_MIN =
    GroupPVEOKResp_GroupPVEOKRet_GroupPVEOKRet_MIN;
  static const GroupPVEOKRet GroupPVEOKRet_MAX =
    GroupPVEOKResp_GroupPVEOKRet_GroupPVEOKRet_MAX;
  static const int GroupPVEOKRet_ARRAYSIZE =
    GroupPVEOKResp_GroupPVEOKRet_GroupPVEOKRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupPVEOKRet_descriptor() {
    return GroupPVEOKResp_GroupPVEOKRet_descriptor();
  }
  static inline const ::std::string& GroupPVEOKRet_Name(GroupPVEOKRet value) {
    return GroupPVEOKResp_GroupPVEOKRet_Name(value);
  }
  static inline bool GroupPVEOKRet_Parse(const ::std::string& name,
      GroupPVEOKRet* value) {
    return GroupPVEOKResp_GroupPVEOKRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupPVEOKResp.GroupPVEOKRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupPVEOKResp_GroupPVEOKRet result() const;
  inline void set_result(::GroupPVEOKResp_GroupPVEOKRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GroupPVEOKResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupPVEOKResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVEAddTimsReq : public ::google::protobuf::Message {
 public:
  GroupPVEAddTimsReq();
  virtual ~GroupPVEAddTimsReq();

  GroupPVEAddTimsReq(const GroupPVEAddTimsReq& from);

  inline GroupPVEAddTimsReq& operator=(const GroupPVEAddTimsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPVEAddTimsReq& default_instance();

  void Swap(GroupPVEAddTimsReq* other);

  // implements Message ----------------------------------------------

  GroupPVEAddTimsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPVEAddTimsReq& from);
  void MergeFrom(const GroupPVEAddTimsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 group_boss_id = 1;
  inline bool has_group_boss_id() const;
  inline void clear_group_boss_id();
  static const int kGroupBossIdFieldNumber = 1;
  inline ::google::protobuf::int32 group_boss_id() const;
  inline void set_group_boss_id(::google::protobuf::int32 value);

  // required int32 times = 2;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 2;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupPVEAddTimsReq)
 private:
  inline void set_has_group_boss_id();
  inline void clear_has_group_boss_id();
  inline void set_has_times();
  inline void clear_has_times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 group_boss_id_;
  ::google::protobuf::int32 times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupPVEAddTimsReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVEAddTimsResp : public ::google::protobuf::Message {
 public:
  GroupPVEAddTimsResp();
  virtual ~GroupPVEAddTimsResp();

  GroupPVEAddTimsResp(const GroupPVEAddTimsResp& from);

  inline GroupPVEAddTimsResp& operator=(const GroupPVEAddTimsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPVEAddTimsResp& default_instance();

  void Swap(GroupPVEAddTimsResp* other);

  // implements Message ----------------------------------------------

  GroupPVEAddTimsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPVEAddTimsResp& from);
  void MergeFrom(const GroupPVEAddTimsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsRet;
  static const GroupPVEAddTimsRet OK = GroupPVEAddTimsResp_GroupPVEAddTimsRet_OK;
  static const GroupPVEAddTimsRet FAIL = GroupPVEAddTimsResp_GroupPVEAddTimsRet_FAIL;
  static const GroupPVEAddTimsRet NO_GROUP = GroupPVEAddTimsResp_GroupPVEAddTimsRet_NO_GROUP;
  static const GroupPVEAddTimsRet NO_DATA = GroupPVEAddTimsResp_GroupPVEAddTimsRet_NO_DATA;
  static const GroupPVEAddTimsRet MAX_TIMES = GroupPVEAddTimsResp_GroupPVEAddTimsRet_MAX_TIMES;
  static const GroupPVEAddTimsRet ERROR_TIMES = GroupPVEAddTimsResp_GroupPVEAddTimsRet_ERROR_TIMES;
  static const GroupPVEAddTimsRet NO_MONEY = GroupPVEAddTimsResp_GroupPVEAddTimsRet_NO_MONEY;
  static inline bool GroupPVEAddTimsRet_IsValid(int value) {
    return GroupPVEAddTimsResp_GroupPVEAddTimsRet_IsValid(value);
  }
  static const GroupPVEAddTimsRet GroupPVEAddTimsRet_MIN =
    GroupPVEAddTimsResp_GroupPVEAddTimsRet_GroupPVEAddTimsRet_MIN;
  static const GroupPVEAddTimsRet GroupPVEAddTimsRet_MAX =
    GroupPVEAddTimsResp_GroupPVEAddTimsRet_GroupPVEAddTimsRet_MAX;
  static const int GroupPVEAddTimsRet_ARRAYSIZE =
    GroupPVEAddTimsResp_GroupPVEAddTimsRet_GroupPVEAddTimsRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupPVEAddTimsRet_descriptor() {
    return GroupPVEAddTimsResp_GroupPVEAddTimsRet_descriptor();
  }
  static inline const ::std::string& GroupPVEAddTimsRet_Name(GroupPVEAddTimsRet value) {
    return GroupPVEAddTimsResp_GroupPVEAddTimsRet_Name(value);
  }
  static inline bool GroupPVEAddTimsRet_Parse(const ::std::string& name,
      GroupPVEAddTimsRet* value) {
    return GroupPVEAddTimsResp_GroupPVEAddTimsRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupPVEAddTimsResp.GroupPVEAddTimsRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupPVEAddTimsResp_GroupPVEAddTimsRet result() const;
  inline void set_result(::GroupPVEAddTimsResp_GroupPVEAddTimsRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .GroupPVEAddTimsReq req = 3;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 3;
  inline const ::GroupPVEAddTimsReq& req() const;
  inline ::GroupPVEAddTimsReq* mutable_req();
  inline ::GroupPVEAddTimsReq* release_req();
  inline void set_allocated_req(::GroupPVEAddTimsReq* req);

  // @@protoc_insertion_point(class_scope:GroupPVEAddTimsResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::GroupPVEAddTimsReq* req_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupPVEAddTimsResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVERewardReq : public ::google::protobuf::Message {
 public:
  GroupPVERewardReq();
  virtual ~GroupPVERewardReq();

  GroupPVERewardReq(const GroupPVERewardReq& from);

  inline GroupPVERewardReq& operator=(const GroupPVERewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPVERewardReq& default_instance();

  void Swap(GroupPVERewardReq* other);

  // implements Message ----------------------------------------------

  GroupPVERewardReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPVERewardReq& from);
  void MergeFrom(const GroupPVERewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 group_boss_id = 1;
  inline bool has_group_boss_id() const;
  inline void clear_group_boss_id();
  static const int kGroupBossIdFieldNumber = 1;
  inline ::google::protobuf::int32 group_boss_id() const;
  inline void set_group_boss_id(::google::protobuf::int32 value);

  // required int32 reward_index = 2;
  inline bool has_reward_index() const;
  inline void clear_reward_index();
  static const int kRewardIndexFieldNumber = 2;
  inline ::google::protobuf::int32 reward_index() const;
  inline void set_reward_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupPVERewardReq)
 private:
  inline void set_has_group_boss_id();
  inline void clear_has_group_boss_id();
  inline void set_has_reward_index();
  inline void clear_has_reward_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 group_boss_id_;
  ::google::protobuf::int32 reward_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupPVERewardReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVERewardResp : public ::google::protobuf::Message {
 public:
  GroupPVERewardResp();
  virtual ~GroupPVERewardResp();

  GroupPVERewardResp(const GroupPVERewardResp& from);

  inline GroupPVERewardResp& operator=(const GroupPVERewardResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPVERewardResp& default_instance();

  void Swap(GroupPVERewardResp* other);

  // implements Message ----------------------------------------------

  GroupPVERewardResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupPVERewardResp& from);
  void MergeFrom(const GroupPVERewardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupPVERewardResp_GroupPVERewardRet GroupPVERewardRet;
  static const GroupPVERewardRet OK = GroupPVERewardResp_GroupPVERewardRet_OK;
  static const GroupPVERewardRet FAIL = GroupPVERewardResp_GroupPVERewardRet_FAIL;
  static const GroupPVERewardRet NO_GROUP = GroupPVERewardResp_GroupPVERewardRet_NO_GROUP;
  static const GroupPVERewardRet NO_DATA = GroupPVERewardResp_GroupPVERewardRet_NO_DATA;
  static const GroupPVERewardRet NO_INDEX = GroupPVERewardResp_GroupPVERewardRet_NO_INDEX;
  static const GroupPVERewardRet NO_INDEX_DATA = GroupPVERewardResp_GroupPVERewardRet_NO_INDEX_DATA;
  static const GroupPVERewardRet SMALL_DAMAGE = GroupPVERewardResp_GroupPVERewardRet_SMALL_DAMAGE;
  static const GroupPVERewardRet GETTED = GroupPVERewardResp_GroupPVERewardRet_GETTED;
  static inline bool GroupPVERewardRet_IsValid(int value) {
    return GroupPVERewardResp_GroupPVERewardRet_IsValid(value);
  }
  static const GroupPVERewardRet GroupPVERewardRet_MIN =
    GroupPVERewardResp_GroupPVERewardRet_GroupPVERewardRet_MIN;
  static const GroupPVERewardRet GroupPVERewardRet_MAX =
    GroupPVERewardResp_GroupPVERewardRet_GroupPVERewardRet_MAX;
  static const int GroupPVERewardRet_ARRAYSIZE =
    GroupPVERewardResp_GroupPVERewardRet_GroupPVERewardRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupPVERewardRet_descriptor() {
    return GroupPVERewardResp_GroupPVERewardRet_descriptor();
  }
  static inline const ::std::string& GroupPVERewardRet_Name(GroupPVERewardRet value) {
    return GroupPVERewardResp_GroupPVERewardRet_Name(value);
  }
  static inline bool GroupPVERewardRet_Parse(const ::std::string& name,
      GroupPVERewardRet* value) {
    return GroupPVERewardResp_GroupPVERewardRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupPVERewardResp.GroupPVERewardRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupPVERewardResp_GroupPVERewardRet result() const;
  inline void set_result(::GroupPVERewardResp_GroupPVERewardRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .GroupPVERewardReq req = 3;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 3;
  inline const ::GroupPVERewardReq& req() const;
  inline ::GroupPVERewardReq* mutable_req();
  inline ::GroupPVERewardReq* release_req();
  inline void set_allocated_req(::GroupPVERewardReq* req);

  // @@protoc_insertion_point(class_scope:GroupPVERewardResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::GroupPVERewardReq* req_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupPVERewardResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupRequestHelpReq : public ::google::protobuf::Message {
 public:
  GroupRequestHelpReq();
  virtual ~GroupRequestHelpReq();

  GroupRequestHelpReq(const GroupRequestHelpReq& from);

  inline GroupRequestHelpReq& operator=(const GroupRequestHelpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupRequestHelpReq& default_instance();

  void Swap(GroupRequestHelpReq* other);

  // implements Message ----------------------------------------------

  GroupRequestHelpReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupRequestHelpReq& from);
  void MergeFrom(const GroupRequestHelpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int32 id = 2;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::int32 value);
  inline void add_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id();

  // @@protoc_insertion_point(class_scope:GroupRequestHelpReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupRequestHelpReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupRequestHelpResp : public ::google::protobuf::Message {
 public:
  GroupRequestHelpResp();
  virtual ~GroupRequestHelpResp();

  GroupRequestHelpResp(const GroupRequestHelpResp& from);

  inline GroupRequestHelpResp& operator=(const GroupRequestHelpResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupRequestHelpResp& default_instance();

  void Swap(GroupRequestHelpResp* other);

  // implements Message ----------------------------------------------

  GroupRequestHelpResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupRequestHelpResp& from);
  void MergeFrom(const GroupRequestHelpResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpRet;
  static const GroupRequestHelpRet OK = GroupRequestHelpResp_GroupRequestHelpRet_OK;
  static const GroupRequestHelpRet FAIL = GroupRequestHelpResp_GroupRequestHelpRet_FAIL;
  static const GroupRequestHelpRet NO_DATA = GroupRequestHelpResp_GroupRequestHelpRet_NO_DATA;
  static const GroupRequestHelpRet NO_CD = GroupRequestHelpResp_GroupRequestHelpRet_NO_CD;
  static const GroupRequestHelpRet REQUESTED = GroupRequestHelpResp_GroupRequestHelpRet_REQUESTED;
  static const GroupRequestHelpRet REQ_DATA_ERROR = GroupRequestHelpResp_GroupRequestHelpRet_REQ_DATA_ERROR;
  static const GroupRequestHelpRet HELPED = GroupRequestHelpResp_GroupRequestHelpRet_HELPED;
  static inline bool GroupRequestHelpRet_IsValid(int value) {
    return GroupRequestHelpResp_GroupRequestHelpRet_IsValid(value);
  }
  static const GroupRequestHelpRet GroupRequestHelpRet_MIN =
    GroupRequestHelpResp_GroupRequestHelpRet_GroupRequestHelpRet_MIN;
  static const GroupRequestHelpRet GroupRequestHelpRet_MAX =
    GroupRequestHelpResp_GroupRequestHelpRet_GroupRequestHelpRet_MAX;
  static const int GroupRequestHelpRet_ARRAYSIZE =
    GroupRequestHelpResp_GroupRequestHelpRet_GroupRequestHelpRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupRequestHelpRet_descriptor() {
    return GroupRequestHelpResp_GroupRequestHelpRet_descriptor();
  }
  static inline const ::std::string& GroupRequestHelpRet_Name(GroupRequestHelpRet value) {
    return GroupRequestHelpResp_GroupRequestHelpRet_Name(value);
  }
  static inline bool GroupRequestHelpRet_Parse(const ::std::string& name,
      GroupRequestHelpRet* value) {
    return GroupRequestHelpResp_GroupRequestHelpRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupRequestHelpResp.GroupRequestHelpRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupRequestHelpResp_GroupRequestHelpRet result() const;
  inline void set_result(::GroupRequestHelpResp_GroupRequestHelpRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .HelpInfo help_list = 3;
  inline int help_list_size() const;
  inline void clear_help_list();
  static const int kHelpListFieldNumber = 3;
  inline const ::HelpInfo& help_list(int index) const;
  inline ::HelpInfo* mutable_help_list(int index);
  inline ::HelpInfo* add_help_list();
  inline const ::google::protobuf::RepeatedPtrField< ::HelpInfo >&
      help_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelpInfo >*
      mutable_help_list();

  // @@protoc_insertion_point(class_scope:GroupRequestHelpResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::HelpInfo > help_list_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupRequestHelpResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupHelpListResp : public ::google::protobuf::Message {
 public:
  GroupHelpListResp();
  virtual ~GroupHelpListResp();

  GroupHelpListResp(const GroupHelpListResp& from);

  inline GroupHelpListResp& operator=(const GroupHelpListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupHelpListResp& default_instance();

  void Swap(GroupHelpListResp* other);

  // implements Message ----------------------------------------------

  GroupHelpListResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupHelpListResp& from);
  void MergeFrom(const GroupHelpListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupHelpListResp_GroupHelpListRet GroupHelpListRet;
  static const GroupHelpListRet OK = GroupHelpListResp_GroupHelpListRet_OK;
  static const GroupHelpListRet FAIL = GroupHelpListResp_GroupHelpListRet_FAIL;
  static inline bool GroupHelpListRet_IsValid(int value) {
    return GroupHelpListResp_GroupHelpListRet_IsValid(value);
  }
  static const GroupHelpListRet GroupHelpListRet_MIN =
    GroupHelpListResp_GroupHelpListRet_GroupHelpListRet_MIN;
  static const GroupHelpListRet GroupHelpListRet_MAX =
    GroupHelpListResp_GroupHelpListRet_GroupHelpListRet_MAX;
  static const int GroupHelpListRet_ARRAYSIZE =
    GroupHelpListResp_GroupHelpListRet_GroupHelpListRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupHelpListRet_descriptor() {
    return GroupHelpListResp_GroupHelpListRet_descriptor();
  }
  static inline const ::std::string& GroupHelpListRet_Name(GroupHelpListRet value) {
    return GroupHelpListResp_GroupHelpListRet_Name(value);
  }
  static inline bool GroupHelpListRet_Parse(const ::std::string& name,
      GroupHelpListRet* value) {
    return GroupHelpListResp_GroupHelpListRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupHelpListResp.GroupHelpListRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupHelpListResp_GroupHelpListRet result() const;
  inline void set_result(::GroupHelpListResp_GroupHelpListRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .HelpInfo help_list = 3;
  inline int help_list_size() const;
  inline void clear_help_list();
  static const int kHelpListFieldNumber = 3;
  inline const ::HelpInfo& help_list(int index) const;
  inline ::HelpInfo* mutable_help_list(int index);
  inline ::HelpInfo* add_help_list();
  inline const ::google::protobuf::RepeatedPtrField< ::HelpInfo >&
      help_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelpInfo >*
      mutable_help_list();

  // @@protoc_insertion_point(class_scope:GroupHelpListResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::HelpInfo > help_list_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupHelpListResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupHelpReq : public ::google::protobuf::Message {
 public:
  GroupHelpReq();
  virtual ~GroupHelpReq();

  GroupHelpReq(const GroupHelpReq& from);

  inline GroupHelpReq& operator=(const GroupHelpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupHelpReq& default_instance();

  void Swap(GroupHelpReq* other);

  // implements Message ----------------------------------------------

  GroupHelpReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupHelpReq& from);
  void MergeFrom(const GroupHelpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int32 id = 3;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::int32 value);
  inline void add_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id();

  // @@protoc_insertion_point(class_scope:GroupHelpReq)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupHelpReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupHelpResp : public ::google::protobuf::Message {
 public:
  GroupHelpResp();
  virtual ~GroupHelpResp();

  GroupHelpResp(const GroupHelpResp& from);

  inline GroupHelpResp& operator=(const GroupHelpResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupHelpResp& default_instance();

  void Swap(GroupHelpResp* other);

  // implements Message ----------------------------------------------

  GroupHelpResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupHelpResp& from);
  void MergeFrom(const GroupHelpResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupHelpResp_GroupHelpRet GroupHelpRet;
  static const GroupHelpRet OK = GroupHelpResp_GroupHelpRet_OK;
  static const GroupHelpRet FAIL = GroupHelpResp_GroupHelpRet_FAIL;
  static const GroupHelpRet HELP_TIME_MAX = GroupHelpResp_GroupHelpRet_HELP_TIME_MAX;
  static const GroupHelpRet NO_DATA = GroupHelpResp_GroupHelpRet_NO_DATA;
  static const GroupHelpRet NO_INFO_DATA = GroupHelpResp_GroupHelpRet_NO_INFO_DATA;
  static const GroupHelpRet NO_CD = GroupHelpResp_GroupHelpRet_NO_CD;
  static const GroupHelpRet REQ_DATA_ERROR = GroupHelpResp_GroupHelpRet_REQ_DATA_ERROR;
  static inline bool GroupHelpRet_IsValid(int value) {
    return GroupHelpResp_GroupHelpRet_IsValid(value);
  }
  static const GroupHelpRet GroupHelpRet_MIN =
    GroupHelpResp_GroupHelpRet_GroupHelpRet_MIN;
  static const GroupHelpRet GroupHelpRet_MAX =
    GroupHelpResp_GroupHelpRet_GroupHelpRet_MAX;
  static const int GroupHelpRet_ARRAYSIZE =
    GroupHelpResp_GroupHelpRet_GroupHelpRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupHelpRet_descriptor() {
    return GroupHelpResp_GroupHelpRet_descriptor();
  }
  static inline const ::std::string& GroupHelpRet_Name(GroupHelpRet value) {
    return GroupHelpResp_GroupHelpRet_Name(value);
  }
  static inline bool GroupHelpRet_Parse(const ::std::string& name,
      GroupHelpRet* value) {
    return GroupHelpResp_GroupHelpRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupHelpResp.GroupHelpRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupHelpResp_GroupHelpRet result() const;
  inline void set_result(::GroupHelpResp_GroupHelpRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .HelpInfo help_list = 3;
  inline int help_list_size() const;
  inline void clear_help_list();
  static const int kHelpListFieldNumber = 3;
  inline const ::HelpInfo& help_list(int index) const;
  inline ::HelpInfo* mutable_help_list(int index);
  inline ::HelpInfo* add_help_list();
  inline const ::google::protobuf::RepeatedPtrField< ::HelpInfo >&
      help_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelpInfo >*
      mutable_help_list();

  // @@protoc_insertion_point(class_scope:GroupHelpResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::HelpInfo > help_list_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupHelpResp* default_instance_;
};
// -------------------------------------------------------------------

class NewGroupUpdate : public ::google::protobuf::Message {
 public:
  NewGroupUpdate();
  virtual ~NewGroupUpdate();

  NewGroupUpdate(const NewGroupUpdate& from);

  inline NewGroupUpdate& operator=(const NewGroupUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewGroupUpdate& default_instance();

  void Swap(NewGroupUpdate* other);

  // implements Message ----------------------------------------------

  NewGroupUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewGroupUpdate& from);
  void MergeFrom(const NewGroupUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // @@protoc_insertion_point(class_scope:NewGroupUpdate)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sender_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static NewGroupUpdate* default_instance_;
};
// -------------------------------------------------------------------

class GroupInviteReq : public ::google::protobuf::Message {
 public:
  GroupInviteReq();
  virtual ~GroupInviteReq();

  GroupInviteReq(const GroupInviteReq& from);

  inline GroupInviteReq& operator=(const GroupInviteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInviteReq& default_instance();

  void Swap(GroupInviteReq* other);

  // implements Message ----------------------------------------------

  GroupInviteReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupInviteReq& from);
  void MergeFrom(const GroupInviteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string recver = 1;
  inline bool has_recver() const;
  inline void clear_recver();
  static const int kRecverFieldNumber = 1;
  inline const ::std::string& recver() const;
  inline void set_recver(const ::std::string& value);
  inline void set_recver(const char* value);
  inline void set_recver(const char* value, size_t size);
  inline ::std::string* mutable_recver();
  inline ::std::string* release_recver();
  inline void set_allocated_recver(::std::string* recver);

  // @@protoc_insertion_point(class_scope:GroupInviteReq)
 private:
  inline void set_has_recver();
  inline void clear_has_recver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* recver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupInviteReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupInviteResp : public ::google::protobuf::Message {
 public:
  GroupInviteResp();
  virtual ~GroupInviteResp();

  GroupInviteResp(const GroupInviteResp& from);

  inline GroupInviteResp& operator=(const GroupInviteResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInviteResp& default_instance();

  void Swap(GroupInviteResp* other);

  // implements Message ----------------------------------------------

  GroupInviteResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupInviteResp& from);
  void MergeFrom(const GroupInviteResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupInviteResp_GroupInviteRet GroupInviteRet;
  static const GroupInviteRet OK = GroupInviteResp_GroupInviteRet_OK;
  static const GroupInviteRet FAIL = GroupInviteResp_GroupInviteRet_FAIL;
  static const GroupInviteRet OTHER_BLACK = GroupInviteResp_GroupInviteRet_OTHER_BLACK;
  static const GroupInviteRet MY_BLACK = GroupInviteResp_GroupInviteRet_MY_BLACK;
  static const GroupInviteRet SENDED = GroupInviteResp_GroupInviteRet_SENDED;
  static const GroupInviteRet HAS_GROUP = GroupInviteResp_GroupInviteRet_HAS_GROUP;
  static const GroupInviteRet NO_POWER = GroupInviteResp_GroupInviteRet_NO_POWER;
  static const GroupInviteRet NO_OPEN = GroupInviteResp_GroupInviteRet_NO_OPEN;
  static inline bool GroupInviteRet_IsValid(int value) {
    return GroupInviteResp_GroupInviteRet_IsValid(value);
  }
  static const GroupInviteRet GroupInviteRet_MIN =
    GroupInviteResp_GroupInviteRet_GroupInviteRet_MIN;
  static const GroupInviteRet GroupInviteRet_MAX =
    GroupInviteResp_GroupInviteRet_GroupInviteRet_MAX;
  static const int GroupInviteRet_ARRAYSIZE =
    GroupInviteResp_GroupInviteRet_GroupInviteRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupInviteRet_descriptor() {
    return GroupInviteResp_GroupInviteRet_descriptor();
  }
  static inline const ::std::string& GroupInviteRet_Name(GroupInviteRet value) {
    return GroupInviteResp_GroupInviteRet_Name(value);
  }
  static inline bool GroupInviteRet_Parse(const ::std::string& name,
      GroupInviteRet* value) {
    return GroupInviteResp_GroupInviteRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupInviteResp.GroupInviteRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupInviteResp_GroupInviteRet result() const;
  inline void set_result(::GroupInviteResp_GroupInviteRet value);

  // @@protoc_insertion_point(class_scope:GroupInviteResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupInviteResp* default_instance_;
};
// -------------------------------------------------------------------

class GroupWorshipReq : public ::google::protobuf::Message {
 public:
  GroupWorshipReq();
  virtual ~GroupWorshipReq();

  GroupWorshipReq(const GroupWorshipReq& from);

  inline GroupWorshipReq& operator=(const GroupWorshipReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupWorshipReq& default_instance();

  void Swap(GroupWorshipReq* other);

  // implements Message ----------------------------------------------

  GroupWorshipReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupWorshipReq& from);
  void MergeFrom(const GroupWorshipReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupWorshipReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupWorshipReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupWorshipResp : public ::google::protobuf::Message {
 public:
  GroupWorshipResp();
  virtual ~GroupWorshipResp();

  GroupWorshipResp(const GroupWorshipResp& from);

  inline GroupWorshipResp& operator=(const GroupWorshipResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupWorshipResp& default_instance();

  void Swap(GroupWorshipResp* other);

  // implements Message ----------------------------------------------

  GroupWorshipResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupWorshipResp& from);
  void MergeFrom(const GroupWorshipResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GroupWorshipResp_GroupWorshipRet GroupWorshipRet;
  static const GroupWorshipRet OK = GroupWorshipResp_GroupWorshipRet_OK;
  static const GroupWorshipRet FAIL = GroupWorshipResp_GroupWorshipRet_FAIL;
  static const GroupWorshipRet ALREADY = GroupWorshipResp_GroupWorshipRet_ALREADY;
  static const GroupWorshipRet NO_CONF = GroupWorshipResp_GroupWorshipRet_NO_CONF;
  static const GroupWorshipRet NO_GROUP = GroupWorshipResp_GroupWorshipRet_NO_GROUP;
  static const GroupWorshipRet NO_RES = GroupWorshipResp_GroupWorshipRet_NO_RES;
  static const GroupWorshipRet GETTED = GroupWorshipResp_GroupWorshipRet_GETTED;
  static const GroupWorshipRet LOW_POINT = GroupWorshipResp_GroupWorshipRet_LOW_POINT;
  static const GroupWorshipRet NO_WORSHIP = GroupWorshipResp_GroupWorshipRet_NO_WORSHIP;
  static inline bool GroupWorshipRet_IsValid(int value) {
    return GroupWorshipResp_GroupWorshipRet_IsValid(value);
  }
  static const GroupWorshipRet GroupWorshipRet_MIN =
    GroupWorshipResp_GroupWorshipRet_GroupWorshipRet_MIN;
  static const GroupWorshipRet GroupWorshipRet_MAX =
    GroupWorshipResp_GroupWorshipRet_GroupWorshipRet_MAX;
  static const int GroupWorshipRet_ARRAYSIZE =
    GroupWorshipResp_GroupWorshipRet_GroupWorshipRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupWorshipRet_descriptor() {
    return GroupWorshipResp_GroupWorshipRet_descriptor();
  }
  static inline const ::std::string& GroupWorshipRet_Name(GroupWorshipRet value) {
    return GroupWorshipResp_GroupWorshipRet_Name(value);
  }
  static inline bool GroupWorshipRet_Parse(const ::std::string& name,
      GroupWorshipRet* value) {
    return GroupWorshipResp_GroupWorshipRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GroupWorshipResp.GroupWorshipRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GroupWorshipResp_GroupWorshipRet result() const;
  inline void set_result(::GroupWorshipResp_GroupWorshipRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .GroupWorshipReq req = 3;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 3;
  inline const ::GroupWorshipReq& req() const;
  inline ::GroupWorshipReq* mutable_req();
  inline ::GroupWorshipReq* release_req();
  inline void set_allocated_req(::GroupWorshipReq* req);

  // @@protoc_insertion_point(class_scope:GroupWorshipResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::GroupWorshipReq* req_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdGroup_2eproto();
  friend void protobuf_AssignDesc_CmdGroup_2eproto();
  friend void protobuf_ShutdownFile_CmdGroup_2eproto();

  void InitAsDefaultInstance();
  static GroupWorshipResp* default_instance_;
};
// ===================================================================


// ===================================================================

// CreateGroupReq

// optional string nickname = 1;
inline bool CreateGroupReq::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateGroupReq::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateGroupReq::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateGroupReq::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& CreateGroupReq::nickname() const {
  return *nickname_;
}
inline void CreateGroupReq::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void CreateGroupReq::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void CreateGroupReq::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateGroupReq::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* CreateGroupReq::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateGroupReq::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 icon_id = 2;
inline bool CreateGroupReq::has_icon_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateGroupReq::set_has_icon_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateGroupReq::clear_has_icon_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateGroupReq::clear_icon_id() {
  icon_id_ = 0;
  clear_has_icon_id();
}
inline ::google::protobuf::int32 CreateGroupReq::icon_id() const {
  return icon_id_;
}
inline void CreateGroupReq::set_icon_id(::google::protobuf::int32 value) {
  set_has_icon_id();
  icon_id_ = value;
}

// -------------------------------------------------------------------

// CreateGroupResp

// required int32 result = 1;
inline bool CreateGroupResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateGroupResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateGroupResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateGroupResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CreateGroupResp::result() const {
  return result_;
}
inline void CreateGroupResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool CreateGroupResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateGroupResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateGroupResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateGroupResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& CreateGroupResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* CreateGroupResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* CreateGroupResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void CreateGroupResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GetGroupReq

// required string groupid = 1;
inline bool GetGroupReq::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGroupReq::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGroupReq::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGroupReq::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& GetGroupReq::groupid() const {
  return *groupid_;
}
inline void GetGroupReq::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GetGroupReq::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GetGroupReq::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetGroupReq::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* GetGroupReq::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetGroupReq::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetGroupResp

// required int32 result = 1;
inline bool GetGroupResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGroupResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGroupResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGroupResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GetGroupResp::result() const {
  return result_;
}
inline void GetGroupResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GetGroupResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetGroupResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetGroupResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetGroupResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GetGroupResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GetGroupResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GetGroupResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GetGroupResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .OtherGroupInfo other_group_info = 3;
inline bool GetGroupResp::has_other_group_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetGroupResp::set_has_other_group_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetGroupResp::clear_has_other_group_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetGroupResp::clear_other_group_info() {
  if (other_group_info_ != NULL) other_group_info_->::OtherGroupInfo::Clear();
  clear_has_other_group_info();
}
inline const ::OtherGroupInfo& GetGroupResp::other_group_info() const {
  return other_group_info_ != NULL ? *other_group_info_ : *default_instance_->other_group_info_;
}
inline ::OtherGroupInfo* GetGroupResp::mutable_other_group_info() {
  set_has_other_group_info();
  if (other_group_info_ == NULL) other_group_info_ = new ::OtherGroupInfo;
  return other_group_info_;
}
inline ::OtherGroupInfo* GetGroupResp::release_other_group_info() {
  clear_has_other_group_info();
  ::OtherGroupInfo* temp = other_group_info_;
  other_group_info_ = NULL;
  return temp;
}
inline void GetGroupResp::set_allocated_other_group_info(::OtherGroupInfo* other_group_info) {
  delete other_group_info_;
  other_group_info_ = other_group_info;
  if (other_group_info) {
    set_has_other_group_info();
  } else {
    clear_has_other_group_info();
  }
}

// -------------------------------------------------------------------

// GroupUpdate_UserUpdate

// optional string user_name = 1;
inline bool GroupUpdate_UserUpdate::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdate_UserUpdate::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdate_UserUpdate::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdate_UserUpdate::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& GroupUpdate_UserUpdate::user_name() const {
  return *user_name_;
}
inline void GroupUpdate_UserUpdate::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupUpdate_UserUpdate::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupUpdate_UserUpdate::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupUpdate_UserUpdate::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* GroupUpdate_UserUpdate::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupUpdate_UserUpdate::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .UserSync user_sync = 2;
inline bool GroupUpdate_UserUpdate::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUpdate_UserUpdate::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUpdate_UserUpdate::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUpdate_UserUpdate::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupUpdate_UserUpdate::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupUpdate_UserUpdate::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupUpdate_UserUpdate::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupUpdate_UserUpdate::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .PlanetUser planet_user = 3;
inline bool GroupUpdate_UserUpdate::has_planet_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUpdate_UserUpdate::set_has_planet_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUpdate_UserUpdate::clear_has_planet_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUpdate_UserUpdate::clear_planet_user() {
  if (planet_user_ != NULL) planet_user_->::PlanetUser::Clear();
  clear_has_planet_user();
}
inline const ::PlanetUser& GroupUpdate_UserUpdate::planet_user() const {
  return planet_user_ != NULL ? *planet_user_ : *default_instance_->planet_user_;
}
inline ::PlanetUser* GroupUpdate_UserUpdate::mutable_planet_user() {
  set_has_planet_user();
  if (planet_user_ == NULL) planet_user_ = new ::PlanetUser;
  return planet_user_;
}
inline ::PlanetUser* GroupUpdate_UserUpdate::release_planet_user() {
  clear_has_planet_user();
  ::PlanetUser* temp = planet_user_;
  planet_user_ = NULL;
  return temp;
}
inline void GroupUpdate_UserUpdate::set_allocated_planet_user(::PlanetUser* planet_user) {
  delete planet_user_;
  planet_user_ = planet_user;
  if (planet_user) {
    set_has_planet_user();
  } else {
    clear_has_planet_user();
  }
}

// -------------------------------------------------------------------

// GroupUpdate

// optional .GroupMainData group_main = 1;
inline bool GroupUpdate::has_group_main() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdate::set_has_group_main() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdate::clear_has_group_main() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdate::clear_group_main() {
  if (group_main_ != NULL) group_main_->::GroupMainData::Clear();
  clear_has_group_main();
}
inline const ::GroupMainData& GroupUpdate::group_main() const {
  return group_main_ != NULL ? *group_main_ : *default_instance_->group_main_;
}
inline ::GroupMainData* GroupUpdate::mutable_group_main() {
  set_has_group_main();
  if (group_main_ == NULL) group_main_ = new ::GroupMainData;
  return group_main_;
}
inline ::GroupMainData* GroupUpdate::release_group_main() {
  clear_has_group_main();
  ::GroupMainData* temp = group_main_;
  group_main_ = NULL;
  return temp;
}
inline void GroupUpdate::set_allocated_group_main(::GroupMainData* group_main) {
  delete group_main_;
  group_main_ = group_main;
  if (group_main) {
    set_has_group_main();
  } else {
    clear_has_group_main();
  }
}

// optional string user_name = 2;
inline bool GroupUpdate::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUpdate::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUpdate::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUpdate::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& GroupUpdate::user_name() const {
  return *user_name_;
}
inline void GroupUpdate::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupUpdate::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupUpdate::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupUpdate::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* GroupUpdate::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupUpdate::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .GroupUpdate.UserUpdate user_update_list = 3;
inline int GroupUpdate::user_update_list_size() const {
  return user_update_list_.size();
}
inline void GroupUpdate::clear_user_update_list() {
  user_update_list_.Clear();
}
inline const ::GroupUpdate_UserUpdate& GroupUpdate::user_update_list(int index) const {
  return user_update_list_.Get(index);
}
inline ::GroupUpdate_UserUpdate* GroupUpdate::mutable_user_update_list(int index) {
  return user_update_list_.Mutable(index);
}
inline ::GroupUpdate_UserUpdate* GroupUpdate::add_user_update_list() {
  return user_update_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GroupUpdate_UserUpdate >&
GroupUpdate::user_update_list() const {
  return user_update_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::GroupUpdate_UserUpdate >*
GroupUpdate::mutable_user_update_list() {
  return &user_update_list_;
}

// -------------------------------------------------------------------

// GroupJoinConditionReq

// required bool needAllow = 1;
inline bool GroupJoinConditionReq::has_needallow() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupJoinConditionReq::set_has_needallow() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupJoinConditionReq::clear_has_needallow() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupJoinConditionReq::clear_needallow() {
  needallow_ = false;
  clear_has_needallow();
}
inline bool GroupJoinConditionReq::needallow() const {
  return needallow_;
}
inline void GroupJoinConditionReq::set_needallow(bool value) {
  set_has_needallow();
  needallow_ = value;
}

// optional int32 level = 2;
inline bool GroupJoinConditionReq::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupJoinConditionReq::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupJoinConditionReq::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupJoinConditionReq::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GroupJoinConditionReq::level() const {
  return level_;
}
inline void GroupJoinConditionReq::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 power = 3;
inline bool GroupJoinConditionReq::has_power() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupJoinConditionReq::set_has_power() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupJoinConditionReq::clear_has_power() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupJoinConditionReq::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 GroupJoinConditionReq::power() const {
  return power_;
}
inline void GroupJoinConditionReq::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// -------------------------------------------------------------------

// GroupJoinConditionResp

// required int32 result = 1;
inline bool GroupJoinConditionResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupJoinConditionResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupJoinConditionResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupJoinConditionResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GroupJoinConditionResp::result() const {
  return result_;
}
inline void GroupJoinConditionResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupJoinConditionResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupJoinConditionResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupJoinConditionResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupJoinConditionResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupJoinConditionResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupJoinConditionResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupJoinConditionResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupJoinConditionResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupJoinReq

// required string groupid = 1;
inline bool GroupJoinReq::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupJoinReq::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupJoinReq::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupJoinReq::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& GroupJoinReq::groupid() const {
  return *groupid_;
}
inline void GroupJoinReq::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GroupJoinReq::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GroupJoinReq::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupJoinReq::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* GroupJoinReq::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupJoinReq::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 2;
inline bool GroupJoinReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupJoinReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupJoinReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupJoinReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GroupJoinReq::type() const {
  return type_;
}
inline void GroupJoinReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// GroupJoinResp

// required .GroupJoinResp.GroupJoinRet result = 1;
inline bool GroupJoinResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupJoinResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupJoinResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupJoinResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupJoinResp_GroupJoinRet GroupJoinResp::result() const {
  return static_cast< ::GroupJoinResp_GroupJoinRet >(result_);
}
inline void GroupJoinResp::set_result(::GroupJoinResp_GroupJoinRet value) {
  assert(::GroupJoinResp_GroupJoinRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupJoinResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupJoinResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupJoinResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupJoinResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupJoinResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupJoinResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupJoinResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupJoinResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupAllowReq

// required string username = 1;
inline bool GroupAllowReq::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupAllowReq::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupAllowReq::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupAllowReq::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& GroupAllowReq::username() const {
  return *username_;
}
inline void GroupAllowReq::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GroupAllowReq::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GroupAllowReq::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupAllowReq::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* GroupAllowReq::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupAllowReq::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 2;
inline bool GroupAllowReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupAllowReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupAllowReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupAllowReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GroupAllowReq::type() const {
  return type_;
}
inline void GroupAllowReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// GroupAllowResp

// required .GroupAllowResp.GroupAllowRet result = 1;
inline bool GroupAllowResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupAllowResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupAllowResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupAllowResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupAllowResp_GroupAllowRet GroupAllowResp::result() const {
  return static_cast< ::GroupAllowResp_GroupAllowRet >(result_);
}
inline void GroupAllowResp::set_result(::GroupAllowResp_GroupAllowRet value) {
  assert(::GroupAllowResp_GroupAllowRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupAllowResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupAllowResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupAllowResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupAllowResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupAllowResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupAllowResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupAllowResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupAllowResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupExitGroupReq

// required int32 result = 1;
inline bool GroupExitGroupReq::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupExitGroupReq::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupExitGroupReq::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupExitGroupReq::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GroupExitGroupReq::result() const {
  return result_;
}
inline void GroupExitGroupReq::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// GroupExitGroupResp

// required int32 result = 1;
inline bool GroupExitGroupResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupExitGroupResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupExitGroupResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupExitGroupResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GroupExitGroupResp::result() const {
  return result_;
}
inline void GroupExitGroupResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupExitGroupResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupExitGroupResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupExitGroupResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupExitGroupResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupExitGroupResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupExitGroupResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupExitGroupResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupExitGroupResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupKickReq

// required string user_name = 1;
inline bool GroupKickReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupKickReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupKickReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupKickReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& GroupKickReq::user_name() const {
  return *user_name_;
}
inline void GroupKickReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupKickReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupKickReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupKickReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* GroupKickReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupKickReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupKickResp

// required .GroupKickResp.GroupKickRet result = 1;
inline bool GroupKickResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupKickResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupKickResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupKickResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupKickResp_GroupKickRet GroupKickResp::result() const {
  return static_cast< ::GroupKickResp_GroupKickRet >(result_);
}
inline void GroupKickResp::set_result(::GroupKickResp_GroupKickRet value) {
  assert(::GroupKickResp_GroupKickRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupKickResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupKickResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupKickResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupKickResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupKickResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupKickResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupKickResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupKickResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .GroupKickReq req = 3;
inline bool GroupKickResp::has_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupKickResp::set_has_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupKickResp::clear_has_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupKickResp::clear_req() {
  if (req_ != NULL) req_->::GroupKickReq::Clear();
  clear_has_req();
}
inline const ::GroupKickReq& GroupKickResp::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::GroupKickReq* GroupKickResp::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::GroupKickReq;
  return req_;
}
inline ::GroupKickReq* GroupKickResp::release_req() {
  clear_has_req();
  ::GroupKickReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void GroupKickResp::set_allocated_req(::GroupKickReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// -------------------------------------------------------------------

// GroupBroadcastReq

// optional string blurb = 1;
inline bool GroupBroadcastReq::has_blurb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupBroadcastReq::set_has_blurb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupBroadcastReq::clear_has_blurb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupBroadcastReq::clear_blurb() {
  if (blurb_ != &::google::protobuf::internal::kEmptyString) {
    blurb_->clear();
  }
  clear_has_blurb();
}
inline const ::std::string& GroupBroadcastReq::blurb() const {
  return *blurb_;
}
inline void GroupBroadcastReq::set_blurb(const ::std::string& value) {
  set_has_blurb();
  if (blurb_ == &::google::protobuf::internal::kEmptyString) {
    blurb_ = new ::std::string;
  }
  blurb_->assign(value);
}
inline void GroupBroadcastReq::set_blurb(const char* value) {
  set_has_blurb();
  if (blurb_ == &::google::protobuf::internal::kEmptyString) {
    blurb_ = new ::std::string;
  }
  blurb_->assign(value);
}
inline void GroupBroadcastReq::set_blurb(const char* value, size_t size) {
  set_has_blurb();
  if (blurb_ == &::google::protobuf::internal::kEmptyString) {
    blurb_ = new ::std::string;
  }
  blurb_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupBroadcastReq::mutable_blurb() {
  set_has_blurb();
  if (blurb_ == &::google::protobuf::internal::kEmptyString) {
    blurb_ = new ::std::string;
  }
  return blurb_;
}
inline ::std::string* GroupBroadcastReq::release_blurb() {
  clear_has_blurb();
  if (blurb_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = blurb_;
    blurb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupBroadcastReq::set_allocated_blurb(::std::string* blurb) {
  if (blurb_ != &::google::protobuf::internal::kEmptyString) {
    delete blurb_;
  }
  if (blurb) {
    set_has_blurb();
    blurb_ = blurb;
  } else {
    clear_has_blurb();
    blurb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string broadcast = 2;
inline bool GroupBroadcastReq::has_broadcast() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupBroadcastReq::set_has_broadcast() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupBroadcastReq::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupBroadcastReq::clear_broadcast() {
  if (broadcast_ != &::google::protobuf::internal::kEmptyString) {
    broadcast_->clear();
  }
  clear_has_broadcast();
}
inline const ::std::string& GroupBroadcastReq::broadcast() const {
  return *broadcast_;
}
inline void GroupBroadcastReq::set_broadcast(const ::std::string& value) {
  set_has_broadcast();
  if (broadcast_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_ = new ::std::string;
  }
  broadcast_->assign(value);
}
inline void GroupBroadcastReq::set_broadcast(const char* value) {
  set_has_broadcast();
  if (broadcast_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_ = new ::std::string;
  }
  broadcast_->assign(value);
}
inline void GroupBroadcastReq::set_broadcast(const char* value, size_t size) {
  set_has_broadcast();
  if (broadcast_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_ = new ::std::string;
  }
  broadcast_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupBroadcastReq::mutable_broadcast() {
  set_has_broadcast();
  if (broadcast_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_ = new ::std::string;
  }
  return broadcast_;
}
inline ::std::string* GroupBroadcastReq::release_broadcast() {
  clear_has_broadcast();
  if (broadcast_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = broadcast_;
    broadcast_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupBroadcastReq::set_allocated_broadcast(::std::string* broadcast) {
  if (broadcast_ != &::google::protobuf::internal::kEmptyString) {
    delete broadcast_;
  }
  if (broadcast) {
    set_has_broadcast();
    broadcast_ = broadcast;
  } else {
    clear_has_broadcast();
    broadcast_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupBroadcastResp

// required .GroupBroadcastResp.GroupBroadcastRet result = 1;
inline bool GroupBroadcastResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupBroadcastResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupBroadcastResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupBroadcastResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp::result() const {
  return static_cast< ::GroupBroadcastResp_GroupBroadcastRet >(result_);
}
inline void GroupBroadcastResp::set_result(::GroupBroadcastResp_GroupBroadcastRet value) {
  assert(::GroupBroadcastResp_GroupBroadcastRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupBroadcastResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupBroadcastResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupBroadcastResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupBroadcastResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupBroadcastResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupBroadcastResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupBroadcastResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupBroadcastResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupJobReq

// required string user_name = 1;
inline bool GroupJobReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupJobReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupJobReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupJobReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& GroupJobReq::user_name() const {
  return *user_name_;
}
inline void GroupJobReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupJobReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupJobReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupJobReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* GroupJobReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupJobReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 job = 2;
inline bool GroupJobReq::has_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupJobReq::set_has_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupJobReq::clear_has_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupJobReq::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 GroupJobReq::job() const {
  return job_;
}
inline void GroupJobReq::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// -------------------------------------------------------------------

// GroupJobResp

// required .GroupJobResp.GroupJobRet result = 1;
inline bool GroupJobResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupJobResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupJobResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupJobResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupJobResp_GroupJobRet GroupJobResp::result() const {
  return static_cast< ::GroupJobResp_GroupJobRet >(result_);
}
inline void GroupJobResp::set_result(::GroupJobResp_GroupJobRet value) {
  assert(::GroupJobResp_GroupJobRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupJobResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupJobResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupJobResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupJobResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupJobResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupJobResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupJobResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupJobResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupDisbandResp

// required .GroupDisbandResp.GroupDisbandRet result = 1;
inline bool GroupDisbandResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupDisbandResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupDisbandResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupDisbandResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupDisbandResp_GroupDisbandRet GroupDisbandResp::result() const {
  return static_cast< ::GroupDisbandResp_GroupDisbandRet >(result_);
}
inline void GroupDisbandResp::set_result(::GroupDisbandResp_GroupDisbandRet value) {
  assert(::GroupDisbandResp_GroupDisbandRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupDisbandResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupDisbandResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupDisbandResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupDisbandResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupDisbandResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupDisbandResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupDisbandResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupDisbandResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupSearchReq

// optional string groupid = 1;
inline bool GroupSearchReq::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSearchReq::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSearchReq::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSearchReq::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& GroupSearchReq::groupid() const {
  return *groupid_;
}
inline void GroupSearchReq::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GroupSearchReq::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GroupSearchReq::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSearchReq::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* GroupSearchReq::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupSearchReq::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 page = 2;
inline bool GroupSearchReq::has_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupSearchReq::set_has_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupSearchReq::clear_has_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupSearchReq::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 GroupSearchReq::page() const {
  return page_;
}
inline void GroupSearchReq::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// optional string group_name = 3;
inline bool GroupSearchReq::has_group_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupSearchReq::set_has_group_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupSearchReq::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupSearchReq::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupSearchReq::group_name() const {
  return *group_name_;
}
inline void GroupSearchReq::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupSearchReq::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupSearchReq::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSearchReq::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* GroupSearchReq::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupSearchReq::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupSearchResp

// required int32 result = 1;
inline bool GroupSearchResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSearchResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSearchResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSearchResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GroupSearchResp::result() const {
  return result_;
}
inline void GroupSearchResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupSearchResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupSearchResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupSearchResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupSearchResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupSearchResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupSearchResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupSearchResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupSearchResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .GroupMainData group_list = 3;
inline int GroupSearchResp::group_list_size() const {
  return group_list_.size();
}
inline void GroupSearchResp::clear_group_list() {
  group_list_.Clear();
}
inline const ::GroupMainData& GroupSearchResp::group_list(int index) const {
  return group_list_.Get(index);
}
inline ::GroupMainData* GroupSearchResp::mutable_group_list(int index) {
  return group_list_.Mutable(index);
}
inline ::GroupMainData* GroupSearchResp::add_group_list() {
  return group_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GroupMainData >&
GroupSearchResp::group_list() const {
  return group_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::GroupMainData >*
GroupSearchResp::mutable_group_list() {
  return &group_list_;
}

// optional int32 total_page = 4;
inline bool GroupSearchResp::has_total_page() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupSearchResp::set_has_total_page() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupSearchResp::clear_has_total_page() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupSearchResp::clear_total_page() {
  total_page_ = 0;
  clear_has_total_page();
}
inline ::google::protobuf::int32 GroupSearchResp::total_page() const {
  return total_page_;
}
inline void GroupSearchResp::set_total_page(::google::protobuf::int32 value) {
  set_has_total_page();
  total_page_ = value;
}

// -------------------------------------------------------------------

// GroupContributeReq

// required int32 type = 1;
inline bool GroupContributeReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupContributeReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupContributeReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupContributeReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GroupContributeReq::type() const {
  return type_;
}
inline void GroupContributeReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 tech_id = 2;
inline bool GroupContributeReq::has_tech_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupContributeReq::set_has_tech_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupContributeReq::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupContributeReq::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 GroupContributeReq::tech_id() const {
  return tech_id_;
}
inline void GroupContributeReq::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// -------------------------------------------------------------------

// GroupContributeResp

// required int32 result = 1;
inline bool GroupContributeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupContributeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupContributeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupContributeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GroupContributeResp::result() const {
  return result_;
}
inline void GroupContributeResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupContributeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupContributeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupContributeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupContributeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupContributeResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupContributeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupContributeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupContributeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupContributeCDResp

// required int32 result = 1;
inline bool GroupContributeCDResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupContributeCDResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupContributeCDResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupContributeCDResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GroupContributeCDResp::result() const {
  return result_;
}
inline void GroupContributeCDResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupContributeCDResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupContributeCDResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupContributeCDResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupContributeCDResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupContributeCDResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupContributeCDResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupContributeCDResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupContributeCDResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupTechLevelupReq

// required int32 tech_id = 1;
inline bool GroupTechLevelupReq::has_tech_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupTechLevelupReq::set_has_tech_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupTechLevelupReq::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupTechLevelupReq::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 GroupTechLevelupReq::tech_id() const {
  return tech_id_;
}
inline void GroupTechLevelupReq::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// -------------------------------------------------------------------

// GroupTechLevelupResp

// required int32 result = 1;
inline bool GroupTechLevelupResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupTechLevelupResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupTechLevelupResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupTechLevelupResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GroupTechLevelupResp::result() const {
  return result_;
}
inline void GroupTechLevelupResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupTechLevelupResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupTechLevelupResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupTechLevelupResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupTechLevelupResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupTechLevelupResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupTechLevelupResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupTechLevelupResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupTechLevelupResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupGetTechReq

// required int32 tech_id = 1;
inline bool GroupGetTechReq::has_tech_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupGetTechReq::set_has_tech_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupGetTechReq::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupGetTechReq::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 GroupGetTechReq::tech_id() const {
  return tech_id_;
}
inline void GroupGetTechReq::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// -------------------------------------------------------------------

// GroupGetTechResp

// required int32 result = 1;
inline bool GroupGetTechResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupGetTechResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupGetTechResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupGetTechResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GroupGetTechResp::result() const {
  return result_;
}
inline void GroupGetTechResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupGetTechResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupGetTechResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupGetTechResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupGetTechResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupGetTechResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupGetTechResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupGetTechResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupGetTechResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .GroupTechnology group_tech = 3;
inline bool GroupGetTechResp::has_group_tech() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupGetTechResp::set_has_group_tech() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupGetTechResp::clear_has_group_tech() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupGetTechResp::clear_group_tech() {
  if (group_tech_ != NULL) group_tech_->::GroupTechnology::Clear();
  clear_has_group_tech();
}
inline const ::GroupTechnology& GroupGetTechResp::group_tech() const {
  return group_tech_ != NULL ? *group_tech_ : *default_instance_->group_tech_;
}
inline ::GroupTechnology* GroupGetTechResp::mutable_group_tech() {
  set_has_group_tech();
  if (group_tech_ == NULL) group_tech_ = new ::GroupTechnology;
  return group_tech_;
}
inline ::GroupTechnology* GroupGetTechResp::release_group_tech() {
  clear_has_group_tech();
  ::GroupTechnology* temp = group_tech_;
  group_tech_ = NULL;
  return temp;
}
inline void GroupGetTechResp::set_allocated_group_tech(::GroupTechnology* group_tech) {
  delete group_tech_;
  group_tech_ = group_tech;
  if (group_tech) {
    set_has_group_tech();
  } else {
    clear_has_group_tech();
  }
}

// -------------------------------------------------------------------

// GroupLevelupResp

// required int32 result = 1;
inline bool GroupLevelupResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupLevelupResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupLevelupResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupLevelupResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GroupLevelupResp::result() const {
  return result_;
}
inline void GroupLevelupResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupLevelupResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupLevelupResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupLevelupResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupLevelupResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupLevelupResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupLevelupResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupLevelupResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupLevelupResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupPVEGetInfoReq

// required int32 group_boss_id = 1;
inline bool GroupPVEGetInfoReq::has_group_boss_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVEGetInfoReq::set_has_group_boss_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVEGetInfoReq::clear_has_group_boss_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVEGetInfoReq::clear_group_boss_id() {
  group_boss_id_ = 0;
  clear_has_group_boss_id();
}
inline ::google::protobuf::int32 GroupPVEGetInfoReq::group_boss_id() const {
  return group_boss_id_;
}
inline void GroupPVEGetInfoReq::set_group_boss_id(::google::protobuf::int32 value) {
  set_has_group_boss_id();
  group_boss_id_ = value;
}

// -------------------------------------------------------------------

// GroupPVEGetInfoResp

// required .GroupPVEGetInfoResp.GroupPVEGetInfoRet result = 1;
inline bool GroupPVEGetInfoResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVEGetInfoResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVEGetInfoResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVEGetInfoResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupPVEGetInfoResp_GroupPVEGetInfoRet GroupPVEGetInfoResp::result() const {
  return static_cast< ::GroupPVEGetInfoResp_GroupPVEGetInfoRet >(result_);
}
inline void GroupPVEGetInfoResp::set_result(::GroupPVEGetInfoResp_GroupPVEGetInfoRet value) {
  assert(::GroupPVEGetInfoResp_GroupPVEGetInfoRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupPVEGetInfoResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPVEGetInfoResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPVEGetInfoResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPVEGetInfoResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupPVEGetInfoResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupPVEGetInfoResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupPVEGetInfoResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupPVEGetInfoResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .GroupPVECheckpoint info = 3;
inline bool GroupPVEGetInfoResp::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupPVEGetInfoResp::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupPVEGetInfoResp::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupPVEGetInfoResp::clear_info() {
  if (info_ != NULL) info_->::GroupPVECheckpoint::Clear();
  clear_has_info();
}
inline const ::GroupPVECheckpoint& GroupPVEGetInfoResp::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::GroupPVECheckpoint* GroupPVEGetInfoResp::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::GroupPVECheckpoint;
  return info_;
}
inline ::GroupPVECheckpoint* GroupPVEGetInfoResp::release_info() {
  clear_has_info();
  ::GroupPVECheckpoint* temp = info_;
  info_ = NULL;
  return temp;
}
inline void GroupPVEGetInfoResp::set_allocated_info(::GroupPVECheckpoint* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// GroupPVEReq

// required int32 group_boss_id = 1;
inline bool GroupPVEReq::has_group_boss_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVEReq::set_has_group_boss_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVEReq::clear_has_group_boss_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVEReq::clear_group_boss_id() {
  group_boss_id_ = 0;
  clear_has_group_boss_id();
}
inline ::google::protobuf::int32 GroupPVEReq::group_boss_id() const {
  return group_boss_id_;
}
inline void GroupPVEReq::set_group_boss_id(::google::protobuf::int32 value) {
  set_has_group_boss_id();
  group_boss_id_ = value;
}

// -------------------------------------------------------------------

// GroupPVEResp

// required .GroupPVEResp.GroupPVERet result = 1;
inline bool GroupPVEResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVEResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVEResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVEResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupPVEResp_GroupPVERet GroupPVEResp::result() const {
  return static_cast< ::GroupPVEResp_GroupPVERet >(result_);
}
inline void GroupPVEResp::set_result(::GroupPVEResp_GroupPVERet value) {
  assert(::GroupPVEResp_GroupPVERet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupPVEResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPVEResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPVEResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPVEResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupPVEResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupPVEResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupPVEResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupPVEResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .AirShip attack_list = 3;
inline int GroupPVEResp::attack_list_size() const {
  return attack_list_.size();
}
inline void GroupPVEResp::clear_attack_list() {
  attack_list_.Clear();
}
inline const ::AirShip& GroupPVEResp::attack_list(int index) const {
  return attack_list_.Get(index);
}
inline ::AirShip* GroupPVEResp::mutable_attack_list(int index) {
  return attack_list_.Mutable(index);
}
inline ::AirShip* GroupPVEResp::add_attack_list() {
  return attack_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
GroupPVEResp::attack_list() const {
  return attack_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
GroupPVEResp::mutable_attack_list() {
  return &attack_list_;
}

// repeated .AirShip hurter_list = 4;
inline int GroupPVEResp::hurter_list_size() const {
  return hurter_list_.size();
}
inline void GroupPVEResp::clear_hurter_list() {
  hurter_list_.Clear();
}
inline const ::AirShip& GroupPVEResp::hurter_list(int index) const {
  return hurter_list_.Get(index);
}
inline ::AirShip* GroupPVEResp::mutable_hurter_list(int index) {
  return hurter_list_.Mutable(index);
}
inline ::AirShip* GroupPVEResp::add_hurter_list() {
  return hurter_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
GroupPVEResp::hurter_list() const {
  return hurter_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
GroupPVEResp::mutable_hurter_list() {
  return &hurter_list_;
}

// repeated int32 hurter_hp_list = 5;
inline int GroupPVEResp::hurter_hp_list_size() const {
  return hurter_hp_list_.size();
}
inline void GroupPVEResp::clear_hurter_hp_list() {
  hurter_hp_list_.Clear();
}
inline ::google::protobuf::int32 GroupPVEResp::hurter_hp_list(int index) const {
  return hurter_hp_list_.Get(index);
}
inline void GroupPVEResp::set_hurter_hp_list(int index, ::google::protobuf::int32 value) {
  hurter_hp_list_.Set(index, value);
}
inline void GroupPVEResp::add_hurter_hp_list(::google::protobuf::int32 value) {
  hurter_hp_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GroupPVEResp::hurter_hp_list() const {
  return hurter_hp_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GroupPVEResp::mutable_hurter_hp_list() {
  return &hurter_hp_list_;
}

// optional int32 group_boss_id = 6;
inline bool GroupPVEResp::has_group_boss_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupPVEResp::set_has_group_boss_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupPVEResp::clear_has_group_boss_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupPVEResp::clear_group_boss_id() {
  group_boss_id_ = 0;
  clear_has_group_boss_id();
}
inline ::google::protobuf::int32 GroupPVEResp::group_boss_id() const {
  return group_boss_id_;
}
inline void GroupPVEResp::set_group_boss_id(::google::protobuf::int32 value) {
  set_has_group_boss_id();
  group_boss_id_ = value;
}

// -------------------------------------------------------------------

// GroupPVEOKReq

// required int32 group_boss_id = 1;
inline bool GroupPVEOKReq::has_group_boss_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVEOKReq::set_has_group_boss_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVEOKReq::clear_has_group_boss_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVEOKReq::clear_group_boss_id() {
  group_boss_id_ = 0;
  clear_has_group_boss_id();
}
inline ::google::protobuf::int32 GroupPVEOKReq::group_boss_id() const {
  return group_boss_id_;
}
inline void GroupPVEOKReq::set_group_boss_id(::google::protobuf::int32 value) {
  set_has_group_boss_id();
  group_boss_id_ = value;
}

// required int32 result = 2;
inline bool GroupPVEOKReq::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPVEOKReq::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPVEOKReq::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPVEOKReq::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GroupPVEOKReq::result() const {
  return result_;
}
inline void GroupPVEOKReq::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated int32 hurter_hp_list = 3;
inline int GroupPVEOKReq::hurter_hp_list_size() const {
  return hurter_hp_list_.size();
}
inline void GroupPVEOKReq::clear_hurter_hp_list() {
  hurter_hp_list_.Clear();
}
inline ::google::protobuf::int32 GroupPVEOKReq::hurter_hp_list(int index) const {
  return hurter_hp_list_.Get(index);
}
inline void GroupPVEOKReq::set_hurter_hp_list(int index, ::google::protobuf::int32 value) {
  hurter_hp_list_.Set(index, value);
}
inline void GroupPVEOKReq::add_hurter_hp_list(::google::protobuf::int32 value) {
  hurter_hp_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GroupPVEOKReq::hurter_hp_list() const {
  return hurter_hp_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GroupPVEOKReq::mutable_hurter_hp_list() {
  return &hurter_hp_list_;
}

// -------------------------------------------------------------------

// GroupPVEOKResp

// required .GroupPVEOKResp.GroupPVEOKRet result = 1;
inline bool GroupPVEOKResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVEOKResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVEOKResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVEOKResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp::result() const {
  return static_cast< ::GroupPVEOKResp_GroupPVEOKRet >(result_);
}
inline void GroupPVEOKResp::set_result(::GroupPVEOKResp_GroupPVEOKRet value) {
  assert(::GroupPVEOKResp_GroupPVEOKRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupPVEOKResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPVEOKResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPVEOKResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPVEOKResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupPVEOKResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupPVEOKResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupPVEOKResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupPVEOKResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GroupPVEAddTimsReq

// required int32 group_boss_id = 1;
inline bool GroupPVEAddTimsReq::has_group_boss_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVEAddTimsReq::set_has_group_boss_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVEAddTimsReq::clear_has_group_boss_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVEAddTimsReq::clear_group_boss_id() {
  group_boss_id_ = 0;
  clear_has_group_boss_id();
}
inline ::google::protobuf::int32 GroupPVEAddTimsReq::group_boss_id() const {
  return group_boss_id_;
}
inline void GroupPVEAddTimsReq::set_group_boss_id(::google::protobuf::int32 value) {
  set_has_group_boss_id();
  group_boss_id_ = value;
}

// required int32 times = 2;
inline bool GroupPVEAddTimsReq::has_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPVEAddTimsReq::set_has_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPVEAddTimsReq::clear_has_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPVEAddTimsReq::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 GroupPVEAddTimsReq::times() const {
  return times_;
}
inline void GroupPVEAddTimsReq::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// -------------------------------------------------------------------

// GroupPVEAddTimsResp

// required .GroupPVEAddTimsResp.GroupPVEAddTimsRet result = 1;
inline bool GroupPVEAddTimsResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVEAddTimsResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVEAddTimsResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVEAddTimsResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp::result() const {
  return static_cast< ::GroupPVEAddTimsResp_GroupPVEAddTimsRet >(result_);
}
inline void GroupPVEAddTimsResp::set_result(::GroupPVEAddTimsResp_GroupPVEAddTimsRet value) {
  assert(::GroupPVEAddTimsResp_GroupPVEAddTimsRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupPVEAddTimsResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPVEAddTimsResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPVEAddTimsResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPVEAddTimsResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupPVEAddTimsResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupPVEAddTimsResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupPVEAddTimsResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupPVEAddTimsResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .GroupPVEAddTimsReq req = 3;
inline bool GroupPVEAddTimsResp::has_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupPVEAddTimsResp::set_has_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupPVEAddTimsResp::clear_has_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupPVEAddTimsResp::clear_req() {
  if (req_ != NULL) req_->::GroupPVEAddTimsReq::Clear();
  clear_has_req();
}
inline const ::GroupPVEAddTimsReq& GroupPVEAddTimsResp::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::GroupPVEAddTimsReq* GroupPVEAddTimsResp::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::GroupPVEAddTimsReq;
  return req_;
}
inline ::GroupPVEAddTimsReq* GroupPVEAddTimsResp::release_req() {
  clear_has_req();
  ::GroupPVEAddTimsReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void GroupPVEAddTimsResp::set_allocated_req(::GroupPVEAddTimsReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// -------------------------------------------------------------------

// GroupPVERewardReq

// required int32 group_boss_id = 1;
inline bool GroupPVERewardReq::has_group_boss_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVERewardReq::set_has_group_boss_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVERewardReq::clear_has_group_boss_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVERewardReq::clear_group_boss_id() {
  group_boss_id_ = 0;
  clear_has_group_boss_id();
}
inline ::google::protobuf::int32 GroupPVERewardReq::group_boss_id() const {
  return group_boss_id_;
}
inline void GroupPVERewardReq::set_group_boss_id(::google::protobuf::int32 value) {
  set_has_group_boss_id();
  group_boss_id_ = value;
}

// required int32 reward_index = 2;
inline bool GroupPVERewardReq::has_reward_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPVERewardReq::set_has_reward_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPVERewardReq::clear_has_reward_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPVERewardReq::clear_reward_index() {
  reward_index_ = 0;
  clear_has_reward_index();
}
inline ::google::protobuf::int32 GroupPVERewardReq::reward_index() const {
  return reward_index_;
}
inline void GroupPVERewardReq::set_reward_index(::google::protobuf::int32 value) {
  set_has_reward_index();
  reward_index_ = value;
}

// -------------------------------------------------------------------

// GroupPVERewardResp

// required .GroupPVERewardResp.GroupPVERewardRet result = 1;
inline bool GroupPVERewardResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVERewardResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVERewardResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVERewardResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::result() const {
  return static_cast< ::GroupPVERewardResp_GroupPVERewardRet >(result_);
}
inline void GroupPVERewardResp::set_result(::GroupPVERewardResp_GroupPVERewardRet value) {
  assert(::GroupPVERewardResp_GroupPVERewardRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupPVERewardResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPVERewardResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPVERewardResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPVERewardResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupPVERewardResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupPVERewardResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupPVERewardResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupPVERewardResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .GroupPVERewardReq req = 3;
inline bool GroupPVERewardResp::has_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupPVERewardResp::set_has_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupPVERewardResp::clear_has_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupPVERewardResp::clear_req() {
  if (req_ != NULL) req_->::GroupPVERewardReq::Clear();
  clear_has_req();
}
inline const ::GroupPVERewardReq& GroupPVERewardResp::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::GroupPVERewardReq* GroupPVERewardResp::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::GroupPVERewardReq;
  return req_;
}
inline ::GroupPVERewardReq* GroupPVERewardResp::release_req() {
  clear_has_req();
  ::GroupPVERewardReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void GroupPVERewardResp::set_allocated_req(::GroupPVERewardReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// -------------------------------------------------------------------

// GroupRequestHelpReq

// required int32 type = 1;
inline bool GroupRequestHelpReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupRequestHelpReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupRequestHelpReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupRequestHelpReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GroupRequestHelpReq::type() const {
  return type_;
}
inline void GroupRequestHelpReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 id = 2;
inline int GroupRequestHelpReq::id_size() const {
  return id_.size();
}
inline void GroupRequestHelpReq::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int32 GroupRequestHelpReq::id(int index) const {
  return id_.Get(index);
}
inline void GroupRequestHelpReq::set_id(int index, ::google::protobuf::int32 value) {
  id_.Set(index, value);
}
inline void GroupRequestHelpReq::add_id(::google::protobuf::int32 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GroupRequestHelpReq::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GroupRequestHelpReq::mutable_id() {
  return &id_;
}

// -------------------------------------------------------------------

// GroupRequestHelpResp

// required .GroupRequestHelpResp.GroupRequestHelpRet result = 1;
inline bool GroupRequestHelpResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupRequestHelpResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupRequestHelpResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupRequestHelpResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp::result() const {
  return static_cast< ::GroupRequestHelpResp_GroupRequestHelpRet >(result_);
}
inline void GroupRequestHelpResp::set_result(::GroupRequestHelpResp_GroupRequestHelpRet value) {
  assert(::GroupRequestHelpResp_GroupRequestHelpRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupRequestHelpResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupRequestHelpResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupRequestHelpResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupRequestHelpResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupRequestHelpResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupRequestHelpResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupRequestHelpResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupRequestHelpResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .HelpInfo help_list = 3;
inline int GroupRequestHelpResp::help_list_size() const {
  return help_list_.size();
}
inline void GroupRequestHelpResp::clear_help_list() {
  help_list_.Clear();
}
inline const ::HelpInfo& GroupRequestHelpResp::help_list(int index) const {
  return help_list_.Get(index);
}
inline ::HelpInfo* GroupRequestHelpResp::mutable_help_list(int index) {
  return help_list_.Mutable(index);
}
inline ::HelpInfo* GroupRequestHelpResp::add_help_list() {
  return help_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelpInfo >&
GroupRequestHelpResp::help_list() const {
  return help_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelpInfo >*
GroupRequestHelpResp::mutable_help_list() {
  return &help_list_;
}

// -------------------------------------------------------------------

// GroupHelpListResp

// required .GroupHelpListResp.GroupHelpListRet result = 1;
inline bool GroupHelpListResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupHelpListResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupHelpListResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupHelpListResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupHelpListResp_GroupHelpListRet GroupHelpListResp::result() const {
  return static_cast< ::GroupHelpListResp_GroupHelpListRet >(result_);
}
inline void GroupHelpListResp::set_result(::GroupHelpListResp_GroupHelpListRet value) {
  assert(::GroupHelpListResp_GroupHelpListRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupHelpListResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupHelpListResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupHelpListResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupHelpListResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupHelpListResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupHelpListResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupHelpListResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupHelpListResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .HelpInfo help_list = 3;
inline int GroupHelpListResp::help_list_size() const {
  return help_list_.size();
}
inline void GroupHelpListResp::clear_help_list() {
  help_list_.Clear();
}
inline const ::HelpInfo& GroupHelpListResp::help_list(int index) const {
  return help_list_.Get(index);
}
inline ::HelpInfo* GroupHelpListResp::mutable_help_list(int index) {
  return help_list_.Mutable(index);
}
inline ::HelpInfo* GroupHelpListResp::add_help_list() {
  return help_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelpInfo >&
GroupHelpListResp::help_list() const {
  return help_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelpInfo >*
GroupHelpListResp::mutable_help_list() {
  return &help_list_;
}

// -------------------------------------------------------------------

// GroupHelpReq

// required string user_name = 1;
inline bool GroupHelpReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupHelpReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupHelpReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupHelpReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& GroupHelpReq::user_name() const {
  return *user_name_;
}
inline void GroupHelpReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupHelpReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupHelpReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupHelpReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* GroupHelpReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupHelpReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 2;
inline bool GroupHelpReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupHelpReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupHelpReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupHelpReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GroupHelpReq::type() const {
  return type_;
}
inline void GroupHelpReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 id = 3;
inline int GroupHelpReq::id_size() const {
  return id_.size();
}
inline void GroupHelpReq::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int32 GroupHelpReq::id(int index) const {
  return id_.Get(index);
}
inline void GroupHelpReq::set_id(int index, ::google::protobuf::int32 value) {
  id_.Set(index, value);
}
inline void GroupHelpReq::add_id(::google::protobuf::int32 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GroupHelpReq::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GroupHelpReq::mutable_id() {
  return &id_;
}

// -------------------------------------------------------------------

// GroupHelpResp

// required .GroupHelpResp.GroupHelpRet result = 1;
inline bool GroupHelpResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupHelpResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupHelpResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupHelpResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupHelpResp_GroupHelpRet GroupHelpResp::result() const {
  return static_cast< ::GroupHelpResp_GroupHelpRet >(result_);
}
inline void GroupHelpResp::set_result(::GroupHelpResp_GroupHelpRet value) {
  assert(::GroupHelpResp_GroupHelpRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupHelpResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupHelpResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupHelpResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupHelpResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupHelpResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupHelpResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupHelpResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupHelpResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .HelpInfo help_list = 3;
inline int GroupHelpResp::help_list_size() const {
  return help_list_.size();
}
inline void GroupHelpResp::clear_help_list() {
  help_list_.Clear();
}
inline const ::HelpInfo& GroupHelpResp::help_list(int index) const {
  return help_list_.Get(index);
}
inline ::HelpInfo* GroupHelpResp::mutable_help_list(int index) {
  return help_list_.Mutable(index);
}
inline ::HelpInfo* GroupHelpResp::add_help_list() {
  return help_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelpInfo >&
GroupHelpResp::help_list() const {
  return help_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelpInfo >*
GroupHelpResp::mutable_help_list() {
  return &help_list_;
}

// -------------------------------------------------------------------

// NewGroupUpdate

// required string sender = 1;
inline bool NewGroupUpdate::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewGroupUpdate::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewGroupUpdate::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewGroupUpdate::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& NewGroupUpdate::sender() const {
  return *sender_;
}
inline void NewGroupUpdate::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void NewGroupUpdate::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void NewGroupUpdate::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewGroupUpdate::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* NewGroupUpdate::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewGroupUpdate::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupInviteReq

// required string recver = 1;
inline bool GroupInviteReq::has_recver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInviteReq::set_has_recver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInviteReq::clear_has_recver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInviteReq::clear_recver() {
  if (recver_ != &::google::protobuf::internal::kEmptyString) {
    recver_->clear();
  }
  clear_has_recver();
}
inline const ::std::string& GroupInviteReq::recver() const {
  return *recver_;
}
inline void GroupInviteReq::set_recver(const ::std::string& value) {
  set_has_recver();
  if (recver_ == &::google::protobuf::internal::kEmptyString) {
    recver_ = new ::std::string;
  }
  recver_->assign(value);
}
inline void GroupInviteReq::set_recver(const char* value) {
  set_has_recver();
  if (recver_ == &::google::protobuf::internal::kEmptyString) {
    recver_ = new ::std::string;
  }
  recver_->assign(value);
}
inline void GroupInviteReq::set_recver(const char* value, size_t size) {
  set_has_recver();
  if (recver_ == &::google::protobuf::internal::kEmptyString) {
    recver_ = new ::std::string;
  }
  recver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInviteReq::mutable_recver() {
  set_has_recver();
  if (recver_ == &::google::protobuf::internal::kEmptyString) {
    recver_ = new ::std::string;
  }
  return recver_;
}
inline ::std::string* GroupInviteReq::release_recver() {
  clear_has_recver();
  if (recver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recver_;
    recver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupInviteReq::set_allocated_recver(::std::string* recver) {
  if (recver_ != &::google::protobuf::internal::kEmptyString) {
    delete recver_;
  }
  if (recver) {
    set_has_recver();
    recver_ = recver;
  } else {
    clear_has_recver();
    recver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupInviteResp

// required .GroupInviteResp.GroupInviteRet result = 1;
inline bool GroupInviteResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInviteResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInviteResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInviteResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupInviteResp_GroupInviteRet GroupInviteResp::result() const {
  return static_cast< ::GroupInviteResp_GroupInviteRet >(result_);
}
inline void GroupInviteResp::set_result(::GroupInviteResp_GroupInviteRet value) {
  assert(::GroupInviteResp_GroupInviteRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// GroupWorshipReq

// required int32 type = 1;
inline bool GroupWorshipReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupWorshipReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupWorshipReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupWorshipReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GroupWorshipReq::type() const {
  return type_;
}
inline void GroupWorshipReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 level = 2;
inline bool GroupWorshipReq::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupWorshipReq::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupWorshipReq::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupWorshipReq::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GroupWorshipReq::level() const {
  return level_;
}
inline void GroupWorshipReq::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// GroupWorshipResp

// required .GroupWorshipResp.GroupWorshipRet result = 1;
inline bool GroupWorshipResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupWorshipResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupWorshipResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupWorshipResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GroupWorshipResp_GroupWorshipRet GroupWorshipResp::result() const {
  return static_cast< ::GroupWorshipResp_GroupWorshipRet >(result_);
}
inline void GroupWorshipResp::set_result(::GroupWorshipResp_GroupWorshipRet value) {
  assert(::GroupWorshipResp_GroupWorshipRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GroupWorshipResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupWorshipResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupWorshipResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupWorshipResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GroupWorshipResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* GroupWorshipResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GroupWorshipResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GroupWorshipResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .GroupWorshipReq req = 3;
inline bool GroupWorshipResp::has_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupWorshipResp::set_has_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupWorshipResp::clear_has_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupWorshipResp::clear_req() {
  if (req_ != NULL) req_->::GroupWorshipReq::Clear();
  clear_has_req();
}
inline const ::GroupWorshipReq& GroupWorshipResp::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::GroupWorshipReq* GroupWorshipResp::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::GroupWorshipReq;
  return req_;
}
inline ::GroupWorshipReq* GroupWorshipResp::release_req() {
  clear_has_req();
  ::GroupWorshipReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void GroupWorshipResp::set_allocated_req(::GroupWorshipReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupJoinResp_GroupJoinRet>() {
  return ::GroupJoinResp_GroupJoinRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupAllowResp_GroupAllowRet>() {
  return ::GroupAllowResp_GroupAllowRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupKickResp_GroupKickRet>() {
  return ::GroupKickResp_GroupKickRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupBroadcastResp_GroupBroadcastRet>() {
  return ::GroupBroadcastResp_GroupBroadcastRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupJobResp_GroupJobRet>() {
  return ::GroupJobResp_GroupJobRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupDisbandResp_GroupDisbandRet>() {
  return ::GroupDisbandResp_GroupDisbandRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupPVEGetInfoResp_GroupPVEGetInfoRet>() {
  return ::GroupPVEGetInfoResp_GroupPVEGetInfoRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupPVEResp_GroupPVERet>() {
  return ::GroupPVEResp_GroupPVERet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupPVEOKResp_GroupPVEOKRet>() {
  return ::GroupPVEOKResp_GroupPVEOKRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupPVEAddTimsResp_GroupPVEAddTimsRet>() {
  return ::GroupPVEAddTimsResp_GroupPVEAddTimsRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupPVERewardResp_GroupPVERewardRet>() {
  return ::GroupPVERewardResp_GroupPVERewardRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupRequestHelpResp_GroupRequestHelpRet>() {
  return ::GroupRequestHelpResp_GroupRequestHelpRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupHelpListResp_GroupHelpListRet>() {
  return ::GroupHelpListResp_GroupHelpListRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupHelpResp_GroupHelpRet>() {
  return ::GroupHelpResp_GroupHelpRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupInviteResp_GroupInviteRet>() {
  return ::GroupInviteResp_GroupInviteRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GroupWorshipResp_GroupWorshipRet>() {
  return ::GroupWorshipResp_GroupWorshipRet_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdGroup_2eproto__INCLUDED
