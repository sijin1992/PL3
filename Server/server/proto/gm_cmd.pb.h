// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gm_cmd.proto

#ifndef PROTOBUF_gm_5fcmd_2eproto__INCLUDED
#define PROTOBUF_gm_5fcmd_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Item.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gm_5fcmd_2eproto();
void protobuf_AssignDesc_gm_5fcmd_2eproto();
void protobuf_ShutdownFile_gm_5fcmd_2eproto();

class GMFightReq;
class GMFightResp;
class GMAddItemReq;
class GMAddItemResp;
class DBSendMailReq;
class DBGMResp;
class GMSendMailReq;
class GMGeneralResp;
class UserSnapInfo;
class GMGetUserSnapReq;
class GMGetUserSnapResp;
class GMBlockReq;

enum GMFightResp_Result {
  GMFightResp_Result_OK = 0,
  GMFightResp_Result_FAIL = -1
};
bool GMFightResp_Result_IsValid(int value);
const GMFightResp_Result GMFightResp_Result_Result_MIN = GMFightResp_Result_FAIL;
const GMFightResp_Result GMFightResp_Result_Result_MAX = GMFightResp_Result_OK;
const int GMFightResp_Result_Result_ARRAYSIZE = GMFightResp_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* GMFightResp_Result_descriptor();
inline const ::std::string& GMFightResp_Result_Name(GMFightResp_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    GMFightResp_Result_descriptor(), value);
}
inline bool GMFightResp_Result_Parse(
    const ::std::string& name, GMFightResp_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GMFightResp_Result>(
    GMFightResp_Result_descriptor(), name, value);
}
enum GMAddItemResp_Result {
  GMAddItemResp_Result_OK = 0,
  GMAddItemResp_Result_FAIL = -1
};
bool GMAddItemResp_Result_IsValid(int value);
const GMAddItemResp_Result GMAddItemResp_Result_Result_MIN = GMAddItemResp_Result_FAIL;
const GMAddItemResp_Result GMAddItemResp_Result_Result_MAX = GMAddItemResp_Result_OK;
const int GMAddItemResp_Result_Result_ARRAYSIZE = GMAddItemResp_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* GMAddItemResp_Result_descriptor();
inline const ::std::string& GMAddItemResp_Result_Name(GMAddItemResp_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    GMAddItemResp_Result_descriptor(), value);
}
inline bool GMAddItemResp_Result_Parse(
    const ::std::string& name, GMAddItemResp_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GMAddItemResp_Result>(
    GMAddItemResp_Result_descriptor(), name, value);
}
enum GMGetUserSnapResp_Result {
  GMGetUserSnapResp_Result_OK = 0,
  GMGetUserSnapResp_Result_FAIL = -1
};
bool GMGetUserSnapResp_Result_IsValid(int value);
const GMGetUserSnapResp_Result GMGetUserSnapResp_Result_Result_MIN = GMGetUserSnapResp_Result_FAIL;
const GMGetUserSnapResp_Result GMGetUserSnapResp_Result_Result_MAX = GMGetUserSnapResp_Result_OK;
const int GMGetUserSnapResp_Result_Result_ARRAYSIZE = GMGetUserSnapResp_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* GMGetUserSnapResp_Result_descriptor();
inline const ::std::string& GMGetUserSnapResp_Result_Name(GMGetUserSnapResp_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    GMGetUserSnapResp_Result_descriptor(), value);
}
inline bool GMGetUserSnapResp_Result_Parse(
    const ::std::string& name, GMGetUserSnapResp_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GMGetUserSnapResp_Result>(
    GMGetUserSnapResp_Result_descriptor(), name, value);
}
// ===================================================================

class GMFightReq : public ::google::protobuf::Message {
 public:
  GMFightReq();
  virtual ~GMFightReq();

  GMFightReq(const GMFightReq& from);

  inline GMFightReq& operator=(const GMFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMFightReq& default_instance();

  void Swap(GMFightReq* other);

  // implements Message ----------------------------------------------

  GMFightReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMFightReq& from);
  void MergeFrom(const GMFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const void* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required int32 battle = 2;
  inline bool has_battle() const;
  inline void clear_battle();
  static const int kBattleFieldNumber = 2;
  inline ::google::protobuf::int32 battle() const;
  inline void set_battle(::google::protobuf::int32 value);

  // required int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // required int32 difficult = 4;
  inline bool has_difficult() const;
  inline void clear_difficult();
  static const int kDifficultFieldNumber = 4;
  inline ::google::protobuf::int32 difficult() const;
  inline void set_difficult(::google::protobuf::int32 value);

  // optional int32 fd = 5;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 5;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // optional int64 session = 6;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 6;
  inline ::google::protobuf::int64 session() const;
  inline void set_session(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GMFightReq)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_battle();
  inline void clear_has_battle();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_difficult();
  inline void clear_has_difficult();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::google::protobuf::int32 battle_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 difficult_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int64 session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static GMFightReq* default_instance_;
};
// -------------------------------------------------------------------

class GMFightResp : public ::google::protobuf::Message {
 public:
  GMFightResp();
  virtual ~GMFightResp();

  GMFightResp(const GMFightResp& from);

  inline GMFightResp& operator=(const GMFightResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMFightResp& default_instance();

  void Swap(GMFightResp* other);

  // implements Message ----------------------------------------------

  GMFightResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMFightResp& from);
  void MergeFrom(const GMFightResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GMFightResp_Result Result;
  static const Result OK = GMFightResp_Result_OK;
  static const Result FAIL = GMFightResp_Result_FAIL;
  static inline bool Result_IsValid(int value) {
    return GMFightResp_Result_IsValid(value);
  }
  static const Result Result_MIN =
    GMFightResp_Result_Result_MIN;
  static const Result Result_MAX =
    GMFightResp_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    GMFightResp_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return GMFightResp_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return GMFightResp_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return GMFightResp_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GMFightResp.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GMFightResp_Result result() const;
  inline void set_result(::GMFightResp_Result value);

  // required bytes user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const void* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required int32 battle = 3;
  inline bool has_battle() const;
  inline void clear_battle();
  static const int kBattleFieldNumber = 3;
  inline ::google::protobuf::int32 battle() const;
  inline void set_battle(::google::protobuf::int32 value);

  // required int32 num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // required int32 difficult = 5;
  inline bool has_difficult() const;
  inline void clear_difficult();
  static const int kDifficultFieldNumber = 5;
  inline ::google::protobuf::int32 difficult() const;
  inline void set_difficult(::google::protobuf::int32 value);

  // optional int32 win = 6;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 6;
  inline ::google::protobuf::int32 win() const;
  inline void set_win(::google::protobuf::int32 value);

  // optional int32 fd = 7;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 7;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // optional int64 session = 8;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 8;
  inline ::google::protobuf::int64 session() const;
  inline void set_session(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GMFightResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_battle();
  inline void clear_has_battle();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_difficult();
  inline void clear_has_difficult();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  int result_;
  ::google::protobuf::int32 battle_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 difficult_;
  ::google::protobuf::int32 win_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int64 session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static GMFightResp* default_instance_;
};
// -------------------------------------------------------------------

class GMAddItemReq : public ::google::protobuf::Message {
 public:
  GMAddItemReq();
  virtual ~GMAddItemReq();

  GMAddItemReq(const GMAddItemReq& from);

  inline GMAddItemReq& operator=(const GMAddItemReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMAddItemReq& default_instance();

  void Swap(GMAddItemReq* other);

  // implements Message ----------------------------------------------

  GMAddItemReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMAddItemReq& from);
  void MergeFrom(const GMAddItemReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const void* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required int32 gold = 2;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 2;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // required int32 item_id = 3;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 3;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // required int32 item_num = 4;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 4;
  inline ::google::protobuf::int32 item_num() const;
  inline void set_item_num(::google::protobuf::int32 value);

  // required string gm_user = 5;
  inline bool has_gm_user() const;
  inline void clear_gm_user();
  static const int kGmUserFieldNumber = 5;
  inline const ::std::string& gm_user() const;
  inline void set_gm_user(const ::std::string& value);
  inline void set_gm_user(const char* value);
  inline void set_gm_user(const char* value, size_t size);
  inline ::std::string* mutable_gm_user();
  inline ::std::string* release_gm_user();
  inline void set_allocated_gm_user(::std::string* gm_user);

  // required string gm_pswd = 6;
  inline bool has_gm_pswd() const;
  inline void clear_gm_pswd();
  static const int kGmPswdFieldNumber = 6;
  inline const ::std::string& gm_pswd() const;
  inline void set_gm_pswd(const ::std::string& value);
  inline void set_gm_pswd(const char* value);
  inline void set_gm_pswd(const char* value, size_t size);
  inline ::std::string* mutable_gm_pswd();
  inline ::std::string* release_gm_pswd();
  inline void set_allocated_gm_pswd(::std::string* gm_pswd);

  // optional int32 fd = 7;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 7;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // optional int64 session = 8;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 8;
  inline ::google::protobuf::int64 session() const;
  inline void set_session(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GMAddItemReq)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_gm_user();
  inline void clear_has_gm_user();
  inline void set_has_gm_pswd();
  inline void clear_has_gm_pswd();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 item_id_;
  ::std::string* gm_user_;
  ::google::protobuf::int32 item_num_;
  ::google::protobuf::int32 fd_;
  ::std::string* gm_pswd_;
  ::google::protobuf::int64 session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static GMAddItemReq* default_instance_;
};
// -------------------------------------------------------------------

class GMAddItemResp : public ::google::protobuf::Message {
 public:
  GMAddItemResp();
  virtual ~GMAddItemResp();

  GMAddItemResp(const GMAddItemResp& from);

  inline GMAddItemResp& operator=(const GMAddItemResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMAddItemResp& default_instance();

  void Swap(GMAddItemResp* other);

  // implements Message ----------------------------------------------

  GMAddItemResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMAddItemResp& from);
  void MergeFrom(const GMAddItemResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GMAddItemResp_Result Result;
  static const Result OK = GMAddItemResp_Result_OK;
  static const Result FAIL = GMAddItemResp_Result_FAIL;
  static inline bool Result_IsValid(int value) {
    return GMAddItemResp_Result_IsValid(value);
  }
  static const Result Result_MIN =
    GMAddItemResp_Result_Result_MIN;
  static const Result Result_MAX =
    GMAddItemResp_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    GMAddItemResp_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return GMAddItemResp_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return GMAddItemResp_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return GMAddItemResp_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GMAddItemResp.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GMAddItemResp_Result result() const;
  inline void set_result(::GMAddItemResp_Result value);

  // optional int32 fd = 2;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 2;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // optional int64 session = 3;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 3;
  inline ::google::protobuf::int64 session() const;
  inline void set_session(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GMAddItemResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int result_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int64 session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static GMAddItemResp* default_instance_;
};
// -------------------------------------------------------------------

class DBSendMailReq : public ::google::protobuf::Message {
 public:
  DBSendMailReq();
  virtual ~DBSendMailReq();

  DBSendMailReq(const DBSendMailReq& from);

  inline DBSendMailReq& operator=(const DBSendMailReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBSendMailReq& default_instance();

  void Swap(DBSendMailReq* other);

  // implements Message ----------------------------------------------

  DBSendMailReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBSendMailReq& from);
  void MergeFrom(const DBSendMailReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const void* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string from = 3;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 3;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // repeated .Item item_list = 5;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 5;
  inline const ::Item& item_list(int index) const;
  inline ::Item* mutable_item_list(int index);
  inline ::Item* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Item >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Item >*
      mutable_item_list();

  // required string subject = 6;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 6;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const char* value, size_t size);
  inline ::std::string* mutable_subject();
  inline ::std::string* release_subject();
  inline void set_allocated_subject(::std::string* subject);

  // optional int32 time = 7;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 7;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // optional int32 buchang = 8;
  inline bool has_buchang() const;
  inline void clear_buchang();
  static const int kBuchangFieldNumber = 8;
  inline ::google::protobuf::int32 buchang() const;
  inline void set_buchang(::google::protobuf::int32 value);

  // optional int64 reg_time = 9;
  inline bool has_reg_time() const;
  inline void clear_reg_time();
  static const int kRegTimeFieldNumber = 9;
  inline ::google::protobuf::int64 reg_time() const;
  inline void set_reg_time(::google::protobuf::int64 value);

  // optional int32 vip_limit = 10;
  inline bool has_vip_limit() const;
  inline void clear_vip_limit();
  static const int kVipLimitFieldNumber = 10;
  inline ::google::protobuf::int32 vip_limit() const;
  inline void set_vip_limit(::google::protobuf::int32 value);

  // optional int32 lev_limit = 11;
  inline bool has_lev_limit() const;
  inline void clear_lev_limit();
  static const int kLevLimitFieldNumber = 11;
  inline ::google::protobuf::int32 lev_limit() const;
  inline void set_lev_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DBSendMailReq)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_buchang();
  inline void clear_has_buchang();
  inline void set_has_reg_time();
  inline void clear_has_reg_time();
  inline void set_has_vip_limit();
  inline void clear_has_vip_limit();
  inline void set_has_lev_limit();
  inline void clear_has_lev_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::std::string* from_;
  ::std::string* message_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::RepeatedPtrField< ::Item > item_list_;
  ::std::string* subject_;
  ::google::protobuf::int64 reg_time_;
  ::google::protobuf::int32 buchang_;
  ::google::protobuf::int32 vip_limit_;
  ::google::protobuf::int32 lev_limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static DBSendMailReq* default_instance_;
};
// -------------------------------------------------------------------

class DBGMResp : public ::google::protobuf::Message {
 public:
  DBGMResp();
  virtual ~DBGMResp();

  DBGMResp(const DBGMResp& from);

  inline DBGMResp& operator=(const DBGMResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBGMResp& default_instance();

  void Swap(DBGMResp* other);

  // implements Message ----------------------------------------------

  DBGMResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBGMResp& from);
  void MergeFrom(const DBGMResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DBGMResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static DBGMResp* default_instance_;
};
// -------------------------------------------------------------------

class GMSendMailReq : public ::google::protobuf::Message {
 public:
  GMSendMailReq();
  virtual ~GMSendMailReq();

  GMSendMailReq(const GMSendMailReq& from);

  inline GMSendMailReq& operator=(const GMSendMailReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMSendMailReq& default_instance();

  void Swap(GMSendMailReq* other);

  // implements Message ----------------------------------------------

  GMSendMailReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMSendMailReq& from);
  void MergeFrom(const GMSendMailReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DBSendMailReq req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::DBSendMailReq& req() const;
  inline ::DBSendMailReq* mutable_req();
  inline ::DBSendMailReq* release_req();
  inline void set_allocated_req(::DBSendMailReq* req);

  // required int32 fd = 2;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 2;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // required int64 session = 3;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 3;
  inline ::google::protobuf::int64 session() const;
  inline void set_session(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GMSendMailReq)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::DBSendMailReq* req_;
  ::google::protobuf::int64 session_;
  ::google::protobuf::int32 fd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static GMSendMailReq* default_instance_;
};
// -------------------------------------------------------------------

class GMGeneralResp : public ::google::protobuf::Message {
 public:
  GMGeneralResp();
  virtual ~GMGeneralResp();

  GMGeneralResp(const GMGeneralResp& from);

  inline GMGeneralResp& operator=(const GMGeneralResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMGeneralResp& default_instance();

  void Swap(GMGeneralResp* other);

  // implements Message ----------------------------------------------

  GMGeneralResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMGeneralResp& from);
  void MergeFrom(const GMGeneralResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required int32 fd = 2;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 2;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // required int64 session = 3;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 3;
  inline ::google::protobuf::int64 session() const;
  inline void set_session(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GMGeneralResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int64 session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static GMGeneralResp* default_instance_;
};
// -------------------------------------------------------------------

class UserSnapInfo : public ::google::protobuf::Message {
 public:
  UserSnapInfo();
  virtual ~UserSnapInfo();

  UserSnapInfo(const UserSnapInfo& from);

  inline UserSnapInfo& operator=(const UserSnapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSnapInfo& default_instance();

  void Swap(UserSnapInfo* other);

  // implements Message ----------------------------------------------

  UserSnapInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserSnapInfo& from);
  void MergeFrom(const UserSnapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // optional string qd = 3;
  inline bool has_qd() const;
  inline void clear_qd();
  static const int kQdFieldNumber = 3;
  inline const ::std::string& qd() const;
  inline void set_qd(const ::std::string& value);
  inline void set_qd(const char* value);
  inline void set_qd(const char* value, size_t size);
  inline ::std::string* mutable_qd();
  inline ::std::string* release_qd();
  inline void set_allocated_qd(::std::string* qd);

  // optional int32 lv = 4;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 4;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int64 exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::int64 exp() const;
  inline void set_exp(::google::protobuf::int64 value);

  // optional int32 viplv = 6;
  inline bool has_viplv() const;
  inline void clear_viplv();
  static const int kViplvFieldNumber = 6;
  inline ::google::protobuf::int32 viplv() const;
  inline void set_viplv(::google::protobuf::int32 value);

  // optional int64 vipscore = 7;
  inline bool has_vipscore() const;
  inline void clear_vipscore();
  static const int kVipscoreFieldNumber = 7;
  inline ::google::protobuf::int64 vipscore() const;
  inline void set_vipscore(::google::protobuf::int64 value);

  // optional int32 totaldep = 8;
  inline bool has_totaldep() const;
  inline void clear_totaldep();
  static const int kTotaldepFieldNumber = 8;
  inline ::google::protobuf::int32 totaldep() const;
  inline void set_totaldep(::google::protobuf::int32 value);

  // optional int32 totalrmb = 9;
  inline bool has_totalrmb() const;
  inline void clear_totalrmb();
  static const int kTotalrmbFieldNumber = 9;
  inline ::google::protobuf::int32 totalrmb() const;
  inline void set_totalrmb(::google::protobuf::int32 value);

  // optional int32 gold = 10;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 10;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 money = 11;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 11;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 php = 12;
  inline bool has_php() const;
  inline void clear_php();
  static const int kPhpFieldNumber = 12;
  inline ::google::protobuf::int32 php() const;
  inline void set_php(::google::protobuf::int32 value);

  // optional int32 maxpower = 13;
  inline bool has_maxpower() const;
  inline void clear_maxpower();
  static const int kMaxpowerFieldNumber = 13;
  inline ::google::protobuf::int32 maxpower() const;
  inline void set_maxpower(::google::protobuf::int32 value);

  // optional int32 state = 14;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 14;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 stagelv = 15;
  inline bool has_stagelv() const;
  inline void clear_stagelv();
  static const int kStagelvFieldNumber = 15;
  inline ::google::protobuf::int32 stagelv() const;
  inline void set_stagelv(::google::protobuf::int32 value);

  // optional int32 maxrank = 16;
  inline bool has_maxrank() const;
  inline void clear_maxrank();
  static const int kMaxrankFieldNumber = 16;
  inline ::google::protobuf::int32 maxrank() const;
  inline void set_maxrank(::google::protobuf::int32 value);

  // optional string menpai = 17;
  inline bool has_menpai() const;
  inline void clear_menpai();
  static const int kMenpaiFieldNumber = 17;
  inline const ::std::string& menpai() const;
  inline void set_menpai(const ::std::string& value);
  inline void set_menpai(const char* value);
  inline void set_menpai(const char* value, size_t size);
  inline ::std::string* mutable_menpai();
  inline ::std::string* release_menpai();
  inline void set_allocated_menpai(::std::string* menpai);

  // optional string ip = 51;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 51;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:UserSnapInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_qd();
  inline void clear_has_qd();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_viplv();
  inline void clear_has_viplv();
  inline void set_has_vipscore();
  inline void clear_has_vipscore();
  inline void set_has_totaldep();
  inline void clear_has_totaldep();
  inline void set_has_totalrmb();
  inline void clear_has_totalrmb();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_php();
  inline void clear_has_php();
  inline void set_has_maxpower();
  inline void clear_has_maxpower();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_stagelv();
  inline void clear_has_stagelv();
  inline void set_has_maxrank();
  inline void clear_has_maxrank();
  inline void set_has_menpai();
  inline void clear_has_menpai();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* nick_;
  ::std::string* qd_;
  ::google::protobuf::int64 exp_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 viplv_;
  ::google::protobuf::int64 vipscore_;
  ::google::protobuf::int32 totaldep_;
  ::google::protobuf::int32 totalrmb_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 php_;
  ::google::protobuf::int32 maxpower_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 stagelv_;
  ::std::string* menpai_;
  ::std::string* ip_;
  ::google::protobuf::int32 maxrank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static UserSnapInfo* default_instance_;
};
// -------------------------------------------------------------------

class GMGetUserSnapReq : public ::google::protobuf::Message {
 public:
  GMGetUserSnapReq();
  virtual ~GMGetUserSnapReq();

  GMGetUserSnapReq(const GMGetUserSnapReq& from);

  inline GMGetUserSnapReq& operator=(const GMGetUserSnapReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMGetUserSnapReq& default_instance();

  void Swap(GMGetUserSnapReq* other);

  // implements Message ----------------------------------------------

  GMGetUserSnapReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMGetUserSnapReq& from);
  void MergeFrom(const GMGetUserSnapReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string flags = 2;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 2;
  inline const ::std::string& flags() const;
  inline void set_flags(const ::std::string& value);
  inline void set_flags(const char* value);
  inline void set_flags(const char* value, size_t size);
  inline ::std::string* mutable_flags();
  inline ::std::string* release_flags();
  inline void set_allocated_flags(::std::string* flags);

  // optional string gmuser = 11;
  inline bool has_gmuser() const;
  inline void clear_gmuser();
  static const int kGmuserFieldNumber = 11;
  inline const ::std::string& gmuser() const;
  inline void set_gmuser(const ::std::string& value);
  inline void set_gmuser(const char* value);
  inline void set_gmuser(const char* value, size_t size);
  inline ::std::string* mutable_gmuser();
  inline ::std::string* release_gmuser();
  inline void set_allocated_gmuser(::std::string* gmuser);

  // optional string gmkey = 12;
  inline bool has_gmkey() const;
  inline void clear_gmkey();
  static const int kGmkeyFieldNumber = 12;
  inline const ::std::string& gmkey() const;
  inline void set_gmkey(const ::std::string& value);
  inline void set_gmkey(const char* value);
  inline void set_gmkey(const char* value, size_t size);
  inline ::std::string* mutable_gmkey();
  inline ::std::string* release_gmkey();
  inline void set_allocated_gmkey(::std::string* gmkey);

  // optional int32 fd = 21;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 21;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // optional int64 session = 22;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 22;
  inline ::google::protobuf::int64 session() const;
  inline void set_session(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GMGetUserSnapReq)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_gmuser();
  inline void clear_has_gmuser();
  inline void set_has_gmkey();
  inline void clear_has_gmkey();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* flags_;
  ::std::string* gmuser_;
  ::std::string* gmkey_;
  ::google::protobuf::int64 session_;
  ::google::protobuf::int32 fd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static GMGetUserSnapReq* default_instance_;
};
// -------------------------------------------------------------------

class GMGetUserSnapResp : public ::google::protobuf::Message {
 public:
  GMGetUserSnapResp();
  virtual ~GMGetUserSnapResp();

  GMGetUserSnapResp(const GMGetUserSnapResp& from);

  inline GMGetUserSnapResp& operator=(const GMGetUserSnapResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMGetUserSnapResp& default_instance();

  void Swap(GMGetUserSnapResp* other);

  // implements Message ----------------------------------------------

  GMGetUserSnapResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMGetUserSnapResp& from);
  void MergeFrom(const GMGetUserSnapResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GMGetUserSnapResp_Result Result;
  static const Result OK = GMGetUserSnapResp_Result_OK;
  static const Result FAIL = GMGetUserSnapResp_Result_FAIL;
  static inline bool Result_IsValid(int value) {
    return GMGetUserSnapResp_Result_IsValid(value);
  }
  static const Result Result_MIN =
    GMGetUserSnapResp_Result_Result_MIN;
  static const Result Result_MAX =
    GMGetUserSnapResp_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    GMGetUserSnapResp_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return GMGetUserSnapResp_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return GMGetUserSnapResp_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return GMGetUserSnapResp_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GMGetUserSnapResp.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::GMGetUserSnapResp_Result result() const;
  inline void set_result(::GMGetUserSnapResp_Result value);

  // optional .UserSnapInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::UserSnapInfo& info() const;
  inline ::UserSnapInfo* mutable_info();
  inline ::UserSnapInfo* release_info();
  inline void set_allocated_info(::UserSnapInfo* info);

  // optional int32 fd = 21;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 21;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // optional int64 session = 22;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 22;
  inline ::google::protobuf::int64 session() const;
  inline void set_session(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GMGetUserSnapResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSnapInfo* info_;
  int result_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int64 session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static GMGetUserSnapResp* default_instance_;
};
// -------------------------------------------------------------------

class GMBlockReq : public ::google::protobuf::Message {
 public:
  GMBlockReq();
  virtual ~GMBlockReq();

  GMBlockReq(const GMBlockReq& from);

  inline GMBlockReq& operator=(const GMBlockReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMBlockReq& default_instance();

  void Swap(GMBlockReq* other);

  // implements Message ----------------------------------------------

  GMBlockReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMBlockReq& from);
  void MergeFrom(const GMBlockReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 blocktime = 3;
  inline bool has_blocktime() const;
  inline void clear_blocktime();
  static const int kBlocktimeFieldNumber = 3;
  inline ::google::protobuf::int32 blocktime() const;
  inline void set_blocktime(::google::protobuf::int32 value);

  // required int32 fd = 4;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 4;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // required int64 session = 5;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 5;
  inline ::google::protobuf::int64 session() const;
  inline void set_session(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GMBlockReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_blocktime();
  inline void clear_has_blocktime();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 blocktime_;
  ::google::protobuf::int64 session_;
  ::google::protobuf::int32 fd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_gm_5fcmd_2eproto();
  friend void protobuf_AssignDesc_gm_5fcmd_2eproto();
  friend void protobuf_ShutdownFile_gm_5fcmd_2eproto();

  void InitAsDefaultInstance();
  static GMBlockReq* default_instance_;
};
// ===================================================================


// ===================================================================

// GMFightReq

// required bytes user = 1;
inline bool GMFightReq::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMFightReq::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMFightReq::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMFightReq::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& GMFightReq::user() const {
  return *user_;
}
inline void GMFightReq::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void GMFightReq::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void GMFightReq::set_user(const void* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMFightReq::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* GMFightReq::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMFightReq::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 battle = 2;
inline bool GMFightReq::has_battle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMFightReq::set_has_battle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMFightReq::clear_has_battle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMFightReq::clear_battle() {
  battle_ = 0;
  clear_has_battle();
}
inline ::google::protobuf::int32 GMFightReq::battle() const {
  return battle_;
}
inline void GMFightReq::set_battle(::google::protobuf::int32 value) {
  set_has_battle();
  battle_ = value;
}

// required int32 num = 3;
inline bool GMFightReq::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMFightReq::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMFightReq::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMFightReq::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 GMFightReq::num() const {
  return num_;
}
inline void GMFightReq::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// required int32 difficult = 4;
inline bool GMFightReq::has_difficult() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMFightReq::set_has_difficult() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMFightReq::clear_has_difficult() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMFightReq::clear_difficult() {
  difficult_ = 0;
  clear_has_difficult();
}
inline ::google::protobuf::int32 GMFightReq::difficult() const {
  return difficult_;
}
inline void GMFightReq::set_difficult(::google::protobuf::int32 value) {
  set_has_difficult();
  difficult_ = value;
}

// optional int32 fd = 5;
inline bool GMFightReq::has_fd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GMFightReq::set_has_fd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GMFightReq::clear_has_fd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GMFightReq::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GMFightReq::fd() const {
  return fd_;
}
inline void GMFightReq::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int64 session = 6;
inline bool GMFightReq::has_session() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GMFightReq::set_has_session() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GMFightReq::clear_has_session() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GMFightReq::clear_session() {
  session_ = GOOGLE_LONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::int64 GMFightReq::session() const {
  return session_;
}
inline void GMFightReq::set_session(::google::protobuf::int64 value) {
  set_has_session();
  session_ = value;
}

// -------------------------------------------------------------------

// GMFightResp

// required .GMFightResp.Result result = 1;
inline bool GMFightResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMFightResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMFightResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMFightResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GMFightResp_Result GMFightResp::result() const {
  return static_cast< ::GMFightResp_Result >(result_);
}
inline void GMFightResp::set_result(::GMFightResp_Result value) {
  assert(::GMFightResp_Result_IsValid(value));
  set_has_result();
  result_ = value;
}

// required bytes user = 2;
inline bool GMFightResp::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMFightResp::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMFightResp::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMFightResp::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& GMFightResp::user() const {
  return *user_;
}
inline void GMFightResp::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void GMFightResp::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void GMFightResp::set_user(const void* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMFightResp::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* GMFightResp::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMFightResp::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 battle = 3;
inline bool GMFightResp::has_battle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMFightResp::set_has_battle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMFightResp::clear_has_battle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMFightResp::clear_battle() {
  battle_ = 0;
  clear_has_battle();
}
inline ::google::protobuf::int32 GMFightResp::battle() const {
  return battle_;
}
inline void GMFightResp::set_battle(::google::protobuf::int32 value) {
  set_has_battle();
  battle_ = value;
}

// required int32 num = 4;
inline bool GMFightResp::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMFightResp::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMFightResp::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMFightResp::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 GMFightResp::num() const {
  return num_;
}
inline void GMFightResp::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// required int32 difficult = 5;
inline bool GMFightResp::has_difficult() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GMFightResp::set_has_difficult() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GMFightResp::clear_has_difficult() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GMFightResp::clear_difficult() {
  difficult_ = 0;
  clear_has_difficult();
}
inline ::google::protobuf::int32 GMFightResp::difficult() const {
  return difficult_;
}
inline void GMFightResp::set_difficult(::google::protobuf::int32 value) {
  set_has_difficult();
  difficult_ = value;
}

// optional int32 win = 6;
inline bool GMFightResp::has_win() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GMFightResp::set_has_win() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GMFightResp::clear_has_win() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GMFightResp::clear_win() {
  win_ = 0;
  clear_has_win();
}
inline ::google::protobuf::int32 GMFightResp::win() const {
  return win_;
}
inline void GMFightResp::set_win(::google::protobuf::int32 value) {
  set_has_win();
  win_ = value;
}

// optional int32 fd = 7;
inline bool GMFightResp::has_fd() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GMFightResp::set_has_fd() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GMFightResp::clear_has_fd() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GMFightResp::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GMFightResp::fd() const {
  return fd_;
}
inline void GMFightResp::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int64 session = 8;
inline bool GMFightResp::has_session() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GMFightResp::set_has_session() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GMFightResp::clear_has_session() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GMFightResp::clear_session() {
  session_ = GOOGLE_LONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::int64 GMFightResp::session() const {
  return session_;
}
inline void GMFightResp::set_session(::google::protobuf::int64 value) {
  set_has_session();
  session_ = value;
}

// -------------------------------------------------------------------

// GMAddItemReq

// required bytes user = 1;
inline bool GMAddItemReq::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMAddItemReq::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMAddItemReq::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMAddItemReq::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& GMAddItemReq::user() const {
  return *user_;
}
inline void GMAddItemReq::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void GMAddItemReq::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void GMAddItemReq::set_user(const void* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMAddItemReq::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* GMAddItemReq::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMAddItemReq::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 gold = 2;
inline bool GMAddItemReq::has_gold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMAddItemReq::set_has_gold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMAddItemReq::clear_has_gold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMAddItemReq::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 GMAddItemReq::gold() const {
  return gold_;
}
inline void GMAddItemReq::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// required int32 item_id = 3;
inline bool GMAddItemReq::has_item_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMAddItemReq::set_has_item_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMAddItemReq::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMAddItemReq::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 GMAddItemReq::item_id() const {
  return item_id_;
}
inline void GMAddItemReq::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// required int32 item_num = 4;
inline bool GMAddItemReq::has_item_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMAddItemReq::set_has_item_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMAddItemReq::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMAddItemReq::clear_item_num() {
  item_num_ = 0;
  clear_has_item_num();
}
inline ::google::protobuf::int32 GMAddItemReq::item_num() const {
  return item_num_;
}
inline void GMAddItemReq::set_item_num(::google::protobuf::int32 value) {
  set_has_item_num();
  item_num_ = value;
}

// required string gm_user = 5;
inline bool GMAddItemReq::has_gm_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GMAddItemReq::set_has_gm_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GMAddItemReq::clear_has_gm_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GMAddItemReq::clear_gm_user() {
  if (gm_user_ != &::google::protobuf::internal::kEmptyString) {
    gm_user_->clear();
  }
  clear_has_gm_user();
}
inline const ::std::string& GMAddItemReq::gm_user() const {
  return *gm_user_;
}
inline void GMAddItemReq::set_gm_user(const ::std::string& value) {
  set_has_gm_user();
  if (gm_user_ == &::google::protobuf::internal::kEmptyString) {
    gm_user_ = new ::std::string;
  }
  gm_user_->assign(value);
}
inline void GMAddItemReq::set_gm_user(const char* value) {
  set_has_gm_user();
  if (gm_user_ == &::google::protobuf::internal::kEmptyString) {
    gm_user_ = new ::std::string;
  }
  gm_user_->assign(value);
}
inline void GMAddItemReq::set_gm_user(const char* value, size_t size) {
  set_has_gm_user();
  if (gm_user_ == &::google::protobuf::internal::kEmptyString) {
    gm_user_ = new ::std::string;
  }
  gm_user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMAddItemReq::mutable_gm_user() {
  set_has_gm_user();
  if (gm_user_ == &::google::protobuf::internal::kEmptyString) {
    gm_user_ = new ::std::string;
  }
  return gm_user_;
}
inline ::std::string* GMAddItemReq::release_gm_user() {
  clear_has_gm_user();
  if (gm_user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gm_user_;
    gm_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMAddItemReq::set_allocated_gm_user(::std::string* gm_user) {
  if (gm_user_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_user_;
  }
  if (gm_user) {
    set_has_gm_user();
    gm_user_ = gm_user;
  } else {
    clear_has_gm_user();
    gm_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string gm_pswd = 6;
inline bool GMAddItemReq::has_gm_pswd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GMAddItemReq::set_has_gm_pswd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GMAddItemReq::clear_has_gm_pswd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GMAddItemReq::clear_gm_pswd() {
  if (gm_pswd_ != &::google::protobuf::internal::kEmptyString) {
    gm_pswd_->clear();
  }
  clear_has_gm_pswd();
}
inline const ::std::string& GMAddItemReq::gm_pswd() const {
  return *gm_pswd_;
}
inline void GMAddItemReq::set_gm_pswd(const ::std::string& value) {
  set_has_gm_pswd();
  if (gm_pswd_ == &::google::protobuf::internal::kEmptyString) {
    gm_pswd_ = new ::std::string;
  }
  gm_pswd_->assign(value);
}
inline void GMAddItemReq::set_gm_pswd(const char* value) {
  set_has_gm_pswd();
  if (gm_pswd_ == &::google::protobuf::internal::kEmptyString) {
    gm_pswd_ = new ::std::string;
  }
  gm_pswd_->assign(value);
}
inline void GMAddItemReq::set_gm_pswd(const char* value, size_t size) {
  set_has_gm_pswd();
  if (gm_pswd_ == &::google::protobuf::internal::kEmptyString) {
    gm_pswd_ = new ::std::string;
  }
  gm_pswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMAddItemReq::mutable_gm_pswd() {
  set_has_gm_pswd();
  if (gm_pswd_ == &::google::protobuf::internal::kEmptyString) {
    gm_pswd_ = new ::std::string;
  }
  return gm_pswd_;
}
inline ::std::string* GMAddItemReq::release_gm_pswd() {
  clear_has_gm_pswd();
  if (gm_pswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gm_pswd_;
    gm_pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMAddItemReq::set_allocated_gm_pswd(::std::string* gm_pswd) {
  if (gm_pswd_ != &::google::protobuf::internal::kEmptyString) {
    delete gm_pswd_;
  }
  if (gm_pswd) {
    set_has_gm_pswd();
    gm_pswd_ = gm_pswd;
  } else {
    clear_has_gm_pswd();
    gm_pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fd = 7;
inline bool GMAddItemReq::has_fd() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GMAddItemReq::set_has_fd() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GMAddItemReq::clear_has_fd() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GMAddItemReq::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GMAddItemReq::fd() const {
  return fd_;
}
inline void GMAddItemReq::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int64 session = 8;
inline bool GMAddItemReq::has_session() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GMAddItemReq::set_has_session() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GMAddItemReq::clear_has_session() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GMAddItemReq::clear_session() {
  session_ = GOOGLE_LONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::int64 GMAddItemReq::session() const {
  return session_;
}
inline void GMAddItemReq::set_session(::google::protobuf::int64 value) {
  set_has_session();
  session_ = value;
}

// -------------------------------------------------------------------

// GMAddItemResp

// required .GMAddItemResp.Result result = 1;
inline bool GMAddItemResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMAddItemResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMAddItemResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMAddItemResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GMAddItemResp_Result GMAddItemResp::result() const {
  return static_cast< ::GMAddItemResp_Result >(result_);
}
inline void GMAddItemResp::set_result(::GMAddItemResp_Result value) {
  assert(::GMAddItemResp_Result_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional int32 fd = 2;
inline bool GMAddItemResp::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMAddItemResp::set_has_fd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMAddItemResp::clear_has_fd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMAddItemResp::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GMAddItemResp::fd() const {
  return fd_;
}
inline void GMAddItemResp::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int64 session = 3;
inline bool GMAddItemResp::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMAddItemResp::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMAddItemResp::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMAddItemResp::clear_session() {
  session_ = GOOGLE_LONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::int64 GMAddItemResp::session() const {
  return session_;
}
inline void GMAddItemResp::set_session(::google::protobuf::int64 value) {
  set_has_session();
  session_ = value;
}

// -------------------------------------------------------------------

// DBSendMailReq

// optional bytes user = 1;
inline bool DBSendMailReq::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBSendMailReq::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBSendMailReq::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBSendMailReq::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& DBSendMailReq::user() const {
  return *user_;
}
inline void DBSendMailReq::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void DBSendMailReq::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void DBSendMailReq::set_user(const void* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBSendMailReq::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* DBSendMailReq::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBSendMailReq::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 2;
inline bool DBSendMailReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBSendMailReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBSendMailReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBSendMailReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DBSendMailReq::type() const {
  return type_;
}
inline void DBSendMailReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string from = 3;
inline bool DBSendMailReq::has_from() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBSendMailReq::set_has_from() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBSendMailReq::clear_has_from() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBSendMailReq::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& DBSendMailReq::from() const {
  return *from_;
}
inline void DBSendMailReq::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void DBSendMailReq::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void DBSendMailReq::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBSendMailReq::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* DBSendMailReq::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBSendMailReq::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string message = 4;
inline bool DBSendMailReq::has_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBSendMailReq::set_has_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBSendMailReq::clear_has_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBSendMailReq::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& DBSendMailReq::message() const {
  return *message_;
}
inline void DBSendMailReq::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void DBSendMailReq::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void DBSendMailReq::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBSendMailReq::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* DBSendMailReq::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBSendMailReq::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Item item_list = 5;
inline int DBSendMailReq::item_list_size() const {
  return item_list_.size();
}
inline void DBSendMailReq::clear_item_list() {
  item_list_.Clear();
}
inline const ::Item& DBSendMailReq::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::Item* DBSendMailReq::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::Item* DBSendMailReq::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Item >&
DBSendMailReq::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Item >*
DBSendMailReq::mutable_item_list() {
  return &item_list_;
}

// required string subject = 6;
inline bool DBSendMailReq::has_subject() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DBSendMailReq::set_has_subject() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DBSendMailReq::clear_has_subject() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DBSendMailReq::clear_subject() {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    subject_->clear();
  }
  clear_has_subject();
}
inline const ::std::string& DBSendMailReq::subject() const {
  return *subject_;
}
inline void DBSendMailReq::set_subject(const ::std::string& value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void DBSendMailReq::set_subject(const char* value) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void DBSendMailReq::set_subject(const char* value, size_t size) {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBSendMailReq::mutable_subject() {
  set_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    subject_ = new ::std::string;
  }
  return subject_;
}
inline ::std::string* DBSendMailReq::release_subject() {
  clear_has_subject();
  if (subject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subject_;
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBSendMailReq::set_allocated_subject(::std::string* subject) {
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (subject) {
    set_has_subject();
    subject_ = subject;
  } else {
    clear_has_subject();
    subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 time = 7;
inline bool DBSendMailReq::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DBSendMailReq::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DBSendMailReq::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DBSendMailReq::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 DBSendMailReq::time() const {
  return time_;
}
inline void DBSendMailReq::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 buchang = 8;
inline bool DBSendMailReq::has_buchang() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DBSendMailReq::set_has_buchang() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DBSendMailReq::clear_has_buchang() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DBSendMailReq::clear_buchang() {
  buchang_ = 0;
  clear_has_buchang();
}
inline ::google::protobuf::int32 DBSendMailReq::buchang() const {
  return buchang_;
}
inline void DBSendMailReq::set_buchang(::google::protobuf::int32 value) {
  set_has_buchang();
  buchang_ = value;
}

// optional int64 reg_time = 9;
inline bool DBSendMailReq::has_reg_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DBSendMailReq::set_has_reg_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DBSendMailReq::clear_has_reg_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DBSendMailReq::clear_reg_time() {
  reg_time_ = GOOGLE_LONGLONG(0);
  clear_has_reg_time();
}
inline ::google::protobuf::int64 DBSendMailReq::reg_time() const {
  return reg_time_;
}
inline void DBSendMailReq::set_reg_time(::google::protobuf::int64 value) {
  set_has_reg_time();
  reg_time_ = value;
}

// optional int32 vip_limit = 10;
inline bool DBSendMailReq::has_vip_limit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DBSendMailReq::set_has_vip_limit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DBSendMailReq::clear_has_vip_limit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DBSendMailReq::clear_vip_limit() {
  vip_limit_ = 0;
  clear_has_vip_limit();
}
inline ::google::protobuf::int32 DBSendMailReq::vip_limit() const {
  return vip_limit_;
}
inline void DBSendMailReq::set_vip_limit(::google::protobuf::int32 value) {
  set_has_vip_limit();
  vip_limit_ = value;
}

// optional int32 lev_limit = 11;
inline bool DBSendMailReq::has_lev_limit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DBSendMailReq::set_has_lev_limit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DBSendMailReq::clear_has_lev_limit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DBSendMailReq::clear_lev_limit() {
  lev_limit_ = 0;
  clear_has_lev_limit();
}
inline ::google::protobuf::int32 DBSendMailReq::lev_limit() const {
  return lev_limit_;
}
inline void DBSendMailReq::set_lev_limit(::google::protobuf::int32 value) {
  set_has_lev_limit();
  lev_limit_ = value;
}

// -------------------------------------------------------------------

// DBGMResp

// required int32 result = 1;
inline bool DBGMResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBGMResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBGMResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBGMResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 DBGMResp::result() const {
  return result_;
}
inline void DBGMResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// GMSendMailReq

// required .DBSendMailReq req = 1;
inline bool GMSendMailReq::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMSendMailReq::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMSendMailReq::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMSendMailReq::clear_req() {
  if (req_ != NULL) req_->::DBSendMailReq::Clear();
  clear_has_req();
}
inline const ::DBSendMailReq& GMSendMailReq::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::DBSendMailReq* GMSendMailReq::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::DBSendMailReq;
  return req_;
}
inline ::DBSendMailReq* GMSendMailReq::release_req() {
  clear_has_req();
  ::DBSendMailReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void GMSendMailReq::set_allocated_req(::DBSendMailReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// required int32 fd = 2;
inline bool GMSendMailReq::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMSendMailReq::set_has_fd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMSendMailReq::clear_has_fd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMSendMailReq::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GMSendMailReq::fd() const {
  return fd_;
}
inline void GMSendMailReq::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// required int64 session = 3;
inline bool GMSendMailReq::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMSendMailReq::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMSendMailReq::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMSendMailReq::clear_session() {
  session_ = GOOGLE_LONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::int64 GMSendMailReq::session() const {
  return session_;
}
inline void GMSendMailReq::set_session(::google::protobuf::int64 value) {
  set_has_session();
  session_ = value;
}

// -------------------------------------------------------------------

// GMGeneralResp

// required int32 result = 1;
inline bool GMGeneralResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMGeneralResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMGeneralResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMGeneralResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GMGeneralResp::result() const {
  return result_;
}
inline void GMGeneralResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required int32 fd = 2;
inline bool GMGeneralResp::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMGeneralResp::set_has_fd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMGeneralResp::clear_has_fd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMGeneralResp::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GMGeneralResp::fd() const {
  return fd_;
}
inline void GMGeneralResp::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// required int64 session = 3;
inline bool GMGeneralResp::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMGeneralResp::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMGeneralResp::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMGeneralResp::clear_session() {
  session_ = GOOGLE_LONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::int64 GMGeneralResp::session() const {
  return session_;
}
inline void GMGeneralResp::set_session(::google::protobuf::int64 value) {
  set_has_session();
  session_ = value;
}

// -------------------------------------------------------------------

// UserSnapInfo

// optional string uid = 1;
inline bool UserSnapInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserSnapInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserSnapInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserSnapInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& UserSnapInfo::uid() const {
  return *uid_;
}
inline void UserSnapInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void UserSnapInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void UserSnapInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSnapInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* UserSnapInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSnapInfo::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nick = 2;
inline bool UserSnapInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserSnapInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserSnapInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserSnapInfo::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& UserSnapInfo::nick() const {
  return *nick_;
}
inline void UserSnapInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UserSnapInfo::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UserSnapInfo::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSnapInfo::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* UserSnapInfo::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSnapInfo::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string qd = 3;
inline bool UserSnapInfo::has_qd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserSnapInfo::set_has_qd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserSnapInfo::clear_has_qd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserSnapInfo::clear_qd() {
  if (qd_ != &::google::protobuf::internal::kEmptyString) {
    qd_->clear();
  }
  clear_has_qd();
}
inline const ::std::string& UserSnapInfo::qd() const {
  return *qd_;
}
inline void UserSnapInfo::set_qd(const ::std::string& value) {
  set_has_qd();
  if (qd_ == &::google::protobuf::internal::kEmptyString) {
    qd_ = new ::std::string;
  }
  qd_->assign(value);
}
inline void UserSnapInfo::set_qd(const char* value) {
  set_has_qd();
  if (qd_ == &::google::protobuf::internal::kEmptyString) {
    qd_ = new ::std::string;
  }
  qd_->assign(value);
}
inline void UserSnapInfo::set_qd(const char* value, size_t size) {
  set_has_qd();
  if (qd_ == &::google::protobuf::internal::kEmptyString) {
    qd_ = new ::std::string;
  }
  qd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSnapInfo::mutable_qd() {
  set_has_qd();
  if (qd_ == &::google::protobuf::internal::kEmptyString) {
    qd_ = new ::std::string;
  }
  return qd_;
}
inline ::std::string* UserSnapInfo::release_qd() {
  clear_has_qd();
  if (qd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qd_;
    qd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSnapInfo::set_allocated_qd(::std::string* qd) {
  if (qd_ != &::google::protobuf::internal::kEmptyString) {
    delete qd_;
  }
  if (qd) {
    set_has_qd();
    qd_ = qd;
  } else {
    clear_has_qd();
    qd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 lv = 4;
inline bool UserSnapInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserSnapInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserSnapInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserSnapInfo::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 UserSnapInfo::lv() const {
  return lv_;
}
inline void UserSnapInfo::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int64 exp = 5;
inline bool UserSnapInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserSnapInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserSnapInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserSnapInfo::clear_exp() {
  exp_ = GOOGLE_LONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::int64 UserSnapInfo::exp() const {
  return exp_;
}
inline void UserSnapInfo::set_exp(::google::protobuf::int64 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 viplv = 6;
inline bool UserSnapInfo::has_viplv() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserSnapInfo::set_has_viplv() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserSnapInfo::clear_has_viplv() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserSnapInfo::clear_viplv() {
  viplv_ = 0;
  clear_has_viplv();
}
inline ::google::protobuf::int32 UserSnapInfo::viplv() const {
  return viplv_;
}
inline void UserSnapInfo::set_viplv(::google::protobuf::int32 value) {
  set_has_viplv();
  viplv_ = value;
}

// optional int64 vipscore = 7;
inline bool UserSnapInfo::has_vipscore() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserSnapInfo::set_has_vipscore() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserSnapInfo::clear_has_vipscore() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserSnapInfo::clear_vipscore() {
  vipscore_ = GOOGLE_LONGLONG(0);
  clear_has_vipscore();
}
inline ::google::protobuf::int64 UserSnapInfo::vipscore() const {
  return vipscore_;
}
inline void UserSnapInfo::set_vipscore(::google::protobuf::int64 value) {
  set_has_vipscore();
  vipscore_ = value;
}

// optional int32 totaldep = 8;
inline bool UserSnapInfo::has_totaldep() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserSnapInfo::set_has_totaldep() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserSnapInfo::clear_has_totaldep() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserSnapInfo::clear_totaldep() {
  totaldep_ = 0;
  clear_has_totaldep();
}
inline ::google::protobuf::int32 UserSnapInfo::totaldep() const {
  return totaldep_;
}
inline void UserSnapInfo::set_totaldep(::google::protobuf::int32 value) {
  set_has_totaldep();
  totaldep_ = value;
}

// optional int32 totalrmb = 9;
inline bool UserSnapInfo::has_totalrmb() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserSnapInfo::set_has_totalrmb() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserSnapInfo::clear_has_totalrmb() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserSnapInfo::clear_totalrmb() {
  totalrmb_ = 0;
  clear_has_totalrmb();
}
inline ::google::protobuf::int32 UserSnapInfo::totalrmb() const {
  return totalrmb_;
}
inline void UserSnapInfo::set_totalrmb(::google::protobuf::int32 value) {
  set_has_totalrmb();
  totalrmb_ = value;
}

// optional int32 gold = 10;
inline bool UserSnapInfo::has_gold() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserSnapInfo::set_has_gold() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserSnapInfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserSnapInfo::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 UserSnapInfo::gold() const {
  return gold_;
}
inline void UserSnapInfo::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// optional int32 money = 11;
inline bool UserSnapInfo::has_money() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserSnapInfo::set_has_money() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserSnapInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserSnapInfo::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 UserSnapInfo::money() const {
  return money_;
}
inline void UserSnapInfo::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 php = 12;
inline bool UserSnapInfo::has_php() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserSnapInfo::set_has_php() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserSnapInfo::clear_has_php() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserSnapInfo::clear_php() {
  php_ = 0;
  clear_has_php();
}
inline ::google::protobuf::int32 UserSnapInfo::php() const {
  return php_;
}
inline void UserSnapInfo::set_php(::google::protobuf::int32 value) {
  set_has_php();
  php_ = value;
}

// optional int32 maxpower = 13;
inline bool UserSnapInfo::has_maxpower() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserSnapInfo::set_has_maxpower() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserSnapInfo::clear_has_maxpower() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserSnapInfo::clear_maxpower() {
  maxpower_ = 0;
  clear_has_maxpower();
}
inline ::google::protobuf::int32 UserSnapInfo::maxpower() const {
  return maxpower_;
}
inline void UserSnapInfo::set_maxpower(::google::protobuf::int32 value) {
  set_has_maxpower();
  maxpower_ = value;
}

// optional int32 state = 14;
inline bool UserSnapInfo::has_state() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserSnapInfo::set_has_state() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserSnapInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserSnapInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 UserSnapInfo::state() const {
  return state_;
}
inline void UserSnapInfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional int32 stagelv = 15;
inline bool UserSnapInfo::has_stagelv() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserSnapInfo::set_has_stagelv() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserSnapInfo::clear_has_stagelv() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserSnapInfo::clear_stagelv() {
  stagelv_ = 0;
  clear_has_stagelv();
}
inline ::google::protobuf::int32 UserSnapInfo::stagelv() const {
  return stagelv_;
}
inline void UserSnapInfo::set_stagelv(::google::protobuf::int32 value) {
  set_has_stagelv();
  stagelv_ = value;
}

// optional int32 maxrank = 16;
inline bool UserSnapInfo::has_maxrank() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserSnapInfo::set_has_maxrank() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserSnapInfo::clear_has_maxrank() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserSnapInfo::clear_maxrank() {
  maxrank_ = 0;
  clear_has_maxrank();
}
inline ::google::protobuf::int32 UserSnapInfo::maxrank() const {
  return maxrank_;
}
inline void UserSnapInfo::set_maxrank(::google::protobuf::int32 value) {
  set_has_maxrank();
  maxrank_ = value;
}

// optional string menpai = 17;
inline bool UserSnapInfo::has_menpai() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserSnapInfo::set_has_menpai() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserSnapInfo::clear_has_menpai() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserSnapInfo::clear_menpai() {
  if (menpai_ != &::google::protobuf::internal::kEmptyString) {
    menpai_->clear();
  }
  clear_has_menpai();
}
inline const ::std::string& UserSnapInfo::menpai() const {
  return *menpai_;
}
inline void UserSnapInfo::set_menpai(const ::std::string& value) {
  set_has_menpai();
  if (menpai_ == &::google::protobuf::internal::kEmptyString) {
    menpai_ = new ::std::string;
  }
  menpai_->assign(value);
}
inline void UserSnapInfo::set_menpai(const char* value) {
  set_has_menpai();
  if (menpai_ == &::google::protobuf::internal::kEmptyString) {
    menpai_ = new ::std::string;
  }
  menpai_->assign(value);
}
inline void UserSnapInfo::set_menpai(const char* value, size_t size) {
  set_has_menpai();
  if (menpai_ == &::google::protobuf::internal::kEmptyString) {
    menpai_ = new ::std::string;
  }
  menpai_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSnapInfo::mutable_menpai() {
  set_has_menpai();
  if (menpai_ == &::google::protobuf::internal::kEmptyString) {
    menpai_ = new ::std::string;
  }
  return menpai_;
}
inline ::std::string* UserSnapInfo::release_menpai() {
  clear_has_menpai();
  if (menpai_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = menpai_;
    menpai_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSnapInfo::set_allocated_menpai(::std::string* menpai) {
  if (menpai_ != &::google::protobuf::internal::kEmptyString) {
    delete menpai_;
  }
  if (menpai) {
    set_has_menpai();
    menpai_ = menpai;
  } else {
    clear_has_menpai();
    menpai_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 51;
inline bool UserSnapInfo::has_ip() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UserSnapInfo::set_has_ip() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UserSnapInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UserSnapInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& UserSnapInfo::ip() const {
  return *ip_;
}
inline void UserSnapInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UserSnapInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UserSnapInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSnapInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* UserSnapInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSnapInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GMGetUserSnapReq

// optional string username = 1;
inline bool GMGetUserSnapReq::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMGetUserSnapReq::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMGetUserSnapReq::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMGetUserSnapReq::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& GMGetUserSnapReq::username() const {
  return *username_;
}
inline void GMGetUserSnapReq::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GMGetUserSnapReq::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GMGetUserSnapReq::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMGetUserSnapReq::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* GMGetUserSnapReq::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMGetUserSnapReq::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string flags = 2;
inline bool GMGetUserSnapReq::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMGetUserSnapReq::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMGetUserSnapReq::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMGetUserSnapReq::clear_flags() {
  if (flags_ != &::google::protobuf::internal::kEmptyString) {
    flags_->clear();
  }
  clear_has_flags();
}
inline const ::std::string& GMGetUserSnapReq::flags() const {
  return *flags_;
}
inline void GMGetUserSnapReq::set_flags(const ::std::string& value) {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::kEmptyString) {
    flags_ = new ::std::string;
  }
  flags_->assign(value);
}
inline void GMGetUserSnapReq::set_flags(const char* value) {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::kEmptyString) {
    flags_ = new ::std::string;
  }
  flags_->assign(value);
}
inline void GMGetUserSnapReq::set_flags(const char* value, size_t size) {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::kEmptyString) {
    flags_ = new ::std::string;
  }
  flags_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMGetUserSnapReq::mutable_flags() {
  set_has_flags();
  if (flags_ == &::google::protobuf::internal::kEmptyString) {
    flags_ = new ::std::string;
  }
  return flags_;
}
inline ::std::string* GMGetUserSnapReq::release_flags() {
  clear_has_flags();
  if (flags_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flags_;
    flags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMGetUserSnapReq::set_allocated_flags(::std::string* flags) {
  if (flags_ != &::google::protobuf::internal::kEmptyString) {
    delete flags_;
  }
  if (flags) {
    set_has_flags();
    flags_ = flags;
  } else {
    clear_has_flags();
    flags_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gmuser = 11;
inline bool GMGetUserSnapReq::has_gmuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMGetUserSnapReq::set_has_gmuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMGetUserSnapReq::clear_has_gmuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMGetUserSnapReq::clear_gmuser() {
  if (gmuser_ != &::google::protobuf::internal::kEmptyString) {
    gmuser_->clear();
  }
  clear_has_gmuser();
}
inline const ::std::string& GMGetUserSnapReq::gmuser() const {
  return *gmuser_;
}
inline void GMGetUserSnapReq::set_gmuser(const ::std::string& value) {
  set_has_gmuser();
  if (gmuser_ == &::google::protobuf::internal::kEmptyString) {
    gmuser_ = new ::std::string;
  }
  gmuser_->assign(value);
}
inline void GMGetUserSnapReq::set_gmuser(const char* value) {
  set_has_gmuser();
  if (gmuser_ == &::google::protobuf::internal::kEmptyString) {
    gmuser_ = new ::std::string;
  }
  gmuser_->assign(value);
}
inline void GMGetUserSnapReq::set_gmuser(const char* value, size_t size) {
  set_has_gmuser();
  if (gmuser_ == &::google::protobuf::internal::kEmptyString) {
    gmuser_ = new ::std::string;
  }
  gmuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMGetUserSnapReq::mutable_gmuser() {
  set_has_gmuser();
  if (gmuser_ == &::google::protobuf::internal::kEmptyString) {
    gmuser_ = new ::std::string;
  }
  return gmuser_;
}
inline ::std::string* GMGetUserSnapReq::release_gmuser() {
  clear_has_gmuser();
  if (gmuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gmuser_;
    gmuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMGetUserSnapReq::set_allocated_gmuser(::std::string* gmuser) {
  if (gmuser_ != &::google::protobuf::internal::kEmptyString) {
    delete gmuser_;
  }
  if (gmuser) {
    set_has_gmuser();
    gmuser_ = gmuser;
  } else {
    clear_has_gmuser();
    gmuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gmkey = 12;
inline bool GMGetUserSnapReq::has_gmkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMGetUserSnapReq::set_has_gmkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMGetUserSnapReq::clear_has_gmkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMGetUserSnapReq::clear_gmkey() {
  if (gmkey_ != &::google::protobuf::internal::kEmptyString) {
    gmkey_->clear();
  }
  clear_has_gmkey();
}
inline const ::std::string& GMGetUserSnapReq::gmkey() const {
  return *gmkey_;
}
inline void GMGetUserSnapReq::set_gmkey(const ::std::string& value) {
  set_has_gmkey();
  if (gmkey_ == &::google::protobuf::internal::kEmptyString) {
    gmkey_ = new ::std::string;
  }
  gmkey_->assign(value);
}
inline void GMGetUserSnapReq::set_gmkey(const char* value) {
  set_has_gmkey();
  if (gmkey_ == &::google::protobuf::internal::kEmptyString) {
    gmkey_ = new ::std::string;
  }
  gmkey_->assign(value);
}
inline void GMGetUserSnapReq::set_gmkey(const char* value, size_t size) {
  set_has_gmkey();
  if (gmkey_ == &::google::protobuf::internal::kEmptyString) {
    gmkey_ = new ::std::string;
  }
  gmkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMGetUserSnapReq::mutable_gmkey() {
  set_has_gmkey();
  if (gmkey_ == &::google::protobuf::internal::kEmptyString) {
    gmkey_ = new ::std::string;
  }
  return gmkey_;
}
inline ::std::string* GMGetUserSnapReq::release_gmkey() {
  clear_has_gmkey();
  if (gmkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gmkey_;
    gmkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMGetUserSnapReq::set_allocated_gmkey(::std::string* gmkey) {
  if (gmkey_ != &::google::protobuf::internal::kEmptyString) {
    delete gmkey_;
  }
  if (gmkey) {
    set_has_gmkey();
    gmkey_ = gmkey;
  } else {
    clear_has_gmkey();
    gmkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fd = 21;
inline bool GMGetUserSnapReq::has_fd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GMGetUserSnapReq::set_has_fd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GMGetUserSnapReq::clear_has_fd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GMGetUserSnapReq::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GMGetUserSnapReq::fd() const {
  return fd_;
}
inline void GMGetUserSnapReq::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int64 session = 22;
inline bool GMGetUserSnapReq::has_session() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GMGetUserSnapReq::set_has_session() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GMGetUserSnapReq::clear_has_session() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GMGetUserSnapReq::clear_session() {
  session_ = GOOGLE_LONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::int64 GMGetUserSnapReq::session() const {
  return session_;
}
inline void GMGetUserSnapReq::set_session(::google::protobuf::int64 value) {
  set_has_session();
  session_ = value;
}

// -------------------------------------------------------------------

// GMGetUserSnapResp

// required .GMGetUserSnapResp.Result result = 1;
inline bool GMGetUserSnapResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMGetUserSnapResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMGetUserSnapResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMGetUserSnapResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::GMGetUserSnapResp_Result GMGetUserSnapResp::result() const {
  return static_cast< ::GMGetUserSnapResp_Result >(result_);
}
inline void GMGetUserSnapResp::set_result(::GMGetUserSnapResp_Result value) {
  assert(::GMGetUserSnapResp_Result_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSnapInfo info = 2;
inline bool GMGetUserSnapResp::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMGetUserSnapResp::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMGetUserSnapResp::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMGetUserSnapResp::clear_info() {
  if (info_ != NULL) info_->::UserSnapInfo::Clear();
  clear_has_info();
}
inline const ::UserSnapInfo& GMGetUserSnapResp::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::UserSnapInfo* GMGetUserSnapResp::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::UserSnapInfo;
  return info_;
}
inline ::UserSnapInfo* GMGetUserSnapResp::release_info() {
  clear_has_info();
  ::UserSnapInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void GMGetUserSnapResp::set_allocated_info(::UserSnapInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional int32 fd = 21;
inline bool GMGetUserSnapResp::has_fd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMGetUserSnapResp::set_has_fd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMGetUserSnapResp::clear_has_fd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMGetUserSnapResp::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GMGetUserSnapResp::fd() const {
  return fd_;
}
inline void GMGetUserSnapResp::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int64 session = 22;
inline bool GMGetUserSnapResp::has_session() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMGetUserSnapResp::set_has_session() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMGetUserSnapResp::clear_has_session() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMGetUserSnapResp::clear_session() {
  session_ = GOOGLE_LONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::int64 GMGetUserSnapResp::session() const {
  return session_;
}
inline void GMGetUserSnapResp::set_session(::google::protobuf::int64 value) {
  set_has_session();
  session_ = value;
}

// -------------------------------------------------------------------

// GMBlockReq

// required string uid = 1;
inline bool GMBlockReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMBlockReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMBlockReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMBlockReq::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& GMBlockReq::uid() const {
  return *uid_;
}
inline void GMBlockReq::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void GMBlockReq::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void GMBlockReq::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMBlockReq::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* GMBlockReq::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMBlockReq::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 type = 2;
inline bool GMBlockReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMBlockReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMBlockReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMBlockReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GMBlockReq::type() const {
  return type_;
}
inline void GMBlockReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 blocktime = 3;
inline bool GMBlockReq::has_blocktime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMBlockReq::set_has_blocktime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMBlockReq::clear_has_blocktime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMBlockReq::clear_blocktime() {
  blocktime_ = 0;
  clear_has_blocktime();
}
inline ::google::protobuf::int32 GMBlockReq::blocktime() const {
  return blocktime_;
}
inline void GMBlockReq::set_blocktime(::google::protobuf::int32 value) {
  set_has_blocktime();
  blocktime_ = value;
}

// required int32 fd = 4;
inline bool GMBlockReq::has_fd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMBlockReq::set_has_fd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMBlockReq::clear_has_fd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMBlockReq::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GMBlockReq::fd() const {
  return fd_;
}
inline void GMBlockReq::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// required int64 session = 5;
inline bool GMBlockReq::has_session() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GMBlockReq::set_has_session() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GMBlockReq::clear_has_session() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GMBlockReq::clear_session() {
  session_ = GOOGLE_LONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::int64 GMBlockReq::session() const {
  return session_;
}
inline void GMBlockReq::set_session(::google::protobuf::int64 value) {
  set_has_session();
  session_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GMFightResp_Result>() {
  return ::GMFightResp_Result_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GMAddItemResp_Result>() {
  return ::GMAddItemResp_Result_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GMGetUserSnapResp_Result>() {
  return ::GMGetUserSnapResp_Result_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gm_5fcmd_2eproto__INCLUDED
