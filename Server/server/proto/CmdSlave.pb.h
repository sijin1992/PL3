// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdSlave.proto

#ifndef PROTOBUF_CmdSlave_2eproto__INCLUDED
#define PROTOBUF_CmdSlave_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Item.pb.h"
#include "AirShip.pb.h"
#include "Slave.pb.h"
#include "UserSync.pb.h"
#include "PvpInfo.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdSlave_2eproto();
void protobuf_AssignDesc_CmdSlave_2eproto();
void protobuf_ShutdownFile_CmdSlave_2eproto();

class SlaveSyncDataReq;
class SlaveSyncDataResp;
class SlaveGetResReq;
class SlaveGetResResp;
class SlaveFreeReq;
class SlaveFreeResp;
class SlaveShowReq;
class SlaveShowResp;
class SlaveWorkReq;
class SlaveWorkResp;
class SlaveFawnOnReq;
class SlaveFawnOnResp;
class SlaveHelpReq;
class SlaveHelpResp;
class SlaveSearchReq;
class SlaveSearchResp;
class SlaveAddTimesReq;
class SlaveAddTimesResp;
class SlaveAttackReq;
class SlaveAttackResp;

enum SlaveSyncDataResp_SlaveSyncDataRet {
  SlaveSyncDataResp_SlaveSyncDataRet_OK = 0,
  SlaveSyncDataResp_SlaveSyncDataRet_FAIL = -1
};
bool SlaveSyncDataResp_SlaveSyncDataRet_IsValid(int value);
const SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp_SlaveSyncDataRet_SlaveSyncDataRet_MIN = SlaveSyncDataResp_SlaveSyncDataRet_FAIL;
const SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp_SlaveSyncDataRet_SlaveSyncDataRet_MAX = SlaveSyncDataResp_SlaveSyncDataRet_OK;
const int SlaveSyncDataResp_SlaveSyncDataRet_SlaveSyncDataRet_ARRAYSIZE = SlaveSyncDataResp_SlaveSyncDataRet_SlaveSyncDataRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveSyncDataResp_SlaveSyncDataRet_descriptor();
inline const ::std::string& SlaveSyncDataResp_SlaveSyncDataRet_Name(SlaveSyncDataResp_SlaveSyncDataRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveSyncDataResp_SlaveSyncDataRet_descriptor(), value);
}
inline bool SlaveSyncDataResp_SlaveSyncDataRet_Parse(
    const ::std::string& name, SlaveSyncDataResp_SlaveSyncDataRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveSyncDataResp_SlaveSyncDataRet>(
    SlaveSyncDataResp_SlaveSyncDataRet_descriptor(), name, value);
}
enum SlaveGetResResp_SlaveGetResRet {
  SlaveGetResResp_SlaveGetResRet_OK = 0,
  SlaveGetResResp_SlaveGetResRet_FAIL = -1,
  SlaveGetResResp_SlaveGetResRet_NOT_MY_SLAVE = 1,
  SlaveGetResResp_SlaveGetResRet_CD_TIME = 2
};
bool SlaveGetResResp_SlaveGetResRet_IsValid(int value);
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp_SlaveGetResRet_SlaveGetResRet_MIN = SlaveGetResResp_SlaveGetResRet_FAIL;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp_SlaveGetResRet_SlaveGetResRet_MAX = SlaveGetResResp_SlaveGetResRet_CD_TIME;
const int SlaveGetResResp_SlaveGetResRet_SlaveGetResRet_ARRAYSIZE = SlaveGetResResp_SlaveGetResRet_SlaveGetResRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveGetResResp_SlaveGetResRet_descriptor();
inline const ::std::string& SlaveGetResResp_SlaveGetResRet_Name(SlaveGetResResp_SlaveGetResRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveGetResResp_SlaveGetResRet_descriptor(), value);
}
inline bool SlaveGetResResp_SlaveGetResRet_Parse(
    const ::std::string& name, SlaveGetResResp_SlaveGetResRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveGetResResp_SlaveGetResRet>(
    SlaveGetResResp_SlaveGetResRet_descriptor(), name, value);
}
enum SlaveFreeResp_SlaveFreeRet {
  SlaveFreeResp_SlaveFreeRet_OK = 0,
  SlaveFreeResp_SlaveFreeRet_FAIL = -1,
  SlaveFreeResp_SlaveFreeRet_NOT_MY_SLAVE = 1,
  SlaveFreeResp_SlaveFreeRet_FREE_SLAVE_ERROR = 2
};
bool SlaveFreeResp_SlaveFreeRet_IsValid(int value);
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp_SlaveFreeRet_SlaveFreeRet_MIN = SlaveFreeResp_SlaveFreeRet_FAIL;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp_SlaveFreeRet_SlaveFreeRet_MAX = SlaveFreeResp_SlaveFreeRet_FREE_SLAVE_ERROR;
const int SlaveFreeResp_SlaveFreeRet_SlaveFreeRet_ARRAYSIZE = SlaveFreeResp_SlaveFreeRet_SlaveFreeRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveFreeResp_SlaveFreeRet_descriptor();
inline const ::std::string& SlaveFreeResp_SlaveFreeRet_Name(SlaveFreeResp_SlaveFreeRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveFreeResp_SlaveFreeRet_descriptor(), value);
}
inline bool SlaveFreeResp_SlaveFreeRet_Parse(
    const ::std::string& name, SlaveFreeResp_SlaveFreeRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveFreeResp_SlaveFreeRet>(
    SlaveFreeResp_SlaveFreeRet_descriptor(), name, value);
}
enum SlaveShowResp_SlaveShowRet {
  SlaveShowResp_SlaveShowRet_OK = 0,
  SlaveShowResp_SlaveShowRet_FAIL = -1,
  SlaveShowResp_SlaveShowRet_NOT_MY_SLAVE = 1,
  SlaveShowResp_SlaveShowRet_NO_MONEY = 2,
  SlaveShowResp_SlaveShowRet_STATE_ERROR = 3,
  SlaveShowResp_SlaveShowRet_TYPE_ERROR = 4,
  SlaveShowResp_SlaveShowRet_NO_MASTER = 5,
  SlaveShowResp_SlaveShowRet_WATCH_NUM_MAX = 6,
  SlaveShowResp_SlaveShowRet_WATCHED = 7
};
bool SlaveShowResp_SlaveShowRet_IsValid(int value);
const SlaveShowResp_SlaveShowRet SlaveShowResp_SlaveShowRet_SlaveShowRet_MIN = SlaveShowResp_SlaveShowRet_FAIL;
const SlaveShowResp_SlaveShowRet SlaveShowResp_SlaveShowRet_SlaveShowRet_MAX = SlaveShowResp_SlaveShowRet_WATCHED;
const int SlaveShowResp_SlaveShowRet_SlaveShowRet_ARRAYSIZE = SlaveShowResp_SlaveShowRet_SlaveShowRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveShowResp_SlaveShowRet_descriptor();
inline const ::std::string& SlaveShowResp_SlaveShowRet_Name(SlaveShowResp_SlaveShowRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveShowResp_SlaveShowRet_descriptor(), value);
}
inline bool SlaveShowResp_SlaveShowRet_Parse(
    const ::std::string& name, SlaveShowResp_SlaveShowRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveShowResp_SlaveShowRet>(
    SlaveShowResp_SlaveShowRet_descriptor(), name, value);
}
enum SlaveWorkResp_SlaveWorkRet {
  SlaveWorkResp_SlaveWorkRet_OK = 0,
  SlaveWorkResp_SlaveWorkRet_FAIL = -1,
  SlaveWorkResp_SlaveWorkRet_NOT_MY_SLAVE = 1,
  SlaveWorkResp_SlaveWorkRet_CD_TIME = 2
};
bool SlaveWorkResp_SlaveWorkRet_IsValid(int value);
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp_SlaveWorkRet_SlaveWorkRet_MIN = SlaveWorkResp_SlaveWorkRet_FAIL;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp_SlaveWorkRet_SlaveWorkRet_MAX = SlaveWorkResp_SlaveWorkRet_CD_TIME;
const int SlaveWorkResp_SlaveWorkRet_SlaveWorkRet_ARRAYSIZE = SlaveWorkResp_SlaveWorkRet_SlaveWorkRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveWorkResp_SlaveWorkRet_descriptor();
inline const ::std::string& SlaveWorkResp_SlaveWorkRet_Name(SlaveWorkResp_SlaveWorkRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveWorkResp_SlaveWorkRet_descriptor(), value);
}
inline bool SlaveWorkResp_SlaveWorkRet_Parse(
    const ::std::string& name, SlaveWorkResp_SlaveWorkRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveWorkResp_SlaveWorkRet>(
    SlaveWorkResp_SlaveWorkRet_descriptor(), name, value);
}
enum SlaveFawnOnResp_SlaveFawnOnRet {
  SlaveFawnOnResp_SlaveFawnOnRet_OK = 0,
  SlaveFawnOnResp_SlaveFawnOnRet_FAIL = -1,
  SlaveFawnOnResp_SlaveFawnOnRet_NO_MASTER = 1,
  SlaveFawnOnResp_SlaveFawnOnRet_CD_TIME = 2
};
bool SlaveFawnOnResp_SlaveFawnOnRet_IsValid(int value);
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp_SlaveFawnOnRet_SlaveFawnOnRet_MIN = SlaveFawnOnResp_SlaveFawnOnRet_FAIL;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp_SlaveFawnOnRet_SlaveFawnOnRet_MAX = SlaveFawnOnResp_SlaveFawnOnRet_CD_TIME;
const int SlaveFawnOnResp_SlaveFawnOnRet_SlaveFawnOnRet_ARRAYSIZE = SlaveFawnOnResp_SlaveFawnOnRet_SlaveFawnOnRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveFawnOnResp_SlaveFawnOnRet_descriptor();
inline const ::std::string& SlaveFawnOnResp_SlaveFawnOnRet_Name(SlaveFawnOnResp_SlaveFawnOnRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveFawnOnResp_SlaveFawnOnRet_descriptor(), value);
}
inline bool SlaveFawnOnResp_SlaveFawnOnRet_Parse(
    const ::std::string& name, SlaveFawnOnResp_SlaveFawnOnRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveFawnOnResp_SlaveFawnOnRet>(
    SlaveFawnOnResp_SlaveFawnOnRet_descriptor(), name, value);
}
enum SlaveHelpResp_SlaveHelpRet {
  SlaveHelpResp_SlaveHelpRet_OK = 0,
  SlaveHelpResp_SlaveHelpRet_FAIL = -1,
  SlaveHelpResp_SlaveHelpRet_NO_MASTER = 1,
  SlaveHelpResp_SlaveHelpRet_CD_TIME = 2,
  SlaveHelpResp_SlaveHelpRet_SEND_LIST_EMPTY = 3
};
bool SlaveHelpResp_SlaveHelpRet_IsValid(int value);
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp_SlaveHelpRet_SlaveHelpRet_MIN = SlaveHelpResp_SlaveHelpRet_FAIL;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp_SlaveHelpRet_SlaveHelpRet_MAX = SlaveHelpResp_SlaveHelpRet_SEND_LIST_EMPTY;
const int SlaveHelpResp_SlaveHelpRet_SlaveHelpRet_ARRAYSIZE = SlaveHelpResp_SlaveHelpRet_SlaveHelpRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveHelpResp_SlaveHelpRet_descriptor();
inline const ::std::string& SlaveHelpResp_SlaveHelpRet_Name(SlaveHelpResp_SlaveHelpRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveHelpResp_SlaveHelpRet_descriptor(), value);
}
inline bool SlaveHelpResp_SlaveHelpRet_Parse(
    const ::std::string& name, SlaveHelpResp_SlaveHelpRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveHelpResp_SlaveHelpRet>(
    SlaveHelpResp_SlaveHelpRet_descriptor(), name, value);
}
enum SlaveSearchResp_SlaveSearchRet {
  SlaveSearchResp_SlaveSearchRet_OK = 0,
  SlaveSearchResp_SlaveSearchRet_FAIL = -1,
  SlaveSearchResp_SlaveSearchRet_EMPTY = 1,
  SlaveSearchResp_SlaveSearchRet_HAS_MASTER = 2,
  SlaveSearchResp_SlaveSearchRet_ERROR_TYPE = 3
};
bool SlaveSearchResp_SlaveSearchRet_IsValid(int value);
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp_SlaveSearchRet_SlaveSearchRet_MIN = SlaveSearchResp_SlaveSearchRet_FAIL;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp_SlaveSearchRet_SlaveSearchRet_MAX = SlaveSearchResp_SlaveSearchRet_ERROR_TYPE;
const int SlaveSearchResp_SlaveSearchRet_SlaveSearchRet_ARRAYSIZE = SlaveSearchResp_SlaveSearchRet_SlaveSearchRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveSearchResp_SlaveSearchRet_descriptor();
inline const ::std::string& SlaveSearchResp_SlaveSearchRet_Name(SlaveSearchResp_SlaveSearchRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveSearchResp_SlaveSearchRet_descriptor(), value);
}
inline bool SlaveSearchResp_SlaveSearchRet_Parse(
    const ::std::string& name, SlaveSearchResp_SlaveSearchRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveSearchResp_SlaveSearchRet>(
    SlaveSearchResp_SlaveSearchRet_descriptor(), name, value);
}
enum SlaveAddTimesResp_SlaveAddTimesRet {
  SlaveAddTimesResp_SlaveAddTimesRet_OK = 0,
  SlaveAddTimesResp_SlaveAddTimesRet_FAIL = -1,
  SlaveAddTimesResp_SlaveAddTimesRet_NO_MONEY = 1
};
bool SlaveAddTimesResp_SlaveAddTimesRet_IsValid(int value);
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp_SlaveAddTimesRet_SlaveAddTimesRet_MIN = SlaveAddTimesResp_SlaveAddTimesRet_FAIL;
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp_SlaveAddTimesRet_SlaveAddTimesRet_MAX = SlaveAddTimesResp_SlaveAddTimesRet_NO_MONEY;
const int SlaveAddTimesResp_SlaveAddTimesRet_SlaveAddTimesRet_ARRAYSIZE = SlaveAddTimesResp_SlaveAddTimesRet_SlaveAddTimesRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveAddTimesResp_SlaveAddTimesRet_descriptor();
inline const ::std::string& SlaveAddTimesResp_SlaveAddTimesRet_Name(SlaveAddTimesResp_SlaveAddTimesRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveAddTimesResp_SlaveAddTimesRet_descriptor(), value);
}
inline bool SlaveAddTimesResp_SlaveAddTimesRet_Parse(
    const ::std::string& name, SlaveAddTimesResp_SlaveAddTimesRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveAddTimesResp_SlaveAddTimesRet>(
    SlaveAddTimesResp_SlaveAddTimesRet_descriptor(), name, value);
}
enum SlaveAttackResp_SlaveAttackRet {
  SlaveAttackResp_SlaveAttackRet_OK = 0,
  SlaveAttackResp_SlaveAttackRet_FAIL = -1,
  SlaveAttackResp_SlaveAttackRet_NO_EMEMY = 1,
  SlaveAttackResp_SlaveAttackRet_ATTACK_SELF = 2,
  SlaveAttackResp_SlaveAttackRet_ERROR_TYPE = 3,
  SlaveAttackResp_SlaveAttackRet_HAS_MASTER = 4,
  SlaveAttackResp_SlaveAttackRet_NO_TIMES = 5,
  SlaveAttackResp_SlaveAttackRet_CD_TIME = 6,
  SlaveAttackResp_SlaveAttackRet_NO_SHIPS = 7,
  SlaveAttackResp_SlaveAttackRet_NO_DURABLE = 8,
  SlaveAttackResp_SlaveAttackRet_FIXING = 9,
  SlaveAttackResp_SlaveAttackRet_NOT_SLAVE_MASTER = 10,
  SlaveAttackResp_SlaveAttackRet_MAX_SLAVE = 11,
  SlaveAttackResp_SlaveAttackRet_NO_MASTER = 12,
  SlaveAttackResp_SlaveAttackRet_HAS_SLAVE = 13,
  SlaveAttackResp_SlaveAttackRet_SHOWING = 14,
  SlaveAttackResp_SlaveAttackRet_CATCH_ERROR = 15,
  SlaveAttackResp_SlaveAttackRet_OUTING = 16
};
bool SlaveAttackResp_SlaveAttackRet_IsValid(int value);
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp_SlaveAttackRet_SlaveAttackRet_MIN = SlaveAttackResp_SlaveAttackRet_FAIL;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp_SlaveAttackRet_SlaveAttackRet_MAX = SlaveAttackResp_SlaveAttackRet_OUTING;
const int SlaveAttackResp_SlaveAttackRet_SlaveAttackRet_ARRAYSIZE = SlaveAttackResp_SlaveAttackRet_SlaveAttackRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveAttackResp_SlaveAttackRet_descriptor();
inline const ::std::string& SlaveAttackResp_SlaveAttackRet_Name(SlaveAttackResp_SlaveAttackRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveAttackResp_SlaveAttackRet_descriptor(), value);
}
inline bool SlaveAttackResp_SlaveAttackRet_Parse(
    const ::std::string& name, SlaveAttackResp_SlaveAttackRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveAttackResp_SlaveAttackRet>(
    SlaveAttackResp_SlaveAttackRet_descriptor(), name, value);
}
// ===================================================================

class SlaveSyncDataReq : public ::google::protobuf::Message {
 public:
  SlaveSyncDataReq();
  virtual ~SlaveSyncDataReq();

  SlaveSyncDataReq(const SlaveSyncDataReq& from);

  inline SlaveSyncDataReq& operator=(const SlaveSyncDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveSyncDataReq& default_instance();

  void Swap(SlaveSyncDataReq* other);

  // implements Message ----------------------------------------------

  SlaveSyncDataReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveSyncDataReq& from);
  void MergeFrom(const SlaveSyncDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated string user_name_list = 2;
  inline int user_name_list_size() const;
  inline void clear_user_name_list();
  static const int kUserNameListFieldNumber = 2;
  inline const ::std::string& user_name_list(int index) const;
  inline ::std::string* mutable_user_name_list(int index);
  inline void set_user_name_list(int index, const ::std::string& value);
  inline void set_user_name_list(int index, const char* value);
  inline void set_user_name_list(int index, const char* value, size_t size);
  inline ::std::string* add_user_name_list();
  inline void add_user_name_list(const ::std::string& value);
  inline void add_user_name_list(const char* value);
  inline void add_user_name_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_name_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_name_list();

  // @@protoc_insertion_point(class_scope:SlaveSyncDataReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> user_name_list_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveSyncDataReq* default_instance_;
};
// -------------------------------------------------------------------

class SlaveSyncDataResp : public ::google::protobuf::Message {
 public:
  SlaveSyncDataResp();
  virtual ~SlaveSyncDataResp();

  SlaveSyncDataResp(const SlaveSyncDataResp& from);

  inline SlaveSyncDataResp& operator=(const SlaveSyncDataResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveSyncDataResp& default_instance();

  void Swap(SlaveSyncDataResp* other);

  // implements Message ----------------------------------------------

  SlaveSyncDataResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveSyncDataResp& from);
  void MergeFrom(const SlaveSyncDataResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataRet;
  static const SlaveSyncDataRet OK = SlaveSyncDataResp_SlaveSyncDataRet_OK;
  static const SlaveSyncDataRet FAIL = SlaveSyncDataResp_SlaveSyncDataRet_FAIL;
  static inline bool SlaveSyncDataRet_IsValid(int value) {
    return SlaveSyncDataResp_SlaveSyncDataRet_IsValid(value);
  }
  static const SlaveSyncDataRet SlaveSyncDataRet_MIN =
    SlaveSyncDataResp_SlaveSyncDataRet_SlaveSyncDataRet_MIN;
  static const SlaveSyncDataRet SlaveSyncDataRet_MAX =
    SlaveSyncDataResp_SlaveSyncDataRet_SlaveSyncDataRet_MAX;
  static const int SlaveSyncDataRet_ARRAYSIZE =
    SlaveSyncDataResp_SlaveSyncDataRet_SlaveSyncDataRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SlaveSyncDataRet_descriptor() {
    return SlaveSyncDataResp_SlaveSyncDataRet_descriptor();
  }
  static inline const ::std::string& SlaveSyncDataRet_Name(SlaveSyncDataRet value) {
    return SlaveSyncDataResp_SlaveSyncDataRet_Name(value);
  }
  static inline bool SlaveSyncDataRet_Parse(const ::std::string& name,
      SlaveSyncDataRet* value) {
    return SlaveSyncDataResp_SlaveSyncDataRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SlaveSyncDataResp.SlaveSyncDataRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::SlaveSyncDataResp_SlaveSyncDataRet result() const;
  inline void set_result(::SlaveSyncDataResp_SlaveSyncDataRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .SlaveData slave_data_list = 3;
  inline int slave_data_list_size() const;
  inline void clear_slave_data_list();
  static const int kSlaveDataListFieldNumber = 3;
  inline const ::SlaveData& slave_data_list(int index) const;
  inline ::SlaveData* mutable_slave_data_list(int index);
  inline ::SlaveData* add_slave_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::SlaveData >&
      slave_data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::SlaveData >*
      mutable_slave_data_list();

  // repeated .SlaveBriefInfo info_list = 4;
  inline int info_list_size() const;
  inline void clear_info_list();
  static const int kInfoListFieldNumber = 4;
  inline const ::SlaveBriefInfo& info_list(int index) const;
  inline ::SlaveBriefInfo* mutable_info_list(int index);
  inline ::SlaveBriefInfo* add_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::SlaveBriefInfo >&
      info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::SlaveBriefInfo >*
      mutable_info_list();

  // @@protoc_insertion_point(class_scope:SlaveSyncDataResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::SlaveData > slave_data_list_;
  ::google::protobuf::RepeatedPtrField< ::SlaveBriefInfo > info_list_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveSyncDataResp* default_instance_;
};
// -------------------------------------------------------------------

class SlaveGetResReq : public ::google::protobuf::Message {
 public:
  SlaveGetResReq();
  virtual ~SlaveGetResReq();

  SlaveGetResReq(const SlaveGetResReq& from);

  inline SlaveGetResReq& operator=(const SlaveGetResReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveGetResReq& default_instance();

  void Swap(SlaveGetResReq* other);

  // implements Message ----------------------------------------------

  SlaveGetResReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveGetResReq& from);
  void MergeFrom(const SlaveGetResReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string slave_name = 2;
  inline bool has_slave_name() const;
  inline void clear_slave_name();
  static const int kSlaveNameFieldNumber = 2;
  inline const ::std::string& slave_name() const;
  inline void set_slave_name(const ::std::string& value);
  inline void set_slave_name(const char* value);
  inline void set_slave_name(const char* value, size_t size);
  inline ::std::string* mutable_slave_name();
  inline ::std::string* release_slave_name();
  inline void set_allocated_slave_name(::std::string* slave_name);

  // @@protoc_insertion_point(class_scope:SlaveGetResReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_slave_name();
  inline void clear_has_slave_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* slave_name_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveGetResReq* default_instance_;
};
// -------------------------------------------------------------------

class SlaveGetResResp : public ::google::protobuf::Message {
 public:
  SlaveGetResResp();
  virtual ~SlaveGetResResp();

  SlaveGetResResp(const SlaveGetResResp& from);

  inline SlaveGetResResp& operator=(const SlaveGetResResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveGetResResp& default_instance();

  void Swap(SlaveGetResResp* other);

  // implements Message ----------------------------------------------

  SlaveGetResResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveGetResResp& from);
  void MergeFrom(const SlaveGetResResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveGetResResp_SlaveGetResRet SlaveGetResRet;
  static const SlaveGetResRet OK = SlaveGetResResp_SlaveGetResRet_OK;
  static const SlaveGetResRet FAIL = SlaveGetResResp_SlaveGetResRet_FAIL;
  static const SlaveGetResRet NOT_MY_SLAVE = SlaveGetResResp_SlaveGetResRet_NOT_MY_SLAVE;
  static const SlaveGetResRet CD_TIME = SlaveGetResResp_SlaveGetResRet_CD_TIME;
  static inline bool SlaveGetResRet_IsValid(int value) {
    return SlaveGetResResp_SlaveGetResRet_IsValid(value);
  }
  static const SlaveGetResRet SlaveGetResRet_MIN =
    SlaveGetResResp_SlaveGetResRet_SlaveGetResRet_MIN;
  static const SlaveGetResRet SlaveGetResRet_MAX =
    SlaveGetResResp_SlaveGetResRet_SlaveGetResRet_MAX;
  static const int SlaveGetResRet_ARRAYSIZE =
    SlaveGetResResp_SlaveGetResRet_SlaveGetResRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SlaveGetResRet_descriptor() {
    return SlaveGetResResp_SlaveGetResRet_descriptor();
  }
  static inline const ::std::string& SlaveGetResRet_Name(SlaveGetResRet value) {
    return SlaveGetResResp_SlaveGetResRet_Name(value);
  }
  static inline bool SlaveGetResRet_Parse(const ::std::string& name,
      SlaveGetResRet* value) {
    return SlaveGetResResp_SlaveGetResRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SlaveGetResResp.SlaveGetResRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::SlaveGetResResp_SlaveGetResRet result() const;
  inline void set_result(::SlaveGetResResp_SlaveGetResRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated int32 res = 3;
  inline int res_size() const;
  inline void clear_res();
  static const int kResFieldNumber = 3;
  inline ::google::protobuf::int32 res(int index) const;
  inline void set_res(int index, ::google::protobuf::int32 value);
  inline void add_res(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      res() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_res();

  // optional int32 exp = 4;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 4;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SlaveGetResResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  int result_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveGetResResp* default_instance_;
};
// -------------------------------------------------------------------

class SlaveFreeReq : public ::google::protobuf::Message {
 public:
  SlaveFreeReq();
  virtual ~SlaveFreeReq();

  SlaveFreeReq(const SlaveFreeReq& from);

  inline SlaveFreeReq& operator=(const SlaveFreeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveFreeReq& default_instance();

  void Swap(SlaveFreeReq* other);

  // implements Message ----------------------------------------------

  SlaveFreeReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveFreeReq& from);
  void MergeFrom(const SlaveFreeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string slave_name = 2;
  inline bool has_slave_name() const;
  inline void clear_slave_name();
  static const int kSlaveNameFieldNumber = 2;
  inline const ::std::string& slave_name() const;
  inline void set_slave_name(const ::std::string& value);
  inline void set_slave_name(const char* value);
  inline void set_slave_name(const char* value, size_t size);
  inline ::std::string* mutable_slave_name();
  inline ::std::string* release_slave_name();
  inline void set_allocated_slave_name(::std::string* slave_name);

  // @@protoc_insertion_point(class_scope:SlaveFreeReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_slave_name();
  inline void clear_has_slave_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* slave_name_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveFreeReq* default_instance_;
};
// -------------------------------------------------------------------

class SlaveFreeResp : public ::google::protobuf::Message {
 public:
  SlaveFreeResp();
  virtual ~SlaveFreeResp();

  SlaveFreeResp(const SlaveFreeResp& from);

  inline SlaveFreeResp& operator=(const SlaveFreeResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveFreeResp& default_instance();

  void Swap(SlaveFreeResp* other);

  // implements Message ----------------------------------------------

  SlaveFreeResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveFreeResp& from);
  void MergeFrom(const SlaveFreeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveFreeResp_SlaveFreeRet SlaveFreeRet;
  static const SlaveFreeRet OK = SlaveFreeResp_SlaveFreeRet_OK;
  static const SlaveFreeRet FAIL = SlaveFreeResp_SlaveFreeRet_FAIL;
  static const SlaveFreeRet NOT_MY_SLAVE = SlaveFreeResp_SlaveFreeRet_NOT_MY_SLAVE;
  static const SlaveFreeRet FREE_SLAVE_ERROR = SlaveFreeResp_SlaveFreeRet_FREE_SLAVE_ERROR;
  static inline bool SlaveFreeRet_IsValid(int value) {
    return SlaveFreeResp_SlaveFreeRet_IsValid(value);
  }
  static const SlaveFreeRet SlaveFreeRet_MIN =
    SlaveFreeResp_SlaveFreeRet_SlaveFreeRet_MIN;
  static const SlaveFreeRet SlaveFreeRet_MAX =
    SlaveFreeResp_SlaveFreeRet_SlaveFreeRet_MAX;
  static const int SlaveFreeRet_ARRAYSIZE =
    SlaveFreeResp_SlaveFreeRet_SlaveFreeRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SlaveFreeRet_descriptor() {
    return SlaveFreeResp_SlaveFreeRet_descriptor();
  }
  static inline const ::std::string& SlaveFreeRet_Name(SlaveFreeRet value) {
    return SlaveFreeResp_SlaveFreeRet_Name(value);
  }
  static inline bool SlaveFreeRet_Parse(const ::std::string& name,
      SlaveFreeRet* value) {
    return SlaveFreeResp_SlaveFreeRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SlaveFreeResp.SlaveFreeRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::SlaveFreeResp_SlaveFreeRet result() const;
  inline void set_result(::SlaveFreeResp_SlaveFreeRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:SlaveFreeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveFreeResp* default_instance_;
};
// -------------------------------------------------------------------

class SlaveShowReq : public ::google::protobuf::Message {
 public:
  SlaveShowReq();
  virtual ~SlaveShowReq();

  SlaveShowReq(const SlaveShowReq& from);

  inline SlaveShowReq& operator=(const SlaveShowReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveShowReq& default_instance();

  void Swap(SlaveShowReq* other);

  // implements Message ----------------------------------------------

  SlaveShowReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveShowReq& from);
  void MergeFrom(const SlaveShowReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string slave_name = 2;
  inline bool has_slave_name() const;
  inline void clear_slave_name();
  static const int kSlaveNameFieldNumber = 2;
  inline const ::std::string& slave_name() const;
  inline void set_slave_name(const ::std::string& value);
  inline void set_slave_name(const char* value);
  inline void set_slave_name(const char* value, size_t size);
  inline ::std::string* mutable_slave_name();
  inline ::std::string* release_slave_name();
  inline void set_allocated_slave_name(::std::string* slave_name);

  // @@protoc_insertion_point(class_scope:SlaveShowReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_slave_name();
  inline void clear_has_slave_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* slave_name_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveShowReq* default_instance_;
};
// -------------------------------------------------------------------

class SlaveShowResp : public ::google::protobuf::Message {
 public:
  SlaveShowResp();
  virtual ~SlaveShowResp();

  SlaveShowResp(const SlaveShowResp& from);

  inline SlaveShowResp& operator=(const SlaveShowResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveShowResp& default_instance();

  void Swap(SlaveShowResp* other);

  // implements Message ----------------------------------------------

  SlaveShowResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveShowResp& from);
  void MergeFrom(const SlaveShowResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveShowResp_SlaveShowRet SlaveShowRet;
  static const SlaveShowRet OK = SlaveShowResp_SlaveShowRet_OK;
  static const SlaveShowRet FAIL = SlaveShowResp_SlaveShowRet_FAIL;
  static const SlaveShowRet NOT_MY_SLAVE = SlaveShowResp_SlaveShowRet_NOT_MY_SLAVE;
  static const SlaveShowRet NO_MONEY = SlaveShowResp_SlaveShowRet_NO_MONEY;
  static const SlaveShowRet STATE_ERROR = SlaveShowResp_SlaveShowRet_STATE_ERROR;
  static const SlaveShowRet TYPE_ERROR = SlaveShowResp_SlaveShowRet_TYPE_ERROR;
  static const SlaveShowRet NO_MASTER = SlaveShowResp_SlaveShowRet_NO_MASTER;
  static const SlaveShowRet WATCH_NUM_MAX = SlaveShowResp_SlaveShowRet_WATCH_NUM_MAX;
  static const SlaveShowRet WATCHED = SlaveShowResp_SlaveShowRet_WATCHED;
  static inline bool SlaveShowRet_IsValid(int value) {
    return SlaveShowResp_SlaveShowRet_IsValid(value);
  }
  static const SlaveShowRet SlaveShowRet_MIN =
    SlaveShowResp_SlaveShowRet_SlaveShowRet_MIN;
  static const SlaveShowRet SlaveShowRet_MAX =
    SlaveShowResp_SlaveShowRet_SlaveShowRet_MAX;
  static const int SlaveShowRet_ARRAYSIZE =
    SlaveShowResp_SlaveShowRet_SlaveShowRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SlaveShowRet_descriptor() {
    return SlaveShowResp_SlaveShowRet_descriptor();
  }
  static inline const ::std::string& SlaveShowRet_Name(SlaveShowRet value) {
    return SlaveShowResp_SlaveShowRet_Name(value);
  }
  static inline bool SlaveShowRet_Parse(const ::std::string& name,
      SlaveShowRet* value) {
    return SlaveShowResp_SlaveShowRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SlaveShowResp.SlaveShowRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::SlaveShowResp_SlaveShowRet result() const;
  inline void set_result(::SlaveShowResp_SlaveShowRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .Pair get_item_list = 3;
  inline int get_item_list_size() const;
  inline void clear_get_item_list();
  static const int kGetItemListFieldNumber = 3;
  inline const ::Pair& get_item_list(int index) const;
  inline ::Pair* mutable_get_item_list(int index);
  inline ::Pair* add_get_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
      get_item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Pair >*
      mutable_get_item_list();

  // @@protoc_insertion_point(class_scope:SlaveShowResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::Pair > get_item_list_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveShowResp* default_instance_;
};
// -------------------------------------------------------------------

class SlaveWorkReq : public ::google::protobuf::Message {
 public:
  SlaveWorkReq();
  virtual ~SlaveWorkReq();

  SlaveWorkReq(const SlaveWorkReq& from);

  inline SlaveWorkReq& operator=(const SlaveWorkReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveWorkReq& default_instance();

  void Swap(SlaveWorkReq* other);

  // implements Message ----------------------------------------------

  SlaveWorkReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveWorkReq& from);
  void MergeFrom(const SlaveWorkReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string slave_name = 1;
  inline bool has_slave_name() const;
  inline void clear_slave_name();
  static const int kSlaveNameFieldNumber = 1;
  inline const ::std::string& slave_name() const;
  inline void set_slave_name(const ::std::string& value);
  inline void set_slave_name(const char* value);
  inline void set_slave_name(const char* value, size_t size);
  inline ::std::string* mutable_slave_name();
  inline ::std::string* release_slave_name();
  inline void set_allocated_slave_name(::std::string* slave_name);

  // @@protoc_insertion_point(class_scope:SlaveWorkReq)
 private:
  inline void set_has_slave_name();
  inline void clear_has_slave_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* slave_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveWorkReq* default_instance_;
};
// -------------------------------------------------------------------

class SlaveWorkResp : public ::google::protobuf::Message {
 public:
  SlaveWorkResp();
  virtual ~SlaveWorkResp();

  SlaveWorkResp(const SlaveWorkResp& from);

  inline SlaveWorkResp& operator=(const SlaveWorkResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveWorkResp& default_instance();

  void Swap(SlaveWorkResp* other);

  // implements Message ----------------------------------------------

  SlaveWorkResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveWorkResp& from);
  void MergeFrom(const SlaveWorkResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveWorkResp_SlaveWorkRet SlaveWorkRet;
  static const SlaveWorkRet OK = SlaveWorkResp_SlaveWorkRet_OK;
  static const SlaveWorkRet FAIL = SlaveWorkResp_SlaveWorkRet_FAIL;
  static const SlaveWorkRet NOT_MY_SLAVE = SlaveWorkResp_SlaveWorkRet_NOT_MY_SLAVE;
  static const SlaveWorkRet CD_TIME = SlaveWorkResp_SlaveWorkRet_CD_TIME;
  static inline bool SlaveWorkRet_IsValid(int value) {
    return SlaveWorkResp_SlaveWorkRet_IsValid(value);
  }
  static const SlaveWorkRet SlaveWorkRet_MIN =
    SlaveWorkResp_SlaveWorkRet_SlaveWorkRet_MIN;
  static const SlaveWorkRet SlaveWorkRet_MAX =
    SlaveWorkResp_SlaveWorkRet_SlaveWorkRet_MAX;
  static const int SlaveWorkRet_ARRAYSIZE =
    SlaveWorkResp_SlaveWorkRet_SlaveWorkRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SlaveWorkRet_descriptor() {
    return SlaveWorkResp_SlaveWorkRet_descriptor();
  }
  static inline const ::std::string& SlaveWorkRet_Name(SlaveWorkRet value) {
    return SlaveWorkResp_SlaveWorkRet_Name(value);
  }
  static inline bool SlaveWorkRet_Parse(const ::std::string& name,
      SlaveWorkRet* value) {
    return SlaveWorkResp_SlaveWorkRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SlaveWorkResp.SlaveWorkRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::SlaveWorkResp_SlaveWorkRet result() const;
  inline void set_result(::SlaveWorkResp_SlaveWorkRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .Pair get_item_list = 3;
  inline int get_item_list_size() const;
  inline void clear_get_item_list();
  static const int kGetItemListFieldNumber = 3;
  inline const ::Pair& get_item_list(int index) const;
  inline ::Pair* mutable_get_item_list(int index);
  inline ::Pair* add_get_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
      get_item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Pair >*
      mutable_get_item_list();

  // optional .SlaveNoteInfo note_info = 4;
  inline bool has_note_info() const;
  inline void clear_note_info();
  static const int kNoteInfoFieldNumber = 4;
  inline const ::SlaveNoteInfo& note_info() const;
  inline ::SlaveNoteInfo* mutable_note_info();
  inline ::SlaveNoteInfo* release_note_info();
  inline void set_allocated_note_info(::SlaveNoteInfo* note_info);

  // @@protoc_insertion_point(class_scope:SlaveWorkResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_note_info();
  inline void clear_has_note_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::Pair > get_item_list_;
  ::SlaveNoteInfo* note_info_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveWorkResp* default_instance_;
};
// -------------------------------------------------------------------

class SlaveFawnOnReq : public ::google::protobuf::Message {
 public:
  SlaveFawnOnReq();
  virtual ~SlaveFawnOnReq();

  SlaveFawnOnReq(const SlaveFawnOnReq& from);

  inline SlaveFawnOnReq& operator=(const SlaveFawnOnReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveFawnOnReq& default_instance();

  void Swap(SlaveFawnOnReq* other);

  // implements Message ----------------------------------------------

  SlaveFawnOnReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveFawnOnReq& from);
  void MergeFrom(const SlaveFawnOnReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SlaveFawnOnReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveFawnOnReq* default_instance_;
};
// -------------------------------------------------------------------

class SlaveFawnOnResp : public ::google::protobuf::Message {
 public:
  SlaveFawnOnResp();
  virtual ~SlaveFawnOnResp();

  SlaveFawnOnResp(const SlaveFawnOnResp& from);

  inline SlaveFawnOnResp& operator=(const SlaveFawnOnResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveFawnOnResp& default_instance();

  void Swap(SlaveFawnOnResp* other);

  // implements Message ----------------------------------------------

  SlaveFawnOnResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveFawnOnResp& from);
  void MergeFrom(const SlaveFawnOnResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnRet;
  static const SlaveFawnOnRet OK = SlaveFawnOnResp_SlaveFawnOnRet_OK;
  static const SlaveFawnOnRet FAIL = SlaveFawnOnResp_SlaveFawnOnRet_FAIL;
  static const SlaveFawnOnRet NO_MASTER = SlaveFawnOnResp_SlaveFawnOnRet_NO_MASTER;
  static const SlaveFawnOnRet CD_TIME = SlaveFawnOnResp_SlaveFawnOnRet_CD_TIME;
  static inline bool SlaveFawnOnRet_IsValid(int value) {
    return SlaveFawnOnResp_SlaveFawnOnRet_IsValid(value);
  }
  static const SlaveFawnOnRet SlaveFawnOnRet_MIN =
    SlaveFawnOnResp_SlaveFawnOnRet_SlaveFawnOnRet_MIN;
  static const SlaveFawnOnRet SlaveFawnOnRet_MAX =
    SlaveFawnOnResp_SlaveFawnOnRet_SlaveFawnOnRet_MAX;
  static const int SlaveFawnOnRet_ARRAYSIZE =
    SlaveFawnOnResp_SlaveFawnOnRet_SlaveFawnOnRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SlaveFawnOnRet_descriptor() {
    return SlaveFawnOnResp_SlaveFawnOnRet_descriptor();
  }
  static inline const ::std::string& SlaveFawnOnRet_Name(SlaveFawnOnRet value) {
    return SlaveFawnOnResp_SlaveFawnOnRet_Name(value);
  }
  static inline bool SlaveFawnOnRet_Parse(const ::std::string& name,
      SlaveFawnOnRet* value) {
    return SlaveFawnOnResp_SlaveFawnOnRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SlaveFawnOnResp.SlaveFawnOnRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::SlaveFawnOnResp_SlaveFawnOnRet result() const;
  inline void set_result(::SlaveFawnOnResp_SlaveFawnOnRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .Pair get_item_list = 3;
  inline int get_item_list_size() const;
  inline void clear_get_item_list();
  static const int kGetItemListFieldNumber = 3;
  inline const ::Pair& get_item_list(int index) const;
  inline ::Pair* mutable_get_item_list(int index);
  inline ::Pair* add_get_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
      get_item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Pair >*
      mutable_get_item_list();

  // optional .SlaveNoteInfo note_info = 4;
  inline bool has_note_info() const;
  inline void clear_note_info();
  static const int kNoteInfoFieldNumber = 4;
  inline const ::SlaveNoteInfo& note_info() const;
  inline ::SlaveNoteInfo* mutable_note_info();
  inline ::SlaveNoteInfo* release_note_info();
  inline void set_allocated_note_info(::SlaveNoteInfo* note_info);

  // @@protoc_insertion_point(class_scope:SlaveFawnOnResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_note_info();
  inline void clear_has_note_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::Pair > get_item_list_;
  ::SlaveNoteInfo* note_info_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveFawnOnResp* default_instance_;
};
// -------------------------------------------------------------------

class SlaveHelpReq : public ::google::protobuf::Message {
 public:
  SlaveHelpReq();
  virtual ~SlaveHelpReq();

  SlaveHelpReq(const SlaveHelpReq& from);

  inline SlaveHelpReq& operator=(const SlaveHelpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveHelpReq& default_instance();

  void Swap(SlaveHelpReq* other);

  // implements Message ----------------------------------------------

  SlaveHelpReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveHelpReq& from);
  void MergeFrom(const SlaveHelpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SlaveHelpReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveHelpReq* default_instance_;
};
// -------------------------------------------------------------------

class SlaveHelpResp : public ::google::protobuf::Message {
 public:
  SlaveHelpResp();
  virtual ~SlaveHelpResp();

  SlaveHelpResp(const SlaveHelpResp& from);

  inline SlaveHelpResp& operator=(const SlaveHelpResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveHelpResp& default_instance();

  void Swap(SlaveHelpResp* other);

  // implements Message ----------------------------------------------

  SlaveHelpResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveHelpResp& from);
  void MergeFrom(const SlaveHelpResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveHelpResp_SlaveHelpRet SlaveHelpRet;
  static const SlaveHelpRet OK = SlaveHelpResp_SlaveHelpRet_OK;
  static const SlaveHelpRet FAIL = SlaveHelpResp_SlaveHelpRet_FAIL;
  static const SlaveHelpRet NO_MASTER = SlaveHelpResp_SlaveHelpRet_NO_MASTER;
  static const SlaveHelpRet CD_TIME = SlaveHelpResp_SlaveHelpRet_CD_TIME;
  static const SlaveHelpRet SEND_LIST_EMPTY = SlaveHelpResp_SlaveHelpRet_SEND_LIST_EMPTY;
  static inline bool SlaveHelpRet_IsValid(int value) {
    return SlaveHelpResp_SlaveHelpRet_IsValid(value);
  }
  static const SlaveHelpRet SlaveHelpRet_MIN =
    SlaveHelpResp_SlaveHelpRet_SlaveHelpRet_MIN;
  static const SlaveHelpRet SlaveHelpRet_MAX =
    SlaveHelpResp_SlaveHelpRet_SlaveHelpRet_MAX;
  static const int SlaveHelpRet_ARRAYSIZE =
    SlaveHelpResp_SlaveHelpRet_SlaveHelpRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SlaveHelpRet_descriptor() {
    return SlaveHelpResp_SlaveHelpRet_descriptor();
  }
  static inline const ::std::string& SlaveHelpRet_Name(SlaveHelpRet value) {
    return SlaveHelpResp_SlaveHelpRet_Name(value);
  }
  static inline bool SlaveHelpRet_Parse(const ::std::string& name,
      SlaveHelpRet* value) {
    return SlaveHelpResp_SlaveHelpRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SlaveHelpResp.SlaveHelpRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::SlaveHelpResp_SlaveHelpRet result() const;
  inline void set_result(::SlaveHelpResp_SlaveHelpRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:SlaveHelpResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveHelpResp* default_instance_;
};
// -------------------------------------------------------------------

class SlaveSearchReq : public ::google::protobuf::Message {
 public:
  SlaveSearchReq();
  virtual ~SlaveSearchReq();

  SlaveSearchReq(const SlaveSearchReq& from);

  inline SlaveSearchReq& operator=(const SlaveSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveSearchReq& default_instance();

  void Swap(SlaveSearchReq* other);

  // implements Message ----------------------------------------------

  SlaveSearchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveSearchReq& from);
  void MergeFrom(const SlaveSearchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SlaveSearchReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class SlaveSearchResp : public ::google::protobuf::Message {
 public:
  SlaveSearchResp();
  virtual ~SlaveSearchResp();

  SlaveSearchResp(const SlaveSearchResp& from);

  inline SlaveSearchResp& operator=(const SlaveSearchResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveSearchResp& default_instance();

  void Swap(SlaveSearchResp* other);

  // implements Message ----------------------------------------------

  SlaveSearchResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveSearchResp& from);
  void MergeFrom(const SlaveSearchResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveSearchResp_SlaveSearchRet SlaveSearchRet;
  static const SlaveSearchRet OK = SlaveSearchResp_SlaveSearchRet_OK;
  static const SlaveSearchRet FAIL = SlaveSearchResp_SlaveSearchRet_FAIL;
  static const SlaveSearchRet EMPTY = SlaveSearchResp_SlaveSearchRet_EMPTY;
  static const SlaveSearchRet HAS_MASTER = SlaveSearchResp_SlaveSearchRet_HAS_MASTER;
  static const SlaveSearchRet ERROR_TYPE = SlaveSearchResp_SlaveSearchRet_ERROR_TYPE;
  static inline bool SlaveSearchRet_IsValid(int value) {
    return SlaveSearchResp_SlaveSearchRet_IsValid(value);
  }
  static const SlaveSearchRet SlaveSearchRet_MIN =
    SlaveSearchResp_SlaveSearchRet_SlaveSearchRet_MIN;
  static const SlaveSearchRet SlaveSearchRet_MAX =
    SlaveSearchResp_SlaveSearchRet_SlaveSearchRet_MAX;
  static const int SlaveSearchRet_ARRAYSIZE =
    SlaveSearchResp_SlaveSearchRet_SlaveSearchRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SlaveSearchRet_descriptor() {
    return SlaveSearchResp_SlaveSearchRet_descriptor();
  }
  static inline const ::std::string& SlaveSearchRet_Name(SlaveSearchRet value) {
    return SlaveSearchResp_SlaveSearchRet_Name(value);
  }
  static inline bool SlaveSearchRet_Parse(const ::std::string& name,
      SlaveSearchRet* value) {
    return SlaveSearchResp_SlaveSearchRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SlaveSearchResp.SlaveSearchRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::SlaveSearchResp_SlaveSearchRet result() const;
  inline void set_result(::SlaveSearchResp_SlaveSearchRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .SlaveBriefInfo info_list = 3;
  inline int info_list_size() const;
  inline void clear_info_list();
  static const int kInfoListFieldNumber = 3;
  inline const ::SlaveBriefInfo& info_list(int index) const;
  inline ::SlaveBriefInfo* mutable_info_list(int index);
  inline ::SlaveBriefInfo* add_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::SlaveBriefInfo >&
      info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::SlaveBriefInfo >*
      mutable_info_list();

  // @@protoc_insertion_point(class_scope:SlaveSearchResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::SlaveBriefInfo > info_list_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveSearchResp* default_instance_;
};
// -------------------------------------------------------------------

class SlaveAddTimesReq : public ::google::protobuf::Message {
 public:
  SlaveAddTimesReq();
  virtual ~SlaveAddTimesReq();

  SlaveAddTimesReq(const SlaveAddTimesReq& from);

  inline SlaveAddTimesReq& operator=(const SlaveAddTimesReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveAddTimesReq& default_instance();

  void Swap(SlaveAddTimesReq* other);

  // implements Message ----------------------------------------------

  SlaveAddTimesReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveAddTimesReq& from);
  void MergeFrom(const SlaveAddTimesReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SlaveAddTimesReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveAddTimesReq* default_instance_;
};
// -------------------------------------------------------------------

class SlaveAddTimesResp : public ::google::protobuf::Message {
 public:
  SlaveAddTimesResp();
  virtual ~SlaveAddTimesResp();

  SlaveAddTimesResp(const SlaveAddTimesResp& from);

  inline SlaveAddTimesResp& operator=(const SlaveAddTimesResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveAddTimesResp& default_instance();

  void Swap(SlaveAddTimesResp* other);

  // implements Message ----------------------------------------------

  SlaveAddTimesResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveAddTimesResp& from);
  void MergeFrom(const SlaveAddTimesResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesRet;
  static const SlaveAddTimesRet OK = SlaveAddTimesResp_SlaveAddTimesRet_OK;
  static const SlaveAddTimesRet FAIL = SlaveAddTimesResp_SlaveAddTimesRet_FAIL;
  static const SlaveAddTimesRet NO_MONEY = SlaveAddTimesResp_SlaveAddTimesRet_NO_MONEY;
  static inline bool SlaveAddTimesRet_IsValid(int value) {
    return SlaveAddTimesResp_SlaveAddTimesRet_IsValid(value);
  }
  static const SlaveAddTimesRet SlaveAddTimesRet_MIN =
    SlaveAddTimesResp_SlaveAddTimesRet_SlaveAddTimesRet_MIN;
  static const SlaveAddTimesRet SlaveAddTimesRet_MAX =
    SlaveAddTimesResp_SlaveAddTimesRet_SlaveAddTimesRet_MAX;
  static const int SlaveAddTimesRet_ARRAYSIZE =
    SlaveAddTimesResp_SlaveAddTimesRet_SlaveAddTimesRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SlaveAddTimesRet_descriptor() {
    return SlaveAddTimesResp_SlaveAddTimesRet_descriptor();
  }
  static inline const ::std::string& SlaveAddTimesRet_Name(SlaveAddTimesRet value) {
    return SlaveAddTimesResp_SlaveAddTimesRet_Name(value);
  }
  static inline bool SlaveAddTimesRet_Parse(const ::std::string& name,
      SlaveAddTimesRet* value) {
    return SlaveAddTimesResp_SlaveAddTimesRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SlaveAddTimesResp.SlaveAddTimesRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::SlaveAddTimesResp_SlaveAddTimesRet result() const;
  inline void set_result(::SlaveAddTimesResp_SlaveAddTimesRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:SlaveAddTimesResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveAddTimesResp* default_instance_;
};
// -------------------------------------------------------------------

class SlaveAttackReq : public ::google::protobuf::Message {
 public:
  SlaveAttackReq();
  virtual ~SlaveAttackReq();

  SlaveAttackReq(const SlaveAttackReq& from);

  inline SlaveAttackReq& operator=(const SlaveAttackReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveAttackReq& default_instance();

  void Swap(SlaveAttackReq* other);

  // implements Message ----------------------------------------------

  SlaveAttackReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveAttackReq& from);
  void MergeFrom(const SlaveAttackReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // repeated int32 lineup = 3;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 3;
  inline ::google::protobuf::int32 lineup(int index) const;
  inline void set_lineup(int index, ::google::protobuf::int32 value);
  inline void add_lineup(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lineup();

  // @@protoc_insertion_point(class_scope:SlaveAttackReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lineup_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveAttackReq* default_instance_;
};
// -------------------------------------------------------------------

class SlaveAttackResp : public ::google::protobuf::Message {
 public:
  SlaveAttackResp();
  virtual ~SlaveAttackResp();

  SlaveAttackResp(const SlaveAttackResp& from);

  inline SlaveAttackResp& operator=(const SlaveAttackResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveAttackResp& default_instance();

  void Swap(SlaveAttackResp* other);

  // implements Message ----------------------------------------------

  SlaveAttackResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveAttackResp& from);
  void MergeFrom(const SlaveAttackResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveAttackResp_SlaveAttackRet SlaveAttackRet;
  static const SlaveAttackRet OK = SlaveAttackResp_SlaveAttackRet_OK;
  static const SlaveAttackRet FAIL = SlaveAttackResp_SlaveAttackRet_FAIL;
  static const SlaveAttackRet NO_EMEMY = SlaveAttackResp_SlaveAttackRet_NO_EMEMY;
  static const SlaveAttackRet ATTACK_SELF = SlaveAttackResp_SlaveAttackRet_ATTACK_SELF;
  static const SlaveAttackRet ERROR_TYPE = SlaveAttackResp_SlaveAttackRet_ERROR_TYPE;
  static const SlaveAttackRet HAS_MASTER = SlaveAttackResp_SlaveAttackRet_HAS_MASTER;
  static const SlaveAttackRet NO_TIMES = SlaveAttackResp_SlaveAttackRet_NO_TIMES;
  static const SlaveAttackRet CD_TIME = SlaveAttackResp_SlaveAttackRet_CD_TIME;
  static const SlaveAttackRet NO_SHIPS = SlaveAttackResp_SlaveAttackRet_NO_SHIPS;
  static const SlaveAttackRet NO_DURABLE = SlaveAttackResp_SlaveAttackRet_NO_DURABLE;
  static const SlaveAttackRet FIXING = SlaveAttackResp_SlaveAttackRet_FIXING;
  static const SlaveAttackRet NOT_SLAVE_MASTER = SlaveAttackResp_SlaveAttackRet_NOT_SLAVE_MASTER;
  static const SlaveAttackRet MAX_SLAVE = SlaveAttackResp_SlaveAttackRet_MAX_SLAVE;
  static const SlaveAttackRet NO_MASTER = SlaveAttackResp_SlaveAttackRet_NO_MASTER;
  static const SlaveAttackRet HAS_SLAVE = SlaveAttackResp_SlaveAttackRet_HAS_SLAVE;
  static const SlaveAttackRet SHOWING = SlaveAttackResp_SlaveAttackRet_SHOWING;
  static const SlaveAttackRet CATCH_ERROR = SlaveAttackResp_SlaveAttackRet_CATCH_ERROR;
  static const SlaveAttackRet OUTING = SlaveAttackResp_SlaveAttackRet_OUTING;
  static inline bool SlaveAttackRet_IsValid(int value) {
    return SlaveAttackResp_SlaveAttackRet_IsValid(value);
  }
  static const SlaveAttackRet SlaveAttackRet_MIN =
    SlaveAttackResp_SlaveAttackRet_SlaveAttackRet_MIN;
  static const SlaveAttackRet SlaveAttackRet_MAX =
    SlaveAttackResp_SlaveAttackRet_SlaveAttackRet_MAX;
  static const int SlaveAttackRet_ARRAYSIZE =
    SlaveAttackResp_SlaveAttackRet_SlaveAttackRet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SlaveAttackRet_descriptor() {
    return SlaveAttackResp_SlaveAttackRet_descriptor();
  }
  static inline const ::std::string& SlaveAttackRet_Name(SlaveAttackRet value) {
    return SlaveAttackResp_SlaveAttackRet_Name(value);
  }
  static inline bool SlaveAttackRet_Parse(const ::std::string& name,
      SlaveAttackRet* value) {
    return SlaveAttackResp_SlaveAttackRet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SlaveAttackResp.SlaveAttackRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::SlaveAttackResp_SlaveAttackRet result() const;
  inline void set_result(::SlaveAttackResp_SlaveAttackRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .AirShip attack_list = 3;
  inline int attack_list_size() const;
  inline void clear_attack_list();
  static const int kAttackListFieldNumber = 3;
  inline const ::AirShip& attack_list(int index) const;
  inline ::AirShip* mutable_attack_list(int index);
  inline ::AirShip* add_attack_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
      attack_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
      mutable_attack_list();

  // repeated .AirShip hurter_list = 4;
  inline int hurter_list_size() const;
  inline void clear_hurter_list();
  static const int kHurterListFieldNumber = 4;
  inline const ::AirShip& hurter_list(int index) const;
  inline ::AirShip* mutable_hurter_list(int index);
  inline ::AirShip* add_hurter_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
      hurter_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
      mutable_hurter_list();

  // repeated .EventInfo event_list = 5;
  inline int event_list_size() const;
  inline void clear_event_list();
  static const int kEventListFieldNumber = 5;
  inline const ::EventInfo& event_list(int index) const;
  inline ::EventInfo* mutable_event_list(int index);
  inline ::EventInfo* add_event_list();
  inline const ::google::protobuf::RepeatedPtrField< ::EventInfo >&
      event_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::EventInfo >*
      mutable_event_list();

  // optional bool isWin = 6;
  inline bool has_iswin() const;
  inline void clear_iswin();
  static const int kIsWinFieldNumber = 6;
  inline bool iswin() const;
  inline void set_iswin(bool value);

  // optional bool isCatch = 7;
  inline bool has_iscatch() const;
  inline void clear_iscatch();
  static const int kIsCatchFieldNumber = 7;
  inline bool iscatch() const;
  inline void set_iscatch(bool value);

  // repeated .Pair get_item_list = 8;
  inline int get_item_list_size() const;
  inline void clear_get_item_list();
  static const int kGetItemListFieldNumber = 8;
  inline const ::Pair& get_item_list(int index) const;
  inline ::Pair* mutable_get_item_list(int index);
  inline ::Pair* add_get_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
      get_item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Pair >*
      mutable_get_item_list();

  // optional .SlaveAttackReq req = 9;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 9;
  inline const ::SlaveAttackReq& req() const;
  inline ::SlaveAttackReq* mutable_req();
  inline ::SlaveAttackReq* release_req();
  inline void set_allocated_req(::SlaveAttackReq* req);

  // @@protoc_insertion_point(class_scope:SlaveAttackResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_iswin();
  inline void clear_has_iswin();
  inline void set_has_iscatch();
  inline void clear_has_iscatch();
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::AirShip > attack_list_;
  ::google::protobuf::RepeatedPtrField< ::AirShip > hurter_list_;
  int result_;
  bool iswin_;
  bool iscatch_;
  ::google::protobuf::RepeatedPtrField< ::EventInfo > event_list_;
  ::google::protobuf::RepeatedPtrField< ::Pair > get_item_list_;
  ::SlaveAttackReq* req_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_CmdSlave_2eproto();
  friend void protobuf_AssignDesc_CmdSlave_2eproto();
  friend void protobuf_ShutdownFile_CmdSlave_2eproto();

  void InitAsDefaultInstance();
  static SlaveAttackResp* default_instance_;
};
// ===================================================================


// ===================================================================

// SlaveSyncDataReq

// required int32 type = 1;
inline bool SlaveSyncDataReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveSyncDataReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveSyncDataReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveSyncDataReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SlaveSyncDataReq::type() const {
  return type_;
}
inline void SlaveSyncDataReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated string user_name_list = 2;
inline int SlaveSyncDataReq::user_name_list_size() const {
  return user_name_list_.size();
}
inline void SlaveSyncDataReq::clear_user_name_list() {
  user_name_list_.Clear();
}
inline const ::std::string& SlaveSyncDataReq::user_name_list(int index) const {
  return user_name_list_.Get(index);
}
inline ::std::string* SlaveSyncDataReq::mutable_user_name_list(int index) {
  return user_name_list_.Mutable(index);
}
inline void SlaveSyncDataReq::set_user_name_list(int index, const ::std::string& value) {
  user_name_list_.Mutable(index)->assign(value);
}
inline void SlaveSyncDataReq::set_user_name_list(int index, const char* value) {
  user_name_list_.Mutable(index)->assign(value);
}
inline void SlaveSyncDataReq::set_user_name_list(int index, const char* value, size_t size) {
  user_name_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveSyncDataReq::add_user_name_list() {
  return user_name_list_.Add();
}
inline void SlaveSyncDataReq::add_user_name_list(const ::std::string& value) {
  user_name_list_.Add()->assign(value);
}
inline void SlaveSyncDataReq::add_user_name_list(const char* value) {
  user_name_list_.Add()->assign(value);
}
inline void SlaveSyncDataReq::add_user_name_list(const char* value, size_t size) {
  user_name_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SlaveSyncDataReq::user_name_list() const {
  return user_name_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SlaveSyncDataReq::mutable_user_name_list() {
  return &user_name_list_;
}

// -------------------------------------------------------------------

// SlaveSyncDataResp

// required .SlaveSyncDataResp.SlaveSyncDataRet result = 1;
inline bool SlaveSyncDataResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveSyncDataResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveSyncDataResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveSyncDataResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp::result() const {
  return static_cast< ::SlaveSyncDataResp_SlaveSyncDataRet >(result_);
}
inline void SlaveSyncDataResp::set_result(::SlaveSyncDataResp_SlaveSyncDataRet value) {
  assert(::SlaveSyncDataResp_SlaveSyncDataRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SlaveSyncDataResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveSyncDataResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveSyncDataResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveSyncDataResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SlaveSyncDataResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SlaveSyncDataResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SlaveSyncDataResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SlaveSyncDataResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .SlaveData slave_data_list = 3;
inline int SlaveSyncDataResp::slave_data_list_size() const {
  return slave_data_list_.size();
}
inline void SlaveSyncDataResp::clear_slave_data_list() {
  slave_data_list_.Clear();
}
inline const ::SlaveData& SlaveSyncDataResp::slave_data_list(int index) const {
  return slave_data_list_.Get(index);
}
inline ::SlaveData* SlaveSyncDataResp::mutable_slave_data_list(int index) {
  return slave_data_list_.Mutable(index);
}
inline ::SlaveData* SlaveSyncDataResp::add_slave_data_list() {
  return slave_data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SlaveData >&
SlaveSyncDataResp::slave_data_list() const {
  return slave_data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::SlaveData >*
SlaveSyncDataResp::mutable_slave_data_list() {
  return &slave_data_list_;
}

// repeated .SlaveBriefInfo info_list = 4;
inline int SlaveSyncDataResp::info_list_size() const {
  return info_list_.size();
}
inline void SlaveSyncDataResp::clear_info_list() {
  info_list_.Clear();
}
inline const ::SlaveBriefInfo& SlaveSyncDataResp::info_list(int index) const {
  return info_list_.Get(index);
}
inline ::SlaveBriefInfo* SlaveSyncDataResp::mutable_info_list(int index) {
  return info_list_.Mutable(index);
}
inline ::SlaveBriefInfo* SlaveSyncDataResp::add_info_list() {
  return info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SlaveBriefInfo >&
SlaveSyncDataResp::info_list() const {
  return info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::SlaveBriefInfo >*
SlaveSyncDataResp::mutable_info_list() {
  return &info_list_;
}

// -------------------------------------------------------------------

// SlaveGetResReq

// required int32 type = 1;
inline bool SlaveGetResReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveGetResReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveGetResReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveGetResReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SlaveGetResReq::type() const {
  return type_;
}
inline void SlaveGetResReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string slave_name = 2;
inline bool SlaveGetResReq::has_slave_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveGetResReq::set_has_slave_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveGetResReq::clear_has_slave_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveGetResReq::clear_slave_name() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    slave_name_->clear();
  }
  clear_has_slave_name();
}
inline const ::std::string& SlaveGetResReq::slave_name() const {
  return *slave_name_;
}
inline void SlaveGetResReq::set_slave_name(const ::std::string& value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void SlaveGetResReq::set_slave_name(const char* value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void SlaveGetResReq::set_slave_name(const char* value, size_t size) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveGetResReq::mutable_slave_name() {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  return slave_name_;
}
inline ::std::string* SlaveGetResReq::release_slave_name() {
  clear_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slave_name_;
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveGetResReq::set_allocated_slave_name(::std::string* slave_name) {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  if (slave_name) {
    set_has_slave_name();
    slave_name_ = slave_name;
  } else {
    clear_has_slave_name();
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SlaveGetResResp

// required .SlaveGetResResp.SlaveGetResRet result = 1;
inline bool SlaveGetResResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveGetResResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveGetResResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveGetResResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::SlaveGetResResp_SlaveGetResRet SlaveGetResResp::result() const {
  return static_cast< ::SlaveGetResResp_SlaveGetResRet >(result_);
}
inline void SlaveGetResResp::set_result(::SlaveGetResResp_SlaveGetResRet value) {
  assert(::SlaveGetResResp_SlaveGetResRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SlaveGetResResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveGetResResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveGetResResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveGetResResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SlaveGetResResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SlaveGetResResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SlaveGetResResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SlaveGetResResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated int32 res = 3;
inline int SlaveGetResResp::res_size() const {
  return res_.size();
}
inline void SlaveGetResResp::clear_res() {
  res_.Clear();
}
inline ::google::protobuf::int32 SlaveGetResResp::res(int index) const {
  return res_.Get(index);
}
inline void SlaveGetResResp::set_res(int index, ::google::protobuf::int32 value) {
  res_.Set(index, value);
}
inline void SlaveGetResResp::add_res(::google::protobuf::int32 value) {
  res_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SlaveGetResResp::res() const {
  return res_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SlaveGetResResp::mutable_res() {
  return &res_;
}

// optional int32 exp = 4;
inline bool SlaveGetResResp::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveGetResResp::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveGetResResp::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveGetResResp::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 SlaveGetResResp::exp() const {
  return exp_;
}
inline void SlaveGetResResp::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// SlaveFreeReq

// required int32 type = 1;
inline bool SlaveFreeReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveFreeReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveFreeReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveFreeReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SlaveFreeReq::type() const {
  return type_;
}
inline void SlaveFreeReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string slave_name = 2;
inline bool SlaveFreeReq::has_slave_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveFreeReq::set_has_slave_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveFreeReq::clear_has_slave_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveFreeReq::clear_slave_name() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    slave_name_->clear();
  }
  clear_has_slave_name();
}
inline const ::std::string& SlaveFreeReq::slave_name() const {
  return *slave_name_;
}
inline void SlaveFreeReq::set_slave_name(const ::std::string& value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void SlaveFreeReq::set_slave_name(const char* value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void SlaveFreeReq::set_slave_name(const char* value, size_t size) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveFreeReq::mutable_slave_name() {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  return slave_name_;
}
inline ::std::string* SlaveFreeReq::release_slave_name() {
  clear_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slave_name_;
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveFreeReq::set_allocated_slave_name(::std::string* slave_name) {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  if (slave_name) {
    set_has_slave_name();
    slave_name_ = slave_name;
  } else {
    clear_has_slave_name();
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SlaveFreeResp

// required .SlaveFreeResp.SlaveFreeRet result = 1;
inline bool SlaveFreeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveFreeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveFreeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveFreeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::SlaveFreeResp_SlaveFreeRet SlaveFreeResp::result() const {
  return static_cast< ::SlaveFreeResp_SlaveFreeRet >(result_);
}
inline void SlaveFreeResp::set_result(::SlaveFreeResp_SlaveFreeRet value) {
  assert(::SlaveFreeResp_SlaveFreeRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SlaveFreeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveFreeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveFreeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveFreeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SlaveFreeResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SlaveFreeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SlaveFreeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SlaveFreeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// SlaveShowReq

// required int32 type = 1;
inline bool SlaveShowReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveShowReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveShowReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveShowReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SlaveShowReq::type() const {
  return type_;
}
inline void SlaveShowReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string slave_name = 2;
inline bool SlaveShowReq::has_slave_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveShowReq::set_has_slave_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveShowReq::clear_has_slave_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveShowReq::clear_slave_name() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    slave_name_->clear();
  }
  clear_has_slave_name();
}
inline const ::std::string& SlaveShowReq::slave_name() const {
  return *slave_name_;
}
inline void SlaveShowReq::set_slave_name(const ::std::string& value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void SlaveShowReq::set_slave_name(const char* value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void SlaveShowReq::set_slave_name(const char* value, size_t size) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveShowReq::mutable_slave_name() {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  return slave_name_;
}
inline ::std::string* SlaveShowReq::release_slave_name() {
  clear_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slave_name_;
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveShowReq::set_allocated_slave_name(::std::string* slave_name) {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  if (slave_name) {
    set_has_slave_name();
    slave_name_ = slave_name;
  } else {
    clear_has_slave_name();
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SlaveShowResp

// required .SlaveShowResp.SlaveShowRet result = 1;
inline bool SlaveShowResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveShowResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveShowResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveShowResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::SlaveShowResp_SlaveShowRet SlaveShowResp::result() const {
  return static_cast< ::SlaveShowResp_SlaveShowRet >(result_);
}
inline void SlaveShowResp::set_result(::SlaveShowResp_SlaveShowRet value) {
  assert(::SlaveShowResp_SlaveShowRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SlaveShowResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveShowResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveShowResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveShowResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SlaveShowResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SlaveShowResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SlaveShowResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SlaveShowResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .Pair get_item_list = 3;
inline int SlaveShowResp::get_item_list_size() const {
  return get_item_list_.size();
}
inline void SlaveShowResp::clear_get_item_list() {
  get_item_list_.Clear();
}
inline const ::Pair& SlaveShowResp::get_item_list(int index) const {
  return get_item_list_.Get(index);
}
inline ::Pair* SlaveShowResp::mutable_get_item_list(int index) {
  return get_item_list_.Mutable(index);
}
inline ::Pair* SlaveShowResp::add_get_item_list() {
  return get_item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
SlaveShowResp::get_item_list() const {
  return get_item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Pair >*
SlaveShowResp::mutable_get_item_list() {
  return &get_item_list_;
}

// -------------------------------------------------------------------

// SlaveWorkReq

// required string slave_name = 1;
inline bool SlaveWorkReq::has_slave_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveWorkReq::set_has_slave_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveWorkReq::clear_has_slave_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveWorkReq::clear_slave_name() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    slave_name_->clear();
  }
  clear_has_slave_name();
}
inline const ::std::string& SlaveWorkReq::slave_name() const {
  return *slave_name_;
}
inline void SlaveWorkReq::set_slave_name(const ::std::string& value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void SlaveWorkReq::set_slave_name(const char* value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
}
inline void SlaveWorkReq::set_slave_name(const char* value, size_t size) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveWorkReq::mutable_slave_name() {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    slave_name_ = new ::std::string;
  }
  return slave_name_;
}
inline ::std::string* SlaveWorkReq::release_slave_name() {
  clear_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slave_name_;
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveWorkReq::set_allocated_slave_name(::std::string* slave_name) {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  if (slave_name) {
    set_has_slave_name();
    slave_name_ = slave_name;
  } else {
    clear_has_slave_name();
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SlaveWorkResp

// required .SlaveWorkResp.SlaveWorkRet result = 1;
inline bool SlaveWorkResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveWorkResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveWorkResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveWorkResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::SlaveWorkResp_SlaveWorkRet SlaveWorkResp::result() const {
  return static_cast< ::SlaveWorkResp_SlaveWorkRet >(result_);
}
inline void SlaveWorkResp::set_result(::SlaveWorkResp_SlaveWorkRet value) {
  assert(::SlaveWorkResp_SlaveWorkRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SlaveWorkResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveWorkResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveWorkResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveWorkResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SlaveWorkResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SlaveWorkResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SlaveWorkResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SlaveWorkResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .Pair get_item_list = 3;
inline int SlaveWorkResp::get_item_list_size() const {
  return get_item_list_.size();
}
inline void SlaveWorkResp::clear_get_item_list() {
  get_item_list_.Clear();
}
inline const ::Pair& SlaveWorkResp::get_item_list(int index) const {
  return get_item_list_.Get(index);
}
inline ::Pair* SlaveWorkResp::mutable_get_item_list(int index) {
  return get_item_list_.Mutable(index);
}
inline ::Pair* SlaveWorkResp::add_get_item_list() {
  return get_item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
SlaveWorkResp::get_item_list() const {
  return get_item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Pair >*
SlaveWorkResp::mutable_get_item_list() {
  return &get_item_list_;
}

// optional .SlaveNoteInfo note_info = 4;
inline bool SlaveWorkResp::has_note_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveWorkResp::set_has_note_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveWorkResp::clear_has_note_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveWorkResp::clear_note_info() {
  if (note_info_ != NULL) note_info_->::SlaveNoteInfo::Clear();
  clear_has_note_info();
}
inline const ::SlaveNoteInfo& SlaveWorkResp::note_info() const {
  return note_info_ != NULL ? *note_info_ : *default_instance_->note_info_;
}
inline ::SlaveNoteInfo* SlaveWorkResp::mutable_note_info() {
  set_has_note_info();
  if (note_info_ == NULL) note_info_ = new ::SlaveNoteInfo;
  return note_info_;
}
inline ::SlaveNoteInfo* SlaveWorkResp::release_note_info() {
  clear_has_note_info();
  ::SlaveNoteInfo* temp = note_info_;
  note_info_ = NULL;
  return temp;
}
inline void SlaveWorkResp::set_allocated_note_info(::SlaveNoteInfo* note_info) {
  delete note_info_;
  note_info_ = note_info;
  if (note_info) {
    set_has_note_info();
  } else {
    clear_has_note_info();
  }
}

// -------------------------------------------------------------------

// SlaveFawnOnReq

// required int32 type = 1;
inline bool SlaveFawnOnReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveFawnOnReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveFawnOnReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveFawnOnReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SlaveFawnOnReq::type() const {
  return type_;
}
inline void SlaveFawnOnReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// SlaveFawnOnResp

// required .SlaveFawnOnResp.SlaveFawnOnRet result = 1;
inline bool SlaveFawnOnResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveFawnOnResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveFawnOnResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveFawnOnResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::result() const {
  return static_cast< ::SlaveFawnOnResp_SlaveFawnOnRet >(result_);
}
inline void SlaveFawnOnResp::set_result(::SlaveFawnOnResp_SlaveFawnOnRet value) {
  assert(::SlaveFawnOnResp_SlaveFawnOnRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SlaveFawnOnResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveFawnOnResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveFawnOnResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveFawnOnResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SlaveFawnOnResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SlaveFawnOnResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SlaveFawnOnResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SlaveFawnOnResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .Pair get_item_list = 3;
inline int SlaveFawnOnResp::get_item_list_size() const {
  return get_item_list_.size();
}
inline void SlaveFawnOnResp::clear_get_item_list() {
  get_item_list_.Clear();
}
inline const ::Pair& SlaveFawnOnResp::get_item_list(int index) const {
  return get_item_list_.Get(index);
}
inline ::Pair* SlaveFawnOnResp::mutable_get_item_list(int index) {
  return get_item_list_.Mutable(index);
}
inline ::Pair* SlaveFawnOnResp::add_get_item_list() {
  return get_item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
SlaveFawnOnResp::get_item_list() const {
  return get_item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Pair >*
SlaveFawnOnResp::mutable_get_item_list() {
  return &get_item_list_;
}

// optional .SlaveNoteInfo note_info = 4;
inline bool SlaveFawnOnResp::has_note_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveFawnOnResp::set_has_note_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveFawnOnResp::clear_has_note_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveFawnOnResp::clear_note_info() {
  if (note_info_ != NULL) note_info_->::SlaveNoteInfo::Clear();
  clear_has_note_info();
}
inline const ::SlaveNoteInfo& SlaveFawnOnResp::note_info() const {
  return note_info_ != NULL ? *note_info_ : *default_instance_->note_info_;
}
inline ::SlaveNoteInfo* SlaveFawnOnResp::mutable_note_info() {
  set_has_note_info();
  if (note_info_ == NULL) note_info_ = new ::SlaveNoteInfo;
  return note_info_;
}
inline ::SlaveNoteInfo* SlaveFawnOnResp::release_note_info() {
  clear_has_note_info();
  ::SlaveNoteInfo* temp = note_info_;
  note_info_ = NULL;
  return temp;
}
inline void SlaveFawnOnResp::set_allocated_note_info(::SlaveNoteInfo* note_info) {
  delete note_info_;
  note_info_ = note_info;
  if (note_info) {
    set_has_note_info();
  } else {
    clear_has_note_info();
  }
}

// -------------------------------------------------------------------

// SlaveHelpReq

// required int32 type = 1;
inline bool SlaveHelpReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveHelpReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveHelpReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveHelpReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SlaveHelpReq::type() const {
  return type_;
}
inline void SlaveHelpReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// SlaveHelpResp

// required .SlaveHelpResp.SlaveHelpRet result = 1;
inline bool SlaveHelpResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveHelpResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveHelpResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveHelpResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::SlaveHelpResp_SlaveHelpRet SlaveHelpResp::result() const {
  return static_cast< ::SlaveHelpResp_SlaveHelpRet >(result_);
}
inline void SlaveHelpResp::set_result(::SlaveHelpResp_SlaveHelpRet value) {
  assert(::SlaveHelpResp_SlaveHelpRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SlaveHelpResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveHelpResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveHelpResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveHelpResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SlaveHelpResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SlaveHelpResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SlaveHelpResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SlaveHelpResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// SlaveSearchReq

// required int32 type = 1;
inline bool SlaveSearchReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveSearchReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveSearchReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveSearchReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SlaveSearchReq::type() const {
  return type_;
}
inline void SlaveSearchReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// SlaveSearchResp

// required .SlaveSearchResp.SlaveSearchRet result = 1;
inline bool SlaveSearchResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveSearchResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveSearchResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveSearchResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::SlaveSearchResp_SlaveSearchRet SlaveSearchResp::result() const {
  return static_cast< ::SlaveSearchResp_SlaveSearchRet >(result_);
}
inline void SlaveSearchResp::set_result(::SlaveSearchResp_SlaveSearchRet value) {
  assert(::SlaveSearchResp_SlaveSearchRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SlaveSearchResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveSearchResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveSearchResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveSearchResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SlaveSearchResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SlaveSearchResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SlaveSearchResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SlaveSearchResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .SlaveBriefInfo info_list = 3;
inline int SlaveSearchResp::info_list_size() const {
  return info_list_.size();
}
inline void SlaveSearchResp::clear_info_list() {
  info_list_.Clear();
}
inline const ::SlaveBriefInfo& SlaveSearchResp::info_list(int index) const {
  return info_list_.Get(index);
}
inline ::SlaveBriefInfo* SlaveSearchResp::mutable_info_list(int index) {
  return info_list_.Mutable(index);
}
inline ::SlaveBriefInfo* SlaveSearchResp::add_info_list() {
  return info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SlaveBriefInfo >&
SlaveSearchResp::info_list() const {
  return info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::SlaveBriefInfo >*
SlaveSearchResp::mutable_info_list() {
  return &info_list_;
}

// -------------------------------------------------------------------

// SlaveAddTimesReq

// required int32 type = 1;
inline bool SlaveAddTimesReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveAddTimesReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveAddTimesReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveAddTimesReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SlaveAddTimesReq::type() const {
  return type_;
}
inline void SlaveAddTimesReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// SlaveAddTimesResp

// required .SlaveAddTimesResp.SlaveAddTimesRet result = 1;
inline bool SlaveAddTimesResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveAddTimesResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveAddTimesResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveAddTimesResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::result() const {
  return static_cast< ::SlaveAddTimesResp_SlaveAddTimesRet >(result_);
}
inline void SlaveAddTimesResp::set_result(::SlaveAddTimesResp_SlaveAddTimesRet value) {
  assert(::SlaveAddTimesResp_SlaveAddTimesRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SlaveAddTimesResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveAddTimesResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveAddTimesResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveAddTimesResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SlaveAddTimesResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SlaveAddTimesResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SlaveAddTimesResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SlaveAddTimesResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// SlaveAttackReq

// required int32 type = 1;
inline bool SlaveAttackReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveAttackReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveAttackReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveAttackReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SlaveAttackReq::type() const {
  return type_;
}
inline void SlaveAttackReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string user_name = 2;
inline bool SlaveAttackReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveAttackReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveAttackReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveAttackReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& SlaveAttackReq::user_name() const {
  return *user_name_;
}
inline void SlaveAttackReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void SlaveAttackReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void SlaveAttackReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveAttackReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* SlaveAttackReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveAttackReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 lineup = 3;
inline int SlaveAttackReq::lineup_size() const {
  return lineup_.size();
}
inline void SlaveAttackReq::clear_lineup() {
  lineup_.Clear();
}
inline ::google::protobuf::int32 SlaveAttackReq::lineup(int index) const {
  return lineup_.Get(index);
}
inline void SlaveAttackReq::set_lineup(int index, ::google::protobuf::int32 value) {
  lineup_.Set(index, value);
}
inline void SlaveAttackReq::add_lineup(::google::protobuf::int32 value) {
  lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SlaveAttackReq::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SlaveAttackReq::mutable_lineup() {
  return &lineup_;
}

// -------------------------------------------------------------------

// SlaveAttackResp

// required .SlaveAttackResp.SlaveAttackRet result = 1;
inline bool SlaveAttackResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveAttackResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveAttackResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveAttackResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::SlaveAttackResp_SlaveAttackRet SlaveAttackResp::result() const {
  return static_cast< ::SlaveAttackResp_SlaveAttackRet >(result_);
}
inline void SlaveAttackResp::set_result(::SlaveAttackResp_SlaveAttackRet value) {
  assert(::SlaveAttackResp_SlaveAttackRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SlaveAttackResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveAttackResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveAttackResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveAttackResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SlaveAttackResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* SlaveAttackResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SlaveAttackResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SlaveAttackResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .AirShip attack_list = 3;
inline int SlaveAttackResp::attack_list_size() const {
  return attack_list_.size();
}
inline void SlaveAttackResp::clear_attack_list() {
  attack_list_.Clear();
}
inline const ::AirShip& SlaveAttackResp::attack_list(int index) const {
  return attack_list_.Get(index);
}
inline ::AirShip* SlaveAttackResp::mutable_attack_list(int index) {
  return attack_list_.Mutable(index);
}
inline ::AirShip* SlaveAttackResp::add_attack_list() {
  return attack_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
SlaveAttackResp::attack_list() const {
  return attack_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
SlaveAttackResp::mutable_attack_list() {
  return &attack_list_;
}

// repeated .AirShip hurter_list = 4;
inline int SlaveAttackResp::hurter_list_size() const {
  return hurter_list_.size();
}
inline void SlaveAttackResp::clear_hurter_list() {
  hurter_list_.Clear();
}
inline const ::AirShip& SlaveAttackResp::hurter_list(int index) const {
  return hurter_list_.Get(index);
}
inline ::AirShip* SlaveAttackResp::mutable_hurter_list(int index) {
  return hurter_list_.Mutable(index);
}
inline ::AirShip* SlaveAttackResp::add_hurter_list() {
  return hurter_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
SlaveAttackResp::hurter_list() const {
  return hurter_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
SlaveAttackResp::mutable_hurter_list() {
  return &hurter_list_;
}

// repeated .EventInfo event_list = 5;
inline int SlaveAttackResp::event_list_size() const {
  return event_list_.size();
}
inline void SlaveAttackResp::clear_event_list() {
  event_list_.Clear();
}
inline const ::EventInfo& SlaveAttackResp::event_list(int index) const {
  return event_list_.Get(index);
}
inline ::EventInfo* SlaveAttackResp::mutable_event_list(int index) {
  return event_list_.Mutable(index);
}
inline ::EventInfo* SlaveAttackResp::add_event_list() {
  return event_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EventInfo >&
SlaveAttackResp::event_list() const {
  return event_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::EventInfo >*
SlaveAttackResp::mutable_event_list() {
  return &event_list_;
}

// optional bool isWin = 6;
inline bool SlaveAttackResp::has_iswin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveAttackResp::set_has_iswin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveAttackResp::clear_has_iswin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveAttackResp::clear_iswin() {
  iswin_ = false;
  clear_has_iswin();
}
inline bool SlaveAttackResp::iswin() const {
  return iswin_;
}
inline void SlaveAttackResp::set_iswin(bool value) {
  set_has_iswin();
  iswin_ = value;
}

// optional bool isCatch = 7;
inline bool SlaveAttackResp::has_iscatch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlaveAttackResp::set_has_iscatch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlaveAttackResp::clear_has_iscatch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlaveAttackResp::clear_iscatch() {
  iscatch_ = false;
  clear_has_iscatch();
}
inline bool SlaveAttackResp::iscatch() const {
  return iscatch_;
}
inline void SlaveAttackResp::set_iscatch(bool value) {
  set_has_iscatch();
  iscatch_ = value;
}

// repeated .Pair get_item_list = 8;
inline int SlaveAttackResp::get_item_list_size() const {
  return get_item_list_.size();
}
inline void SlaveAttackResp::clear_get_item_list() {
  get_item_list_.Clear();
}
inline const ::Pair& SlaveAttackResp::get_item_list(int index) const {
  return get_item_list_.Get(index);
}
inline ::Pair* SlaveAttackResp::mutable_get_item_list(int index) {
  return get_item_list_.Mutable(index);
}
inline ::Pair* SlaveAttackResp::add_get_item_list() {
  return get_item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
SlaveAttackResp::get_item_list() const {
  return get_item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Pair >*
SlaveAttackResp::mutable_get_item_list() {
  return &get_item_list_;
}

// optional .SlaveAttackReq req = 9;
inline bool SlaveAttackResp::has_req() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SlaveAttackResp::set_has_req() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SlaveAttackResp::clear_has_req() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SlaveAttackResp::clear_req() {
  if (req_ != NULL) req_->::SlaveAttackReq::Clear();
  clear_has_req();
}
inline const ::SlaveAttackReq& SlaveAttackResp::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::SlaveAttackReq* SlaveAttackResp::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::SlaveAttackReq;
  return req_;
}
inline ::SlaveAttackReq* SlaveAttackResp::release_req() {
  clear_has_req();
  ::SlaveAttackReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void SlaveAttackResp::set_allocated_req(::SlaveAttackReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SlaveSyncDataResp_SlaveSyncDataRet>() {
  return ::SlaveSyncDataResp_SlaveSyncDataRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SlaveGetResResp_SlaveGetResRet>() {
  return ::SlaveGetResResp_SlaveGetResRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SlaveFreeResp_SlaveFreeRet>() {
  return ::SlaveFreeResp_SlaveFreeRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SlaveShowResp_SlaveShowRet>() {
  return ::SlaveShowResp_SlaveShowRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SlaveWorkResp_SlaveWorkRet>() {
  return ::SlaveWorkResp_SlaveWorkRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SlaveFawnOnResp_SlaveFawnOnRet>() {
  return ::SlaveFawnOnResp_SlaveFawnOnRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SlaveHelpResp_SlaveHelpRet>() {
  return ::SlaveHelpResp_SlaveHelpRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SlaveSearchResp_SlaveSearchRet>() {
  return ::SlaveSearchResp_SlaveSearchRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SlaveAddTimesResp_SlaveAddTimesRet>() {
  return ::SlaveAddTimesResp_SlaveAddTimesRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SlaveAttackResp_SlaveAttackRet>() {
  return ::SlaveAttackResp_SlaveAttackRet_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdSlave_2eproto__INCLUDED
