// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdPvp.proto

#ifndef PROTOBUF_CmdPvp_2eproto__INCLUDED
#define PROTOBUF_CmdPvp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "AirShip.pb.h"
#include "PvpInfo.pb.h"
#include "UserSync.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdPvp_2eproto();
void protobuf_AssignDesc_CmdPvp_2eproto();
void protobuf_ShutdownFile_CmdPvp_2eproto();

class PvpReq;
class PvpResp;
class VideoData;
class PvpVideoReq;
class PvpVideoResp;

// ===================================================================

class PvpReq : public ::google::protobuf::Message {
 public:
  PvpReq();
  virtual ~PvpReq();

  PvpReq(const PvpReq& from);

  inline PvpReq& operator=(const PvpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpReq& default_instance();

  void Swap(PvpReq* other);

  // implements Message ----------------------------------------------

  PvpReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpReq& from);
  void MergeFrom(const PvpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string target_name = 2;
  inline bool has_target_name() const;
  inline void clear_target_name();
  static const int kTargetNameFieldNumber = 2;
  inline const ::std::string& target_name() const;
  inline void set_target_name(const ::std::string& value);
  inline void set_target_name(const char* value);
  inline void set_target_name(const char* value, size_t size);
  inline ::std::string* mutable_target_name();
  inline ::std::string* release_target_name();
  inline void set_allocated_target_name(::std::string* target_name);

  // required int32 target_sid = 3;
  inline bool has_target_sid() const;
  inline void clear_target_sid();
  static const int kTargetSidFieldNumber = 3;
  inline ::google::protobuf::int32 target_sid() const;
  inline void set_target_sid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PvpReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_target_name();
  inline void clear_has_target_name();
  inline void set_has_target_sid();
  inline void clear_has_target_sid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* target_name_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 target_sid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPvp_2eproto();
  friend void protobuf_AssignDesc_CmdPvp_2eproto();
  friend void protobuf_ShutdownFile_CmdPvp_2eproto();

  void InitAsDefaultInstance();
  static PvpReq* default_instance_;
};
// -------------------------------------------------------------------

class PvpResp : public ::google::protobuf::Message {
 public:
  PvpResp();
  virtual ~PvpResp();

  PvpResp(const PvpResp& from);

  inline PvpResp& operator=(const PvpResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpResp& default_instance();

  void Swap(PvpResp* other);

  // implements Message ----------------------------------------------

  PvpResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpResp& from);
  void MergeFrom(const PvpResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .AirShip attack_list = 3;
  inline int attack_list_size() const;
  inline void clear_attack_list();
  static const int kAttackListFieldNumber = 3;
  inline const ::AirShip& attack_list(int index) const;
  inline ::AirShip* mutable_attack_list(int index);
  inline ::AirShip* add_attack_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
      attack_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
      mutable_attack_list();

  // repeated .AirShip hurter_list = 4;
  inline int hurter_list_size() const;
  inline void clear_hurter_list();
  static const int kHurterListFieldNumber = 4;
  inline const ::AirShip& hurter_list(int index) const;
  inline ::AirShip* mutable_hurter_list(int index);
  inline ::AirShip* add_hurter_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
      hurter_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
      mutable_hurter_list();

  // repeated .EventInfo event_list = 5;
  inline int event_list_size() const;
  inline void clear_event_list();
  static const int kEventListFieldNumber = 5;
  inline const ::EventInfo& event_list(int index) const;
  inline ::EventInfo* mutable_event_list(int index);
  inline ::EventInfo* add_event_list();
  inline const ::google::protobuf::RepeatedPtrField< ::EventInfo >&
      event_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::EventInfo >*
      mutable_event_list();

  // repeated int32 attacker_hp_list = 6;
  inline int attacker_hp_list_size() const;
  inline void clear_attacker_hp_list();
  static const int kAttackerHpListFieldNumber = 6;
  inline ::google::protobuf::int32 attacker_hp_list(int index) const;
  inline void set_attacker_hp_list(int index, ::google::protobuf::int32 value);
  inline void add_attacker_hp_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      attacker_hp_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_attacker_hp_list();

  // repeated int32 hurter_hp_list = 7;
  inline int hurter_hp_list_size() const;
  inline void clear_hurter_hp_list();
  static const int kHurterHpListFieldNumber = 7;
  inline ::google::protobuf::int32 hurter_hp_list(int index) const;
  inline void set_hurter_hp_list(int index, ::google::protobuf::int32 value);
  inline void add_hurter_hp_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hurter_hp_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hurter_hp_list();

  // @@protoc_insertion_point(class_scope:PvpResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::AirShip > attack_list_;
  ::google::protobuf::RepeatedPtrField< ::AirShip > hurter_list_;
  ::google::protobuf::RepeatedPtrField< ::EventInfo > event_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > attacker_hp_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hurter_hp_list_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPvp_2eproto();
  friend void protobuf_AssignDesc_CmdPvp_2eproto();
  friend void protobuf_ShutdownFile_CmdPvp_2eproto();

  void InitAsDefaultInstance();
  static PvpResp* default_instance_;
};
// -------------------------------------------------------------------

class VideoData : public ::google::protobuf::Message {
 public:
  VideoData();
  virtual ~VideoData();

  VideoData(const VideoData& from);

  inline VideoData& operator=(const VideoData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoData& default_instance();

  void Swap(VideoData* other);

  // implements Message ----------------------------------------------

  VideoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoData& from);
  void MergeFrom(const VideoData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline ::google::protobuf::int32 guid() const;
  inline void set_guid(::google::protobuf::int32 value);

  // required int64 stamp = 2;
  inline bool has_stamp() const;
  inline void clear_stamp();
  static const int kStampFieldNumber = 2;
  inline ::google::protobuf::int64 stamp() const;
  inline void set_stamp(::google::protobuf::int64 value);

  // required int64 expiry_stamp = 3;
  inline bool has_expiry_stamp() const;
  inline void clear_expiry_stamp();
  static const int kExpiryStampFieldNumber = 3;
  inline ::google::protobuf::int64 expiry_stamp() const;
  inline void set_expiry_stamp(::google::protobuf::int64 value);

  // required .PvpResp resp = 4;
  inline bool has_resp() const;
  inline void clear_resp();
  static const int kRespFieldNumber = 4;
  inline const ::PvpResp& resp() const;
  inline ::PvpResp* mutable_resp();
  inline ::PvpResp* release_resp();
  inline void set_allocated_resp(::PvpResp* resp);

  // @@protoc_insertion_point(class_scope:VideoData)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_stamp();
  inline void clear_has_stamp();
  inline void set_has_expiry_stamp();
  inline void clear_has_expiry_stamp();
  inline void set_has_resp();
  inline void clear_has_resp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 stamp_;
  ::google::protobuf::int64 expiry_stamp_;
  ::PvpResp* resp_;
  ::google::protobuf::int32 guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPvp_2eproto();
  friend void protobuf_AssignDesc_CmdPvp_2eproto();
  friend void protobuf_ShutdownFile_CmdPvp_2eproto();

  void InitAsDefaultInstance();
  static VideoData* default_instance_;
};
// -------------------------------------------------------------------

class PvpVideoReq : public ::google::protobuf::Message {
 public:
  PvpVideoReq();
  virtual ~PvpVideoReq();

  PvpVideoReq(const PvpVideoReq& from);

  inline PvpVideoReq& operator=(const PvpVideoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpVideoReq& default_instance();

  void Swap(PvpVideoReq* other);

  // implements Message ----------------------------------------------

  PvpVideoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpVideoReq& from);
  void MergeFrom(const PvpVideoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string video_key = 1;
  inline bool has_video_key() const;
  inline void clear_video_key();
  static const int kVideoKeyFieldNumber = 1;
  inline const ::std::string& video_key() const;
  inline void set_video_key(const ::std::string& value);
  inline void set_video_key(const char* value);
  inline void set_video_key(const char* value, size_t size);
  inline ::std::string* mutable_video_key();
  inline ::std::string* release_video_key();
  inline void set_allocated_video_key(::std::string* video_key);

  // @@protoc_insertion_point(class_scope:PvpVideoReq)
 private:
  inline void set_has_video_key();
  inline void clear_has_video_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* video_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPvp_2eproto();
  friend void protobuf_AssignDesc_CmdPvp_2eproto();
  friend void protobuf_ShutdownFile_CmdPvp_2eproto();

  void InitAsDefaultInstance();
  static PvpVideoReq* default_instance_;
};
// -------------------------------------------------------------------

class PvpVideoResp : public ::google::protobuf::Message {
 public:
  PvpVideoResp();
  virtual ~PvpVideoResp();

  PvpVideoResp(const PvpVideoResp& from);

  inline PvpVideoResp& operator=(const PvpVideoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpVideoResp& default_instance();

  void Swap(PvpVideoResp* other);

  // implements Message ----------------------------------------------

  PvpVideoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PvpVideoResp& from);
  void MergeFrom(const PvpVideoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .VideoData data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::VideoData& data() const;
  inline ::VideoData* mutable_data();
  inline ::VideoData* release_data();
  inline void set_allocated_data(::VideoData* data);

  // @@protoc_insertion_point(class_scope:PvpVideoResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserSync* user_sync_;
  ::VideoData* data_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CmdPvp_2eproto();
  friend void protobuf_AssignDesc_CmdPvp_2eproto();
  friend void protobuf_ShutdownFile_CmdPvp_2eproto();

  void InitAsDefaultInstance();
  static PvpVideoResp* default_instance_;
};
// ===================================================================


// ===================================================================

// PvpReq

// required int32 type = 1;
inline bool PvpReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PvpReq::type() const {
  return type_;
}
inline void PvpReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string target_name = 2;
inline bool PvpReq::has_target_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpReq::set_has_target_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpReq::clear_has_target_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpReq::clear_target_name() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    target_name_->clear();
  }
  clear_has_target_name();
}
inline const ::std::string& PvpReq::target_name() const {
  return *target_name_;
}
inline void PvpReq::set_target_name(const ::std::string& value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void PvpReq::set_target_name(const char* value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void PvpReq::set_target_name(const char* value, size_t size) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PvpReq::mutable_target_name() {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  return target_name_;
}
inline ::std::string* PvpReq::release_target_name() {
  clear_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_name_;
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PvpReq::set_allocated_target_name(::std::string* target_name) {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  if (target_name) {
    set_has_target_name();
    target_name_ = target_name;
  } else {
    clear_has_target_name();
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 target_sid = 3;
inline bool PvpReq::has_target_sid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpReq::set_has_target_sid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpReq::clear_has_target_sid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpReq::clear_target_sid() {
  target_sid_ = 0;
  clear_has_target_sid();
}
inline ::google::protobuf::int32 PvpReq::target_sid() const {
  return target_sid_;
}
inline void PvpReq::set_target_sid(::google::protobuf::int32 value) {
  set_has_target_sid();
  target_sid_ = value;
}

// -------------------------------------------------------------------

// PvpResp

// required int32 result = 1;
inline bool PvpResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PvpResp::result() const {
  return result_;
}
inline void PvpResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PvpResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PvpResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* PvpResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PvpResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PvpResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .AirShip attack_list = 3;
inline int PvpResp::attack_list_size() const {
  return attack_list_.size();
}
inline void PvpResp::clear_attack_list() {
  attack_list_.Clear();
}
inline const ::AirShip& PvpResp::attack_list(int index) const {
  return attack_list_.Get(index);
}
inline ::AirShip* PvpResp::mutable_attack_list(int index) {
  return attack_list_.Mutable(index);
}
inline ::AirShip* PvpResp::add_attack_list() {
  return attack_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
PvpResp::attack_list() const {
  return attack_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
PvpResp::mutable_attack_list() {
  return &attack_list_;
}

// repeated .AirShip hurter_list = 4;
inline int PvpResp::hurter_list_size() const {
  return hurter_list_.size();
}
inline void PvpResp::clear_hurter_list() {
  hurter_list_.Clear();
}
inline const ::AirShip& PvpResp::hurter_list(int index) const {
  return hurter_list_.Get(index);
}
inline ::AirShip* PvpResp::mutable_hurter_list(int index) {
  return hurter_list_.Mutable(index);
}
inline ::AirShip* PvpResp::add_hurter_list() {
  return hurter_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
PvpResp::hurter_list() const {
  return hurter_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
PvpResp::mutable_hurter_list() {
  return &hurter_list_;
}

// repeated .EventInfo event_list = 5;
inline int PvpResp::event_list_size() const {
  return event_list_.size();
}
inline void PvpResp::clear_event_list() {
  event_list_.Clear();
}
inline const ::EventInfo& PvpResp::event_list(int index) const {
  return event_list_.Get(index);
}
inline ::EventInfo* PvpResp::mutable_event_list(int index) {
  return event_list_.Mutable(index);
}
inline ::EventInfo* PvpResp::add_event_list() {
  return event_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EventInfo >&
PvpResp::event_list() const {
  return event_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::EventInfo >*
PvpResp::mutable_event_list() {
  return &event_list_;
}

// repeated int32 attacker_hp_list = 6;
inline int PvpResp::attacker_hp_list_size() const {
  return attacker_hp_list_.size();
}
inline void PvpResp::clear_attacker_hp_list() {
  attacker_hp_list_.Clear();
}
inline ::google::protobuf::int32 PvpResp::attacker_hp_list(int index) const {
  return attacker_hp_list_.Get(index);
}
inline void PvpResp::set_attacker_hp_list(int index, ::google::protobuf::int32 value) {
  attacker_hp_list_.Set(index, value);
}
inline void PvpResp::add_attacker_hp_list(::google::protobuf::int32 value) {
  attacker_hp_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PvpResp::attacker_hp_list() const {
  return attacker_hp_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PvpResp::mutable_attacker_hp_list() {
  return &attacker_hp_list_;
}

// repeated int32 hurter_hp_list = 7;
inline int PvpResp::hurter_hp_list_size() const {
  return hurter_hp_list_.size();
}
inline void PvpResp::clear_hurter_hp_list() {
  hurter_hp_list_.Clear();
}
inline ::google::protobuf::int32 PvpResp::hurter_hp_list(int index) const {
  return hurter_hp_list_.Get(index);
}
inline void PvpResp::set_hurter_hp_list(int index, ::google::protobuf::int32 value) {
  hurter_hp_list_.Set(index, value);
}
inline void PvpResp::add_hurter_hp_list(::google::protobuf::int32 value) {
  hurter_hp_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PvpResp::hurter_hp_list() const {
  return hurter_hp_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PvpResp::mutable_hurter_hp_list() {
  return &hurter_hp_list_;
}

// -------------------------------------------------------------------

// VideoData

// required int32 guid = 1;
inline bool VideoData::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoData::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoData::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoData::clear_guid() {
  guid_ = 0;
  clear_has_guid();
}
inline ::google::protobuf::int32 VideoData::guid() const {
  return guid_;
}
inline void VideoData::set_guid(::google::protobuf::int32 value) {
  set_has_guid();
  guid_ = value;
}

// required int64 stamp = 2;
inline bool VideoData::has_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoData::set_has_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoData::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoData::clear_stamp() {
  stamp_ = GOOGLE_LONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::int64 VideoData::stamp() const {
  return stamp_;
}
inline void VideoData::set_stamp(::google::protobuf::int64 value) {
  set_has_stamp();
  stamp_ = value;
}

// required int64 expiry_stamp = 3;
inline bool VideoData::has_expiry_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoData::set_has_expiry_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoData::clear_has_expiry_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoData::clear_expiry_stamp() {
  expiry_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_expiry_stamp();
}
inline ::google::protobuf::int64 VideoData::expiry_stamp() const {
  return expiry_stamp_;
}
inline void VideoData::set_expiry_stamp(::google::protobuf::int64 value) {
  set_has_expiry_stamp();
  expiry_stamp_ = value;
}

// required .PvpResp resp = 4;
inline bool VideoData::has_resp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoData::set_has_resp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VideoData::clear_has_resp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VideoData::clear_resp() {
  if (resp_ != NULL) resp_->::PvpResp::Clear();
  clear_has_resp();
}
inline const ::PvpResp& VideoData::resp() const {
  return resp_ != NULL ? *resp_ : *default_instance_->resp_;
}
inline ::PvpResp* VideoData::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) resp_ = new ::PvpResp;
  return resp_;
}
inline ::PvpResp* VideoData::release_resp() {
  clear_has_resp();
  ::PvpResp* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void VideoData::set_allocated_resp(::PvpResp* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    set_has_resp();
  } else {
    clear_has_resp();
  }
}

// -------------------------------------------------------------------

// PvpVideoReq

// required string video_key = 1;
inline bool PvpVideoReq::has_video_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpVideoReq::set_has_video_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpVideoReq::clear_has_video_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpVideoReq::clear_video_key() {
  if (video_key_ != &::google::protobuf::internal::kEmptyString) {
    video_key_->clear();
  }
  clear_has_video_key();
}
inline const ::std::string& PvpVideoReq::video_key() const {
  return *video_key_;
}
inline void PvpVideoReq::set_video_key(const ::std::string& value) {
  set_has_video_key();
  if (video_key_ == &::google::protobuf::internal::kEmptyString) {
    video_key_ = new ::std::string;
  }
  video_key_->assign(value);
}
inline void PvpVideoReq::set_video_key(const char* value) {
  set_has_video_key();
  if (video_key_ == &::google::protobuf::internal::kEmptyString) {
    video_key_ = new ::std::string;
  }
  video_key_->assign(value);
}
inline void PvpVideoReq::set_video_key(const char* value, size_t size) {
  set_has_video_key();
  if (video_key_ == &::google::protobuf::internal::kEmptyString) {
    video_key_ = new ::std::string;
  }
  video_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PvpVideoReq::mutable_video_key() {
  set_has_video_key();
  if (video_key_ == &::google::protobuf::internal::kEmptyString) {
    video_key_ = new ::std::string;
  }
  return video_key_;
}
inline ::std::string* PvpVideoReq::release_video_key() {
  clear_has_video_key();
  if (video_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = video_key_;
    video_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PvpVideoReq::set_allocated_video_key(::std::string* video_key) {
  if (video_key_ != &::google::protobuf::internal::kEmptyString) {
    delete video_key_;
  }
  if (video_key) {
    set_has_video_key();
    video_key_ = video_key;
  } else {
    clear_has_video_key();
    video_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PvpVideoResp

// required int32 result = 1;
inline bool PvpVideoResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpVideoResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpVideoResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpVideoResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PvpVideoResp::result() const {
  return result_;
}
inline void PvpVideoResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PvpVideoResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpVideoResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpVideoResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpVideoResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PvpVideoResp::user_sync() const {
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
}
inline ::UserSync* PvpVideoResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PvpVideoResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PvpVideoResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .VideoData data = 3;
inline bool PvpVideoResp::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpVideoResp::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpVideoResp::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpVideoResp::clear_data() {
  if (data_ != NULL) data_->::VideoData::Clear();
  clear_has_data();
}
inline const ::VideoData& PvpVideoResp::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::VideoData* PvpVideoResp::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::VideoData;
  return data_;
}
inline ::VideoData* PvpVideoResp::release_data() {
  clear_has_data();
  ::VideoData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void PvpVideoResp::set_allocated_data(::VideoData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdPvp_2eproto__INCLUDED
