// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdBuilding.proto

#ifndef PROTOBUF_CmdBuilding_2eproto__INCLUDED
#define PROTOBUF_CmdBuilding_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Building.pb.h"
#include "UserSync.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdBuilding_2eproto();
void protobuf_AssignDesc_CmdBuilding_2eproto();
void protobuf_ShutdownFile_CmdBuilding_2eproto();

class BuildingUpgradeReq;
class BuildingUpgradeResp;
class BuildingUpdateReq;
class BuildingUpdateResp;
class BuildingUpgradeSpeedUpReq;
class BuildingUpgradeSpeedUpResp;
class BuildQueueAddReq;
class BuildQueueAddResp;
class BuildQueueRemoveReq;
class BuildQueueRemoveResp;

// ===================================================================

class BuildingUpgradeReq : public ::google::protobuf::MessageLite {
 public:
  BuildingUpgradeReq();
  virtual ~BuildingUpgradeReq();

  BuildingUpgradeReq(const BuildingUpgradeReq& from);

  inline BuildingUpgradeReq& operator=(const BuildingUpgradeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildingUpgradeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildingUpgradeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildingUpgradeReq* other);

  // implements Message ----------------------------------------------

  BuildingUpgradeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildingUpgradeReq& from);
  void MergeFrom(const BuildingUpgradeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BuildingUpgradeReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdBuilding_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdBuilding_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdBuilding_2eproto();
  friend void protobuf_ShutdownFile_CmdBuilding_2eproto();

  void InitAsDefaultInstance();
  static BuildingUpgradeReq* default_instance_;
};
// -------------------------------------------------------------------

class BuildingUpgradeResp : public ::google::protobuf::MessageLite {
 public:
  BuildingUpgradeResp();
  virtual ~BuildingUpgradeResp();

  BuildingUpgradeResp(const BuildingUpgradeResp& from);

  inline BuildingUpgradeResp& operator=(const BuildingUpgradeResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildingUpgradeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildingUpgradeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildingUpgradeResp* other);

  // implements Message ----------------------------------------------

  BuildingUpgradeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildingUpgradeResp& from);
  void MergeFrom(const BuildingUpgradeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .BuildingInfo info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::BuildingInfo& info() const;
  inline ::BuildingInfo* mutable_info();
  inline ::BuildingInfo* release_info();
  inline void set_allocated_info(::BuildingInfo* info);

  // @@protoc_insertion_point(class_scope:BuildingUpgradeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_info();
  inline void clear_has_info();

  ::UserSync* user_sync_;
  ::BuildingInfo* info_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdBuilding_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdBuilding_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdBuilding_2eproto();
  friend void protobuf_ShutdownFile_CmdBuilding_2eproto();

  void InitAsDefaultInstance();
  static BuildingUpgradeResp* default_instance_;
};
// -------------------------------------------------------------------

class BuildingUpdateReq : public ::google::protobuf::MessageLite {
 public:
  BuildingUpdateReq();
  virtual ~BuildingUpdateReq();

  BuildingUpdateReq(const BuildingUpdateReq& from);

  inline BuildingUpdateReq& operator=(const BuildingUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildingUpdateReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildingUpdateReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildingUpdateReq* other);

  // implements Message ----------------------------------------------

  BuildingUpdateReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildingUpdateReq& from);
  void MergeFrom(const BuildingUpdateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BuildingUpdateReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdBuilding_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdBuilding_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdBuilding_2eproto();
  friend void protobuf_ShutdownFile_CmdBuilding_2eproto();

  void InitAsDefaultInstance();
  static BuildingUpdateReq* default_instance_;
};
// -------------------------------------------------------------------

class BuildingUpdateResp : public ::google::protobuf::MessageLite {
 public:
  BuildingUpdateResp();
  virtual ~BuildingUpdateResp();

  BuildingUpdateResp(const BuildingUpdateResp& from);

  inline BuildingUpdateResp& operator=(const BuildingUpdateResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildingUpdateResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildingUpdateResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildingUpdateResp* other);

  // implements Message ----------------------------------------------

  BuildingUpdateResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildingUpdateResp& from);
  void MergeFrom(const BuildingUpdateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // required int32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BuildingUpdateResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_index();
  inline void clear_has_index();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdBuilding_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdBuilding_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdBuilding_2eproto();
  friend void protobuf_ShutdownFile_CmdBuilding_2eproto();

  void InitAsDefaultInstance();
  static BuildingUpdateResp* default_instance_;
};
// -------------------------------------------------------------------

class BuildingUpgradeSpeedUpReq : public ::google::protobuf::MessageLite {
 public:
  BuildingUpgradeSpeedUpReq();
  virtual ~BuildingUpgradeSpeedUpReq();

  BuildingUpgradeSpeedUpReq(const BuildingUpgradeSpeedUpReq& from);

  inline BuildingUpgradeSpeedUpReq& operator=(const BuildingUpgradeSpeedUpReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildingUpgradeSpeedUpReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildingUpgradeSpeedUpReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildingUpgradeSpeedUpReq* other);

  // implements Message ----------------------------------------------

  BuildingUpgradeSpeedUpReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildingUpgradeSpeedUpReq& from);
  void MergeFrom(const BuildingUpgradeSpeedUpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BuildingUpgradeSpeedUpReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdBuilding_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdBuilding_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdBuilding_2eproto();
  friend void protobuf_ShutdownFile_CmdBuilding_2eproto();

  void InitAsDefaultInstance();
  static BuildingUpgradeSpeedUpReq* default_instance_;
};
// -------------------------------------------------------------------

class BuildingUpgradeSpeedUpResp : public ::google::protobuf::MessageLite {
 public:
  BuildingUpgradeSpeedUpResp();
  virtual ~BuildingUpgradeSpeedUpResp();

  BuildingUpgradeSpeedUpResp(const BuildingUpgradeSpeedUpResp& from);

  inline BuildingUpgradeSpeedUpResp& operator=(const BuildingUpgradeSpeedUpResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildingUpgradeSpeedUpResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildingUpgradeSpeedUpResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildingUpgradeSpeedUpResp* other);

  // implements Message ----------------------------------------------

  BuildingUpgradeSpeedUpResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildingUpgradeSpeedUpResp& from);
  void MergeFrom(const BuildingUpgradeSpeedUpResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .BuildingInfo info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::BuildingInfo& info() const;
  inline ::BuildingInfo* mutable_info();
  inline ::BuildingInfo* release_info();
  inline void set_allocated_info(::BuildingInfo* info);

  // required int32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BuildingUpgradeSpeedUpResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_index();
  inline void clear_has_index();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 index_;
  ::BuildingInfo* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdBuilding_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdBuilding_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdBuilding_2eproto();
  friend void protobuf_ShutdownFile_CmdBuilding_2eproto();

  void InitAsDefaultInstance();
  static BuildingUpgradeSpeedUpResp* default_instance_;
};
// -------------------------------------------------------------------

class BuildQueueAddReq : public ::google::protobuf::MessageLite {
 public:
  BuildQueueAddReq();
  virtual ~BuildQueueAddReq();

  BuildQueueAddReq(const BuildQueueAddReq& from);

  inline BuildQueueAddReq& operator=(const BuildQueueAddReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildQueueAddReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildQueueAddReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildQueueAddReq* other);

  // implements Message ----------------------------------------------

  BuildQueueAddReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildQueueAddReq& from);
  void MergeFrom(const BuildQueueAddReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BuildQueueAddReq)
 private:
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdBuilding_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdBuilding_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdBuilding_2eproto();
  friend void protobuf_ShutdownFile_CmdBuilding_2eproto();

  void InitAsDefaultInstance();
  static BuildQueueAddReq* default_instance_;
};
// -------------------------------------------------------------------

class BuildQueueAddResp : public ::google::protobuf::MessageLite {
 public:
  BuildQueueAddResp();
  virtual ~BuildQueueAddResp();

  BuildQueueAddResp(const BuildQueueAddResp& from);

  inline BuildQueueAddResp& operator=(const BuildQueueAddResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildQueueAddResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildQueueAddResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildQueueAddResp* other);

  // implements Message ----------------------------------------------

  BuildQueueAddResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildQueueAddResp& from);
  void MergeFrom(const BuildQueueAddResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:BuildQueueAddResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdBuilding_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdBuilding_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdBuilding_2eproto();
  friend void protobuf_ShutdownFile_CmdBuilding_2eproto();

  void InitAsDefaultInstance();
  static BuildQueueAddResp* default_instance_;
};
// -------------------------------------------------------------------

class BuildQueueRemoveReq : public ::google::protobuf::MessageLite {
 public:
  BuildQueueRemoveReq();
  virtual ~BuildQueueRemoveReq();

  BuildQueueRemoveReq(const BuildQueueRemoveReq& from);

  inline BuildQueueRemoveReq& operator=(const BuildQueueRemoveReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildQueueRemoveReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildQueueRemoveReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildQueueRemoveReq* other);

  // implements Message ----------------------------------------------

  BuildQueueRemoveReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildQueueRemoveReq& from);
  void MergeFrom(const BuildQueueRemoveReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BuildQueueRemoveReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdBuilding_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdBuilding_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdBuilding_2eproto();
  friend void protobuf_ShutdownFile_CmdBuilding_2eproto();

  void InitAsDefaultInstance();
  static BuildQueueRemoveReq* default_instance_;
};
// -------------------------------------------------------------------

class BuildQueueRemoveResp : public ::google::protobuf::MessageLite {
 public:
  BuildQueueRemoveResp();
  virtual ~BuildQueueRemoveResp();

  BuildQueueRemoveResp(const BuildQueueRemoveResp& from);

  inline BuildQueueRemoveResp& operator=(const BuildQueueRemoveResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildQueueRemoveResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildQueueRemoveResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildQueueRemoveResp* other);

  // implements Message ----------------------------------------------

  BuildQueueRemoveResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildQueueRemoveResp& from);
  void MergeFrom(const BuildQueueRemoveResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:BuildQueueRemoveResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdBuilding_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdBuilding_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdBuilding_2eproto();
  friend void protobuf_ShutdownFile_CmdBuilding_2eproto();

  void InitAsDefaultInstance();
  static BuildQueueRemoveResp* default_instance_;
};
// ===================================================================


// ===================================================================

// BuildingUpgradeReq

// required int32 index = 1;
inline bool BuildingUpgradeReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildingUpgradeReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildingUpgradeReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildingUpgradeReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 BuildingUpgradeReq::index() const {
  return index_;
}
inline void BuildingUpgradeReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// BuildingUpgradeResp

// required int32 result = 1;
inline bool BuildingUpgradeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildingUpgradeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildingUpgradeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildingUpgradeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BuildingUpgradeResp::result() const {
  return result_;
}
inline void BuildingUpgradeResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool BuildingUpgradeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildingUpgradeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildingUpgradeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildingUpgradeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& BuildingUpgradeResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* BuildingUpgradeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* BuildingUpgradeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void BuildingUpgradeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .BuildingInfo info = 3;
inline bool BuildingUpgradeResp::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildingUpgradeResp::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildingUpgradeResp::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildingUpgradeResp::clear_info() {
  if (info_ != NULL) info_->::BuildingInfo::Clear();
  clear_has_info();
}
inline const ::BuildingInfo& BuildingUpgradeResp::info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return info_ != NULL ? *info_ : *default_instance().info_;
#else
  return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
}
inline ::BuildingInfo* BuildingUpgradeResp::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::BuildingInfo;
  return info_;
}
inline ::BuildingInfo* BuildingUpgradeResp::release_info() {
  clear_has_info();
  ::BuildingInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void BuildingUpgradeResp::set_allocated_info(::BuildingInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// BuildingUpdateReq

// required int32 index = 1;
inline bool BuildingUpdateReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildingUpdateReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildingUpdateReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildingUpdateReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 BuildingUpdateReq::index() const {
  return index_;
}
inline void BuildingUpdateReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// BuildingUpdateResp

// required int32 result = 1;
inline bool BuildingUpdateResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildingUpdateResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildingUpdateResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildingUpdateResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BuildingUpdateResp::result() const {
  return result_;
}
inline void BuildingUpdateResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool BuildingUpdateResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildingUpdateResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildingUpdateResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildingUpdateResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& BuildingUpdateResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* BuildingUpdateResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* BuildingUpdateResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void BuildingUpdateResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// required int32 index = 3;
inline bool BuildingUpdateResp::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildingUpdateResp::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildingUpdateResp::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildingUpdateResp::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 BuildingUpdateResp::index() const {
  return index_;
}
inline void BuildingUpdateResp::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// BuildingUpgradeSpeedUpReq

// required int32 index = 1;
inline bool BuildingUpgradeSpeedUpReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildingUpgradeSpeedUpReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildingUpgradeSpeedUpReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildingUpgradeSpeedUpReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 BuildingUpgradeSpeedUpReq::index() const {
  return index_;
}
inline void BuildingUpgradeSpeedUpReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// BuildingUpgradeSpeedUpResp

// required int32 result = 1;
inline bool BuildingUpgradeSpeedUpResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildingUpgradeSpeedUpResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildingUpgradeSpeedUpResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildingUpgradeSpeedUpResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BuildingUpgradeSpeedUpResp::result() const {
  return result_;
}
inline void BuildingUpgradeSpeedUpResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool BuildingUpgradeSpeedUpResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildingUpgradeSpeedUpResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildingUpgradeSpeedUpResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildingUpgradeSpeedUpResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& BuildingUpgradeSpeedUpResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* BuildingUpgradeSpeedUpResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* BuildingUpgradeSpeedUpResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void BuildingUpgradeSpeedUpResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .BuildingInfo info = 3;
inline bool BuildingUpgradeSpeedUpResp::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildingUpgradeSpeedUpResp::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildingUpgradeSpeedUpResp::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildingUpgradeSpeedUpResp::clear_info() {
  if (info_ != NULL) info_->::BuildingInfo::Clear();
  clear_has_info();
}
inline const ::BuildingInfo& BuildingUpgradeSpeedUpResp::info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return info_ != NULL ? *info_ : *default_instance().info_;
#else
  return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
}
inline ::BuildingInfo* BuildingUpgradeSpeedUpResp::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::BuildingInfo;
  return info_;
}
inline ::BuildingInfo* BuildingUpgradeSpeedUpResp::release_info() {
  clear_has_info();
  ::BuildingInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void BuildingUpgradeSpeedUpResp::set_allocated_info(::BuildingInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// required int32 index = 4;
inline bool BuildingUpgradeSpeedUpResp::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuildingUpgradeSpeedUpResp::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuildingUpgradeSpeedUpResp::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuildingUpgradeSpeedUpResp::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 BuildingUpgradeSpeedUpResp::index() const {
  return index_;
}
inline void BuildingUpgradeSpeedUpResp::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// BuildQueueAddReq

// required int32 num = 1;
inline bool BuildQueueAddReq::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildQueueAddReq::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildQueueAddReq::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildQueueAddReq::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 BuildQueueAddReq::num() const {
  return num_;
}
inline void BuildQueueAddReq::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// BuildQueueAddResp

// required int32 result = 1;
inline bool BuildQueueAddResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildQueueAddResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildQueueAddResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildQueueAddResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BuildQueueAddResp::result() const {
  return result_;
}
inline void BuildQueueAddResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool BuildQueueAddResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildQueueAddResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildQueueAddResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildQueueAddResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& BuildQueueAddResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* BuildQueueAddResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* BuildQueueAddResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void BuildQueueAddResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// BuildQueueRemoveReq

// required int32 index = 1;
inline bool BuildQueueRemoveReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildQueueRemoveReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildQueueRemoveReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildQueueRemoveReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 BuildQueueRemoveReq::index() const {
  return index_;
}
inline void BuildQueueRemoveReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// BuildQueueRemoveResp

// required int32 result = 1;
inline bool BuildQueueRemoveResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildQueueRemoveResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildQueueRemoveResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildQueueRemoveResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BuildQueueRemoveResp::result() const {
  return result_;
}
inline void BuildQueueRemoveResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool BuildQueueRemoveResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildQueueRemoveResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildQueueRemoveResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildQueueRemoveResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& BuildQueueRemoveResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* BuildQueueRemoveResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* BuildQueueRemoveResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void BuildQueueRemoveResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdBuilding_2eproto__INCLUDED
