// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdMail.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CmdMail.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_CmdMail_2eproto() {
  delete GetMailListReq::default_instance_;
  delete GetMailListResp::default_instance_;
  delete ReadMailReq::default_instance_;
  delete ReadMailResp::default_instance_;
  delete ReadMailListReq::default_instance_;
  delete ReadMailListResp::default_instance_;
  delete SendMailReq::default_instance_;
  delete SendMailResp::default_instance_;
  delete DelMailReq::default_instance_;
  delete DelMailResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_CmdMail_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_CmdMail_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_Mail_2eproto();
  ::protobuf_AddDesc_Item_2eproto();
  ::protobuf_AddDesc_UserSync_2eproto();
  GetMailListReq::default_instance_ = new GetMailListReq();
  GetMailListResp::default_instance_ = new GetMailListResp();
  ReadMailReq::default_instance_ = new ReadMailReq();
  ReadMailResp::default_instance_ = new ReadMailResp();
  ReadMailListReq::default_instance_ = new ReadMailListReq();
  ReadMailListResp::default_instance_ = new ReadMailListResp();
  SendMailReq::default_instance_ = new SendMailReq();
  SendMailResp::default_instance_ = new SendMailResp();
  DelMailReq::default_instance_ = new DelMailReq();
  DelMailResp::default_instance_ = new DelMailResp();
  GetMailListReq::default_instance_->InitAsDefaultInstance();
  GetMailListResp::default_instance_->InitAsDefaultInstance();
  ReadMailReq::default_instance_->InitAsDefaultInstance();
  ReadMailResp::default_instance_->InitAsDefaultInstance();
  ReadMailListReq::default_instance_->InitAsDefaultInstance();
  ReadMailListResp::default_instance_->InitAsDefaultInstance();
  SendMailReq::default_instance_->InitAsDefaultInstance();
  SendMailResp::default_instance_->InitAsDefaultInstance();
  DelMailReq::default_instance_->InitAsDefaultInstance();
  DelMailResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CmdMail_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_CmdMail_2eproto_once_);
void protobuf_AddDesc_CmdMail_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_CmdMail_2eproto_once_,
                 &protobuf_AddDesc_CmdMail_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CmdMail_2eproto {
  StaticDescriptorInitializer_CmdMail_2eproto() {
    protobuf_AddDesc_CmdMail_2eproto();
  }
} static_descriptor_initializer_CmdMail_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int GetMailListReq::kNumFieldNumber;
#endif  // !_MSC_VER

GetMailListReq::GetMailListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetMailListReq::InitAsDefaultInstance() {
}

GetMailListReq::GetMailListReq(const GetMailListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetMailListReq::SharedCtor() {
  _cached_size_ = 0;
  num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetMailListReq::~GetMailListReq() {
  SharedDtor();
}

void GetMailListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetMailListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetMailListReq& GetMailListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdMail_2eproto();
#endif
  return *default_instance_;
}

GetMailListReq* GetMailListReq::default_instance_ = NULL;

GetMailListReq* GetMailListReq::New() const {
  return new GetMailListReq;
}

void GetMailListReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    num_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetMailListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 num = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetMailListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 num = 1;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->num(), output);
  }

}

int GetMailListReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 num = 1;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetMailListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetMailListReq*>(&from));
}

void GetMailListReq::MergeFrom(const GetMailListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_num()) {
      set_num(from.num());
    }
  }
}

void GetMailListReq::CopyFrom(const GetMailListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMailListReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetMailListReq::Swap(GetMailListReq* other) {
  if (other != this) {
    std::swap(num_, other->num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetMailListReq::GetTypeName() const {
  return "GetMailListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetMailListResp::kResultFieldNumber;
const int GetMailListResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GetMailListResp::GetMailListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetMailListResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GetMailListResp::GetMailListResp(const GetMailListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetMailListResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetMailListResp::~GetMailListResp() {
  SharedDtor();
}

void GetMailListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GetMailListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetMailListResp& GetMailListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdMail_2eproto();
#endif
  return *default_instance_;
}

GetMailListResp* GetMailListResp::default_instance_ = NULL;

GetMailListResp* GetMailListResp::New() const {
  return new GetMailListResp;
}

void GetMailListResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetMailListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetMailListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GetMailListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetMailListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetMailListResp*>(&from));
}

void GetMailListResp::MergeFrom(const GetMailListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GetMailListResp::CopyFrom(const GetMailListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMailListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GetMailListResp::Swap(GetMailListResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetMailListResp::GetTypeName() const {
  return "GetMailListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ReadMailReq::kGuidFieldNumber;
#endif  // !_MSC_VER

ReadMailReq::ReadMailReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReadMailReq::InitAsDefaultInstance() {
}

ReadMailReq::ReadMailReq(const ReadMailReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReadMailReq::SharedCtor() {
  _cached_size_ = 0;
  guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadMailReq::~ReadMailReq() {
  SharedDtor();
}

void ReadMailReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReadMailReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReadMailReq& ReadMailReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdMail_2eproto();
#endif
  return *default_instance_;
}

ReadMailReq* ReadMailReq::default_instance_ = NULL;

ReadMailReq* ReadMailReq::New() const {
  return new ReadMailReq;
}

void ReadMailReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    guid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReadMailReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 guid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &guid_)));
          set_has_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReadMailReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 guid = 1;
  if (has_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->guid(), output);
  }

}

int ReadMailReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 guid = 1;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->guid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadMailReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReadMailReq*>(&from));
}

void ReadMailReq::MergeFrom(const ReadMailReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_guid()) {
      set_guid(from.guid());
    }
  }
}

void ReadMailReq::CopyFrom(const ReadMailReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadMailReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReadMailReq::Swap(ReadMailReq* other) {
  if (other != this) {
    std::swap(guid_, other->guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReadMailReq::GetTypeName() const {
  return "ReadMailReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ReadMailResp::kResultFieldNumber;
const int ReadMailResp::kUserSyncFieldNumber;
const int ReadMailResp::kReqFieldNumber;
const int ReadMailResp::kGetItemListFieldNumber;
#endif  // !_MSC_VER

ReadMailResp::ReadMailResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReadMailResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::ReadMailReq*>(
      ::ReadMailReq::internal_default_instance());
#else
  req_ = const_cast< ::ReadMailReq*>(&::ReadMailReq::default_instance());
#endif
}

ReadMailResp::ReadMailResp(const ReadMailResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReadMailResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  req_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadMailResp::~ReadMailResp() {
  SharedDtor();
}

void ReadMailResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete req_;
  }
}

void ReadMailResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReadMailResp& ReadMailResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdMail_2eproto();
#endif
  return *default_instance_;
}

ReadMailResp* ReadMailResp::default_instance_ = NULL;

ReadMailResp* ReadMailResp::New() const {
  return new ReadMailResp;
}

void ReadMailResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_req()) {
      if (req_ != NULL) req_->::ReadMailReq::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReadMailResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_req;
        break;
      }

      // required .ReadMailReq req = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_get_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReadMailResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // required .ReadMailReq req = 3;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->req(), output);
  }

  // repeated .Pair get_item_list = 4;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->get_item_list(i), output);
  }

}

int ReadMailResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // required .ReadMailReq req = 3;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

  }
  // repeated .Pair get_item_list = 4;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadMailResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReadMailResp*>(&from));
}

void ReadMailResp::MergeFrom(const ReadMailResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_req()) {
      mutable_req()->::ReadMailReq::MergeFrom(from.req());
    }
  }
}

void ReadMailResp::CopyFrom(const ReadMailResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadMailResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  return true;
}

void ReadMailResp::Swap(ReadMailResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(req_, other->req_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReadMailResp::GetTypeName() const {
  return "ReadMailResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ReadMailListReq::kGuidFieldNumber;
#endif  // !_MSC_VER

ReadMailListReq::ReadMailListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReadMailListReq::InitAsDefaultInstance() {
}

ReadMailListReq::ReadMailListReq(const ReadMailListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReadMailListReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadMailListReq::~ReadMailListReq() {
  SharedDtor();
}

void ReadMailListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReadMailListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReadMailListReq& ReadMailListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdMail_2eproto();
#endif
  return *default_instance_;
}

ReadMailListReq* ReadMailListReq::default_instance_ = NULL;

ReadMailListReq* ReadMailListReq::New() const {
  return new ReadMailListReq;
}

void ReadMailListReq::Clear() {
  guid_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReadMailListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 guid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_guid())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_guid())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_guid;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReadMailListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 guid = 1;
  for (int i = 0; i < this->guid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->guid(i), output);
  }

}

int ReadMailListReq::ByteSize() const {
  int total_size = 0;

  // repeated int32 guid = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->guid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->guid(i));
    }
    total_size += 1 * this->guid_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadMailListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReadMailListReq*>(&from));
}

void ReadMailListReq::MergeFrom(const ReadMailListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  guid_.MergeFrom(from.guid_);
}

void ReadMailListReq::CopyFrom(const ReadMailListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadMailListReq::IsInitialized() const {

  return true;
}

void ReadMailListReq::Swap(ReadMailListReq* other) {
  if (other != this) {
    guid_.Swap(&other->guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReadMailListReq::GetTypeName() const {
  return "ReadMailListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ReadMailListResp::kResultFieldNumber;
const int ReadMailListResp::kUserSyncFieldNumber;
const int ReadMailListResp::kReqFieldNumber;
const int ReadMailListResp::kGetItemListFieldNumber;
#endif  // !_MSC_VER

ReadMailListResp::ReadMailListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReadMailListResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::ReadMailListReq*>(
      ::ReadMailListReq::internal_default_instance());
#else
  req_ = const_cast< ::ReadMailListReq*>(&::ReadMailListReq::default_instance());
#endif
}

ReadMailListResp::ReadMailListResp(const ReadMailListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReadMailListResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  req_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadMailListResp::~ReadMailListResp() {
  SharedDtor();
}

void ReadMailListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete req_;
  }
}

void ReadMailListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReadMailListResp& ReadMailListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdMail_2eproto();
#endif
  return *default_instance_;
}

ReadMailListResp* ReadMailListResp::default_instance_ = NULL;

ReadMailListResp* ReadMailListResp::New() const {
  return new ReadMailListResp;
}

void ReadMailListResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_req()) {
      if (req_ != NULL) req_->::ReadMailListReq::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReadMailListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_req;
        break;
      }

      // required .ReadMailListReq req = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_get_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReadMailListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // required .ReadMailListReq req = 3;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->req(), output);
  }

  // repeated .Pair get_item_list = 4;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->get_item_list(i), output);
  }

}

int ReadMailListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // required .ReadMailListReq req = 3;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

  }
  // repeated .Pair get_item_list = 4;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadMailListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReadMailListResp*>(&from));
}

void ReadMailListResp::MergeFrom(const ReadMailListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_req()) {
      mutable_req()->::ReadMailListReq::MergeFrom(from.req());
    }
  }
}

void ReadMailListResp::CopyFrom(const ReadMailListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadMailListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  return true;
}

void ReadMailListResp::Swap(ReadMailListResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(req_, other->req_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReadMailListResp::GetTypeName() const {
  return "ReadMailListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int SendMailReq::kUserNameFieldNumber;
const int SendMailReq::kSubjectFieldNumber;
const int SendMailReq::kMessageFieldNumber;
#endif  // !_MSC_VER

SendMailReq::SendMailReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SendMailReq::InitAsDefaultInstance() {
}

SendMailReq::SendMailReq(const SendMailReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SendMailReq::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendMailReq::~SendMailReq() {
  SharedDtor();
}

void SendMailReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SendMailReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SendMailReq& SendMailReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdMail_2eproto();
#endif
  return *default_instance_;
}

SendMailReq* SendMailReq::default_instance_ = NULL;

SendMailReq* SendMailReq::New() const {
  return new SendMailReq;
}

void SendMailReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    if (has_subject()) {
      if (subject_ != &::google::protobuf::internal::kEmptyString) {
        subject_->clear();
      }
    }
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SendMailReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_subject;
        break;
      }

      // required string subject = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_subject:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subject()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_message;
        break;
      }

      // required string message = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendMailReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

  // required string subject = 2;
  if (has_subject()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->subject(), output);
  }

  // required string message = 3;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->message(), output);
  }

}

int SendMailReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required string subject = 2;
    if (has_subject()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subject());
    }

    // required string message = 3;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendMailReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SendMailReq*>(&from));
}

void SendMailReq::MergeFrom(const SendMailReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_subject()) {
      set_subject(from.subject());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
  }
}

void SendMailReq::CopyFrom(const SendMailReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendMailReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void SendMailReq::Swap(SendMailReq* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(subject_, other->subject_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SendMailReq::GetTypeName() const {
  return "SendMailReq";
}


// ===================================================================

#ifndef _MSC_VER
const int SendMailResp::kResultFieldNumber;
const int SendMailResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

SendMailResp::SendMailResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SendMailResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

SendMailResp::SendMailResp(const SendMailResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SendMailResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendMailResp::~SendMailResp() {
  SharedDtor();
}

void SendMailResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void SendMailResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SendMailResp& SendMailResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdMail_2eproto();
#endif
  return *default_instance_;
}

SendMailResp* SendMailResp::default_instance_ = NULL;

SendMailResp* SendMailResp::New() const {
  return new SendMailResp;
}

void SendMailResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SendMailResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendMailResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int SendMailResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendMailResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SendMailResp*>(&from));
}

void SendMailResp::MergeFrom(const SendMailResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void SendMailResp::CopyFrom(const SendMailResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendMailResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void SendMailResp::Swap(SendMailResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SendMailResp::GetTypeName() const {
  return "SendMailResp";
}


// ===================================================================

#ifndef _MSC_VER
const int DelMailReq::kGuidListFieldNumber;
#endif  // !_MSC_VER

DelMailReq::DelMailReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DelMailReq::InitAsDefaultInstance() {
}

DelMailReq::DelMailReq(const DelMailReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DelMailReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DelMailReq::~DelMailReq() {
  SharedDtor();
}

void DelMailReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DelMailReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DelMailReq& DelMailReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdMail_2eproto();
#endif
  return *default_instance_;
}

DelMailReq* DelMailReq::default_instance_ = NULL;

DelMailReq* DelMailReq::New() const {
  return new DelMailReq;
}

void DelMailReq::Clear() {
  guid_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DelMailReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 guid_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guid_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_guid_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_guid_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_guid_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DelMailReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 guid_list = 1;
  for (int i = 0; i < this->guid_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->guid_list(i), output);
  }

}

int DelMailReq::ByteSize() const {
  int total_size = 0;

  // repeated int32 guid_list = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->guid_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->guid_list(i));
    }
    total_size += 1 * this->guid_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DelMailReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DelMailReq*>(&from));
}

void DelMailReq::MergeFrom(const DelMailReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  guid_list_.MergeFrom(from.guid_list_);
}

void DelMailReq::CopyFrom(const DelMailReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelMailReq::IsInitialized() const {

  return true;
}

void DelMailReq::Swap(DelMailReq* other) {
  if (other != this) {
    guid_list_.Swap(&other->guid_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DelMailReq::GetTypeName() const {
  return "DelMailReq";
}


// ===================================================================

#ifndef _MSC_VER
const int DelMailResp::kResultFieldNumber;
const int DelMailResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

DelMailResp::DelMailResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DelMailResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

DelMailResp::DelMailResp(const DelMailResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DelMailResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DelMailResp::~DelMailResp() {
  SharedDtor();
}

void DelMailResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void DelMailResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DelMailResp& DelMailResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdMail_2eproto();
#endif
  return *default_instance_;
}

DelMailResp* DelMailResp::default_instance_ = NULL;

DelMailResp* DelMailResp::New() const {
  return new DelMailResp;
}

void DelMailResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DelMailResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DelMailResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int DelMailResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DelMailResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DelMailResp*>(&from));
}

void DelMailResp::MergeFrom(const DelMailResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void DelMailResp::CopyFrom(const DelMailResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelMailResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void DelMailResp::Swap(DelMailResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DelMailResp::GetTypeName() const {
  return "DelMailResp";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
