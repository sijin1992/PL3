// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserInfo.proto

#ifndef PROTOBUF_UserInfo_2eproto__INCLUDED
#define PROTOBUF_UserInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Weapon.pb.h"
#include "Equip.pb.h"
#include "Home.pb.h"
#include "Building.pb.h"
#include "Trial.pb.h"
#include "Stage.pb.h"
#include "Activity.pb.h"
#include "Item.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_UserInfo_2eproto();
void protobuf_AssignDesc_UserInfo_2eproto();
void protobuf_ShutdownFile_UserInfo_2eproto();

class TimeStamp;
class Lineup;
class UserInfo;
class UserInfo_BlockInfo;
class NewHandGiftBag;
class NewHandGiftBagData;
class GiftBag;
class NextGiftBagData;
class TradeData;
class BlueprintDevelopInfo;
class ShipLotteryInfo;
class ShipLotteryData;
class ShopGoods;
class ShopData;
class Point;
class DailyData;
class AchievementData;
class TaskInfo;
class BuildQueue;
class TechContributeData;
class GroupPVECheckpoint;
class GroupData;
class TechnologyData;
class TechnologyInfo;
class ArenaRank;
class ArenaData;
class FriendFamiliarity;
class FriendsData;

// ===================================================================

class TimeStamp : public ::google::protobuf::MessageLite {
 public:
  TimeStamp();
  virtual ~TimeStamp();

  TimeStamp(const TimeStamp& from);

  inline TimeStamp& operator=(const TimeStamp& from) {
    CopyFrom(from);
    return *this;
  }

  static const TimeStamp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeStamp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeStamp* other);

  // implements Message ----------------------------------------------

  TimeStamp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeStamp& from);
  void MergeFrom(const TimeStamp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 last_0am_day = 1;
  inline bool has_last_0am_day() const;
  inline void clear_last_0am_day();
  static const int kLast0AmDayFieldNumber = 1;
  inline ::google::protobuf::int64 last_0am_day() const;
  inline void set_last_0am_day(::google::protobuf::int64 value);

  // required int64 regist_time = 2;
  inline bool has_regist_time() const;
  inline void clear_regist_time();
  static const int kRegistTimeFieldNumber = 2;
  inline ::google::protobuf::int64 regist_time() const;
  inline void set_regist_time(::google::protobuf::int64 value);

  // required int64 strength_timer = 3;
  inline bool has_strength_timer() const;
  inline void clear_strength_timer();
  static const int kStrengthTimerFieldNumber = 3;
  inline ::google::protobuf::int64 strength_timer() const;
  inline void set_strength_timer(::google::protobuf::int64 value);

  // optional int32 gmail = 4;
  inline bool has_gmail() const;
  inline void clear_gmail();
  static const int kGmailFieldNumber = 4;
  inline ::google::protobuf::int32 gmail() const;
  inline void set_gmail(::google::protobuf::int32 value);

  // optional int64 today_online_time = 5;
  inline bool has_today_online_time() const;
  inline void clear_today_online_time();
  static const int kTodayOnlineTimeFieldNumber = 5;
  inline ::google::protobuf::int64 today_online_time() const;
  inline void set_today_online_time(::google::protobuf::int64 value);

  // optional int64 regist_aid_award_time = 6;
  inline bool has_regist_aid_award_time() const;
  inline void clear_regist_aid_award_time();
  static const int kRegistAidAwardTimeFieldNumber = 6;
  inline ::google::protobuf::int64 regist_aid_award_time() const;
  inline void set_regist_aid_award_time(::google::protobuf::int64 value);

  // optional int64 card_end_time = 7;
  inline bool has_card_end_time() const;
  inline void clear_card_end_time();
  static const int kCardEndTimeFieldNumber = 7;
  inline ::google::protobuf::int64 card_end_time() const;
  inline void set_card_end_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:TimeStamp)
 private:
  inline void set_has_last_0am_day();
  inline void clear_has_last_0am_day();
  inline void set_has_regist_time();
  inline void clear_has_regist_time();
  inline void set_has_strength_timer();
  inline void clear_has_strength_timer();
  inline void set_has_gmail();
  inline void clear_has_gmail();
  inline void set_has_today_online_time();
  inline void clear_has_today_online_time();
  inline void set_has_regist_aid_award_time();
  inline void clear_has_regist_aid_award_time();
  inline void set_has_card_end_time();
  inline void clear_has_card_end_time();

  ::google::protobuf::int64 last_0am_day_;
  ::google::protobuf::int64 regist_time_;
  ::google::protobuf::int64 strength_timer_;
  ::google::protobuf::int64 today_online_time_;
  ::google::protobuf::int64 regist_aid_award_time_;
  ::google::protobuf::int64 card_end_time_;
  ::google::protobuf::int32 gmail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static TimeStamp* default_instance_;
};
// -------------------------------------------------------------------

class Lineup : public ::google::protobuf::MessageLite {
 public:
  Lineup();
  virtual ~Lineup();

  Lineup(const Lineup& from);

  inline Lineup& operator=(const Lineup& from) {
    CopyFrom(from);
    return *this;
  }

  static const Lineup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Lineup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Lineup* other);

  // implements Message ----------------------------------------------

  Lineup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Lineup& from);
  void MergeFrom(const Lineup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 ship_guid_list = 1;
  inline int ship_guid_list_size() const;
  inline void clear_ship_guid_list();
  static const int kShipGuidListFieldNumber = 1;
  inline ::google::protobuf::int32 ship_guid_list(int index) const;
  inline void set_ship_guid_list(int index, ::google::protobuf::int32 value);
  inline void add_ship_guid_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ship_guid_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ship_guid_list();

  // optional string line_name = 2;
  inline bool has_line_name() const;
  inline void clear_line_name();
  static const int kLineNameFieldNumber = 2;
  inline const ::std::string& line_name() const;
  inline void set_line_name(const ::std::string& value);
  inline void set_line_name(const char* value);
  inline void set_line_name(const char* value, size_t size);
  inline ::std::string* mutable_line_name();
  inline ::std::string* release_line_name();
  inline void set_allocated_line_name(::std::string* line_name);

  // @@protoc_insertion_point(class_scope:Lineup)
 private:
  inline void set_has_line_name();
  inline void clear_has_line_name();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ship_guid_list_;
  ::std::string* line_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static Lineup* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo_BlockInfo : public ::google::protobuf::MessageLite {
 public:
  UserInfo_BlockInfo();
  virtual ~UserInfo_BlockInfo();

  UserInfo_BlockInfo(const UserInfo_BlockInfo& from);

  inline UserInfo_BlockInfo& operator=(const UserInfo_BlockInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserInfo_BlockInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserInfo_BlockInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserInfo_BlockInfo* other);

  // implements Message ----------------------------------------------

  UserInfo_BlockInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserInfo_BlockInfo& from);
  void MergeFrom(const UserInfo_BlockInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int64 stamp = 2;
  inline bool has_stamp() const;
  inline void clear_stamp();
  static const int kStampFieldNumber = 2;
  inline ::google::protobuf::int64 stamp() const;
  inline void set_stamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:UserInfo.BlockInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_stamp();
  inline void clear_has_stamp();

  ::google::protobuf::int64 stamp_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static UserInfo_BlockInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::MessageLite {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UserInfo_BlockInfo BlockInfo;

  // accessors -------------------------------------------------------

  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional int32 icon_id = 4;
  inline bool has_icon_id() const;
  inline void clear_icon_id();
  static const int kIconIdFieldNumber = 4;
  inline ::google::protobuf::int32 icon_id() const;
  inline void set_icon_id(::google::protobuf::int32 value);

  // repeated int32 lineup = 5;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 5;
  inline ::google::protobuf::int32 lineup(int index) const;
  inline void set_lineup(int index, ::google::protobuf::int32 value);
  inline void add_lineup(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lineup();

  // optional int32 init_ship_index = 6;
  inline bool has_init_ship_index() const;
  inline void clear_init_ship_index();
  static const int kInitShipIndexFieldNumber = 6;
  inline ::google::protobuf::int32 init_ship_index() const;
  inline void set_init_ship_index(::google::protobuf::int32 value);

  // optional int32 aid_award_index = 7;
  inline bool has_aid_award_index() const;
  inline void clear_aid_award_index();
  static const int kAidAwardIndexFieldNumber = 7;
  inline ::google::protobuf::int32 aid_award_index() const;
  inline void set_aid_award_index(::google::protobuf::int32 value);

  // optional int32 strength = 8;
  inline bool has_strength() const;
  inline void clear_strength();
  static const int kStrengthFieldNumber = 8;
  inline ::google::protobuf::int32 strength() const;
  inline void set_strength(::google::protobuf::int32 value);

  // optional int32 strength_buy_times = 9;
  inline bool has_strength_buy_times() const;
  inline void clear_strength_buy_times();
  static const int kStrengthBuyTimesFieldNumber = 9;
  inline ::google::protobuf::int32 strength_buy_times() const;
  inline void set_strength_buy_times(::google::protobuf::int32 value);

  // repeated int64 res = 10;
  inline int res_size() const;
  inline void clear_res();
  static const int kResFieldNumber = 10;
  inline ::google::protobuf::int64 res(int index) const;
  inline void set_res(int index, ::google::protobuf::int64 value);
  inline void add_res(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      res() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_res();

  // optional int32 money = 11;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 11;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 vip_level = 12;
  inline bool has_vip_level() const;
  inline void clear_vip_level();
  static const int kVipLevelFieldNumber = 12;
  inline ::google::protobuf::int32 vip_level() const;
  inline void set_vip_level(::google::protobuf::int32 value);

  // optional int32 exp = 13;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 13;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 level = 14;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 14;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional string ip = 15;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 15;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string mcc = 16;
  inline bool has_mcc() const;
  inline void clear_mcc();
  static const int kMccFieldNumber = 16;
  inline const ::std::string& mcc() const;
  inline void set_mcc(const ::std::string& value);
  inline void set_mcc(const char* value);
  inline void set_mcc(const char* value, size_t size);
  inline ::std::string* mutable_mcc();
  inline ::std::string* release_mcc();
  inline void set_allocated_mcc(::std::string* mcc);

  // optional string client_version = 17;
  inline bool has_client_version() const;
  inline void clear_client_version();
  static const int kClientVersionFieldNumber = 17;
  inline const ::std::string& client_version() const;
  inline void set_client_version(const ::std::string& value);
  inline void set_client_version(const char* value);
  inline void set_client_version(const char* value, size_t size);
  inline ::std::string* mutable_client_version();
  inline ::std::string* release_client_version();
  inline void set_allocated_client_version(::std::string* client_version);

  // repeated .Equip equip_list = 18;
  inline int equip_list_size() const;
  inline void clear_equip_list();
  static const int kEquipListFieldNumber = 18;
  inline const ::Equip& equip_list(int index) const;
  inline ::Equip* mutable_equip_list(int index);
  inline ::Equip* add_equip_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Equip >&
      equip_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Equip >*
      mutable_equip_list();

  // repeated .Gem gem_list = 19;
  inline int gem_list_size() const;
  inline void clear_gem_list();
  static const int kGemListFieldNumber = 19;
  inline const ::Gem& gem_list(int index) const;
  inline ::Gem* mutable_gem_list(int index);
  inline ::Gem* add_gem_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Gem >&
      gem_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Gem >*
      mutable_gem_list();

  // repeated .Weapon weapon_list = 20;
  inline int weapon_list_size() const;
  inline void clear_weapon_list();
  static const int kWeaponListFieldNumber = 20;
  inline const ::Weapon& weapon_list(int index) const;
  inline ::Weapon* mutable_weapon_list(int index);
  inline ::Weapon* add_weapon_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Weapon >&
      weapon_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Weapon >*
      mutable_weapon_list();

  // optional .GroupData group_data = 21;
  inline bool has_group_data() const;
  inline void clear_group_data();
  static const int kGroupDataFieldNumber = 21;
  inline const ::GroupData& group_data() const;
  inline ::GroupData* mutable_group_data();
  inline ::GroupData* release_group_data();
  inline void set_allocated_group_data(::GroupData* group_data);

  // repeated .BuildQueue build_queue_list = 22;
  inline int build_queue_list_size() const;
  inline void clear_build_queue_list();
  static const int kBuildQueueListFieldNumber = 22;
  inline const ::BuildQueue& build_queue_list(int index) const;
  inline ::BuildQueue* mutable_build_queue_list(int index);
  inline ::BuildQueue* add_build_queue_list();
  inline const ::google::protobuf::RepeatedPtrField< ::BuildQueue >&
      build_queue_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::BuildQueue >*
      mutable_build_queue_list();

  // repeated .BuildingInfo building_list = 23;
  inline int building_list_size() const;
  inline void clear_building_list();
  static const int kBuildingListFieldNumber = 23;
  inline const ::BuildingInfo& building_list(int index) const;
  inline ::BuildingInfo* mutable_building_list(int index);
  inline ::BuildingInfo* add_building_list();
  inline const ::google::protobuf::RepeatedPtrField< ::BuildingInfo >&
      building_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::BuildingInfo >*
      mutable_building_list();

  // optional .StageData stage_data = 24;
  inline bool has_stage_data() const;
  inline void clear_stage_data();
  static const int kStageDataFieldNumber = 24;
  inline const ::StageData& stage_data() const;
  inline ::StageData* mutable_stage_data();
  inline ::StageData* release_stage_data();
  inline void set_allocated_stage_data(::StageData* stage_data);

  // optional .HomeSystemInfo home_info = 25;
  inline bool has_home_info() const;
  inline void clear_home_info();
  static const int kHomeInfoFieldNumber = 25;
  inline const ::HomeSystemInfo& home_info() const;
  inline ::HomeSystemInfo* mutable_home_info();
  inline ::HomeSystemInfo* release_home_info();
  inline void set_allocated_home_info(::HomeSystemInfo* home_info);

  // optional .TechnologyData tech_data = 26;
  inline bool has_tech_data() const;
  inline void clear_tech_data();
  static const int kTechDataFieldNumber = 26;
  inline const ::TechnologyData& tech_data() const;
  inline ::TechnologyData* mutable_tech_data();
  inline ::TechnologyData* release_tech_data();
  inline void set_allocated_tech_data(::TechnologyData* tech_data);

  // optional .TrialData trial_data = 27;
  inline bool has_trial_data() const;
  inline void clear_trial_data();
  static const int kTrialDataFieldNumber = 27;
  inline const ::TrialData& trial_data() const;
  inline ::TrialData* mutable_trial_data();
  inline ::TrialData* release_trial_data();
  inline void set_allocated_trial_data(::TrialData* trial_data);

  // optional .ArenaData arena_data = 28;
  inline bool has_arena_data() const;
  inline void clear_arena_data();
  static const int kArenaDataFieldNumber = 28;
  inline const ::ArenaData& arena_data() const;
  inline ::ArenaData* mutable_arena_data();
  inline ::ArenaData* release_arena_data();
  inline void set_allocated_arena_data(::ArenaData* arena_data);

  // optional .FriendsData friends_data = 29;
  inline bool has_friends_data() const;
  inline void clear_friends_data();
  static const int kFriendsDataFieldNumber = 29;
  inline const ::FriendsData& friends_data() const;
  inline ::FriendsData* mutable_friends_data();
  inline ::FriendsData* release_friends_data();
  inline void set_allocated_friends_data(::FriendsData* friends_data);

  // repeated .TaskInfo task_list = 30;
  inline int task_list_size() const;
  inline void clear_task_list();
  static const int kTaskListFieldNumber = 30;
  inline const ::TaskInfo& task_list(int index) const;
  inline ::TaskInfo* mutable_task_list(int index);
  inline ::TaskInfo* add_task_list();
  inline const ::google::protobuf::RepeatedPtrField< ::TaskInfo >&
      task_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::TaskInfo >*
      mutable_task_list();

  // optional .DailyData daily_data = 31;
  inline bool has_daily_data() const;
  inline void clear_daily_data();
  static const int kDailyDataFieldNumber = 31;
  inline const ::DailyData& daily_data() const;
  inline ::DailyData* mutable_daily_data();
  inline ::DailyData* release_daily_data();
  inline void set_allocated_daily_data(::DailyData* daily_data);

  // repeated .BlueprintDevelopInfo blueprint_list = 32;
  inline int blueprint_list_size() const;
  inline void clear_blueprint_list();
  static const int kBlueprintListFieldNumber = 32;
  inline const ::BlueprintDevelopInfo& blueprint_list(int index) const;
  inline ::BlueprintDevelopInfo* mutable_blueprint_list(int index);
  inline ::BlueprintDevelopInfo* add_blueprint_list();
  inline const ::google::protobuf::RepeatedPtrField< ::BlueprintDevelopInfo >&
      blueprint_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::BlueprintDevelopInfo >*
      mutable_blueprint_list();

  // optional .AchievementData achievement_data = 33;
  inline bool has_achievement_data() const;
  inline void clear_achievement_data();
  static const int kAchievementDataFieldNumber = 33;
  inline const ::AchievementData& achievement_data() const;
  inline ::AchievementData* mutable_achievement_data();
  inline ::AchievementData* release_achievement_data();
  inline void set_allocated_achievement_data(::AchievementData* achievement_data);

  // optional .ShopData shop_data = 34;
  inline bool has_shop_data() const;
  inline void clear_shop_data();
  static const int kShopDataFieldNumber = 34;
  inline const ::ShopData& shop_data() const;
  inline ::ShopData* mutable_shop_data();
  inline ::ShopData* release_shop_data();
  inline void set_allocated_shop_data(::ShopData* shop_data);

  // optional .ShipLotteryData ship_lottery_data = 35;
  inline bool has_ship_lottery_data() const;
  inline void clear_ship_lottery_data();
  static const int kShipLotteryDataFieldNumber = 35;
  inline const ::ShipLotteryData& ship_lottery_data() const;
  inline ::ShipLotteryData* mutable_ship_lottery_data();
  inline ::ShipLotteryData* release_ship_lottery_data();
  inline void set_allocated_ship_lottery_data(::ShipLotteryData* ship_lottery_data);

  // repeated .Activity activity_list = 37;
  inline int activity_list_size() const;
  inline void clear_activity_list();
  static const int kActivityListFieldNumber = 37;
  inline const ::Activity& activity_list(int index) const;
  inline ::Activity* mutable_activity_list(int index);
  inline ::Activity* add_activity_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Activity >&
      activity_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Activity >*
      mutable_activity_list();

  // optional int32 state = 38;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 38;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // repeated .Lineup preset_lineup_list = 39;
  inline int preset_lineup_list_size() const;
  inline void clear_preset_lineup_list();
  static const int kPresetLineupListFieldNumber = 39;
  inline const ::Lineup& preset_lineup_list(int index) const;
  inline ::Lineup* mutable_preset_lineup_list(int index);
  inline ::Lineup* add_preset_lineup_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Lineup >&
      preset_lineup_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lineup >*
      mutable_preset_lineup_list();

  // optional .TradeData trade_data = 40;
  inline bool has_trade_data() const;
  inline void clear_trade_data();
  static const int kTradeDataFieldNumber = 40;
  inline const ::TradeData& trade_data() const;
  inline ::TradeData* mutable_trade_data();
  inline ::TradeData* release_trade_data();
  inline void set_allocated_trade_data(::TradeData* trade_data);

  // repeated .ForgeEquip forge_equip_list = 41;
  inline int forge_equip_list_size() const;
  inline void clear_forge_equip_list();
  static const int kForgeEquipListFieldNumber = 41;
  inline const ::ForgeEquip& forge_equip_list(int index) const;
  inline ::ForgeEquip* mutable_forge_equip_list(int index);
  inline ::ForgeEquip* add_forge_equip_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ForgeEquip >&
      forge_equip_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ForgeEquip >*
      mutable_forge_equip_list();

  // optional .NewHandGiftBagData new_hand_gift_bag_data = 42;
  inline bool has_new_hand_gift_bag_data() const;
  inline void clear_new_hand_gift_bag_data();
  static const int kNewHandGiftBagDataFieldNumber = 42;
  inline const ::NewHandGiftBagData& new_hand_gift_bag_data() const;
  inline ::NewHandGiftBagData* mutable_new_hand_gift_bag_data();
  inline ::NewHandGiftBagData* release_new_hand_gift_bag_data();
  inline void set_allocated_new_hand_gift_bag_data(::NewHandGiftBagData* new_hand_gift_bag_data);

  // repeated .GiftBag gift_bag_list = 43;
  inline int gift_bag_list_size() const;
  inline void clear_gift_bag_list();
  static const int kGiftBagListFieldNumber = 43;
  inline const ::GiftBag& gift_bag_list(int index) const;
  inline ::GiftBag* mutable_gift_bag_list(int index);
  inline ::GiftBag* add_gift_bag_list();
  inline const ::google::protobuf::RepeatedPtrField< ::GiftBag >&
      gift_bag_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::GiftBag >*
      mutable_gift_bag_list();

  // repeated int32 vip_award_list = 44;
  inline int vip_award_list_size() const;
  inline void clear_vip_award_list();
  static const int kVipAwardListFieldNumber = 44;
  inline ::google::protobuf::int32 vip_award_list(int index) const;
  inline void set_vip_award_list(int index, ::google::protobuf::int32 value);
  inline void add_vip_award_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vip_award_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vip_award_list();

  // repeated int32 vip_pack_list = 45;
  inline int vip_pack_list_size() const;
  inline void clear_vip_pack_list();
  static const int kVipPackListFieldNumber = 45;
  inline ::google::protobuf::int32 vip_pack_list(int index) const;
  inline void set_vip_pack_list(int index, ::google::protobuf::int32 value);
  inline void add_vip_pack_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vip_pack_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vip_pack_list();

  // optional .NextGiftBagData next_gift_bag_data = 46;
  inline bool has_next_gift_bag_data() const;
  inline void clear_next_gift_bag_data();
  static const int kNextGiftBagDataFieldNumber = 46;
  inline const ::NextGiftBagData& next_gift_bag_data() const;
  inline ::NextGiftBagData* mutable_next_gift_bag_data();
  inline ::NextGiftBagData* release_next_gift_bag_data();
  inline void set_allocated_next_gift_bag_data(::NextGiftBagData* next_gift_bag_data);

  // optional int64 ship_energy_end_time = 47;
  inline bool has_ship_energy_end_time() const;
  inline void clear_ship_energy_end_time();
  static const int kShipEnergyEndTimeFieldNumber = 47;
  inline ::google::protobuf::int64 ship_energy_end_time() const;
  inline void set_ship_energy_end_time(::google::protobuf::int64 value);

  // optional int32 ship_energy_time_lock = 48;
  inline bool has_ship_energy_time_lock() const;
  inline void clear_ship_energy_time_lock();
  static const int kShipEnergyTimeLockFieldNumber = 48;
  inline ::google::protobuf::int32 ship_energy_time_lock() const;
  inline void set_ship_energy_time_lock(::google::protobuf::int32 value);

  // optional int32 gm_level = 97;
  inline bool has_gm_level() const;
  inline void clear_gm_level();
  static const int kGmLevelFieldNumber = 97;
  inline ::google::protobuf::int32 gm_level() const;
  inline void set_gm_level(::google::protobuf::int32 value);

  // optional .UserInfo.BlockInfo blocked = 98;
  inline bool has_blocked() const;
  inline void clear_blocked();
  static const int kBlockedFieldNumber = 98;
  inline const ::UserInfo_BlockInfo& blocked() const;
  inline ::UserInfo_BlockInfo* mutable_blocked();
  inline ::UserInfo_BlockInfo* release_blocked();
  inline void set_allocated_blocked(::UserInfo_BlockInfo* blocked);

  // optional .TimeStamp timestamp = 99;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 99;
  inline const ::TimeStamp& timestamp() const;
  inline ::TimeStamp* mutable_timestamp();
  inline ::TimeStamp* release_timestamp();
  inline void set_allocated_timestamp(::TimeStamp* timestamp);

  // optional int32 data_version = 100;
  inline bool has_data_version() const;
  inline void clear_data_version();
  static const int kDataVersionFieldNumber = 100;
  inline ::google::protobuf::int32 data_version() const;
  inline void set_data_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UserInfo)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_icon_id();
  inline void clear_has_icon_id();
  inline void set_has_init_ship_index();
  inline void clear_has_init_ship_index();
  inline void set_has_aid_award_index();
  inline void clear_has_aid_award_index();
  inline void set_has_strength();
  inline void clear_has_strength();
  inline void set_has_strength_buy_times();
  inline void clear_has_strength_buy_times();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_vip_level();
  inline void clear_has_vip_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_mcc();
  inline void clear_has_mcc();
  inline void set_has_client_version();
  inline void clear_has_client_version();
  inline void set_has_group_data();
  inline void clear_has_group_data();
  inline void set_has_stage_data();
  inline void clear_has_stage_data();
  inline void set_has_home_info();
  inline void clear_has_home_info();
  inline void set_has_tech_data();
  inline void clear_has_tech_data();
  inline void set_has_trial_data();
  inline void clear_has_trial_data();
  inline void set_has_arena_data();
  inline void clear_has_arena_data();
  inline void set_has_friends_data();
  inline void clear_has_friends_data();
  inline void set_has_daily_data();
  inline void clear_has_daily_data();
  inline void set_has_achievement_data();
  inline void clear_has_achievement_data();
  inline void set_has_shop_data();
  inline void clear_has_shop_data();
  inline void set_has_ship_lottery_data();
  inline void clear_has_ship_lottery_data();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_trade_data();
  inline void clear_has_trade_data();
  inline void set_has_new_hand_gift_bag_data();
  inline void clear_has_new_hand_gift_bag_data();
  inline void set_has_next_gift_bag_data();
  inline void clear_has_next_gift_bag_data();
  inline void set_has_ship_energy_end_time();
  inline void clear_has_ship_energy_end_time();
  inline void set_has_ship_energy_time_lock();
  inline void clear_has_ship_energy_time_lock();
  inline void set_has_gm_level();
  inline void clear_has_gm_level();
  inline void set_has_blocked();
  inline void clear_has_blocked();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_data_version();
  inline void clear_has_data_version();

  ::std::string* user_name_;
  ::std::string* nickname_;
  ::std::string* account_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lineup_;
  ::google::protobuf::int32 icon_id_;
  ::google::protobuf::int32 init_ship_index_;
  ::google::protobuf::int32 aid_award_index_;
  ::google::protobuf::int32 strength_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > res_;
  ::google::protobuf::int32 strength_buy_times_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 vip_level_;
  ::google::protobuf::int32 exp_;
  ::std::string* ip_;
  ::std::string* mcc_;
  ::std::string* client_version_;
  ::google::protobuf::RepeatedPtrField< ::Equip > equip_list_;
  ::google::protobuf::RepeatedPtrField< ::Gem > gem_list_;
  ::google::protobuf::RepeatedPtrField< ::Weapon > weapon_list_;
  ::GroupData* group_data_;
  ::google::protobuf::RepeatedPtrField< ::BuildQueue > build_queue_list_;
  ::google::protobuf::RepeatedPtrField< ::BuildingInfo > building_list_;
  ::StageData* stage_data_;
  ::HomeSystemInfo* home_info_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 state_;
  ::TechnologyData* tech_data_;
  ::TrialData* trial_data_;
  ::ArenaData* arena_data_;
  ::FriendsData* friends_data_;
  ::google::protobuf::RepeatedPtrField< ::TaskInfo > task_list_;
  ::DailyData* daily_data_;
  ::google::protobuf::RepeatedPtrField< ::BlueprintDevelopInfo > blueprint_list_;
  ::AchievementData* achievement_data_;
  ::ShopData* shop_data_;
  ::ShipLotteryData* ship_lottery_data_;
  ::google::protobuf::RepeatedPtrField< ::Activity > activity_list_;
  ::google::protobuf::RepeatedPtrField< ::Lineup > preset_lineup_list_;
  ::TradeData* trade_data_;
  ::google::protobuf::RepeatedPtrField< ::ForgeEquip > forge_equip_list_;
  ::NewHandGiftBagData* new_hand_gift_bag_data_;
  ::google::protobuf::RepeatedPtrField< ::GiftBag > gift_bag_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vip_award_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vip_pack_list_;
  ::NextGiftBagData* next_gift_bag_data_;
  ::google::protobuf::int64 ship_energy_end_time_;
  ::google::protobuf::int32 ship_energy_time_lock_;
  ::google::protobuf::int32 gm_level_;
  ::UserInfo_BlockInfo* blocked_;
  ::TimeStamp* timestamp_;
  ::google::protobuf::int32 data_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(51 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class NewHandGiftBag : public ::google::protobuf::MessageLite {
 public:
  NewHandGiftBag();
  virtual ~NewHandGiftBag();

  NewHandGiftBag(const NewHandGiftBag& from);

  inline NewHandGiftBag& operator=(const NewHandGiftBag& from) {
    CopyFrom(from);
    return *this;
  }

  static const NewHandGiftBag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewHandGiftBag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewHandGiftBag* other);

  // implements Message ----------------------------------------------

  NewHandGiftBag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewHandGiftBag& from);
  void MergeFrom(const NewHandGiftBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 gift_id = 2;
  inline bool has_gift_id() const;
  inline void clear_gift_id();
  static const int kGiftIdFieldNumber = 2;
  inline ::google::protobuf::int32 gift_id() const;
  inline void set_gift_id(::google::protobuf::int32 value);

  // required int64 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::int64 start_time() const;
  inline void set_start_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:NewHandGiftBag)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_gift_id();
  inline void clear_has_gift_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 gift_id_;
  ::google::protobuf::int64 start_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static NewHandGiftBag* default_instance_;
};
// -------------------------------------------------------------------

class NewHandGiftBagData : public ::google::protobuf::MessageLite {
 public:
  NewHandGiftBagData();
  virtual ~NewHandGiftBagData();

  NewHandGiftBagData(const NewHandGiftBagData& from);

  inline NewHandGiftBagData& operator=(const NewHandGiftBagData& from) {
    CopyFrom(from);
    return *this;
  }

  static const NewHandGiftBagData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewHandGiftBagData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewHandGiftBagData* other);

  // implements Message ----------------------------------------------

  NewHandGiftBagData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewHandGiftBagData& from);
  void MergeFrom(const NewHandGiftBagData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 times = 1;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 1;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // repeated .NewHandGiftBag new_hand_gift_bag_list = 2;
  inline int new_hand_gift_bag_list_size() const;
  inline void clear_new_hand_gift_bag_list();
  static const int kNewHandGiftBagListFieldNumber = 2;
  inline const ::NewHandGiftBag& new_hand_gift_bag_list(int index) const;
  inline ::NewHandGiftBag* mutable_new_hand_gift_bag_list(int index);
  inline ::NewHandGiftBag* add_new_hand_gift_bag_list();
  inline const ::google::protobuf::RepeatedPtrField< ::NewHandGiftBag >&
      new_hand_gift_bag_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::NewHandGiftBag >*
      mutable_new_hand_gift_bag_list();

  // @@protoc_insertion_point(class_scope:NewHandGiftBagData)
 private:
  inline void set_has_times();
  inline void clear_has_times();

  ::google::protobuf::RepeatedPtrField< ::NewHandGiftBag > new_hand_gift_bag_list_;
  ::google::protobuf::int32 times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static NewHandGiftBagData* default_instance_;
};
// -------------------------------------------------------------------

class GiftBag : public ::google::protobuf::MessageLite {
 public:
  GiftBag();
  virtual ~GiftBag();

  GiftBag(const GiftBag& from);

  inline GiftBag& operator=(const GiftBag& from) {
    CopyFrom(from);
    return *this;
  }

  static const GiftBag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiftBag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiftBag* other);

  // implements Message ----------------------------------------------

  GiftBag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiftBag& from);
  void MergeFrom(const GiftBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required int64 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::int64 start_time() const;
  inline void set_start_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GiftBag)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_start_time();
  inline void clear_has_start_time();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int64 start_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static GiftBag* default_instance_;
};
// -------------------------------------------------------------------

class NextGiftBagData : public ::google::protobuf::MessageLite {
 public:
  NextGiftBagData();
  virtual ~NextGiftBagData();

  NextGiftBagData(const NextGiftBagData& from);

  inline NextGiftBagData& operator=(const NextGiftBagData& from) {
    CopyFrom(from);
    return *this;
  }

  static const NextGiftBagData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NextGiftBagData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NextGiftBagData* other);

  // implements Message ----------------------------------------------

  NextGiftBagData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NextGiftBagData& from);
  void MergeFrom(const NextGiftBagData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NewHandGiftBag next_gift_bag = 1;
  inline int next_gift_bag_size() const;
  inline void clear_next_gift_bag();
  static const int kNextGiftBagFieldNumber = 1;
  inline const ::NewHandGiftBag& next_gift_bag(int index) const;
  inline ::NewHandGiftBag* mutable_next_gift_bag(int index);
  inline ::NewHandGiftBag* add_next_gift_bag();
  inline const ::google::protobuf::RepeatedPtrField< ::NewHandGiftBag >&
      next_gift_bag() const;
  inline ::google::protobuf::RepeatedPtrField< ::NewHandGiftBag >*
      mutable_next_gift_bag();

  // @@protoc_insertion_point(class_scope:NextGiftBagData)
 private:

  ::google::protobuf::RepeatedPtrField< ::NewHandGiftBag > next_gift_bag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static NextGiftBagData* default_instance_;
};
// -------------------------------------------------------------------

class TradeData : public ::google::protobuf::MessageLite {
 public:
  TradeData();
  virtual ~TradeData();

  TradeData(const TradeData& from);

  inline TradeData& operator=(const TradeData& from) {
    CopyFrom(from);
    return *this;
  }

  static const TradeData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TradeData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TradeData* other);

  // implements Message ----------------------------------------------

  TradeData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TradeData& from);
  void MergeFrom(const TradeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 last_product_time = 1;
  inline bool has_last_product_time() const;
  inline void clear_last_product_time();
  static const int kLastProductTimeFieldNumber = 1;
  inline ::google::protobuf::int64 last_product_time() const;
  inline void set_last_product_time(::google::protobuf::int64 value);

  // required int32 cur_num = 2;
  inline bool has_cur_num() const;
  inline void clear_cur_num();
  static const int kCurNumFieldNumber = 2;
  inline ::google::protobuf::int32 cur_num() const;
  inline void set_cur_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TradeData)
 private:
  inline void set_has_last_product_time();
  inline void clear_has_last_product_time();
  inline void set_has_cur_num();
  inline void clear_has_cur_num();

  ::google::protobuf::int64 last_product_time_;
  ::google::protobuf::int32 cur_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static TradeData* default_instance_;
};
// -------------------------------------------------------------------

class BlueprintDevelopInfo : public ::google::protobuf::MessageLite {
 public:
  BlueprintDevelopInfo();
  virtual ~BlueprintDevelopInfo();

  BlueprintDevelopInfo(const BlueprintDevelopInfo& from);

  inline BlueprintDevelopInfo& operator=(const BlueprintDevelopInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BlueprintDevelopInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BlueprintDevelopInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BlueprintDevelopInfo* other);

  // implements Message ----------------------------------------------

  BlueprintDevelopInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BlueprintDevelopInfo& from);
  void MergeFrom(const BlueprintDevelopInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 blueprint_id = 1;
  inline bool has_blueprint_id() const;
  inline void clear_blueprint_id();
  static const int kBlueprintIdFieldNumber = 1;
  inline ::google::protobuf::int32 blueprint_id() const;
  inline void set_blueprint_id(::google::protobuf::int32 value);

  // required int64 start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline ::google::protobuf::int64 start_time() const;
  inline void set_start_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:BlueprintDevelopInfo)
 private:
  inline void set_has_blueprint_id();
  inline void clear_has_blueprint_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();

  ::google::protobuf::int64 start_time_;
  ::google::protobuf::int32 blueprint_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static BlueprintDevelopInfo* default_instance_;
};
// -------------------------------------------------------------------

class ShipLotteryInfo : public ::google::protobuf::MessageLite {
 public:
  ShipLotteryInfo();
  virtual ~ShipLotteryInfo();

  ShipLotteryInfo(const ShipLotteryInfo& from);

  inline ShipLotteryInfo& operator=(const ShipLotteryInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipLotteryInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipLotteryInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipLotteryInfo* other);

  // implements Message ----------------------------------------------

  ShipLotteryInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipLotteryInfo& from);
  void MergeFrom(const ShipLotteryInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 free_times = 2;
  inline bool has_free_times() const;
  inline void clear_free_times();
  static const int kFreeTimesFieldNumber = 2;
  inline ::google::protobuf::int32 free_times() const;
  inline void set_free_times(::google::protobuf::int32 value);

  // required int64 add_free_start_time = 3;
  inline bool has_add_free_start_time() const;
  inline void clear_add_free_start_time();
  static const int kAddFreeStartTimeFieldNumber = 3;
  inline ::google::protobuf::int64 add_free_start_time() const;
  inline void set_add_free_start_time(::google::protobuf::int64 value);

  // required int64 cd_start_time = 4;
  inline bool has_cd_start_time() const;
  inline void clear_cd_start_time();
  static const int kCdStartTimeFieldNumber = 4;
  inline ::google::protobuf::int64 cd_start_time() const;
  inline void set_cd_start_time(::google::protobuf::int64 value);

  // required int32 single_times = 5;
  inline bool has_single_times() const;
  inline void clear_single_times();
  static const int kSingleTimesFieldNumber = 5;
  inline ::google::protobuf::int32 single_times() const;
  inline void set_single_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShipLotteryInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_free_times();
  inline void clear_has_free_times();
  inline void set_has_add_free_start_time();
  inline void clear_has_add_free_start_time();
  inline void set_has_cd_start_time();
  inline void clear_has_cd_start_time();
  inline void set_has_single_times();
  inline void clear_has_single_times();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 free_times_;
  ::google::protobuf::int64 add_free_start_time_;
  ::google::protobuf::int64 cd_start_time_;
  ::google::protobuf::int32 single_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static ShipLotteryInfo* default_instance_;
};
// -------------------------------------------------------------------

class ShipLotteryData : public ::google::protobuf::MessageLite {
 public:
  ShipLotteryData();
  virtual ~ShipLotteryData();

  ShipLotteryData(const ShipLotteryData& from);

  inline ShipLotteryData& operator=(const ShipLotteryData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipLotteryData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipLotteryData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipLotteryData* other);

  // implements Message ----------------------------------------------

  ShipLotteryData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipLotteryData& from);
  void MergeFrom(const ShipLotteryData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ShipLotteryInfo info_list = 1;
  inline int info_list_size() const;
  inline void clear_info_list();
  static const int kInfoListFieldNumber = 1;
  inline const ::ShipLotteryInfo& info_list(int index) const;
  inline ::ShipLotteryInfo* mutable_info_list(int index);
  inline ::ShipLotteryInfo* add_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ShipLotteryInfo >&
      info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ShipLotteryInfo >*
      mutable_info_list();

  // @@protoc_insertion_point(class_scope:ShipLotteryData)
 private:

  ::google::protobuf::RepeatedPtrField< ::ShipLotteryInfo > info_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static ShipLotteryData* default_instance_;
};
// -------------------------------------------------------------------

class ShopGoods : public ::google::protobuf::MessageLite {
 public:
  ShopGoods();
  virtual ~ShopGoods();

  ShopGoods(const ShopGoods& from);

  inline ShopGoods& operator=(const ShopGoods& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShopGoods& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShopGoods* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShopGoods* other);

  // implements Message ----------------------------------------------

  ShopGoods* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShopGoods& from);
  void MergeFrom(const ShopGoods& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 buy_times = 2;
  inline bool has_buy_times() const;
  inline void clear_buy_times();
  static const int kBuyTimesFieldNumber = 2;
  inline ::google::protobuf::int32 buy_times() const;
  inline void set_buy_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShopGoods)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_buy_times();
  inline void clear_has_buy_times();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 buy_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static ShopGoods* default_instance_;
};
// -------------------------------------------------------------------

class ShopData : public ::google::protobuf::MessageLite {
 public:
  ShopData();
  virtual ~ShopData();

  ShopData(const ShopData& from);

  inline ShopData& operator=(const ShopData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShopData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShopData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShopData* other);

  // implements Message ----------------------------------------------

  ShopData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShopData& from);
  void MergeFrom(const ShopData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ShopGoods goods_list = 1;
  inline int goods_list_size() const;
  inline void clear_goods_list();
  static const int kGoodsListFieldNumber = 1;
  inline const ::ShopGoods& goods_list(int index) const;
  inline ::ShopGoods* mutable_goods_list(int index);
  inline ::ShopGoods* add_goods_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ShopGoods >&
      goods_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ShopGoods >*
      mutable_goods_list();

  // @@protoc_insertion_point(class_scope:ShopData)
 private:

  ::google::protobuf::RepeatedPtrField< ::ShopGoods > goods_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static ShopData* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::MessageLite {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  static const Point& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Point* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  Point* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::int32 key() const;
  inline void set_key(::google::protobuf::int32 value);

  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Point)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::int32 key_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class DailyData : public ::google::protobuf::MessageLite {
 public:
  DailyData();
  virtual ~DailyData();

  DailyData(const DailyData& from);

  inline DailyData& operator=(const DailyData& from) {
    CopyFrom(from);
    return *this;
  }

  static const DailyData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DailyData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DailyData* other);

  // implements Message ----------------------------------------------

  DailyData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DailyData& from);
  void MergeFrom(const DailyData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ship_levelup_count = 1;
  inline bool has_ship_levelup_count() const;
  inline void clear_ship_levelup_count();
  static const int kShipLevelupCountFieldNumber = 1;
  inline ::google::protobuf::int32 ship_levelup_count() const;
  inline void set_ship_levelup_count(::google::protobuf::int32 value);

  // optional int32 equip_strength_count = 2;
  inline bool has_equip_strength_count() const;
  inline void clear_equip_strength_count();
  static const int kEquipStrengthCountFieldNumber = 2;
  inline ::google::protobuf::int32 equip_strength_count() const;
  inline void set_equip_strength_count(::google::protobuf::int32 value);

  // optional int32 ship_break_count = 3;
  inline bool has_ship_break_count() const;
  inline void clear_ship_break_count();
  static const int kShipBreakCountFieldNumber = 3;
  inline ::google::protobuf::int32 ship_break_count() const;
  inline void set_ship_break_count(::google::protobuf::int32 value);

  // optional int32 checkpoint_fight = 4;
  inline bool has_checkpoint_fight() const;
  inline void clear_checkpoint_fight();
  static const int kCheckpointFightFieldNumber = 4;
  inline ::google::protobuf::int32 checkpoint_fight() const;
  inline void set_checkpoint_fight(::google::protobuf::int32 value);

  // optional int32 checkpoint_win = 5;
  inline bool has_checkpoint_win() const;
  inline void clear_checkpoint_win();
  static const int kCheckpointWinFieldNumber = 5;
  inline ::google::protobuf::int32 checkpoint_win() const;
  inline void set_checkpoint_win(::google::protobuf::int32 value);

  // optional int32 contribute_times = 6;
  inline bool has_contribute_times() const;
  inline void clear_contribute_times();
  static const int kContributeTimesFieldNumber = 6;
  inline ::google::protobuf::int32 contribute_times() const;
  inline void set_contribute_times(::google::protobuf::int32 value);

  // optional int32 get_home_res_times = 7;
  inline bool has_get_home_res_times() const;
  inline void clear_get_home_res_times();
  static const int kGetHomeResTimesFieldNumber = 7;
  inline ::google::protobuf::int32 get_home_res_times() const;
  inline void set_get_home_res_times(::google::protobuf::int32 value);

  // optional int32 trial_times = 8;
  inline bool has_trial_times() const;
  inline void clear_trial_times();
  static const int kTrialTimesFieldNumber = 8;
  inline ::google::protobuf::int32 trial_times() const;
  inline void set_trial_times(::google::protobuf::int32 value);

  // optional int32 group_boss_times = 9;
  inline bool has_group_boss_times() const;
  inline void clear_group_boss_times();
  static const int kGroupBossTimesFieldNumber = 9;
  inline ::google::protobuf::int32 group_boss_times() const;
  inline void set_group_boss_times(::google::protobuf::int32 value);

  // optional int32 raid_times = 10;
  inline bool has_raid_times() const;
  inline void clear_raid_times();
  static const int kRaidTimesFieldNumber = 10;
  inline ::google::protobuf::int32 raid_times() const;
  inline void set_raid_times(::google::protobuf::int32 value);

  // optional int32 explore_ruins_times = 11;
  inline bool has_explore_ruins_times() const;
  inline void clear_explore_ruins_times();
  static const int kExploreRuinsTimesFieldNumber = 11;
  inline ::google::protobuf::int32 explore_ruins_times() const;
  inline void set_explore_ruins_times(::google::protobuf::int32 value);

  // optional int32 fishing_ruins_tims = 12;
  inline bool has_fishing_ruins_tims() const;
  inline void clear_fishing_ruins_tims();
  static const int kFishingRuinsTimsFieldNumber = 12;
  inline ::google::protobuf::int32 fishing_ruins_tims() const;
  inline void set_fishing_ruins_tims(::google::protobuf::int32 value);

  // optional int32 get_planet_res_times = 13;
  inline bool has_get_planet_res_times() const;
  inline void clear_get_planet_res_times();
  static const int kGetPlanetResTimesFieldNumber = 13;
  inline ::google::protobuf::int32 get_planet_res_times() const;
  inline void set_get_planet_res_times(::google::protobuf::int32 value);

  // optional int32 attack_planet_res_times = 14;
  inline bool has_attack_planet_res_times() const;
  inline void clear_attack_planet_res_times();
  static const int kAttackPlanetResTimesFieldNumber = 14;
  inline ::google::protobuf::int32 attack_planet_res_times() const;
  inline void set_attack_planet_res_times(::google::protobuf::int32 value);

  // optional int32 active = 15;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 15;
  inline ::google::protobuf::int32 active() const;
  inline void set_active(::google::protobuf::int32 value);

  // repeated bool get_active_level = 16;
  inline int get_active_level_size() const;
  inline void clear_get_active_level();
  static const int kGetActiveLevelFieldNumber = 16;
  inline bool get_active_level(int index) const;
  inline void set_get_active_level(int index, bool value);
  inline void add_get_active_level(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      get_active_level() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_get_active_level();

  // optional int32 help_times = 17;
  inline bool has_help_times() const;
  inline void clear_help_times();
  static const int kHelpTimesFieldNumber = 17;
  inline ::google::protobuf::int32 help_times() const;
  inline void set_help_times(::google::protobuf::int32 value);

  // optional int32 lottery_count = 18;
  inline bool has_lottery_count() const;
  inline void clear_lottery_count();
  static const int kLotteryCountFieldNumber = 18;
  inline ::google::protobuf::int32 lottery_count() const;
  inline void set_lottery_count(::google::protobuf::int32 value);

  // repeated .Point blueprint_count = 19;
  inline int blueprint_count_size() const;
  inline void clear_blueprint_count();
  static const int kBlueprintCountFieldNumber = 19;
  inline const ::Point& blueprint_count(int index) const;
  inline ::Point* mutable_blueprint_count(int index);
  inline ::Point* add_blueprint_count();
  inline const ::google::protobuf::RepeatedPtrField< ::Point >&
      blueprint_count() const;
  inline ::google::protobuf::RepeatedPtrField< ::Point >*
      mutable_blueprint_count();

  // @@protoc_insertion_point(class_scope:DailyData)
 private:
  inline void set_has_ship_levelup_count();
  inline void clear_has_ship_levelup_count();
  inline void set_has_equip_strength_count();
  inline void clear_has_equip_strength_count();
  inline void set_has_ship_break_count();
  inline void clear_has_ship_break_count();
  inline void set_has_checkpoint_fight();
  inline void clear_has_checkpoint_fight();
  inline void set_has_checkpoint_win();
  inline void clear_has_checkpoint_win();
  inline void set_has_contribute_times();
  inline void clear_has_contribute_times();
  inline void set_has_get_home_res_times();
  inline void clear_has_get_home_res_times();
  inline void set_has_trial_times();
  inline void clear_has_trial_times();
  inline void set_has_group_boss_times();
  inline void clear_has_group_boss_times();
  inline void set_has_raid_times();
  inline void clear_has_raid_times();
  inline void set_has_explore_ruins_times();
  inline void clear_has_explore_ruins_times();
  inline void set_has_fishing_ruins_tims();
  inline void clear_has_fishing_ruins_tims();
  inline void set_has_get_planet_res_times();
  inline void clear_has_get_planet_res_times();
  inline void set_has_attack_planet_res_times();
  inline void clear_has_attack_planet_res_times();
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_help_times();
  inline void clear_has_help_times();
  inline void set_has_lottery_count();
  inline void clear_has_lottery_count();

  ::google::protobuf::int32 ship_levelup_count_;
  ::google::protobuf::int32 equip_strength_count_;
  ::google::protobuf::int32 ship_break_count_;
  ::google::protobuf::int32 checkpoint_fight_;
  ::google::protobuf::int32 checkpoint_win_;
  ::google::protobuf::int32 contribute_times_;
  ::google::protobuf::int32 get_home_res_times_;
  ::google::protobuf::int32 trial_times_;
  ::google::protobuf::int32 group_boss_times_;
  ::google::protobuf::int32 raid_times_;
  ::google::protobuf::int32 explore_ruins_times_;
  ::google::protobuf::int32 fishing_ruins_tims_;
  ::google::protobuf::int32 get_planet_res_times_;
  ::google::protobuf::int32 attack_planet_res_times_;
  ::google::protobuf::RepeatedField< bool > get_active_level_;
  ::google::protobuf::int32 active_;
  ::google::protobuf::int32 help_times_;
  ::google::protobuf::RepeatedPtrField< ::Point > blueprint_count_;
  ::google::protobuf::int32 lottery_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static DailyData* default_instance_;
};
// -------------------------------------------------------------------

class AchievementData : public ::google::protobuf::MessageLite {
 public:
  AchievementData();
  virtual ~AchievementData();

  AchievementData(const AchievementData& from);

  inline AchievementData& operator=(const AchievementData& from) {
    CopyFrom(from);
    return *this;
  }

  static const AchievementData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AchievementData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AchievementData* other);

  // implements Message ----------------------------------------------

  AchievementData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AchievementData& from);
  void MergeFrom(const AchievementData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 contribute_times = 1;
  inline bool has_contribute_times() const;
  inline void clear_contribute_times();
  static const int kContributeTimesFieldNumber = 1;
  inline ::google::protobuf::int32 contribute_times() const;
  inline void set_contribute_times(::google::protobuf::int32 value);

  // optional int32 recharge_money = 2;
  inline bool has_recharge_money() const;
  inline void clear_recharge_money();
  static const int kRechargeMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 recharge_money() const;
  inline void set_recharge_money(::google::protobuf::int32 value);

  // optional int32 consume_money = 3;
  inline bool has_consume_money() const;
  inline void clear_consume_money();
  static const int kConsumeMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 consume_money() const;
  inline void set_consume_money(::google::protobuf::int32 value);

  // optional int32 sign_in_days = 4;
  inline bool has_sign_in_days() const;
  inline void clear_sign_in_days();
  static const int kSignInDaysFieldNumber = 4;
  inline ::google::protobuf::int32 sign_in_days() const;
  inline void set_sign_in_days(::google::protobuf::int32 value);

  // optional int32 lottery_count = 5;
  inline bool has_lottery_count() const;
  inline void clear_lottery_count();
  static const int kLotteryCountFieldNumber = 5;
  inline ::google::protobuf::int32 lottery_count() const;
  inline void set_lottery_count(::google::protobuf::int32 value);

  // repeated int32 recharge_list = 6;
  inline int recharge_list_size() const;
  inline void clear_recharge_list();
  static const int kRechargeListFieldNumber = 6;
  inline ::google::protobuf::int32 recharge_list(int index) const;
  inline void set_recharge_list(int index, ::google::protobuf::int32 value);
  inline void add_recharge_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      recharge_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_recharge_list();

  // optional int32 recharge_real_money = 7;
  inline bool has_recharge_real_money() const;
  inline void clear_recharge_real_money();
  static const int kRechargeRealMoneyFieldNumber = 7;
  inline ::google::protobuf::int32 recharge_real_money() const;
  inline void set_recharge_real_money(::google::protobuf::int32 value);

  // optional string talk_key = 8;
  inline bool has_talk_key() const;
  inline void clear_talk_key();
  static const int kTalkKeyFieldNumber = 8;
  inline const ::std::string& talk_key() const;
  inline void set_talk_key(const ::std::string& value);
  inline void set_talk_key(const char* value);
  inline void set_talk_key(const char* value, size_t size);
  inline ::std::string* mutable_talk_key();
  inline ::std::string* release_talk_key();
  inline void set_allocated_talk_key(::std::string* talk_key);

  // repeated int32 guide_list = 9;
  inline int guide_list_size() const;
  inline void clear_guide_list();
  static const int kGuideListFieldNumber = 9;
  inline ::google::protobuf::int32 guide_list(int index) const;
  inline void set_guide_list(int index, ::google::protobuf::int32 value);
  inline void add_guide_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      guide_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_guide_list();

  // optional bool first_develop_blueprint = 10;
  inline bool has_first_develop_blueprint() const;
  inline void clear_first_develop_blueprint();
  static const int kFirstDevelopBlueprintFieldNumber = 10;
  inline bool first_develop_blueprint() const;
  inline void set_first_develop_blueprint(bool value);

  // optional bool first_finish_collect = 11;
  inline bool has_first_finish_collect() const;
  inline void clear_first_finish_collect();
  static const int kFirstFinishCollectFieldNumber = 11;
  inline bool first_finish_collect() const;
  inline void set_first_finish_collect(bool value);

  // optional bool first_develop_ship = 12;
  inline bool has_first_develop_ship() const;
  inline void clear_first_develop_ship();
  static const int kFirstDevelopShipFieldNumber = 12;
  inline bool first_develop_ship() const;
  inline void set_first_develop_ship(bool value);

  // optional bool first_failed_battle = 13;
  inline bool has_first_failed_battle() const;
  inline void clear_first_failed_battle();
  static const int kFirstFailedBattleFieldNumber = 13;
  inline bool first_failed_battle() const;
  inline void set_first_failed_battle(bool value);

  // optional int32 task_finish_times = 14;
  inline bool has_task_finish_times() const;
  inline void clear_task_finish_times();
  static const int kTaskFinishTimesFieldNumber = 14;
  inline ::google::protobuf::int32 task_finish_times() const;
  inline void set_task_finish_times(::google::protobuf::int32 value);

  // optional int32 slave_times = 15;
  inline bool has_slave_times() const;
  inline void clear_slave_times();
  static const int kSlaveTimesFieldNumber = 15;
  inline ::google::protobuf::int32 slave_times() const;
  inline void set_slave_times(::google::protobuf::int32 value);

  // optional bool first_lottery_money = 16;
  inline bool has_first_lottery_money() const;
  inline void clear_first_lottery_money();
  static const int kFirstLotteryMoneyFieldNumber = 16;
  inline bool first_lottery_money() const;
  inline void set_first_lottery_money(bool value);

  // optional bool first_lottery_res = 17;
  inline bool has_first_lottery_res() const;
  inline void clear_first_lottery_res();
  static const int kFirstLotteryResFieldNumber = 17;
  inline bool first_lottery_res() const;
  inline void set_first_lottery_res(bool value);

  // repeated .Point blueprint_count = 18;
  inline int blueprint_count_size() const;
  inline void clear_blueprint_count();
  static const int kBlueprintCountFieldNumber = 18;
  inline const ::Point& blueprint_count(int index) const;
  inline ::Point* mutable_blueprint_count(int index);
  inline ::Point* add_blueprint_count();
  inline const ::google::protobuf::RepeatedPtrField< ::Point >&
      blueprint_count() const;
  inline ::google::protobuf::RepeatedPtrField< ::Point >*
      mutable_blueprint_count();

  // @@protoc_insertion_point(class_scope:AchievementData)
 private:
  inline void set_has_contribute_times();
  inline void clear_has_contribute_times();
  inline void set_has_recharge_money();
  inline void clear_has_recharge_money();
  inline void set_has_consume_money();
  inline void clear_has_consume_money();
  inline void set_has_sign_in_days();
  inline void clear_has_sign_in_days();
  inline void set_has_lottery_count();
  inline void clear_has_lottery_count();
  inline void set_has_recharge_real_money();
  inline void clear_has_recharge_real_money();
  inline void set_has_talk_key();
  inline void clear_has_talk_key();
  inline void set_has_first_develop_blueprint();
  inline void clear_has_first_develop_blueprint();
  inline void set_has_first_finish_collect();
  inline void clear_has_first_finish_collect();
  inline void set_has_first_develop_ship();
  inline void clear_has_first_develop_ship();
  inline void set_has_first_failed_battle();
  inline void clear_has_first_failed_battle();
  inline void set_has_task_finish_times();
  inline void clear_has_task_finish_times();
  inline void set_has_slave_times();
  inline void clear_has_slave_times();
  inline void set_has_first_lottery_money();
  inline void clear_has_first_lottery_money();
  inline void set_has_first_lottery_res();
  inline void clear_has_first_lottery_res();

  ::google::protobuf::int32 contribute_times_;
  ::google::protobuf::int32 recharge_money_;
  ::google::protobuf::int32 consume_money_;
  ::google::protobuf::int32 sign_in_days_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > recharge_list_;
  ::google::protobuf::int32 lottery_count_;
  ::google::protobuf::int32 recharge_real_money_;
  ::std::string* talk_key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > guide_list_;
  bool first_develop_blueprint_;
  bool first_finish_collect_;
  bool first_develop_ship_;
  bool first_failed_battle_;
  ::google::protobuf::int32 task_finish_times_;
  ::google::protobuf::int32 slave_times_;
  bool first_lottery_money_;
  bool first_lottery_res_;
  ::google::protobuf::RepeatedPtrField< ::Point > blueprint_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static AchievementData* default_instance_;
};
// -------------------------------------------------------------------

class TaskInfo : public ::google::protobuf::MessageLite {
 public:
  TaskInfo();
  virtual ~TaskInfo();

  TaskInfo(const TaskInfo& from);

  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TaskInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TaskInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TaskInfo* other);

  // implements Message ----------------------------------------------

  TaskInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TaskInfo& from);
  void MergeFrom(const TaskInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::int32 task_id() const;
  inline void set_task_id(::google::protobuf::int32 value);

  // optional bool finished = 2;
  inline bool has_finished() const;
  inline void clear_finished();
  static const int kFinishedFieldNumber = 2;
  inline bool finished() const;
  inline void set_finished(bool value);

  // @@protoc_insertion_point(class_scope:TaskInfo)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_finished();
  inline void clear_has_finished();

  ::google::protobuf::int32 task_id_;
  bool finished_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static TaskInfo* default_instance_;
};
// -------------------------------------------------------------------

class BuildQueue : public ::google::protobuf::MessageLite {
 public:
  BuildQueue();
  virtual ~BuildQueue();

  BuildQueue(const BuildQueue& from);

  inline BuildQueue& operator=(const BuildQueue& from) {
    CopyFrom(from);
    return *this;
  }

  static const BuildQueue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BuildQueue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BuildQueue* other);

  // implements Message ----------------------------------------------

  BuildQueue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BuildQueue& from);
  void MergeFrom(const BuildQueue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 duration_time = 1;
  inline bool has_duration_time() const;
  inline void clear_duration_time();
  static const int kDurationTimeFieldNumber = 1;
  inline ::google::protobuf::int64 duration_time() const;
  inline void set_duration_time(::google::protobuf::int64 value);

  // required int64 open_time = 2;
  inline bool has_open_time() const;
  inline void clear_open_time();
  static const int kOpenTimeFieldNumber = 2;
  inline ::google::protobuf::int64 open_time() const;
  inline void set_open_time(::google::protobuf::int64 value);

  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BuildQueue)
 private:
  inline void set_has_duration_time();
  inline void clear_has_duration_time();
  inline void set_has_open_time();
  inline void clear_has_open_time();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int64 duration_time_;
  ::google::protobuf::int64 open_time_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static BuildQueue* default_instance_;
};
// -------------------------------------------------------------------

class TechContributeData : public ::google::protobuf::MessageLite {
 public:
  TechContributeData();
  virtual ~TechContributeData();

  TechContributeData(const TechContributeData& from);

  inline TechContributeData& operator=(const TechContributeData& from) {
    CopyFrom(from);
    return *this;
  }

  static const TechContributeData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TechContributeData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TechContributeData* other);

  // implements Message ----------------------------------------------

  TechContributeData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TechContributeData& from);
  void MergeFrom(const TechContributeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tech_id = 1;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 1;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // repeated int32 item_index_list = 2;
  inline int item_index_list_size() const;
  inline void clear_item_index_list();
  static const int kItemIndexListFieldNumber = 2;
  inline ::google::protobuf::int32 item_index_list(int index) const;
  inline void set_item_index_list(int index, ::google::protobuf::int32 value);
  inline void add_item_index_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      item_index_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_item_index_list();

  // @@protoc_insertion_point(class_scope:TechContributeData)
 private:
  inline void set_has_tech_id();
  inline void clear_has_tech_id();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > item_index_list_;
  ::google::protobuf::int32 tech_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static TechContributeData* default_instance_;
};
// -------------------------------------------------------------------

class GroupPVECheckpoint : public ::google::protobuf::MessageLite {
 public:
  GroupPVECheckpoint();
  virtual ~GroupPVECheckpoint();

  GroupPVECheckpoint(const GroupPVECheckpoint& from);

  inline GroupPVECheckpoint& operator=(const GroupPVECheckpoint& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupPVECheckpoint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupPVECheckpoint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupPVECheckpoint* other);

  // implements Message ----------------------------------------------

  GroupPVECheckpoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupPVECheckpoint& from);
  void MergeFrom(const GroupPVECheckpoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 group_boss_id = 1;
  inline bool has_group_boss_id() const;
  inline void clear_group_boss_id();
  static const int kGroupBossIdFieldNumber = 1;
  inline ::google::protobuf::int32 group_boss_id() const;
  inline void set_group_boss_id(::google::protobuf::int32 value);

  // repeated int32 hurter_hp_list = 2;
  inline int hurter_hp_list_size() const;
  inline void clear_hurter_hp_list();
  static const int kHurterHpListFieldNumber = 2;
  inline ::google::protobuf::int32 hurter_hp_list(int index) const;
  inline void set_hurter_hp_list(int index, ::google::protobuf::int32 value);
  inline void add_hurter_hp_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hurter_hp_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hurter_hp_list();

  // required int32 damage = 3;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 3;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // required int32 challenge_times = 4;
  inline bool has_challenge_times() const;
  inline void clear_challenge_times();
  static const int kChallengeTimesFieldNumber = 4;
  inline ::google::protobuf::int32 challenge_times() const;
  inline void set_challenge_times(::google::protobuf::int32 value);

  // required int32 buy_challenge_times = 5;
  inline bool has_buy_challenge_times() const;
  inline void clear_buy_challenge_times();
  static const int kBuyChallengeTimesFieldNumber = 5;
  inline ::google::protobuf::int32 buy_challenge_times() const;
  inline void set_buy_challenge_times(::google::protobuf::int32 value);

  // repeated bool get_reward_list = 6;
  inline int get_reward_list_size() const;
  inline void clear_get_reward_list();
  static const int kGetRewardListFieldNumber = 6;
  inline bool get_reward_list(int index) const;
  inline void set_get_reward_list(int index, bool value);
  inline void add_get_reward_list(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      get_reward_list() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_get_reward_list();

  // @@protoc_insertion_point(class_scope:GroupPVECheckpoint)
 private:
  inline void set_has_group_boss_id();
  inline void clear_has_group_boss_id();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_challenge_times();
  inline void clear_has_challenge_times();
  inline void set_has_buy_challenge_times();
  inline void clear_has_buy_challenge_times();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hurter_hp_list_;
  ::google::protobuf::int32 group_boss_id_;
  ::google::protobuf::int32 damage_;
  ::google::protobuf::int32 challenge_times_;
  ::google::protobuf::int32 buy_challenge_times_;
  ::google::protobuf::RepeatedField< bool > get_reward_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static GroupPVECheckpoint* default_instance_;
};
// -------------------------------------------------------------------

class GroupData : public ::google::protobuf::MessageLite {
 public:
  GroupData();
  virtual ~GroupData();

  GroupData(const GroupData& from);

  inline GroupData& operator=(const GroupData& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupData* other);

  // implements Message ----------------------------------------------

  GroupData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupData& from);
  void MergeFrom(const GroupData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string groupid = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 1;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // required int32 job = 2;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 2;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // required int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional int32 icon_id = 4;
  inline bool has_icon_id() const;
  inline void clear_icon_id();
  static const int kIconIdFieldNumber = 4;
  inline ::google::protobuf::int32 icon_id() const;
  inline void set_icon_id(::google::protobuf::int32 value);

  // optional int64 anti_time = 5;
  inline bool has_anti_time() const;
  inline void clear_anti_time();
  static const int kAntiTimeFieldNumber = 5;
  inline ::google::protobuf::int64 anti_time() const;
  inline void set_anti_time(::google::protobuf::int64 value);

  // optional int32 today_join_num = 6;
  inline bool has_today_join_num() const;
  inline void clear_today_join_num();
  static const int kTodayJoinNumFieldNumber = 6;
  inline ::google::protobuf::int32 today_join_num() const;
  inline void set_today_join_num(::google::protobuf::int32 value);

  // optional int32 contribute = 7;
  inline bool has_contribute() const;
  inline void clear_contribute();
  static const int kContributeFieldNumber = 7;
  inline ::google::protobuf::int32 contribute() const;
  inline void set_contribute(::google::protobuf::int32 value);

  // repeated .TechContributeData tech_contribute_list = 8;
  inline int tech_contribute_list_size() const;
  inline void clear_tech_contribute_list();
  static const int kTechContributeListFieldNumber = 8;
  inline const ::TechContributeData& tech_contribute_list(int index) const;
  inline ::TechContributeData* mutable_tech_contribute_list(int index);
  inline ::TechContributeData* add_tech_contribute_list();
  inline const ::google::protobuf::RepeatedPtrField< ::TechContributeData >&
      tech_contribute_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::TechContributeData >*
      mutable_tech_contribute_list();

  // optional int64 contribute_end_cd = 9;
  inline bool has_contribute_end_cd() const;
  inline void clear_contribute_end_cd();
  static const int kContributeEndCdFieldNumber = 9;
  inline ::google::protobuf::int64 contribute_end_cd() const;
  inline void set_contribute_end_cd(::google::protobuf::int64 value);

  // optional bool contribute_locker = 10;
  inline bool has_contribute_locker() const;
  inline void clear_contribute_locker();
  static const int kContributeLockerFieldNumber = 10;
  inline bool contribute_locker() const;
  inline void set_contribute_locker(bool value);

  // repeated .GroupPVECheckpoint pve_checkpoint_list = 11;
  inline int pve_checkpoint_list_size() const;
  inline void clear_pve_checkpoint_list();
  static const int kPveCheckpointListFieldNumber = 11;
  inline const ::GroupPVECheckpoint& pve_checkpoint_list(int index) const;
  inline ::GroupPVECheckpoint* mutable_pve_checkpoint_list(int index);
  inline ::GroupPVECheckpoint* add_pve_checkpoint_list();
  inline const ::google::protobuf::RepeatedPtrField< ::GroupPVECheckpoint >&
      pve_checkpoint_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::GroupPVECheckpoint >*
      mutable_pve_checkpoint_list();

  // optional int32 help_times = 12;
  inline bool has_help_times() const;
  inline void clear_help_times();
  static const int kHelpTimesFieldNumber = 12;
  inline ::google::protobuf::int32 help_times() const;
  inline void set_help_times(::google::protobuf::int32 value);

  // optional int32 today_worship_level = 13;
  inline bool has_today_worship_level() const;
  inline void clear_today_worship_level();
  static const int kTodayWorshipLevelFieldNumber = 13;
  inline ::google::protobuf::int32 today_worship_level() const;
  inline void set_today_worship_level(::google::protobuf::int32 value);

  // repeated bool getted_worship_reward = 14;
  inline int getted_worship_reward_size() const;
  inline void clear_getted_worship_reward();
  static const int kGettedWorshipRewardFieldNumber = 14;
  inline bool getted_worship_reward(int index) const;
  inline void set_getted_worship_reward(int index, bool value);
  inline void add_getted_worship_reward(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      getted_worship_reward() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_getted_worship_reward();

  // @@protoc_insertion_point(class_scope:GroupData)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_icon_id();
  inline void clear_has_icon_id();
  inline void set_has_anti_time();
  inline void clear_has_anti_time();
  inline void set_has_today_join_num();
  inline void clear_has_today_join_num();
  inline void set_has_contribute();
  inline void clear_has_contribute();
  inline void set_has_contribute_end_cd();
  inline void clear_has_contribute_end_cd();
  inline void set_has_contribute_locker();
  inline void clear_has_contribute_locker();
  inline void set_has_help_times();
  inline void clear_has_help_times();
  inline void set_has_today_worship_level();
  inline void clear_has_today_worship_level();

  ::std::string* groupid_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int64 anti_time_;
  ::google::protobuf::int32 icon_id_;
  ::google::protobuf::int32 today_join_num_;
  ::google::protobuf::RepeatedPtrField< ::TechContributeData > tech_contribute_list_;
  ::google::protobuf::int32 contribute_;
  bool contribute_locker_;
  ::google::protobuf::int64 contribute_end_cd_;
  ::google::protobuf::RepeatedPtrField< ::GroupPVECheckpoint > pve_checkpoint_list_;
  ::google::protobuf::int32 help_times_;
  ::google::protobuf::int32 today_worship_level_;
  ::google::protobuf::RepeatedField< bool > getted_worship_reward_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static GroupData* default_instance_;
};
// -------------------------------------------------------------------

class TechnologyData : public ::google::protobuf::MessageLite {
 public:
  TechnologyData();
  virtual ~TechnologyData();

  TechnologyData(const TechnologyData& from);

  inline TechnologyData& operator=(const TechnologyData& from) {
    CopyFrom(from);
    return *this;
  }

  static const TechnologyData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TechnologyData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TechnologyData* other);

  // implements Message ----------------------------------------------

  TechnologyData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TechnologyData& from);
  void MergeFrom(const TechnologyData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TechnologyInfo tech_info = 1;
  inline int tech_info_size() const;
  inline void clear_tech_info();
  static const int kTechInfoFieldNumber = 1;
  inline const ::TechnologyInfo& tech_info(int index) const;
  inline ::TechnologyInfo* mutable_tech_info(int index);
  inline ::TechnologyInfo* add_tech_info();
  inline const ::google::protobuf::RepeatedPtrField< ::TechnologyInfo >&
      tech_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::TechnologyInfo >*
      mutable_tech_info();

  // optional int32 upgrade_busy = 2;
  inline bool has_upgrade_busy() const;
  inline void clear_upgrade_busy();
  static const int kUpgradeBusyFieldNumber = 2;
  inline ::google::protobuf::int32 upgrade_busy() const;
  inline void set_upgrade_busy(::google::protobuf::int32 value);

  // optional int32 tech_id = 3;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 3;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TechnologyData)
 private:
  inline void set_has_upgrade_busy();
  inline void clear_has_upgrade_busy();
  inline void set_has_tech_id();
  inline void clear_has_tech_id();

  ::google::protobuf::RepeatedPtrField< ::TechnologyInfo > tech_info_;
  ::google::protobuf::int32 upgrade_busy_;
  ::google::protobuf::int32 tech_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static TechnologyData* default_instance_;
};
// -------------------------------------------------------------------

class TechnologyInfo : public ::google::protobuf::MessageLite {
 public:
  TechnologyInfo();
  virtual ~TechnologyInfo();

  TechnologyInfo(const TechnologyInfo& from);

  inline TechnologyInfo& operator=(const TechnologyInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TechnologyInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TechnologyInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TechnologyInfo* other);

  // implements Message ----------------------------------------------

  TechnologyInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TechnologyInfo& from);
  void MergeFrom(const TechnologyInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tech_id = 1;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 1;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // optional int64 begin_upgrade_time = 2;
  inline bool has_begin_upgrade_time() const;
  inline void clear_begin_upgrade_time();
  static const int kBeginUpgradeTimeFieldNumber = 2;
  inline ::google::protobuf::int64 begin_upgrade_time() const;
  inline void set_begin_upgrade_time(::google::protobuf::int64 value);

  // optional bool helped = 3;
  inline bool has_helped() const;
  inline void clear_helped();
  static const int kHelpedFieldNumber = 3;
  inline bool helped() const;
  inline void set_helped(bool value);

  // @@protoc_insertion_point(class_scope:TechnologyInfo)
 private:
  inline void set_has_tech_id();
  inline void clear_has_tech_id();
  inline void set_has_begin_upgrade_time();
  inline void clear_has_begin_upgrade_time();
  inline void set_has_helped();
  inline void clear_has_helped();

  ::google::protobuf::int64 begin_upgrade_time_;
  ::google::protobuf::int32 tech_id_;
  bool helped_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static TechnologyInfo* default_instance_;
};
// -------------------------------------------------------------------

class ArenaRank : public ::google::protobuf::MessageLite {
 public:
  ArenaRank();
  virtual ~ArenaRank();

  ArenaRank(const ArenaRank& from);

  inline ArenaRank& operator=(const ArenaRank& from) {
    CopyFrom(from);
    return *this;
  }

  static const ArenaRank& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaRank* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaRank* other);

  // implements Message ----------------------------------------------

  ArenaRank* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaRank& from);
  void MergeFrom(const ArenaRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // required bool isChallenged = 2;
  inline bool has_ischallenged() const;
  inline void clear_ischallenged();
  static const int kIsChallengedFieldNumber = 2;
  inline bool ischallenged() const;
  inline void set_ischallenged(bool value);

  // @@protoc_insertion_point(class_scope:ArenaRank)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_ischallenged();
  inline void clear_has_ischallenged();

  ::google::protobuf::int32 rank_;
  bool ischallenged_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static ArenaRank* default_instance_;
};
// -------------------------------------------------------------------

class ArenaData : public ::google::protobuf::MessageLite {
 public:
  ArenaData();
  virtual ~ArenaData();

  ArenaData(const ArenaData& from);

  inline ArenaData& operator=(const ArenaData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ArenaData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ArenaData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ArenaData* other);

  // implements Message ----------------------------------------------

  ArenaData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ArenaData& from);
  void MergeFrom(const ArenaData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 challenge_times = 1;
  inline bool has_challenge_times() const;
  inline void clear_challenge_times();
  static const int kChallengeTimesFieldNumber = 1;
  inline ::google::protobuf::int32 challenge_times() const;
  inline void set_challenge_times(::google::protobuf::int32 value);

  // required int32 purchased_challenge_times = 2;
  inline bool has_purchased_challenge_times() const;
  inline void clear_purchased_challenge_times();
  static const int kPurchasedChallengeTimesFieldNumber = 2;
  inline ::google::protobuf::int32 purchased_challenge_times() const;
  inline void set_purchased_challenge_times(::google::protobuf::int32 value);

  // required int32 honour_point = 3;
  inline bool has_honour_point() const;
  inline void clear_honour_point();
  static const int kHonourPointFieldNumber = 3;
  inline ::google::protobuf::int32 honour_point() const;
  inline void set_honour_point(::google::protobuf::int32 value);

  // repeated .ArenaRank challenge_list = 4;
  inline int challenge_list_size() const;
  inline void clear_challenge_list();
  static const int kChallengeListFieldNumber = 4;
  inline const ::ArenaRank& challenge_list(int index) const;
  inline ::ArenaRank* mutable_challenge_list(int index);
  inline ::ArenaRank* add_challenge_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ArenaRank >&
      challenge_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ArenaRank >*
      mutable_challenge_list();

  // required int64 last_failed_time = 5;
  inline bool has_last_failed_time() const;
  inline void clear_last_failed_time();
  static const int kLastFailedTimeFieldNumber = 5;
  inline ::google::protobuf::int64 last_failed_time() const;
  inline void set_last_failed_time(::google::protobuf::int64 value);

  // required int32 target_rank = 6;
  inline bool has_target_rank() const;
  inline void clear_target_rank();
  static const int kTargetRankFieldNumber = 6;
  inline ::google::protobuf::int32 target_rank() const;
  inline void set_target_rank(::google::protobuf::int32 value);

  // required int32 daily_reward = 7;
  inline bool has_daily_reward() const;
  inline void clear_daily_reward();
  static const int kDailyRewardFieldNumber = 7;
  inline ::google::protobuf::int32 daily_reward() const;
  inline void set_daily_reward(::google::protobuf::int32 value);

  // required int32 already_challenge_times = 8;
  inline bool has_already_challenge_times() const;
  inline void clear_already_challenge_times();
  static const int kAlreadyChallengeTimesFieldNumber = 8;
  inline ::google::protobuf::int32 already_challenge_times() const;
  inline void set_already_challenge_times(::google::protobuf::int32 value);

  // required int32 win_challenge_times = 9;
  inline bool has_win_challenge_times() const;
  inline void clear_win_challenge_times();
  static const int kWinChallengeTimesFieldNumber = 9;
  inline ::google::protobuf::int32 win_challenge_times() const;
  inline void set_win_challenge_times(::google::protobuf::int32 value);

  // required int32 title_level = 10;
  inline bool has_title_level() const;
  inline void clear_title_level();
  static const int kTitleLevelFieldNumber = 10;
  inline ::google::protobuf::int32 title_level() const;
  inline void set_title_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ArenaData)
 private:
  inline void set_has_challenge_times();
  inline void clear_has_challenge_times();
  inline void set_has_purchased_challenge_times();
  inline void clear_has_purchased_challenge_times();
  inline void set_has_honour_point();
  inline void clear_has_honour_point();
  inline void set_has_last_failed_time();
  inline void clear_has_last_failed_time();
  inline void set_has_target_rank();
  inline void clear_has_target_rank();
  inline void set_has_daily_reward();
  inline void clear_has_daily_reward();
  inline void set_has_already_challenge_times();
  inline void clear_has_already_challenge_times();
  inline void set_has_win_challenge_times();
  inline void clear_has_win_challenge_times();
  inline void set_has_title_level();
  inline void clear_has_title_level();

  ::google::protobuf::int32 challenge_times_;
  ::google::protobuf::int32 purchased_challenge_times_;
  ::google::protobuf::RepeatedPtrField< ::ArenaRank > challenge_list_;
  ::google::protobuf::int32 honour_point_;
  ::google::protobuf::int32 target_rank_;
  ::google::protobuf::int64 last_failed_time_;
  ::google::protobuf::int32 daily_reward_;
  ::google::protobuf::int32 already_challenge_times_;
  ::google::protobuf::int32 win_challenge_times_;
  ::google::protobuf::int32 title_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static ArenaData* default_instance_;
};
// -------------------------------------------------------------------

class FriendFamiliarity : public ::google::protobuf::MessageLite {
 public:
  FriendFamiliarity();
  virtual ~FriendFamiliarity();

  FriendFamiliarity(const FriendFamiliarity& from);

  inline FriendFamiliarity& operator=(const FriendFamiliarity& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendFamiliarity& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendFamiliarity* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendFamiliarity* other);

  // implements Message ----------------------------------------------

  FriendFamiliarity* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendFamiliarity& from);
  void MergeFrom(const FriendFamiliarity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required int32 familiarity = 2;
  inline bool has_familiarity() const;
  inline void clear_familiarity();
  static const int kFamiliarityFieldNumber = 2;
  inline ::google::protobuf::int32 familiarity() const;
  inline void set_familiarity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FriendFamiliarity)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_familiarity();
  inline void clear_has_familiarity();

  ::std::string* user_name_;
  ::google::protobuf::int32 familiarity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static FriendFamiliarity* default_instance_;
};
// -------------------------------------------------------------------

class FriendsData : public ::google::protobuf::MessageLite {
 public:
  FriendsData();
  virtual ~FriendsData();

  FriendsData(const FriendsData& from);

  inline FriendsData& operator=(const FriendsData& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendsData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendsData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendsData* other);

  // implements Message ----------------------------------------------

  FriendsData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendsData& from);
  void MergeFrom(const FriendsData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string friends_list = 1;
  inline int friends_list_size() const;
  inline void clear_friends_list();
  static const int kFriendsListFieldNumber = 1;
  inline const ::std::string& friends_list(int index) const;
  inline ::std::string* mutable_friends_list(int index);
  inline void set_friends_list(int index, const ::std::string& value);
  inline void set_friends_list(int index, const char* value);
  inline void set_friends_list(int index, const char* value, size_t size);
  inline ::std::string* add_friends_list();
  inline void add_friends_list(const ::std::string& value);
  inline void add_friends_list(const char* value);
  inline void add_friends_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& friends_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_friends_list();

  // repeated string black_list = 2;
  inline int black_list_size() const;
  inline void clear_black_list();
  static const int kBlackListFieldNumber = 2;
  inline const ::std::string& black_list(int index) const;
  inline ::std::string* mutable_black_list(int index);
  inline void set_black_list(int index, const ::std::string& value);
  inline void set_black_list(int index, const char* value);
  inline void set_black_list(int index, const char* value, size_t size);
  inline ::std::string* add_black_list();
  inline void add_black_list(const ::std::string& value);
  inline void add_black_list(const char* value);
  inline void add_black_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& black_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_black_list();

  // repeated string talk_list = 3;
  inline int talk_list_size() const;
  inline void clear_talk_list();
  static const int kTalkListFieldNumber = 3;
  inline const ::std::string& talk_list(int index) const;
  inline ::std::string* mutable_talk_list(int index);
  inline void set_talk_list(int index, const ::std::string& value);
  inline void set_talk_list(int index, const char* value);
  inline void set_talk_list(int index, const char* value, size_t size);
  inline ::std::string* add_talk_list();
  inline void add_talk_list(const ::std::string& value);
  inline void add_talk_list(const char* value);
  inline void add_talk_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& talk_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_talk_list();

  // repeated .FriendFamiliarity friends_familiarity = 4;
  inline int friends_familiarity_size() const;
  inline void clear_friends_familiarity();
  static const int kFriendsFamiliarityFieldNumber = 4;
  inline const ::FriendFamiliarity& friends_familiarity(int index) const;
  inline ::FriendFamiliarity* mutable_friends_familiarity(int index);
  inline ::FriendFamiliarity* add_friends_familiarity();
  inline const ::google::protobuf::RepeatedPtrField< ::FriendFamiliarity >&
      friends_familiarity() const;
  inline ::google::protobuf::RepeatedPtrField< ::FriendFamiliarity >*
      mutable_friends_familiarity();

  // repeated string add_tili = 5;
  inline int add_tili_size() const;
  inline void clear_add_tili();
  static const int kAddTiliFieldNumber = 5;
  inline const ::std::string& add_tili(int index) const;
  inline ::std::string* mutable_add_tili(int index);
  inline void set_add_tili(int index, const ::std::string& value);
  inline void set_add_tili(int index, const char* value);
  inline void set_add_tili(int index, const char* value, size_t size);
  inline ::std::string* add_add_tili();
  inline void add_add_tili(const ::std::string& value);
  inline void add_add_tili(const char* value);
  inline void add_add_tili(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& add_tili() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_add_tili();

  // repeated string read_tili = 6;
  inline int read_tili_size() const;
  inline void clear_read_tili();
  static const int kReadTiliFieldNumber = 6;
  inline const ::std::string& read_tili(int index) const;
  inline ::std::string* mutable_read_tili(int index);
  inline void set_read_tili(int index, const ::std::string& value);
  inline void set_read_tili(int index, const char* value);
  inline void set_read_tili(int index, const char* value, size_t size);
  inline ::std::string* add_read_tili();
  inline void add_read_tili(const ::std::string& value);
  inline void add_read_tili(const char* value);
  inline void add_read_tili(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& read_tili() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_read_tili();

  // optional int32 add_tili_count = 7;
  inline bool has_add_tili_count() const;
  inline void clear_add_tili_count();
  static const int kAddTiliCountFieldNumber = 7;
  inline ::google::protobuf::int32 add_tili_count() const;
  inline void set_add_tili_count(::google::protobuf::int32 value);

  // optional int32 read_tili_count = 8;
  inline bool has_read_tili_count() const;
  inline void clear_read_tili_count();
  static const int kReadTiliCountFieldNumber = 8;
  inline ::google::protobuf::int32 read_tili_count() const;
  inline void set_read_tili_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FriendsData)
 private:
  inline void set_has_add_tili_count();
  inline void clear_has_add_tili_count();
  inline void set_has_read_tili_count();
  inline void clear_has_read_tili_count();

  ::google::protobuf::RepeatedPtrField< ::std::string> friends_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> black_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> talk_list_;
  ::google::protobuf::RepeatedPtrField< ::FriendFamiliarity > friends_familiarity_;
  ::google::protobuf::RepeatedPtrField< ::std::string> add_tili_;
  ::google::protobuf::RepeatedPtrField< ::std::string> read_tili_;
  ::google::protobuf::int32 add_tili_count_;
  ::google::protobuf::int32 read_tili_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_UserInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_UserInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_UserInfo_2eproto();
  friend void protobuf_ShutdownFile_UserInfo_2eproto();

  void InitAsDefaultInstance();
  static FriendsData* default_instance_;
};
// ===================================================================


// ===================================================================

// TimeStamp

// required int64 last_0am_day = 1;
inline bool TimeStamp::has_last_0am_day() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeStamp::set_has_last_0am_day() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeStamp::clear_has_last_0am_day() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeStamp::clear_last_0am_day() {
  last_0am_day_ = GOOGLE_LONGLONG(0);
  clear_has_last_0am_day();
}
inline ::google::protobuf::int64 TimeStamp::last_0am_day() const {
  return last_0am_day_;
}
inline void TimeStamp::set_last_0am_day(::google::protobuf::int64 value) {
  set_has_last_0am_day();
  last_0am_day_ = value;
}

// required int64 regist_time = 2;
inline bool TimeStamp::has_regist_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeStamp::set_has_regist_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeStamp::clear_has_regist_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeStamp::clear_regist_time() {
  regist_time_ = GOOGLE_LONGLONG(0);
  clear_has_regist_time();
}
inline ::google::protobuf::int64 TimeStamp::regist_time() const {
  return regist_time_;
}
inline void TimeStamp::set_regist_time(::google::protobuf::int64 value) {
  set_has_regist_time();
  regist_time_ = value;
}

// required int64 strength_timer = 3;
inline bool TimeStamp::has_strength_timer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeStamp::set_has_strength_timer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeStamp::clear_has_strength_timer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeStamp::clear_strength_timer() {
  strength_timer_ = GOOGLE_LONGLONG(0);
  clear_has_strength_timer();
}
inline ::google::protobuf::int64 TimeStamp::strength_timer() const {
  return strength_timer_;
}
inline void TimeStamp::set_strength_timer(::google::protobuf::int64 value) {
  set_has_strength_timer();
  strength_timer_ = value;
}

// optional int32 gmail = 4;
inline bool TimeStamp::has_gmail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeStamp::set_has_gmail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeStamp::clear_has_gmail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeStamp::clear_gmail() {
  gmail_ = 0;
  clear_has_gmail();
}
inline ::google::protobuf::int32 TimeStamp::gmail() const {
  return gmail_;
}
inline void TimeStamp::set_gmail(::google::protobuf::int32 value) {
  set_has_gmail();
  gmail_ = value;
}

// optional int64 today_online_time = 5;
inline bool TimeStamp::has_today_online_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimeStamp::set_has_today_online_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimeStamp::clear_has_today_online_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimeStamp::clear_today_online_time() {
  today_online_time_ = GOOGLE_LONGLONG(0);
  clear_has_today_online_time();
}
inline ::google::protobuf::int64 TimeStamp::today_online_time() const {
  return today_online_time_;
}
inline void TimeStamp::set_today_online_time(::google::protobuf::int64 value) {
  set_has_today_online_time();
  today_online_time_ = value;
}

// optional int64 regist_aid_award_time = 6;
inline bool TimeStamp::has_regist_aid_award_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TimeStamp::set_has_regist_aid_award_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TimeStamp::clear_has_regist_aid_award_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TimeStamp::clear_regist_aid_award_time() {
  regist_aid_award_time_ = GOOGLE_LONGLONG(0);
  clear_has_regist_aid_award_time();
}
inline ::google::protobuf::int64 TimeStamp::regist_aid_award_time() const {
  return regist_aid_award_time_;
}
inline void TimeStamp::set_regist_aid_award_time(::google::protobuf::int64 value) {
  set_has_regist_aid_award_time();
  regist_aid_award_time_ = value;
}

// optional int64 card_end_time = 7;
inline bool TimeStamp::has_card_end_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TimeStamp::set_has_card_end_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TimeStamp::clear_has_card_end_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TimeStamp::clear_card_end_time() {
  card_end_time_ = GOOGLE_LONGLONG(0);
  clear_has_card_end_time();
}
inline ::google::protobuf::int64 TimeStamp::card_end_time() const {
  return card_end_time_;
}
inline void TimeStamp::set_card_end_time(::google::protobuf::int64 value) {
  set_has_card_end_time();
  card_end_time_ = value;
}

// -------------------------------------------------------------------

// Lineup

// repeated int32 ship_guid_list = 1;
inline int Lineup::ship_guid_list_size() const {
  return ship_guid_list_.size();
}
inline void Lineup::clear_ship_guid_list() {
  ship_guid_list_.Clear();
}
inline ::google::protobuf::int32 Lineup::ship_guid_list(int index) const {
  return ship_guid_list_.Get(index);
}
inline void Lineup::set_ship_guid_list(int index, ::google::protobuf::int32 value) {
  ship_guid_list_.Set(index, value);
}
inline void Lineup::add_ship_guid_list(::google::protobuf::int32 value) {
  ship_guid_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Lineup::ship_guid_list() const {
  return ship_guid_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Lineup::mutable_ship_guid_list() {
  return &ship_guid_list_;
}

// optional string line_name = 2;
inline bool Lineup::has_line_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Lineup::set_has_line_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Lineup::clear_has_line_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Lineup::clear_line_name() {
  if (line_name_ != &::google::protobuf::internal::kEmptyString) {
    line_name_->clear();
  }
  clear_has_line_name();
}
inline const ::std::string& Lineup::line_name() const {
  return *line_name_;
}
inline void Lineup::set_line_name(const ::std::string& value) {
  set_has_line_name();
  if (line_name_ == &::google::protobuf::internal::kEmptyString) {
    line_name_ = new ::std::string;
  }
  line_name_->assign(value);
}
inline void Lineup::set_line_name(const char* value) {
  set_has_line_name();
  if (line_name_ == &::google::protobuf::internal::kEmptyString) {
    line_name_ = new ::std::string;
  }
  line_name_->assign(value);
}
inline void Lineup::set_line_name(const char* value, size_t size) {
  set_has_line_name();
  if (line_name_ == &::google::protobuf::internal::kEmptyString) {
    line_name_ = new ::std::string;
  }
  line_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Lineup::mutable_line_name() {
  set_has_line_name();
  if (line_name_ == &::google::protobuf::internal::kEmptyString) {
    line_name_ = new ::std::string;
  }
  return line_name_;
}
inline ::std::string* Lineup::release_line_name() {
  clear_has_line_name();
  if (line_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = line_name_;
    line_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Lineup::set_allocated_line_name(::std::string* line_name) {
  if (line_name_ != &::google::protobuf::internal::kEmptyString) {
    delete line_name_;
  }
  if (line_name) {
    set_has_line_name();
    line_name_ = line_name;
  } else {
    clear_has_line_name();
    line_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserInfo_BlockInfo

// required int32 type = 1;
inline bool UserInfo_BlockInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo_BlockInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo_BlockInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo_BlockInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 UserInfo_BlockInfo::type() const {
  return type_;
}
inline void UserInfo_BlockInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int64 stamp = 2;
inline bool UserInfo_BlockInfo::has_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo_BlockInfo::set_has_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo_BlockInfo::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo_BlockInfo::clear_stamp() {
  stamp_ = GOOGLE_LONGLONG(0);
  clear_has_stamp();
}
inline ::google::protobuf::int64 UserInfo_BlockInfo::stamp() const {
  return stamp_;
}
inline void UserInfo_BlockInfo::set_stamp(::google::protobuf::int64 value) {
  set_has_stamp();
  stamp_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// optional string user_name = 1;
inline bool UserInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& UserInfo::user_name() const {
  return *user_name_;
}
inline void UserInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void UserInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void UserInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* UserInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickname = 2;
inline bool UserInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& UserInfo::nickname() const {
  return *nickname_;
}
inline void UserInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void UserInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void UserInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* UserInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 3;
inline bool UserInfo::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& UserInfo::account() const {
  return *account_;
}
inline void UserInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void UserInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void UserInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* UserInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 icon_id = 4;
inline bool UserInfo::has_icon_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_icon_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_icon_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_icon_id() {
  icon_id_ = 0;
  clear_has_icon_id();
}
inline ::google::protobuf::int32 UserInfo::icon_id() const {
  return icon_id_;
}
inline void UserInfo::set_icon_id(::google::protobuf::int32 value) {
  set_has_icon_id();
  icon_id_ = value;
}

// repeated int32 lineup = 5;
inline int UserInfo::lineup_size() const {
  return lineup_.size();
}
inline void UserInfo::clear_lineup() {
  lineup_.Clear();
}
inline ::google::protobuf::int32 UserInfo::lineup(int index) const {
  return lineup_.Get(index);
}
inline void UserInfo::set_lineup(int index, ::google::protobuf::int32 value) {
  lineup_.Set(index, value);
}
inline void UserInfo::add_lineup(::google::protobuf::int32 value) {
  lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UserInfo::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UserInfo::mutable_lineup() {
  return &lineup_;
}

// optional int32 init_ship_index = 6;
inline bool UserInfo::has_init_ship_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_init_ship_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_init_ship_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_init_ship_index() {
  init_ship_index_ = 0;
  clear_has_init_ship_index();
}
inline ::google::protobuf::int32 UserInfo::init_ship_index() const {
  return init_ship_index_;
}
inline void UserInfo::set_init_ship_index(::google::protobuf::int32 value) {
  set_has_init_ship_index();
  init_ship_index_ = value;
}

// optional int32 aid_award_index = 7;
inline bool UserInfo::has_aid_award_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_aid_award_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_aid_award_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_aid_award_index() {
  aid_award_index_ = 0;
  clear_has_aid_award_index();
}
inline ::google::protobuf::int32 UserInfo::aid_award_index() const {
  return aid_award_index_;
}
inline void UserInfo::set_aid_award_index(::google::protobuf::int32 value) {
  set_has_aid_award_index();
  aid_award_index_ = value;
}

// optional int32 strength = 8;
inline bool UserInfo::has_strength() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_strength() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_strength() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_strength() {
  strength_ = 0;
  clear_has_strength();
}
inline ::google::protobuf::int32 UserInfo::strength() const {
  return strength_;
}
inline void UserInfo::set_strength(::google::protobuf::int32 value) {
  set_has_strength();
  strength_ = value;
}

// optional int32 strength_buy_times = 9;
inline bool UserInfo::has_strength_buy_times() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_strength_buy_times() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_strength_buy_times() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_strength_buy_times() {
  strength_buy_times_ = 0;
  clear_has_strength_buy_times();
}
inline ::google::protobuf::int32 UserInfo::strength_buy_times() const {
  return strength_buy_times_;
}
inline void UserInfo::set_strength_buy_times(::google::protobuf::int32 value) {
  set_has_strength_buy_times();
  strength_buy_times_ = value;
}

// repeated int64 res = 10;
inline int UserInfo::res_size() const {
  return res_.size();
}
inline void UserInfo::clear_res() {
  res_.Clear();
}
inline ::google::protobuf::int64 UserInfo::res(int index) const {
  return res_.Get(index);
}
inline void UserInfo::set_res(int index, ::google::protobuf::int64 value) {
  res_.Set(index, value);
}
inline void UserInfo::add_res(::google::protobuf::int64 value) {
  res_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
UserInfo::res() const {
  return res_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
UserInfo::mutable_res() {
  return &res_;
}

// optional int32 money = 11;
inline bool UserInfo::has_money() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfo::set_has_money() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfo::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 UserInfo::money() const {
  return money_;
}
inline void UserInfo::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 vip_level = 12;
inline bool UserInfo::has_vip_level() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfo::set_has_vip_level() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfo::clear_has_vip_level() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfo::clear_vip_level() {
  vip_level_ = 0;
  clear_has_vip_level();
}
inline ::google::protobuf::int32 UserInfo::vip_level() const {
  return vip_level_;
}
inline void UserInfo::set_vip_level(::google::protobuf::int32 value) {
  set_has_vip_level();
  vip_level_ = value;
}

// optional int32 exp = 13;
inline bool UserInfo::has_exp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserInfo::set_has_exp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserInfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 UserInfo::exp() const {
  return exp_;
}
inline void UserInfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 level = 14;
inline bool UserInfo::has_level() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserInfo::set_has_level() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 UserInfo::level() const {
  return level_;
}
inline void UserInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional string ip = 15;
inline bool UserInfo::has_ip() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserInfo::set_has_ip() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& UserInfo::ip() const {
  return *ip_;
}
inline void UserInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UserInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UserInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* UserInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mcc = 16;
inline bool UserInfo::has_mcc() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserInfo::set_has_mcc() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserInfo::clear_has_mcc() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserInfo::clear_mcc() {
  if (mcc_ != &::google::protobuf::internal::kEmptyString) {
    mcc_->clear();
  }
  clear_has_mcc();
}
inline const ::std::string& UserInfo::mcc() const {
  return *mcc_;
}
inline void UserInfo::set_mcc(const ::std::string& value) {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  mcc_->assign(value);
}
inline void UserInfo::set_mcc(const char* value) {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  mcc_->assign(value);
}
inline void UserInfo::set_mcc(const char* value, size_t size) {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  mcc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_mcc() {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  return mcc_;
}
inline ::std::string* UserInfo::release_mcc() {
  clear_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mcc_;
    mcc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_mcc(::std::string* mcc) {
  if (mcc_ != &::google::protobuf::internal::kEmptyString) {
    delete mcc_;
  }
  if (mcc) {
    set_has_mcc();
    mcc_ = mcc;
  } else {
    clear_has_mcc();
    mcc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string client_version = 17;
inline bool UserInfo::has_client_version() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserInfo::set_has_client_version() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserInfo::clear_has_client_version() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserInfo::clear_client_version() {
  if (client_version_ != &::google::protobuf::internal::kEmptyString) {
    client_version_->clear();
  }
  clear_has_client_version();
}
inline const ::std::string& UserInfo::client_version() const {
  return *client_version_;
}
inline void UserInfo::set_client_version(const ::std::string& value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
}
inline void UserInfo::set_client_version(const char* value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
}
inline void UserInfo::set_client_version(const char* value, size_t size) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_client_version() {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  return client_version_;
}
inline ::std::string* UserInfo::release_client_version() {
  clear_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_version_;
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_client_version(::std::string* client_version) {
  if (client_version_ != &::google::protobuf::internal::kEmptyString) {
    delete client_version_;
  }
  if (client_version) {
    set_has_client_version();
    client_version_ = client_version;
  } else {
    clear_has_client_version();
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Equip equip_list = 18;
inline int UserInfo::equip_list_size() const {
  return equip_list_.size();
}
inline void UserInfo::clear_equip_list() {
  equip_list_.Clear();
}
inline const ::Equip& UserInfo::equip_list(int index) const {
  return equip_list_.Get(index);
}
inline ::Equip* UserInfo::mutable_equip_list(int index) {
  return equip_list_.Mutable(index);
}
inline ::Equip* UserInfo::add_equip_list() {
  return equip_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Equip >&
UserInfo::equip_list() const {
  return equip_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Equip >*
UserInfo::mutable_equip_list() {
  return &equip_list_;
}

// repeated .Gem gem_list = 19;
inline int UserInfo::gem_list_size() const {
  return gem_list_.size();
}
inline void UserInfo::clear_gem_list() {
  gem_list_.Clear();
}
inline const ::Gem& UserInfo::gem_list(int index) const {
  return gem_list_.Get(index);
}
inline ::Gem* UserInfo::mutable_gem_list(int index) {
  return gem_list_.Mutable(index);
}
inline ::Gem* UserInfo::add_gem_list() {
  return gem_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Gem >&
UserInfo::gem_list() const {
  return gem_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Gem >*
UserInfo::mutable_gem_list() {
  return &gem_list_;
}

// repeated .Weapon weapon_list = 20;
inline int UserInfo::weapon_list_size() const {
  return weapon_list_.size();
}
inline void UserInfo::clear_weapon_list() {
  weapon_list_.Clear();
}
inline const ::Weapon& UserInfo::weapon_list(int index) const {
  return weapon_list_.Get(index);
}
inline ::Weapon* UserInfo::mutable_weapon_list(int index) {
  return weapon_list_.Mutable(index);
}
inline ::Weapon* UserInfo::add_weapon_list() {
  return weapon_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Weapon >&
UserInfo::weapon_list() const {
  return weapon_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Weapon >*
UserInfo::mutable_weapon_list() {
  return &weapon_list_;
}

// optional .GroupData group_data = 21;
inline bool UserInfo::has_group_data() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void UserInfo::set_has_group_data() {
  _has_bits_[0] |= 0x00100000u;
}
inline void UserInfo::clear_has_group_data() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void UserInfo::clear_group_data() {
  if (group_data_ != NULL) group_data_->::GroupData::Clear();
  clear_has_group_data();
}
inline const ::GroupData& UserInfo::group_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_data_ != NULL ? *group_data_ : *default_instance().group_data_;
#else
  return group_data_ != NULL ? *group_data_ : *default_instance_->group_data_;
#endif
}
inline ::GroupData* UserInfo::mutable_group_data() {
  set_has_group_data();
  if (group_data_ == NULL) group_data_ = new ::GroupData;
  return group_data_;
}
inline ::GroupData* UserInfo::release_group_data() {
  clear_has_group_data();
  ::GroupData* temp = group_data_;
  group_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_group_data(::GroupData* group_data) {
  delete group_data_;
  group_data_ = group_data;
  if (group_data) {
    set_has_group_data();
  } else {
    clear_has_group_data();
  }
}

// repeated .BuildQueue build_queue_list = 22;
inline int UserInfo::build_queue_list_size() const {
  return build_queue_list_.size();
}
inline void UserInfo::clear_build_queue_list() {
  build_queue_list_.Clear();
}
inline const ::BuildQueue& UserInfo::build_queue_list(int index) const {
  return build_queue_list_.Get(index);
}
inline ::BuildQueue* UserInfo::mutable_build_queue_list(int index) {
  return build_queue_list_.Mutable(index);
}
inline ::BuildQueue* UserInfo::add_build_queue_list() {
  return build_queue_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BuildQueue >&
UserInfo::build_queue_list() const {
  return build_queue_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::BuildQueue >*
UserInfo::mutable_build_queue_list() {
  return &build_queue_list_;
}

// repeated .BuildingInfo building_list = 23;
inline int UserInfo::building_list_size() const {
  return building_list_.size();
}
inline void UserInfo::clear_building_list() {
  building_list_.Clear();
}
inline const ::BuildingInfo& UserInfo::building_list(int index) const {
  return building_list_.Get(index);
}
inline ::BuildingInfo* UserInfo::mutable_building_list(int index) {
  return building_list_.Mutable(index);
}
inline ::BuildingInfo* UserInfo::add_building_list() {
  return building_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BuildingInfo >&
UserInfo::building_list() const {
  return building_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::BuildingInfo >*
UserInfo::mutable_building_list() {
  return &building_list_;
}

// optional .StageData stage_data = 24;
inline bool UserInfo::has_stage_data() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void UserInfo::set_has_stage_data() {
  _has_bits_[0] |= 0x00800000u;
}
inline void UserInfo::clear_has_stage_data() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void UserInfo::clear_stage_data() {
  if (stage_data_ != NULL) stage_data_->::StageData::Clear();
  clear_has_stage_data();
}
inline const ::StageData& UserInfo::stage_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stage_data_ != NULL ? *stage_data_ : *default_instance().stage_data_;
#else
  return stage_data_ != NULL ? *stage_data_ : *default_instance_->stage_data_;
#endif
}
inline ::StageData* UserInfo::mutable_stage_data() {
  set_has_stage_data();
  if (stage_data_ == NULL) stage_data_ = new ::StageData;
  return stage_data_;
}
inline ::StageData* UserInfo::release_stage_data() {
  clear_has_stage_data();
  ::StageData* temp = stage_data_;
  stage_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_stage_data(::StageData* stage_data) {
  delete stage_data_;
  stage_data_ = stage_data;
  if (stage_data) {
    set_has_stage_data();
  } else {
    clear_has_stage_data();
  }
}

// optional .HomeSystemInfo home_info = 25;
inline bool UserInfo::has_home_info() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void UserInfo::set_has_home_info() {
  _has_bits_[0] |= 0x01000000u;
}
inline void UserInfo::clear_has_home_info() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void UserInfo::clear_home_info() {
  if (home_info_ != NULL) home_info_->::HomeSystemInfo::Clear();
  clear_has_home_info();
}
inline const ::HomeSystemInfo& UserInfo::home_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return home_info_ != NULL ? *home_info_ : *default_instance().home_info_;
#else
  return home_info_ != NULL ? *home_info_ : *default_instance_->home_info_;
#endif
}
inline ::HomeSystemInfo* UserInfo::mutable_home_info() {
  set_has_home_info();
  if (home_info_ == NULL) home_info_ = new ::HomeSystemInfo;
  return home_info_;
}
inline ::HomeSystemInfo* UserInfo::release_home_info() {
  clear_has_home_info();
  ::HomeSystemInfo* temp = home_info_;
  home_info_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_home_info(::HomeSystemInfo* home_info) {
  delete home_info_;
  home_info_ = home_info;
  if (home_info) {
    set_has_home_info();
  } else {
    clear_has_home_info();
  }
}

// optional .TechnologyData tech_data = 26;
inline bool UserInfo::has_tech_data() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void UserInfo::set_has_tech_data() {
  _has_bits_[0] |= 0x02000000u;
}
inline void UserInfo::clear_has_tech_data() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void UserInfo::clear_tech_data() {
  if (tech_data_ != NULL) tech_data_->::TechnologyData::Clear();
  clear_has_tech_data();
}
inline const ::TechnologyData& UserInfo::tech_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tech_data_ != NULL ? *tech_data_ : *default_instance().tech_data_;
#else
  return tech_data_ != NULL ? *tech_data_ : *default_instance_->tech_data_;
#endif
}
inline ::TechnologyData* UserInfo::mutable_tech_data() {
  set_has_tech_data();
  if (tech_data_ == NULL) tech_data_ = new ::TechnologyData;
  return tech_data_;
}
inline ::TechnologyData* UserInfo::release_tech_data() {
  clear_has_tech_data();
  ::TechnologyData* temp = tech_data_;
  tech_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_tech_data(::TechnologyData* tech_data) {
  delete tech_data_;
  tech_data_ = tech_data;
  if (tech_data) {
    set_has_tech_data();
  } else {
    clear_has_tech_data();
  }
}

// optional .TrialData trial_data = 27;
inline bool UserInfo::has_trial_data() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void UserInfo::set_has_trial_data() {
  _has_bits_[0] |= 0x04000000u;
}
inline void UserInfo::clear_has_trial_data() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void UserInfo::clear_trial_data() {
  if (trial_data_ != NULL) trial_data_->::TrialData::Clear();
  clear_has_trial_data();
}
inline const ::TrialData& UserInfo::trial_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trial_data_ != NULL ? *trial_data_ : *default_instance().trial_data_;
#else
  return trial_data_ != NULL ? *trial_data_ : *default_instance_->trial_data_;
#endif
}
inline ::TrialData* UserInfo::mutable_trial_data() {
  set_has_trial_data();
  if (trial_data_ == NULL) trial_data_ = new ::TrialData;
  return trial_data_;
}
inline ::TrialData* UserInfo::release_trial_data() {
  clear_has_trial_data();
  ::TrialData* temp = trial_data_;
  trial_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_trial_data(::TrialData* trial_data) {
  delete trial_data_;
  trial_data_ = trial_data;
  if (trial_data) {
    set_has_trial_data();
  } else {
    clear_has_trial_data();
  }
}

// optional .ArenaData arena_data = 28;
inline bool UserInfo::has_arena_data() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void UserInfo::set_has_arena_data() {
  _has_bits_[0] |= 0x08000000u;
}
inline void UserInfo::clear_has_arena_data() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void UserInfo::clear_arena_data() {
  if (arena_data_ != NULL) arena_data_->::ArenaData::Clear();
  clear_has_arena_data();
}
inline const ::ArenaData& UserInfo::arena_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return arena_data_ != NULL ? *arena_data_ : *default_instance().arena_data_;
#else
  return arena_data_ != NULL ? *arena_data_ : *default_instance_->arena_data_;
#endif
}
inline ::ArenaData* UserInfo::mutable_arena_data() {
  set_has_arena_data();
  if (arena_data_ == NULL) arena_data_ = new ::ArenaData;
  return arena_data_;
}
inline ::ArenaData* UserInfo::release_arena_data() {
  clear_has_arena_data();
  ::ArenaData* temp = arena_data_;
  arena_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_arena_data(::ArenaData* arena_data) {
  delete arena_data_;
  arena_data_ = arena_data;
  if (arena_data) {
    set_has_arena_data();
  } else {
    clear_has_arena_data();
  }
}

// optional .FriendsData friends_data = 29;
inline bool UserInfo::has_friends_data() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void UserInfo::set_has_friends_data() {
  _has_bits_[0] |= 0x10000000u;
}
inline void UserInfo::clear_has_friends_data() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void UserInfo::clear_friends_data() {
  if (friends_data_ != NULL) friends_data_->::FriendsData::Clear();
  clear_has_friends_data();
}
inline const ::FriendsData& UserInfo::friends_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return friends_data_ != NULL ? *friends_data_ : *default_instance().friends_data_;
#else
  return friends_data_ != NULL ? *friends_data_ : *default_instance_->friends_data_;
#endif
}
inline ::FriendsData* UserInfo::mutable_friends_data() {
  set_has_friends_data();
  if (friends_data_ == NULL) friends_data_ = new ::FriendsData;
  return friends_data_;
}
inline ::FriendsData* UserInfo::release_friends_data() {
  clear_has_friends_data();
  ::FriendsData* temp = friends_data_;
  friends_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_friends_data(::FriendsData* friends_data) {
  delete friends_data_;
  friends_data_ = friends_data;
  if (friends_data) {
    set_has_friends_data();
  } else {
    clear_has_friends_data();
  }
}

// repeated .TaskInfo task_list = 30;
inline int UserInfo::task_list_size() const {
  return task_list_.size();
}
inline void UserInfo::clear_task_list() {
  task_list_.Clear();
}
inline const ::TaskInfo& UserInfo::task_list(int index) const {
  return task_list_.Get(index);
}
inline ::TaskInfo* UserInfo::mutable_task_list(int index) {
  return task_list_.Mutable(index);
}
inline ::TaskInfo* UserInfo::add_task_list() {
  return task_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TaskInfo >&
UserInfo::task_list() const {
  return task_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::TaskInfo >*
UserInfo::mutable_task_list() {
  return &task_list_;
}

// optional .DailyData daily_data = 31;
inline bool UserInfo::has_daily_data() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void UserInfo::set_has_daily_data() {
  _has_bits_[0] |= 0x40000000u;
}
inline void UserInfo::clear_has_daily_data() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void UserInfo::clear_daily_data() {
  if (daily_data_ != NULL) daily_data_->::DailyData::Clear();
  clear_has_daily_data();
}
inline const ::DailyData& UserInfo::daily_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return daily_data_ != NULL ? *daily_data_ : *default_instance().daily_data_;
#else
  return daily_data_ != NULL ? *daily_data_ : *default_instance_->daily_data_;
#endif
}
inline ::DailyData* UserInfo::mutable_daily_data() {
  set_has_daily_data();
  if (daily_data_ == NULL) daily_data_ = new ::DailyData;
  return daily_data_;
}
inline ::DailyData* UserInfo::release_daily_data() {
  clear_has_daily_data();
  ::DailyData* temp = daily_data_;
  daily_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_daily_data(::DailyData* daily_data) {
  delete daily_data_;
  daily_data_ = daily_data;
  if (daily_data) {
    set_has_daily_data();
  } else {
    clear_has_daily_data();
  }
}

// repeated .BlueprintDevelopInfo blueprint_list = 32;
inline int UserInfo::blueprint_list_size() const {
  return blueprint_list_.size();
}
inline void UserInfo::clear_blueprint_list() {
  blueprint_list_.Clear();
}
inline const ::BlueprintDevelopInfo& UserInfo::blueprint_list(int index) const {
  return blueprint_list_.Get(index);
}
inline ::BlueprintDevelopInfo* UserInfo::mutable_blueprint_list(int index) {
  return blueprint_list_.Mutable(index);
}
inline ::BlueprintDevelopInfo* UserInfo::add_blueprint_list() {
  return blueprint_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BlueprintDevelopInfo >&
UserInfo::blueprint_list() const {
  return blueprint_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::BlueprintDevelopInfo >*
UserInfo::mutable_blueprint_list() {
  return &blueprint_list_;
}

// optional .AchievementData achievement_data = 33;
inline bool UserInfo::has_achievement_data() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_achievement_data() {
  _has_bits_[1] |= 0x00000001u;
}
inline void UserInfo::clear_has_achievement_data() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void UserInfo::clear_achievement_data() {
  if (achievement_data_ != NULL) achievement_data_->::AchievementData::Clear();
  clear_has_achievement_data();
}
inline const ::AchievementData& UserInfo::achievement_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return achievement_data_ != NULL ? *achievement_data_ : *default_instance().achievement_data_;
#else
  return achievement_data_ != NULL ? *achievement_data_ : *default_instance_->achievement_data_;
#endif
}
inline ::AchievementData* UserInfo::mutable_achievement_data() {
  set_has_achievement_data();
  if (achievement_data_ == NULL) achievement_data_ = new ::AchievementData;
  return achievement_data_;
}
inline ::AchievementData* UserInfo::release_achievement_data() {
  clear_has_achievement_data();
  ::AchievementData* temp = achievement_data_;
  achievement_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_achievement_data(::AchievementData* achievement_data) {
  delete achievement_data_;
  achievement_data_ = achievement_data;
  if (achievement_data) {
    set_has_achievement_data();
  } else {
    clear_has_achievement_data();
  }
}

// optional .ShopData shop_data = 34;
inline bool UserInfo::has_shop_data() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_shop_data() {
  _has_bits_[1] |= 0x00000002u;
}
inline void UserInfo::clear_has_shop_data() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void UserInfo::clear_shop_data() {
  if (shop_data_ != NULL) shop_data_->::ShopData::Clear();
  clear_has_shop_data();
}
inline const ::ShopData& UserInfo::shop_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return shop_data_ != NULL ? *shop_data_ : *default_instance().shop_data_;
#else
  return shop_data_ != NULL ? *shop_data_ : *default_instance_->shop_data_;
#endif
}
inline ::ShopData* UserInfo::mutable_shop_data() {
  set_has_shop_data();
  if (shop_data_ == NULL) shop_data_ = new ::ShopData;
  return shop_data_;
}
inline ::ShopData* UserInfo::release_shop_data() {
  clear_has_shop_data();
  ::ShopData* temp = shop_data_;
  shop_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_shop_data(::ShopData* shop_data) {
  delete shop_data_;
  shop_data_ = shop_data;
  if (shop_data) {
    set_has_shop_data();
  } else {
    clear_has_shop_data();
  }
}

// optional .ShipLotteryData ship_lottery_data = 35;
inline bool UserInfo::has_ship_lottery_data() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_ship_lottery_data() {
  _has_bits_[1] |= 0x00000004u;
}
inline void UserInfo::clear_has_ship_lottery_data() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void UserInfo::clear_ship_lottery_data() {
  if (ship_lottery_data_ != NULL) ship_lottery_data_->::ShipLotteryData::Clear();
  clear_has_ship_lottery_data();
}
inline const ::ShipLotteryData& UserInfo::ship_lottery_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ship_lottery_data_ != NULL ? *ship_lottery_data_ : *default_instance().ship_lottery_data_;
#else
  return ship_lottery_data_ != NULL ? *ship_lottery_data_ : *default_instance_->ship_lottery_data_;
#endif
}
inline ::ShipLotteryData* UserInfo::mutable_ship_lottery_data() {
  set_has_ship_lottery_data();
  if (ship_lottery_data_ == NULL) ship_lottery_data_ = new ::ShipLotteryData;
  return ship_lottery_data_;
}
inline ::ShipLotteryData* UserInfo::release_ship_lottery_data() {
  clear_has_ship_lottery_data();
  ::ShipLotteryData* temp = ship_lottery_data_;
  ship_lottery_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_ship_lottery_data(::ShipLotteryData* ship_lottery_data) {
  delete ship_lottery_data_;
  ship_lottery_data_ = ship_lottery_data;
  if (ship_lottery_data) {
    set_has_ship_lottery_data();
  } else {
    clear_has_ship_lottery_data();
  }
}

// repeated .Activity activity_list = 37;
inline int UserInfo::activity_list_size() const {
  return activity_list_.size();
}
inline void UserInfo::clear_activity_list() {
  activity_list_.Clear();
}
inline const ::Activity& UserInfo::activity_list(int index) const {
  return activity_list_.Get(index);
}
inline ::Activity* UserInfo::mutable_activity_list(int index) {
  return activity_list_.Mutable(index);
}
inline ::Activity* UserInfo::add_activity_list() {
  return activity_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Activity >&
UserInfo::activity_list() const {
  return activity_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Activity >*
UserInfo::mutable_activity_list() {
  return &activity_list_;
}

// optional int32 state = 38;
inline bool UserInfo::has_state() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_state() {
  _has_bits_[1] |= 0x00000010u;
}
inline void UserInfo::clear_has_state() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void UserInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 UserInfo::state() const {
  return state_;
}
inline void UserInfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// repeated .Lineup preset_lineup_list = 39;
inline int UserInfo::preset_lineup_list_size() const {
  return preset_lineup_list_.size();
}
inline void UserInfo::clear_preset_lineup_list() {
  preset_lineup_list_.Clear();
}
inline const ::Lineup& UserInfo::preset_lineup_list(int index) const {
  return preset_lineup_list_.Get(index);
}
inline ::Lineup* UserInfo::mutable_preset_lineup_list(int index) {
  return preset_lineup_list_.Mutable(index);
}
inline ::Lineup* UserInfo::add_preset_lineup_list() {
  return preset_lineup_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lineup >&
UserInfo::preset_lineup_list() const {
  return preset_lineup_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lineup >*
UserInfo::mutable_preset_lineup_list() {
  return &preset_lineup_list_;
}

// optional .TradeData trade_data = 40;
inline bool UserInfo::has_trade_data() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_trade_data() {
  _has_bits_[1] |= 0x00000040u;
}
inline void UserInfo::clear_has_trade_data() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void UserInfo::clear_trade_data() {
  if (trade_data_ != NULL) trade_data_->::TradeData::Clear();
  clear_has_trade_data();
}
inline const ::TradeData& UserInfo::trade_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trade_data_ != NULL ? *trade_data_ : *default_instance().trade_data_;
#else
  return trade_data_ != NULL ? *trade_data_ : *default_instance_->trade_data_;
#endif
}
inline ::TradeData* UserInfo::mutable_trade_data() {
  set_has_trade_data();
  if (trade_data_ == NULL) trade_data_ = new ::TradeData;
  return trade_data_;
}
inline ::TradeData* UserInfo::release_trade_data() {
  clear_has_trade_data();
  ::TradeData* temp = trade_data_;
  trade_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_trade_data(::TradeData* trade_data) {
  delete trade_data_;
  trade_data_ = trade_data;
  if (trade_data) {
    set_has_trade_data();
  } else {
    clear_has_trade_data();
  }
}

// repeated .ForgeEquip forge_equip_list = 41;
inline int UserInfo::forge_equip_list_size() const {
  return forge_equip_list_.size();
}
inline void UserInfo::clear_forge_equip_list() {
  forge_equip_list_.Clear();
}
inline const ::ForgeEquip& UserInfo::forge_equip_list(int index) const {
  return forge_equip_list_.Get(index);
}
inline ::ForgeEquip* UserInfo::mutable_forge_equip_list(int index) {
  return forge_equip_list_.Mutable(index);
}
inline ::ForgeEquip* UserInfo::add_forge_equip_list() {
  return forge_equip_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ForgeEquip >&
UserInfo::forge_equip_list() const {
  return forge_equip_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ForgeEquip >*
UserInfo::mutable_forge_equip_list() {
  return &forge_equip_list_;
}

// optional .NewHandGiftBagData new_hand_gift_bag_data = 42;
inline bool UserInfo::has_new_hand_gift_bag_data() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_new_hand_gift_bag_data() {
  _has_bits_[1] |= 0x00000100u;
}
inline void UserInfo::clear_has_new_hand_gift_bag_data() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void UserInfo::clear_new_hand_gift_bag_data() {
  if (new_hand_gift_bag_data_ != NULL) new_hand_gift_bag_data_->::NewHandGiftBagData::Clear();
  clear_has_new_hand_gift_bag_data();
}
inline const ::NewHandGiftBagData& UserInfo::new_hand_gift_bag_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return new_hand_gift_bag_data_ != NULL ? *new_hand_gift_bag_data_ : *default_instance().new_hand_gift_bag_data_;
#else
  return new_hand_gift_bag_data_ != NULL ? *new_hand_gift_bag_data_ : *default_instance_->new_hand_gift_bag_data_;
#endif
}
inline ::NewHandGiftBagData* UserInfo::mutable_new_hand_gift_bag_data() {
  set_has_new_hand_gift_bag_data();
  if (new_hand_gift_bag_data_ == NULL) new_hand_gift_bag_data_ = new ::NewHandGiftBagData;
  return new_hand_gift_bag_data_;
}
inline ::NewHandGiftBagData* UserInfo::release_new_hand_gift_bag_data() {
  clear_has_new_hand_gift_bag_data();
  ::NewHandGiftBagData* temp = new_hand_gift_bag_data_;
  new_hand_gift_bag_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_new_hand_gift_bag_data(::NewHandGiftBagData* new_hand_gift_bag_data) {
  delete new_hand_gift_bag_data_;
  new_hand_gift_bag_data_ = new_hand_gift_bag_data;
  if (new_hand_gift_bag_data) {
    set_has_new_hand_gift_bag_data();
  } else {
    clear_has_new_hand_gift_bag_data();
  }
}

// repeated .GiftBag gift_bag_list = 43;
inline int UserInfo::gift_bag_list_size() const {
  return gift_bag_list_.size();
}
inline void UserInfo::clear_gift_bag_list() {
  gift_bag_list_.Clear();
}
inline const ::GiftBag& UserInfo::gift_bag_list(int index) const {
  return gift_bag_list_.Get(index);
}
inline ::GiftBag* UserInfo::mutable_gift_bag_list(int index) {
  return gift_bag_list_.Mutable(index);
}
inline ::GiftBag* UserInfo::add_gift_bag_list() {
  return gift_bag_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GiftBag >&
UserInfo::gift_bag_list() const {
  return gift_bag_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::GiftBag >*
UserInfo::mutable_gift_bag_list() {
  return &gift_bag_list_;
}

// repeated int32 vip_award_list = 44;
inline int UserInfo::vip_award_list_size() const {
  return vip_award_list_.size();
}
inline void UserInfo::clear_vip_award_list() {
  vip_award_list_.Clear();
}
inline ::google::protobuf::int32 UserInfo::vip_award_list(int index) const {
  return vip_award_list_.Get(index);
}
inline void UserInfo::set_vip_award_list(int index, ::google::protobuf::int32 value) {
  vip_award_list_.Set(index, value);
}
inline void UserInfo::add_vip_award_list(::google::protobuf::int32 value) {
  vip_award_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UserInfo::vip_award_list() const {
  return vip_award_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UserInfo::mutable_vip_award_list() {
  return &vip_award_list_;
}

// repeated int32 vip_pack_list = 45;
inline int UserInfo::vip_pack_list_size() const {
  return vip_pack_list_.size();
}
inline void UserInfo::clear_vip_pack_list() {
  vip_pack_list_.Clear();
}
inline ::google::protobuf::int32 UserInfo::vip_pack_list(int index) const {
  return vip_pack_list_.Get(index);
}
inline void UserInfo::set_vip_pack_list(int index, ::google::protobuf::int32 value) {
  vip_pack_list_.Set(index, value);
}
inline void UserInfo::add_vip_pack_list(::google::protobuf::int32 value) {
  vip_pack_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UserInfo::vip_pack_list() const {
  return vip_pack_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UserInfo::mutable_vip_pack_list() {
  return &vip_pack_list_;
}

// optional .NextGiftBagData next_gift_bag_data = 46;
inline bool UserInfo::has_next_gift_bag_data() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void UserInfo::set_has_next_gift_bag_data() {
  _has_bits_[1] |= 0x00001000u;
}
inline void UserInfo::clear_has_next_gift_bag_data() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void UserInfo::clear_next_gift_bag_data() {
  if (next_gift_bag_data_ != NULL) next_gift_bag_data_->::NextGiftBagData::Clear();
  clear_has_next_gift_bag_data();
}
inline const ::NextGiftBagData& UserInfo::next_gift_bag_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return next_gift_bag_data_ != NULL ? *next_gift_bag_data_ : *default_instance().next_gift_bag_data_;
#else
  return next_gift_bag_data_ != NULL ? *next_gift_bag_data_ : *default_instance_->next_gift_bag_data_;
#endif
}
inline ::NextGiftBagData* UserInfo::mutable_next_gift_bag_data() {
  set_has_next_gift_bag_data();
  if (next_gift_bag_data_ == NULL) next_gift_bag_data_ = new ::NextGiftBagData;
  return next_gift_bag_data_;
}
inline ::NextGiftBagData* UserInfo::release_next_gift_bag_data() {
  clear_has_next_gift_bag_data();
  ::NextGiftBagData* temp = next_gift_bag_data_;
  next_gift_bag_data_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_next_gift_bag_data(::NextGiftBagData* next_gift_bag_data) {
  delete next_gift_bag_data_;
  next_gift_bag_data_ = next_gift_bag_data;
  if (next_gift_bag_data) {
    set_has_next_gift_bag_data();
  } else {
    clear_has_next_gift_bag_data();
  }
}

// optional int64 ship_energy_end_time = 47;
inline bool UserInfo::has_ship_energy_end_time() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void UserInfo::set_has_ship_energy_end_time() {
  _has_bits_[1] |= 0x00002000u;
}
inline void UserInfo::clear_has_ship_energy_end_time() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void UserInfo::clear_ship_energy_end_time() {
  ship_energy_end_time_ = GOOGLE_LONGLONG(0);
  clear_has_ship_energy_end_time();
}
inline ::google::protobuf::int64 UserInfo::ship_energy_end_time() const {
  return ship_energy_end_time_;
}
inline void UserInfo::set_ship_energy_end_time(::google::protobuf::int64 value) {
  set_has_ship_energy_end_time();
  ship_energy_end_time_ = value;
}

// optional int32 ship_energy_time_lock = 48;
inline bool UserInfo::has_ship_energy_time_lock() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void UserInfo::set_has_ship_energy_time_lock() {
  _has_bits_[1] |= 0x00004000u;
}
inline void UserInfo::clear_has_ship_energy_time_lock() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void UserInfo::clear_ship_energy_time_lock() {
  ship_energy_time_lock_ = 0;
  clear_has_ship_energy_time_lock();
}
inline ::google::protobuf::int32 UserInfo::ship_energy_time_lock() const {
  return ship_energy_time_lock_;
}
inline void UserInfo::set_ship_energy_time_lock(::google::protobuf::int32 value) {
  set_has_ship_energy_time_lock();
  ship_energy_time_lock_ = value;
}

// optional int32 gm_level = 97;
inline bool UserInfo::has_gm_level() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void UserInfo::set_has_gm_level() {
  _has_bits_[1] |= 0x00008000u;
}
inline void UserInfo::clear_has_gm_level() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void UserInfo::clear_gm_level() {
  gm_level_ = 0;
  clear_has_gm_level();
}
inline ::google::protobuf::int32 UserInfo::gm_level() const {
  return gm_level_;
}
inline void UserInfo::set_gm_level(::google::protobuf::int32 value) {
  set_has_gm_level();
  gm_level_ = value;
}

// optional .UserInfo.BlockInfo blocked = 98;
inline bool UserInfo::has_blocked() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void UserInfo::set_has_blocked() {
  _has_bits_[1] |= 0x00010000u;
}
inline void UserInfo::clear_has_blocked() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void UserInfo::clear_blocked() {
  if (blocked_ != NULL) blocked_->::UserInfo_BlockInfo::Clear();
  clear_has_blocked();
}
inline const ::UserInfo_BlockInfo& UserInfo::blocked() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return blocked_ != NULL ? *blocked_ : *default_instance().blocked_;
#else
  return blocked_ != NULL ? *blocked_ : *default_instance_->blocked_;
#endif
}
inline ::UserInfo_BlockInfo* UserInfo::mutable_blocked() {
  set_has_blocked();
  if (blocked_ == NULL) blocked_ = new ::UserInfo_BlockInfo;
  return blocked_;
}
inline ::UserInfo_BlockInfo* UserInfo::release_blocked() {
  clear_has_blocked();
  ::UserInfo_BlockInfo* temp = blocked_;
  blocked_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_blocked(::UserInfo_BlockInfo* blocked) {
  delete blocked_;
  blocked_ = blocked;
  if (blocked) {
    set_has_blocked();
  } else {
    clear_has_blocked();
  }
}

// optional .TimeStamp timestamp = 99;
inline bool UserInfo::has_timestamp() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void UserInfo::set_has_timestamp() {
  _has_bits_[1] |= 0x00020000u;
}
inline void UserInfo::clear_has_timestamp() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void UserInfo::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::TimeStamp::Clear();
  clear_has_timestamp();
}
inline const ::TimeStamp& UserInfo::timestamp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return timestamp_ != NULL ? *timestamp_ : *default_instance().timestamp_;
#else
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
#endif
}
inline ::TimeStamp* UserInfo::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::TimeStamp;
  return timestamp_;
}
inline ::TimeStamp* UserInfo::release_timestamp() {
  clear_has_timestamp();
  ::TimeStamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_timestamp(::TimeStamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
}

// optional int32 data_version = 100;
inline bool UserInfo::has_data_version() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void UserInfo::set_has_data_version() {
  _has_bits_[1] |= 0x00040000u;
}
inline void UserInfo::clear_has_data_version() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void UserInfo::clear_data_version() {
  data_version_ = 0;
  clear_has_data_version();
}
inline ::google::protobuf::int32 UserInfo::data_version() const {
  return data_version_;
}
inline void UserInfo::set_data_version(::google::protobuf::int32 value) {
  set_has_data_version();
  data_version_ = value;
}

// -------------------------------------------------------------------

// NewHandGiftBag

// required int32 id = 1;
inline bool NewHandGiftBag::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewHandGiftBag::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewHandGiftBag::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewHandGiftBag::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NewHandGiftBag::id() const {
  return id_;
}
inline void NewHandGiftBag::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 gift_id = 2;
inline bool NewHandGiftBag::has_gift_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewHandGiftBag::set_has_gift_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewHandGiftBag::clear_has_gift_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewHandGiftBag::clear_gift_id() {
  gift_id_ = 0;
  clear_has_gift_id();
}
inline ::google::protobuf::int32 NewHandGiftBag::gift_id() const {
  return gift_id_;
}
inline void NewHandGiftBag::set_gift_id(::google::protobuf::int32 value) {
  set_has_gift_id();
  gift_id_ = value;
}

// required int64 start_time = 3;
inline bool NewHandGiftBag::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewHandGiftBag::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewHandGiftBag::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewHandGiftBag::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 NewHandGiftBag::start_time() const {
  return start_time_;
}
inline void NewHandGiftBag::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
}

// -------------------------------------------------------------------

// NewHandGiftBagData

// required int32 times = 1;
inline bool NewHandGiftBagData::has_times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewHandGiftBagData::set_has_times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewHandGiftBagData::clear_has_times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewHandGiftBagData::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 NewHandGiftBagData::times() const {
  return times_;
}
inline void NewHandGiftBagData::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// repeated .NewHandGiftBag new_hand_gift_bag_list = 2;
inline int NewHandGiftBagData::new_hand_gift_bag_list_size() const {
  return new_hand_gift_bag_list_.size();
}
inline void NewHandGiftBagData::clear_new_hand_gift_bag_list() {
  new_hand_gift_bag_list_.Clear();
}
inline const ::NewHandGiftBag& NewHandGiftBagData::new_hand_gift_bag_list(int index) const {
  return new_hand_gift_bag_list_.Get(index);
}
inline ::NewHandGiftBag* NewHandGiftBagData::mutable_new_hand_gift_bag_list(int index) {
  return new_hand_gift_bag_list_.Mutable(index);
}
inline ::NewHandGiftBag* NewHandGiftBagData::add_new_hand_gift_bag_list() {
  return new_hand_gift_bag_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NewHandGiftBag >&
NewHandGiftBagData::new_hand_gift_bag_list() const {
  return new_hand_gift_bag_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::NewHandGiftBag >*
NewHandGiftBagData::mutable_new_hand_gift_bag_list() {
  return &new_hand_gift_bag_list_;
}

// -------------------------------------------------------------------

// GiftBag

// required int32 id = 1;
inline bool GiftBag::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiftBag::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiftBag::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiftBag::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GiftBag::id() const {
  return id_;
}
inline void GiftBag::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 count = 2;
inline bool GiftBag::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GiftBag::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GiftBag::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GiftBag::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 GiftBag::count() const {
  return count_;
}
inline void GiftBag::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// required int64 start_time = 3;
inline bool GiftBag::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GiftBag::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GiftBag::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GiftBag::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 GiftBag::start_time() const {
  return start_time_;
}
inline void GiftBag::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
}

// -------------------------------------------------------------------

// NextGiftBagData

// repeated .NewHandGiftBag next_gift_bag = 1;
inline int NextGiftBagData::next_gift_bag_size() const {
  return next_gift_bag_.size();
}
inline void NextGiftBagData::clear_next_gift_bag() {
  next_gift_bag_.Clear();
}
inline const ::NewHandGiftBag& NextGiftBagData::next_gift_bag(int index) const {
  return next_gift_bag_.Get(index);
}
inline ::NewHandGiftBag* NextGiftBagData::mutable_next_gift_bag(int index) {
  return next_gift_bag_.Mutable(index);
}
inline ::NewHandGiftBag* NextGiftBagData::add_next_gift_bag() {
  return next_gift_bag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NewHandGiftBag >&
NextGiftBagData::next_gift_bag() const {
  return next_gift_bag_;
}
inline ::google::protobuf::RepeatedPtrField< ::NewHandGiftBag >*
NextGiftBagData::mutable_next_gift_bag() {
  return &next_gift_bag_;
}

// -------------------------------------------------------------------

// TradeData

// required int64 last_product_time = 1;
inline bool TradeData::has_last_product_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeData::set_has_last_product_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeData::clear_has_last_product_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeData::clear_last_product_time() {
  last_product_time_ = GOOGLE_LONGLONG(0);
  clear_has_last_product_time();
}
inline ::google::protobuf::int64 TradeData::last_product_time() const {
  return last_product_time_;
}
inline void TradeData::set_last_product_time(::google::protobuf::int64 value) {
  set_has_last_product_time();
  last_product_time_ = value;
}

// required int32 cur_num = 2;
inline bool TradeData::has_cur_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeData::set_has_cur_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeData::clear_has_cur_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeData::clear_cur_num() {
  cur_num_ = 0;
  clear_has_cur_num();
}
inline ::google::protobuf::int32 TradeData::cur_num() const {
  return cur_num_;
}
inline void TradeData::set_cur_num(::google::protobuf::int32 value) {
  set_has_cur_num();
  cur_num_ = value;
}

// -------------------------------------------------------------------

// BlueprintDevelopInfo

// required int32 blueprint_id = 1;
inline bool BlueprintDevelopInfo::has_blueprint_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlueprintDevelopInfo::set_has_blueprint_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlueprintDevelopInfo::clear_has_blueprint_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlueprintDevelopInfo::clear_blueprint_id() {
  blueprint_id_ = 0;
  clear_has_blueprint_id();
}
inline ::google::protobuf::int32 BlueprintDevelopInfo::blueprint_id() const {
  return blueprint_id_;
}
inline void BlueprintDevelopInfo::set_blueprint_id(::google::protobuf::int32 value) {
  set_has_blueprint_id();
  blueprint_id_ = value;
}

// required int64 start_time = 2;
inline bool BlueprintDevelopInfo::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlueprintDevelopInfo::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlueprintDevelopInfo::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlueprintDevelopInfo::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 BlueprintDevelopInfo::start_time() const {
  return start_time_;
}
inline void BlueprintDevelopInfo::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
}

// -------------------------------------------------------------------

// ShipLotteryInfo

// required int32 id = 1;
inline bool ShipLotteryInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipLotteryInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipLotteryInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipLotteryInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ShipLotteryInfo::id() const {
  return id_;
}
inline void ShipLotteryInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 free_times = 2;
inline bool ShipLotteryInfo::has_free_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipLotteryInfo::set_has_free_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipLotteryInfo::clear_has_free_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipLotteryInfo::clear_free_times() {
  free_times_ = 0;
  clear_has_free_times();
}
inline ::google::protobuf::int32 ShipLotteryInfo::free_times() const {
  return free_times_;
}
inline void ShipLotteryInfo::set_free_times(::google::protobuf::int32 value) {
  set_has_free_times();
  free_times_ = value;
}

// required int64 add_free_start_time = 3;
inline bool ShipLotteryInfo::has_add_free_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShipLotteryInfo::set_has_add_free_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShipLotteryInfo::clear_has_add_free_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShipLotteryInfo::clear_add_free_start_time() {
  add_free_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_add_free_start_time();
}
inline ::google::protobuf::int64 ShipLotteryInfo::add_free_start_time() const {
  return add_free_start_time_;
}
inline void ShipLotteryInfo::set_add_free_start_time(::google::protobuf::int64 value) {
  set_has_add_free_start_time();
  add_free_start_time_ = value;
}

// required int64 cd_start_time = 4;
inline bool ShipLotteryInfo::has_cd_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShipLotteryInfo::set_has_cd_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShipLotteryInfo::clear_has_cd_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShipLotteryInfo::clear_cd_start_time() {
  cd_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_cd_start_time();
}
inline ::google::protobuf::int64 ShipLotteryInfo::cd_start_time() const {
  return cd_start_time_;
}
inline void ShipLotteryInfo::set_cd_start_time(::google::protobuf::int64 value) {
  set_has_cd_start_time();
  cd_start_time_ = value;
}

// required int32 single_times = 5;
inline bool ShipLotteryInfo::has_single_times() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShipLotteryInfo::set_has_single_times() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShipLotteryInfo::clear_has_single_times() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShipLotteryInfo::clear_single_times() {
  single_times_ = 0;
  clear_has_single_times();
}
inline ::google::protobuf::int32 ShipLotteryInfo::single_times() const {
  return single_times_;
}
inline void ShipLotteryInfo::set_single_times(::google::protobuf::int32 value) {
  set_has_single_times();
  single_times_ = value;
}

// -------------------------------------------------------------------

// ShipLotteryData

// repeated .ShipLotteryInfo info_list = 1;
inline int ShipLotteryData::info_list_size() const {
  return info_list_.size();
}
inline void ShipLotteryData::clear_info_list() {
  info_list_.Clear();
}
inline const ::ShipLotteryInfo& ShipLotteryData::info_list(int index) const {
  return info_list_.Get(index);
}
inline ::ShipLotteryInfo* ShipLotteryData::mutable_info_list(int index) {
  return info_list_.Mutable(index);
}
inline ::ShipLotteryInfo* ShipLotteryData::add_info_list() {
  return info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShipLotteryInfo >&
ShipLotteryData::info_list() const {
  return info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ShipLotteryInfo >*
ShipLotteryData::mutable_info_list() {
  return &info_list_;
}

// -------------------------------------------------------------------

// ShopGoods

// required int32 id = 1;
inline bool ShopGoods::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShopGoods::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShopGoods::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShopGoods::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ShopGoods::id() const {
  return id_;
}
inline void ShopGoods::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 buy_times = 2;
inline bool ShopGoods::has_buy_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShopGoods::set_has_buy_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShopGoods::clear_has_buy_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShopGoods::clear_buy_times() {
  buy_times_ = 0;
  clear_has_buy_times();
}
inline ::google::protobuf::int32 ShopGoods::buy_times() const {
  return buy_times_;
}
inline void ShopGoods::set_buy_times(::google::protobuf::int32 value) {
  set_has_buy_times();
  buy_times_ = value;
}

// -------------------------------------------------------------------

// ShopData

// repeated .ShopGoods goods_list = 1;
inline int ShopData::goods_list_size() const {
  return goods_list_.size();
}
inline void ShopData::clear_goods_list() {
  goods_list_.Clear();
}
inline const ::ShopGoods& ShopData::goods_list(int index) const {
  return goods_list_.Get(index);
}
inline ::ShopGoods* ShopData::mutable_goods_list(int index) {
  return goods_list_.Mutable(index);
}
inline ::ShopGoods* ShopData::add_goods_list() {
  return goods_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShopGoods >&
ShopData::goods_list() const {
  return goods_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ShopGoods >*
ShopData::mutable_goods_list() {
  return &goods_list_;
}

// -------------------------------------------------------------------

// Point

// required int32 key = 1;
inline bool Point::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 Point::key() const {
  return key_;
}
inline void Point::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
}

// required int32 value = 2;
inline bool Point::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 Point::value() const {
  return value_;
}
inline void Point::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// DailyData

// optional int32 ship_levelup_count = 1;
inline bool DailyData::has_ship_levelup_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyData::set_has_ship_levelup_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyData::clear_has_ship_levelup_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyData::clear_ship_levelup_count() {
  ship_levelup_count_ = 0;
  clear_has_ship_levelup_count();
}
inline ::google::protobuf::int32 DailyData::ship_levelup_count() const {
  return ship_levelup_count_;
}
inline void DailyData::set_ship_levelup_count(::google::protobuf::int32 value) {
  set_has_ship_levelup_count();
  ship_levelup_count_ = value;
}

// optional int32 equip_strength_count = 2;
inline bool DailyData::has_equip_strength_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailyData::set_has_equip_strength_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailyData::clear_has_equip_strength_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailyData::clear_equip_strength_count() {
  equip_strength_count_ = 0;
  clear_has_equip_strength_count();
}
inline ::google::protobuf::int32 DailyData::equip_strength_count() const {
  return equip_strength_count_;
}
inline void DailyData::set_equip_strength_count(::google::protobuf::int32 value) {
  set_has_equip_strength_count();
  equip_strength_count_ = value;
}

// optional int32 ship_break_count = 3;
inline bool DailyData::has_ship_break_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailyData::set_has_ship_break_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailyData::clear_has_ship_break_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailyData::clear_ship_break_count() {
  ship_break_count_ = 0;
  clear_has_ship_break_count();
}
inline ::google::protobuf::int32 DailyData::ship_break_count() const {
  return ship_break_count_;
}
inline void DailyData::set_ship_break_count(::google::protobuf::int32 value) {
  set_has_ship_break_count();
  ship_break_count_ = value;
}

// optional int32 checkpoint_fight = 4;
inline bool DailyData::has_checkpoint_fight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DailyData::set_has_checkpoint_fight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DailyData::clear_has_checkpoint_fight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DailyData::clear_checkpoint_fight() {
  checkpoint_fight_ = 0;
  clear_has_checkpoint_fight();
}
inline ::google::protobuf::int32 DailyData::checkpoint_fight() const {
  return checkpoint_fight_;
}
inline void DailyData::set_checkpoint_fight(::google::protobuf::int32 value) {
  set_has_checkpoint_fight();
  checkpoint_fight_ = value;
}

// optional int32 checkpoint_win = 5;
inline bool DailyData::has_checkpoint_win() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DailyData::set_has_checkpoint_win() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DailyData::clear_has_checkpoint_win() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DailyData::clear_checkpoint_win() {
  checkpoint_win_ = 0;
  clear_has_checkpoint_win();
}
inline ::google::protobuf::int32 DailyData::checkpoint_win() const {
  return checkpoint_win_;
}
inline void DailyData::set_checkpoint_win(::google::protobuf::int32 value) {
  set_has_checkpoint_win();
  checkpoint_win_ = value;
}

// optional int32 contribute_times = 6;
inline bool DailyData::has_contribute_times() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DailyData::set_has_contribute_times() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DailyData::clear_has_contribute_times() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DailyData::clear_contribute_times() {
  contribute_times_ = 0;
  clear_has_contribute_times();
}
inline ::google::protobuf::int32 DailyData::contribute_times() const {
  return contribute_times_;
}
inline void DailyData::set_contribute_times(::google::protobuf::int32 value) {
  set_has_contribute_times();
  contribute_times_ = value;
}

// optional int32 get_home_res_times = 7;
inline bool DailyData::has_get_home_res_times() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DailyData::set_has_get_home_res_times() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DailyData::clear_has_get_home_res_times() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DailyData::clear_get_home_res_times() {
  get_home_res_times_ = 0;
  clear_has_get_home_res_times();
}
inline ::google::protobuf::int32 DailyData::get_home_res_times() const {
  return get_home_res_times_;
}
inline void DailyData::set_get_home_res_times(::google::protobuf::int32 value) {
  set_has_get_home_res_times();
  get_home_res_times_ = value;
}

// optional int32 trial_times = 8;
inline bool DailyData::has_trial_times() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DailyData::set_has_trial_times() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DailyData::clear_has_trial_times() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DailyData::clear_trial_times() {
  trial_times_ = 0;
  clear_has_trial_times();
}
inline ::google::protobuf::int32 DailyData::trial_times() const {
  return trial_times_;
}
inline void DailyData::set_trial_times(::google::protobuf::int32 value) {
  set_has_trial_times();
  trial_times_ = value;
}

// optional int32 group_boss_times = 9;
inline bool DailyData::has_group_boss_times() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DailyData::set_has_group_boss_times() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DailyData::clear_has_group_boss_times() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DailyData::clear_group_boss_times() {
  group_boss_times_ = 0;
  clear_has_group_boss_times();
}
inline ::google::protobuf::int32 DailyData::group_boss_times() const {
  return group_boss_times_;
}
inline void DailyData::set_group_boss_times(::google::protobuf::int32 value) {
  set_has_group_boss_times();
  group_boss_times_ = value;
}

// optional int32 raid_times = 10;
inline bool DailyData::has_raid_times() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DailyData::set_has_raid_times() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DailyData::clear_has_raid_times() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DailyData::clear_raid_times() {
  raid_times_ = 0;
  clear_has_raid_times();
}
inline ::google::protobuf::int32 DailyData::raid_times() const {
  return raid_times_;
}
inline void DailyData::set_raid_times(::google::protobuf::int32 value) {
  set_has_raid_times();
  raid_times_ = value;
}

// optional int32 explore_ruins_times = 11;
inline bool DailyData::has_explore_ruins_times() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DailyData::set_has_explore_ruins_times() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DailyData::clear_has_explore_ruins_times() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DailyData::clear_explore_ruins_times() {
  explore_ruins_times_ = 0;
  clear_has_explore_ruins_times();
}
inline ::google::protobuf::int32 DailyData::explore_ruins_times() const {
  return explore_ruins_times_;
}
inline void DailyData::set_explore_ruins_times(::google::protobuf::int32 value) {
  set_has_explore_ruins_times();
  explore_ruins_times_ = value;
}

// optional int32 fishing_ruins_tims = 12;
inline bool DailyData::has_fishing_ruins_tims() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DailyData::set_has_fishing_ruins_tims() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DailyData::clear_has_fishing_ruins_tims() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DailyData::clear_fishing_ruins_tims() {
  fishing_ruins_tims_ = 0;
  clear_has_fishing_ruins_tims();
}
inline ::google::protobuf::int32 DailyData::fishing_ruins_tims() const {
  return fishing_ruins_tims_;
}
inline void DailyData::set_fishing_ruins_tims(::google::protobuf::int32 value) {
  set_has_fishing_ruins_tims();
  fishing_ruins_tims_ = value;
}

// optional int32 get_planet_res_times = 13;
inline bool DailyData::has_get_planet_res_times() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DailyData::set_has_get_planet_res_times() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DailyData::clear_has_get_planet_res_times() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DailyData::clear_get_planet_res_times() {
  get_planet_res_times_ = 0;
  clear_has_get_planet_res_times();
}
inline ::google::protobuf::int32 DailyData::get_planet_res_times() const {
  return get_planet_res_times_;
}
inline void DailyData::set_get_planet_res_times(::google::protobuf::int32 value) {
  set_has_get_planet_res_times();
  get_planet_res_times_ = value;
}

// optional int32 attack_planet_res_times = 14;
inline bool DailyData::has_attack_planet_res_times() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DailyData::set_has_attack_planet_res_times() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DailyData::clear_has_attack_planet_res_times() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DailyData::clear_attack_planet_res_times() {
  attack_planet_res_times_ = 0;
  clear_has_attack_planet_res_times();
}
inline ::google::protobuf::int32 DailyData::attack_planet_res_times() const {
  return attack_planet_res_times_;
}
inline void DailyData::set_attack_planet_res_times(::google::protobuf::int32 value) {
  set_has_attack_planet_res_times();
  attack_planet_res_times_ = value;
}

// optional int32 active = 15;
inline bool DailyData::has_active() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DailyData::set_has_active() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DailyData::clear_has_active() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DailyData::clear_active() {
  active_ = 0;
  clear_has_active();
}
inline ::google::protobuf::int32 DailyData::active() const {
  return active_;
}
inline void DailyData::set_active(::google::protobuf::int32 value) {
  set_has_active();
  active_ = value;
}

// repeated bool get_active_level = 16;
inline int DailyData::get_active_level_size() const {
  return get_active_level_.size();
}
inline void DailyData::clear_get_active_level() {
  get_active_level_.Clear();
}
inline bool DailyData::get_active_level(int index) const {
  return get_active_level_.Get(index);
}
inline void DailyData::set_get_active_level(int index, bool value) {
  get_active_level_.Set(index, value);
}
inline void DailyData::add_get_active_level(bool value) {
  get_active_level_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
DailyData::get_active_level() const {
  return get_active_level_;
}
inline ::google::protobuf::RepeatedField< bool >*
DailyData::mutable_get_active_level() {
  return &get_active_level_;
}

// optional int32 help_times = 17;
inline bool DailyData::has_help_times() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DailyData::set_has_help_times() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DailyData::clear_has_help_times() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DailyData::clear_help_times() {
  help_times_ = 0;
  clear_has_help_times();
}
inline ::google::protobuf::int32 DailyData::help_times() const {
  return help_times_;
}
inline void DailyData::set_help_times(::google::protobuf::int32 value) {
  set_has_help_times();
  help_times_ = value;
}

// optional int32 lottery_count = 18;
inline bool DailyData::has_lottery_count() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DailyData::set_has_lottery_count() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DailyData::clear_has_lottery_count() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DailyData::clear_lottery_count() {
  lottery_count_ = 0;
  clear_has_lottery_count();
}
inline ::google::protobuf::int32 DailyData::lottery_count() const {
  return lottery_count_;
}
inline void DailyData::set_lottery_count(::google::protobuf::int32 value) {
  set_has_lottery_count();
  lottery_count_ = value;
}

// repeated .Point blueprint_count = 19;
inline int DailyData::blueprint_count_size() const {
  return blueprint_count_.size();
}
inline void DailyData::clear_blueprint_count() {
  blueprint_count_.Clear();
}
inline const ::Point& DailyData::blueprint_count(int index) const {
  return blueprint_count_.Get(index);
}
inline ::Point* DailyData::mutable_blueprint_count(int index) {
  return blueprint_count_.Mutable(index);
}
inline ::Point* DailyData::add_blueprint_count() {
  return blueprint_count_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Point >&
DailyData::blueprint_count() const {
  return blueprint_count_;
}
inline ::google::protobuf::RepeatedPtrField< ::Point >*
DailyData::mutable_blueprint_count() {
  return &blueprint_count_;
}

// -------------------------------------------------------------------

// AchievementData

// optional int32 contribute_times = 1;
inline bool AchievementData::has_contribute_times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AchievementData::set_has_contribute_times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AchievementData::clear_has_contribute_times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AchievementData::clear_contribute_times() {
  contribute_times_ = 0;
  clear_has_contribute_times();
}
inline ::google::protobuf::int32 AchievementData::contribute_times() const {
  return contribute_times_;
}
inline void AchievementData::set_contribute_times(::google::protobuf::int32 value) {
  set_has_contribute_times();
  contribute_times_ = value;
}

// optional int32 recharge_money = 2;
inline bool AchievementData::has_recharge_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AchievementData::set_has_recharge_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AchievementData::clear_has_recharge_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AchievementData::clear_recharge_money() {
  recharge_money_ = 0;
  clear_has_recharge_money();
}
inline ::google::protobuf::int32 AchievementData::recharge_money() const {
  return recharge_money_;
}
inline void AchievementData::set_recharge_money(::google::protobuf::int32 value) {
  set_has_recharge_money();
  recharge_money_ = value;
}

// optional int32 consume_money = 3;
inline bool AchievementData::has_consume_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AchievementData::set_has_consume_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AchievementData::clear_has_consume_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AchievementData::clear_consume_money() {
  consume_money_ = 0;
  clear_has_consume_money();
}
inline ::google::protobuf::int32 AchievementData::consume_money() const {
  return consume_money_;
}
inline void AchievementData::set_consume_money(::google::protobuf::int32 value) {
  set_has_consume_money();
  consume_money_ = value;
}

// optional int32 sign_in_days = 4;
inline bool AchievementData::has_sign_in_days() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AchievementData::set_has_sign_in_days() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AchievementData::clear_has_sign_in_days() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AchievementData::clear_sign_in_days() {
  sign_in_days_ = 0;
  clear_has_sign_in_days();
}
inline ::google::protobuf::int32 AchievementData::sign_in_days() const {
  return sign_in_days_;
}
inline void AchievementData::set_sign_in_days(::google::protobuf::int32 value) {
  set_has_sign_in_days();
  sign_in_days_ = value;
}

// optional int32 lottery_count = 5;
inline bool AchievementData::has_lottery_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AchievementData::set_has_lottery_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AchievementData::clear_has_lottery_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AchievementData::clear_lottery_count() {
  lottery_count_ = 0;
  clear_has_lottery_count();
}
inline ::google::protobuf::int32 AchievementData::lottery_count() const {
  return lottery_count_;
}
inline void AchievementData::set_lottery_count(::google::protobuf::int32 value) {
  set_has_lottery_count();
  lottery_count_ = value;
}

// repeated int32 recharge_list = 6;
inline int AchievementData::recharge_list_size() const {
  return recharge_list_.size();
}
inline void AchievementData::clear_recharge_list() {
  recharge_list_.Clear();
}
inline ::google::protobuf::int32 AchievementData::recharge_list(int index) const {
  return recharge_list_.Get(index);
}
inline void AchievementData::set_recharge_list(int index, ::google::protobuf::int32 value) {
  recharge_list_.Set(index, value);
}
inline void AchievementData::add_recharge_list(::google::protobuf::int32 value) {
  recharge_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AchievementData::recharge_list() const {
  return recharge_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AchievementData::mutable_recharge_list() {
  return &recharge_list_;
}

// optional int32 recharge_real_money = 7;
inline bool AchievementData::has_recharge_real_money() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AchievementData::set_has_recharge_real_money() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AchievementData::clear_has_recharge_real_money() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AchievementData::clear_recharge_real_money() {
  recharge_real_money_ = 0;
  clear_has_recharge_real_money();
}
inline ::google::protobuf::int32 AchievementData::recharge_real_money() const {
  return recharge_real_money_;
}
inline void AchievementData::set_recharge_real_money(::google::protobuf::int32 value) {
  set_has_recharge_real_money();
  recharge_real_money_ = value;
}

// optional string talk_key = 8;
inline bool AchievementData::has_talk_key() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AchievementData::set_has_talk_key() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AchievementData::clear_has_talk_key() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AchievementData::clear_talk_key() {
  if (talk_key_ != &::google::protobuf::internal::kEmptyString) {
    talk_key_->clear();
  }
  clear_has_talk_key();
}
inline const ::std::string& AchievementData::talk_key() const {
  return *talk_key_;
}
inline void AchievementData::set_talk_key(const ::std::string& value) {
  set_has_talk_key();
  if (talk_key_ == &::google::protobuf::internal::kEmptyString) {
    talk_key_ = new ::std::string;
  }
  talk_key_->assign(value);
}
inline void AchievementData::set_talk_key(const char* value) {
  set_has_talk_key();
  if (talk_key_ == &::google::protobuf::internal::kEmptyString) {
    talk_key_ = new ::std::string;
  }
  talk_key_->assign(value);
}
inline void AchievementData::set_talk_key(const char* value, size_t size) {
  set_has_talk_key();
  if (talk_key_ == &::google::protobuf::internal::kEmptyString) {
    talk_key_ = new ::std::string;
  }
  talk_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AchievementData::mutable_talk_key() {
  set_has_talk_key();
  if (talk_key_ == &::google::protobuf::internal::kEmptyString) {
    talk_key_ = new ::std::string;
  }
  return talk_key_;
}
inline ::std::string* AchievementData::release_talk_key() {
  clear_has_talk_key();
  if (talk_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = talk_key_;
    talk_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AchievementData::set_allocated_talk_key(::std::string* talk_key) {
  if (talk_key_ != &::google::protobuf::internal::kEmptyString) {
    delete talk_key_;
  }
  if (talk_key) {
    set_has_talk_key();
    talk_key_ = talk_key;
  } else {
    clear_has_talk_key();
    talk_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 guide_list = 9;
inline int AchievementData::guide_list_size() const {
  return guide_list_.size();
}
inline void AchievementData::clear_guide_list() {
  guide_list_.Clear();
}
inline ::google::protobuf::int32 AchievementData::guide_list(int index) const {
  return guide_list_.Get(index);
}
inline void AchievementData::set_guide_list(int index, ::google::protobuf::int32 value) {
  guide_list_.Set(index, value);
}
inline void AchievementData::add_guide_list(::google::protobuf::int32 value) {
  guide_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AchievementData::guide_list() const {
  return guide_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AchievementData::mutable_guide_list() {
  return &guide_list_;
}

// optional bool first_develop_blueprint = 10;
inline bool AchievementData::has_first_develop_blueprint() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AchievementData::set_has_first_develop_blueprint() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AchievementData::clear_has_first_develop_blueprint() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AchievementData::clear_first_develop_blueprint() {
  first_develop_blueprint_ = false;
  clear_has_first_develop_blueprint();
}
inline bool AchievementData::first_develop_blueprint() const {
  return first_develop_blueprint_;
}
inline void AchievementData::set_first_develop_blueprint(bool value) {
  set_has_first_develop_blueprint();
  first_develop_blueprint_ = value;
}

// optional bool first_finish_collect = 11;
inline bool AchievementData::has_first_finish_collect() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AchievementData::set_has_first_finish_collect() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AchievementData::clear_has_first_finish_collect() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AchievementData::clear_first_finish_collect() {
  first_finish_collect_ = false;
  clear_has_first_finish_collect();
}
inline bool AchievementData::first_finish_collect() const {
  return first_finish_collect_;
}
inline void AchievementData::set_first_finish_collect(bool value) {
  set_has_first_finish_collect();
  first_finish_collect_ = value;
}

// optional bool first_develop_ship = 12;
inline bool AchievementData::has_first_develop_ship() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AchievementData::set_has_first_develop_ship() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AchievementData::clear_has_first_develop_ship() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AchievementData::clear_first_develop_ship() {
  first_develop_ship_ = false;
  clear_has_first_develop_ship();
}
inline bool AchievementData::first_develop_ship() const {
  return first_develop_ship_;
}
inline void AchievementData::set_first_develop_ship(bool value) {
  set_has_first_develop_ship();
  first_develop_ship_ = value;
}

// optional bool first_failed_battle = 13;
inline bool AchievementData::has_first_failed_battle() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AchievementData::set_has_first_failed_battle() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AchievementData::clear_has_first_failed_battle() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AchievementData::clear_first_failed_battle() {
  first_failed_battle_ = false;
  clear_has_first_failed_battle();
}
inline bool AchievementData::first_failed_battle() const {
  return first_failed_battle_;
}
inline void AchievementData::set_first_failed_battle(bool value) {
  set_has_first_failed_battle();
  first_failed_battle_ = value;
}

// optional int32 task_finish_times = 14;
inline bool AchievementData::has_task_finish_times() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AchievementData::set_has_task_finish_times() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AchievementData::clear_has_task_finish_times() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AchievementData::clear_task_finish_times() {
  task_finish_times_ = 0;
  clear_has_task_finish_times();
}
inline ::google::protobuf::int32 AchievementData::task_finish_times() const {
  return task_finish_times_;
}
inline void AchievementData::set_task_finish_times(::google::protobuf::int32 value) {
  set_has_task_finish_times();
  task_finish_times_ = value;
}

// optional int32 slave_times = 15;
inline bool AchievementData::has_slave_times() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AchievementData::set_has_slave_times() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AchievementData::clear_has_slave_times() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AchievementData::clear_slave_times() {
  slave_times_ = 0;
  clear_has_slave_times();
}
inline ::google::protobuf::int32 AchievementData::slave_times() const {
  return slave_times_;
}
inline void AchievementData::set_slave_times(::google::protobuf::int32 value) {
  set_has_slave_times();
  slave_times_ = value;
}

// optional bool first_lottery_money = 16;
inline bool AchievementData::has_first_lottery_money() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AchievementData::set_has_first_lottery_money() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AchievementData::clear_has_first_lottery_money() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AchievementData::clear_first_lottery_money() {
  first_lottery_money_ = false;
  clear_has_first_lottery_money();
}
inline bool AchievementData::first_lottery_money() const {
  return first_lottery_money_;
}
inline void AchievementData::set_first_lottery_money(bool value) {
  set_has_first_lottery_money();
  first_lottery_money_ = value;
}

// optional bool first_lottery_res = 17;
inline bool AchievementData::has_first_lottery_res() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AchievementData::set_has_first_lottery_res() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AchievementData::clear_has_first_lottery_res() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AchievementData::clear_first_lottery_res() {
  first_lottery_res_ = false;
  clear_has_first_lottery_res();
}
inline bool AchievementData::first_lottery_res() const {
  return first_lottery_res_;
}
inline void AchievementData::set_first_lottery_res(bool value) {
  set_has_first_lottery_res();
  first_lottery_res_ = value;
}

// repeated .Point blueprint_count = 18;
inline int AchievementData::blueprint_count_size() const {
  return blueprint_count_.size();
}
inline void AchievementData::clear_blueprint_count() {
  blueprint_count_.Clear();
}
inline const ::Point& AchievementData::blueprint_count(int index) const {
  return blueprint_count_.Get(index);
}
inline ::Point* AchievementData::mutable_blueprint_count(int index) {
  return blueprint_count_.Mutable(index);
}
inline ::Point* AchievementData::add_blueprint_count() {
  return blueprint_count_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Point >&
AchievementData::blueprint_count() const {
  return blueprint_count_;
}
inline ::google::protobuf::RepeatedPtrField< ::Point >*
AchievementData::mutable_blueprint_count() {
  return &blueprint_count_;
}

// -------------------------------------------------------------------

// TaskInfo

// required int32 task_id = 1;
inline bool TaskInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskInfo::clear_task_id() {
  task_id_ = 0;
  clear_has_task_id();
}
inline ::google::protobuf::int32 TaskInfo::task_id() const {
  return task_id_;
}
inline void TaskInfo::set_task_id(::google::protobuf::int32 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional bool finished = 2;
inline bool TaskInfo::has_finished() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskInfo::set_has_finished() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskInfo::clear_has_finished() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskInfo::clear_finished() {
  finished_ = false;
  clear_has_finished();
}
inline bool TaskInfo::finished() const {
  return finished_;
}
inline void TaskInfo::set_finished(bool value) {
  set_has_finished();
  finished_ = value;
}

// -------------------------------------------------------------------

// BuildQueue

// required int64 duration_time = 1;
inline bool BuildQueue::has_duration_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildQueue::set_has_duration_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildQueue::clear_has_duration_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildQueue::clear_duration_time() {
  duration_time_ = GOOGLE_LONGLONG(0);
  clear_has_duration_time();
}
inline ::google::protobuf::int64 BuildQueue::duration_time() const {
  return duration_time_;
}
inline void BuildQueue::set_duration_time(::google::protobuf::int64 value) {
  set_has_duration_time();
  duration_time_ = value;
}

// required int64 open_time = 2;
inline bool BuildQueue::has_open_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildQueue::set_has_open_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildQueue::clear_has_open_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildQueue::clear_open_time() {
  open_time_ = GOOGLE_LONGLONG(0);
  clear_has_open_time();
}
inline ::google::protobuf::int64 BuildQueue::open_time() const {
  return open_time_;
}
inline void BuildQueue::set_open_time(::google::protobuf::int64 value) {
  set_has_open_time();
  open_time_ = value;
}

// required int32 type = 3;
inline bool BuildQueue::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildQueue::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildQueue::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildQueue::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BuildQueue::type() const {
  return type_;
}
inline void BuildQueue::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 index = 4;
inline bool BuildQueue::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuildQueue::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuildQueue::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuildQueue::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 BuildQueue::index() const {
  return index_;
}
inline void BuildQueue::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// TechContributeData

// required int32 tech_id = 1;
inline bool TechContributeData::has_tech_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TechContributeData::set_has_tech_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TechContributeData::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TechContributeData::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 TechContributeData::tech_id() const {
  return tech_id_;
}
inline void TechContributeData::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// repeated int32 item_index_list = 2;
inline int TechContributeData::item_index_list_size() const {
  return item_index_list_.size();
}
inline void TechContributeData::clear_item_index_list() {
  item_index_list_.Clear();
}
inline ::google::protobuf::int32 TechContributeData::item_index_list(int index) const {
  return item_index_list_.Get(index);
}
inline void TechContributeData::set_item_index_list(int index, ::google::protobuf::int32 value) {
  item_index_list_.Set(index, value);
}
inline void TechContributeData::add_item_index_list(::google::protobuf::int32 value) {
  item_index_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TechContributeData::item_index_list() const {
  return item_index_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TechContributeData::mutable_item_index_list() {
  return &item_index_list_;
}

// -------------------------------------------------------------------

// GroupPVECheckpoint

// required int32 group_boss_id = 1;
inline bool GroupPVECheckpoint::has_group_boss_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPVECheckpoint::set_has_group_boss_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPVECheckpoint::clear_has_group_boss_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPVECheckpoint::clear_group_boss_id() {
  group_boss_id_ = 0;
  clear_has_group_boss_id();
}
inline ::google::protobuf::int32 GroupPVECheckpoint::group_boss_id() const {
  return group_boss_id_;
}
inline void GroupPVECheckpoint::set_group_boss_id(::google::protobuf::int32 value) {
  set_has_group_boss_id();
  group_boss_id_ = value;
}

// repeated int32 hurter_hp_list = 2;
inline int GroupPVECheckpoint::hurter_hp_list_size() const {
  return hurter_hp_list_.size();
}
inline void GroupPVECheckpoint::clear_hurter_hp_list() {
  hurter_hp_list_.Clear();
}
inline ::google::protobuf::int32 GroupPVECheckpoint::hurter_hp_list(int index) const {
  return hurter_hp_list_.Get(index);
}
inline void GroupPVECheckpoint::set_hurter_hp_list(int index, ::google::protobuf::int32 value) {
  hurter_hp_list_.Set(index, value);
}
inline void GroupPVECheckpoint::add_hurter_hp_list(::google::protobuf::int32 value) {
  hurter_hp_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GroupPVECheckpoint::hurter_hp_list() const {
  return hurter_hp_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GroupPVECheckpoint::mutable_hurter_hp_list() {
  return &hurter_hp_list_;
}

// required int32 damage = 3;
inline bool GroupPVECheckpoint::has_damage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupPVECheckpoint::set_has_damage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupPVECheckpoint::clear_has_damage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupPVECheckpoint::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 GroupPVECheckpoint::damage() const {
  return damage_;
}
inline void GroupPVECheckpoint::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// required int32 challenge_times = 4;
inline bool GroupPVECheckpoint::has_challenge_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupPVECheckpoint::set_has_challenge_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupPVECheckpoint::clear_has_challenge_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupPVECheckpoint::clear_challenge_times() {
  challenge_times_ = 0;
  clear_has_challenge_times();
}
inline ::google::protobuf::int32 GroupPVECheckpoint::challenge_times() const {
  return challenge_times_;
}
inline void GroupPVECheckpoint::set_challenge_times(::google::protobuf::int32 value) {
  set_has_challenge_times();
  challenge_times_ = value;
}

// required int32 buy_challenge_times = 5;
inline bool GroupPVECheckpoint::has_buy_challenge_times() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupPVECheckpoint::set_has_buy_challenge_times() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupPVECheckpoint::clear_has_buy_challenge_times() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupPVECheckpoint::clear_buy_challenge_times() {
  buy_challenge_times_ = 0;
  clear_has_buy_challenge_times();
}
inline ::google::protobuf::int32 GroupPVECheckpoint::buy_challenge_times() const {
  return buy_challenge_times_;
}
inline void GroupPVECheckpoint::set_buy_challenge_times(::google::protobuf::int32 value) {
  set_has_buy_challenge_times();
  buy_challenge_times_ = value;
}

// repeated bool get_reward_list = 6;
inline int GroupPVECheckpoint::get_reward_list_size() const {
  return get_reward_list_.size();
}
inline void GroupPVECheckpoint::clear_get_reward_list() {
  get_reward_list_.Clear();
}
inline bool GroupPVECheckpoint::get_reward_list(int index) const {
  return get_reward_list_.Get(index);
}
inline void GroupPVECheckpoint::set_get_reward_list(int index, bool value) {
  get_reward_list_.Set(index, value);
}
inline void GroupPVECheckpoint::add_get_reward_list(bool value) {
  get_reward_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
GroupPVECheckpoint::get_reward_list() const {
  return get_reward_list_;
}
inline ::google::protobuf::RepeatedField< bool >*
GroupPVECheckpoint::mutable_get_reward_list() {
  return &get_reward_list_;
}

// -------------------------------------------------------------------

// GroupData

// required string groupid = 1;
inline bool GroupData::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupData::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupData::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupData::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& GroupData::groupid() const {
  return *groupid_;
}
inline void GroupData::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GroupData::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GroupData::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupData::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* GroupData::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupData::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 job = 2;
inline bool GroupData::has_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupData::set_has_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupData::clear_has_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupData::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 GroupData::job() const {
  return job_;
}
inline void GroupData::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// required int32 status = 3;
inline bool GroupData::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupData::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupData::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupData::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 GroupData::status() const {
  return status_;
}
inline void GroupData::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 icon_id = 4;
inline bool GroupData::has_icon_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupData::set_has_icon_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupData::clear_has_icon_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupData::clear_icon_id() {
  icon_id_ = 0;
  clear_has_icon_id();
}
inline ::google::protobuf::int32 GroupData::icon_id() const {
  return icon_id_;
}
inline void GroupData::set_icon_id(::google::protobuf::int32 value) {
  set_has_icon_id();
  icon_id_ = value;
}

// optional int64 anti_time = 5;
inline bool GroupData::has_anti_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupData::set_has_anti_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupData::clear_has_anti_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupData::clear_anti_time() {
  anti_time_ = GOOGLE_LONGLONG(0);
  clear_has_anti_time();
}
inline ::google::protobuf::int64 GroupData::anti_time() const {
  return anti_time_;
}
inline void GroupData::set_anti_time(::google::protobuf::int64 value) {
  set_has_anti_time();
  anti_time_ = value;
}

// optional int32 today_join_num = 6;
inline bool GroupData::has_today_join_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupData::set_has_today_join_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupData::clear_has_today_join_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupData::clear_today_join_num() {
  today_join_num_ = 0;
  clear_has_today_join_num();
}
inline ::google::protobuf::int32 GroupData::today_join_num() const {
  return today_join_num_;
}
inline void GroupData::set_today_join_num(::google::protobuf::int32 value) {
  set_has_today_join_num();
  today_join_num_ = value;
}

// optional int32 contribute = 7;
inline bool GroupData::has_contribute() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupData::set_has_contribute() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupData::clear_has_contribute() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupData::clear_contribute() {
  contribute_ = 0;
  clear_has_contribute();
}
inline ::google::protobuf::int32 GroupData::contribute() const {
  return contribute_;
}
inline void GroupData::set_contribute(::google::protobuf::int32 value) {
  set_has_contribute();
  contribute_ = value;
}

// repeated .TechContributeData tech_contribute_list = 8;
inline int GroupData::tech_contribute_list_size() const {
  return tech_contribute_list_.size();
}
inline void GroupData::clear_tech_contribute_list() {
  tech_contribute_list_.Clear();
}
inline const ::TechContributeData& GroupData::tech_contribute_list(int index) const {
  return tech_contribute_list_.Get(index);
}
inline ::TechContributeData* GroupData::mutable_tech_contribute_list(int index) {
  return tech_contribute_list_.Mutable(index);
}
inline ::TechContributeData* GroupData::add_tech_contribute_list() {
  return tech_contribute_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TechContributeData >&
GroupData::tech_contribute_list() const {
  return tech_contribute_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::TechContributeData >*
GroupData::mutable_tech_contribute_list() {
  return &tech_contribute_list_;
}

// optional int64 contribute_end_cd = 9;
inline bool GroupData::has_contribute_end_cd() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupData::set_has_contribute_end_cd() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupData::clear_has_contribute_end_cd() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupData::clear_contribute_end_cd() {
  contribute_end_cd_ = GOOGLE_LONGLONG(0);
  clear_has_contribute_end_cd();
}
inline ::google::protobuf::int64 GroupData::contribute_end_cd() const {
  return contribute_end_cd_;
}
inline void GroupData::set_contribute_end_cd(::google::protobuf::int64 value) {
  set_has_contribute_end_cd();
  contribute_end_cd_ = value;
}

// optional bool contribute_locker = 10;
inline bool GroupData::has_contribute_locker() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupData::set_has_contribute_locker() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupData::clear_has_contribute_locker() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupData::clear_contribute_locker() {
  contribute_locker_ = false;
  clear_has_contribute_locker();
}
inline bool GroupData::contribute_locker() const {
  return contribute_locker_;
}
inline void GroupData::set_contribute_locker(bool value) {
  set_has_contribute_locker();
  contribute_locker_ = value;
}

// repeated .GroupPVECheckpoint pve_checkpoint_list = 11;
inline int GroupData::pve_checkpoint_list_size() const {
  return pve_checkpoint_list_.size();
}
inline void GroupData::clear_pve_checkpoint_list() {
  pve_checkpoint_list_.Clear();
}
inline const ::GroupPVECheckpoint& GroupData::pve_checkpoint_list(int index) const {
  return pve_checkpoint_list_.Get(index);
}
inline ::GroupPVECheckpoint* GroupData::mutable_pve_checkpoint_list(int index) {
  return pve_checkpoint_list_.Mutable(index);
}
inline ::GroupPVECheckpoint* GroupData::add_pve_checkpoint_list() {
  return pve_checkpoint_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GroupPVECheckpoint >&
GroupData::pve_checkpoint_list() const {
  return pve_checkpoint_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::GroupPVECheckpoint >*
GroupData::mutable_pve_checkpoint_list() {
  return &pve_checkpoint_list_;
}

// optional int32 help_times = 12;
inline bool GroupData::has_help_times() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GroupData::set_has_help_times() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GroupData::clear_has_help_times() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GroupData::clear_help_times() {
  help_times_ = 0;
  clear_has_help_times();
}
inline ::google::protobuf::int32 GroupData::help_times() const {
  return help_times_;
}
inline void GroupData::set_help_times(::google::protobuf::int32 value) {
  set_has_help_times();
  help_times_ = value;
}

// optional int32 today_worship_level = 13;
inline bool GroupData::has_today_worship_level() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GroupData::set_has_today_worship_level() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GroupData::clear_has_today_worship_level() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GroupData::clear_today_worship_level() {
  today_worship_level_ = 0;
  clear_has_today_worship_level();
}
inline ::google::protobuf::int32 GroupData::today_worship_level() const {
  return today_worship_level_;
}
inline void GroupData::set_today_worship_level(::google::protobuf::int32 value) {
  set_has_today_worship_level();
  today_worship_level_ = value;
}

// repeated bool getted_worship_reward = 14;
inline int GroupData::getted_worship_reward_size() const {
  return getted_worship_reward_.size();
}
inline void GroupData::clear_getted_worship_reward() {
  getted_worship_reward_.Clear();
}
inline bool GroupData::getted_worship_reward(int index) const {
  return getted_worship_reward_.Get(index);
}
inline void GroupData::set_getted_worship_reward(int index, bool value) {
  getted_worship_reward_.Set(index, value);
}
inline void GroupData::add_getted_worship_reward(bool value) {
  getted_worship_reward_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
GroupData::getted_worship_reward() const {
  return getted_worship_reward_;
}
inline ::google::protobuf::RepeatedField< bool >*
GroupData::mutable_getted_worship_reward() {
  return &getted_worship_reward_;
}

// -------------------------------------------------------------------

// TechnologyData

// repeated .TechnologyInfo tech_info = 1;
inline int TechnologyData::tech_info_size() const {
  return tech_info_.size();
}
inline void TechnologyData::clear_tech_info() {
  tech_info_.Clear();
}
inline const ::TechnologyInfo& TechnologyData::tech_info(int index) const {
  return tech_info_.Get(index);
}
inline ::TechnologyInfo* TechnologyData::mutable_tech_info(int index) {
  return tech_info_.Mutable(index);
}
inline ::TechnologyInfo* TechnologyData::add_tech_info() {
  return tech_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TechnologyInfo >&
TechnologyData::tech_info() const {
  return tech_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::TechnologyInfo >*
TechnologyData::mutable_tech_info() {
  return &tech_info_;
}

// optional int32 upgrade_busy = 2;
inline bool TechnologyData::has_upgrade_busy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TechnologyData::set_has_upgrade_busy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TechnologyData::clear_has_upgrade_busy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TechnologyData::clear_upgrade_busy() {
  upgrade_busy_ = 0;
  clear_has_upgrade_busy();
}
inline ::google::protobuf::int32 TechnologyData::upgrade_busy() const {
  return upgrade_busy_;
}
inline void TechnologyData::set_upgrade_busy(::google::protobuf::int32 value) {
  set_has_upgrade_busy();
  upgrade_busy_ = value;
}

// optional int32 tech_id = 3;
inline bool TechnologyData::has_tech_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TechnologyData::set_has_tech_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TechnologyData::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TechnologyData::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 TechnologyData::tech_id() const {
  return tech_id_;
}
inline void TechnologyData::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// -------------------------------------------------------------------

// TechnologyInfo

// required int32 tech_id = 1;
inline bool TechnologyInfo::has_tech_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TechnologyInfo::set_has_tech_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TechnologyInfo::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TechnologyInfo::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 TechnologyInfo::tech_id() const {
  return tech_id_;
}
inline void TechnologyInfo::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// optional int64 begin_upgrade_time = 2;
inline bool TechnologyInfo::has_begin_upgrade_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TechnologyInfo::set_has_begin_upgrade_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TechnologyInfo::clear_has_begin_upgrade_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TechnologyInfo::clear_begin_upgrade_time() {
  begin_upgrade_time_ = GOOGLE_LONGLONG(0);
  clear_has_begin_upgrade_time();
}
inline ::google::protobuf::int64 TechnologyInfo::begin_upgrade_time() const {
  return begin_upgrade_time_;
}
inline void TechnologyInfo::set_begin_upgrade_time(::google::protobuf::int64 value) {
  set_has_begin_upgrade_time();
  begin_upgrade_time_ = value;
}

// optional bool helped = 3;
inline bool TechnologyInfo::has_helped() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TechnologyInfo::set_has_helped() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TechnologyInfo::clear_has_helped() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TechnologyInfo::clear_helped() {
  helped_ = false;
  clear_has_helped();
}
inline bool TechnologyInfo::helped() const {
  return helped_;
}
inline void TechnologyInfo::set_helped(bool value) {
  set_has_helped();
  helped_ = value;
}

// -------------------------------------------------------------------

// ArenaRank

// required int32 rank = 1;
inline bool ArenaRank::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaRank::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaRank::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaRank::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 ArenaRank::rank() const {
  return rank_;
}
inline void ArenaRank::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// required bool isChallenged = 2;
inline bool ArenaRank::has_ischallenged() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaRank::set_has_ischallenged() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaRank::clear_has_ischallenged() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaRank::clear_ischallenged() {
  ischallenged_ = false;
  clear_has_ischallenged();
}
inline bool ArenaRank::ischallenged() const {
  return ischallenged_;
}
inline void ArenaRank::set_ischallenged(bool value) {
  set_has_ischallenged();
  ischallenged_ = value;
}

// -------------------------------------------------------------------

// ArenaData

// required int32 challenge_times = 1;
inline bool ArenaData::has_challenge_times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaData::set_has_challenge_times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaData::clear_has_challenge_times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaData::clear_challenge_times() {
  challenge_times_ = 0;
  clear_has_challenge_times();
}
inline ::google::protobuf::int32 ArenaData::challenge_times() const {
  return challenge_times_;
}
inline void ArenaData::set_challenge_times(::google::protobuf::int32 value) {
  set_has_challenge_times();
  challenge_times_ = value;
}

// required int32 purchased_challenge_times = 2;
inline bool ArenaData::has_purchased_challenge_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaData::set_has_purchased_challenge_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaData::clear_has_purchased_challenge_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaData::clear_purchased_challenge_times() {
  purchased_challenge_times_ = 0;
  clear_has_purchased_challenge_times();
}
inline ::google::protobuf::int32 ArenaData::purchased_challenge_times() const {
  return purchased_challenge_times_;
}
inline void ArenaData::set_purchased_challenge_times(::google::protobuf::int32 value) {
  set_has_purchased_challenge_times();
  purchased_challenge_times_ = value;
}

// required int32 honour_point = 3;
inline bool ArenaData::has_honour_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArenaData::set_has_honour_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArenaData::clear_has_honour_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArenaData::clear_honour_point() {
  honour_point_ = 0;
  clear_has_honour_point();
}
inline ::google::protobuf::int32 ArenaData::honour_point() const {
  return honour_point_;
}
inline void ArenaData::set_honour_point(::google::protobuf::int32 value) {
  set_has_honour_point();
  honour_point_ = value;
}

// repeated .ArenaRank challenge_list = 4;
inline int ArenaData::challenge_list_size() const {
  return challenge_list_.size();
}
inline void ArenaData::clear_challenge_list() {
  challenge_list_.Clear();
}
inline const ::ArenaRank& ArenaData::challenge_list(int index) const {
  return challenge_list_.Get(index);
}
inline ::ArenaRank* ArenaData::mutable_challenge_list(int index) {
  return challenge_list_.Mutable(index);
}
inline ::ArenaRank* ArenaData::add_challenge_list() {
  return challenge_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ArenaRank >&
ArenaData::challenge_list() const {
  return challenge_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ArenaRank >*
ArenaData::mutable_challenge_list() {
  return &challenge_list_;
}

// required int64 last_failed_time = 5;
inline bool ArenaData::has_last_failed_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArenaData::set_has_last_failed_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArenaData::clear_has_last_failed_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArenaData::clear_last_failed_time() {
  last_failed_time_ = GOOGLE_LONGLONG(0);
  clear_has_last_failed_time();
}
inline ::google::protobuf::int64 ArenaData::last_failed_time() const {
  return last_failed_time_;
}
inline void ArenaData::set_last_failed_time(::google::protobuf::int64 value) {
  set_has_last_failed_time();
  last_failed_time_ = value;
}

// required int32 target_rank = 6;
inline bool ArenaData::has_target_rank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArenaData::set_has_target_rank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArenaData::clear_has_target_rank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArenaData::clear_target_rank() {
  target_rank_ = 0;
  clear_has_target_rank();
}
inline ::google::protobuf::int32 ArenaData::target_rank() const {
  return target_rank_;
}
inline void ArenaData::set_target_rank(::google::protobuf::int32 value) {
  set_has_target_rank();
  target_rank_ = value;
}

// required int32 daily_reward = 7;
inline bool ArenaData::has_daily_reward() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArenaData::set_has_daily_reward() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArenaData::clear_has_daily_reward() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArenaData::clear_daily_reward() {
  daily_reward_ = 0;
  clear_has_daily_reward();
}
inline ::google::protobuf::int32 ArenaData::daily_reward() const {
  return daily_reward_;
}
inline void ArenaData::set_daily_reward(::google::protobuf::int32 value) {
  set_has_daily_reward();
  daily_reward_ = value;
}

// required int32 already_challenge_times = 8;
inline bool ArenaData::has_already_challenge_times() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ArenaData::set_has_already_challenge_times() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ArenaData::clear_has_already_challenge_times() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ArenaData::clear_already_challenge_times() {
  already_challenge_times_ = 0;
  clear_has_already_challenge_times();
}
inline ::google::protobuf::int32 ArenaData::already_challenge_times() const {
  return already_challenge_times_;
}
inline void ArenaData::set_already_challenge_times(::google::protobuf::int32 value) {
  set_has_already_challenge_times();
  already_challenge_times_ = value;
}

// required int32 win_challenge_times = 9;
inline bool ArenaData::has_win_challenge_times() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ArenaData::set_has_win_challenge_times() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ArenaData::clear_has_win_challenge_times() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ArenaData::clear_win_challenge_times() {
  win_challenge_times_ = 0;
  clear_has_win_challenge_times();
}
inline ::google::protobuf::int32 ArenaData::win_challenge_times() const {
  return win_challenge_times_;
}
inline void ArenaData::set_win_challenge_times(::google::protobuf::int32 value) {
  set_has_win_challenge_times();
  win_challenge_times_ = value;
}

// required int32 title_level = 10;
inline bool ArenaData::has_title_level() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ArenaData::set_has_title_level() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ArenaData::clear_has_title_level() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ArenaData::clear_title_level() {
  title_level_ = 0;
  clear_has_title_level();
}
inline ::google::protobuf::int32 ArenaData::title_level() const {
  return title_level_;
}
inline void ArenaData::set_title_level(::google::protobuf::int32 value) {
  set_has_title_level();
  title_level_ = value;
}

// -------------------------------------------------------------------

// FriendFamiliarity

// required string user_name = 1;
inline bool FriendFamiliarity::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendFamiliarity::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendFamiliarity::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendFamiliarity::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& FriendFamiliarity::user_name() const {
  return *user_name_;
}
inline void FriendFamiliarity::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void FriendFamiliarity::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void FriendFamiliarity::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendFamiliarity::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* FriendFamiliarity::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendFamiliarity::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 familiarity = 2;
inline bool FriendFamiliarity::has_familiarity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendFamiliarity::set_has_familiarity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendFamiliarity::clear_has_familiarity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendFamiliarity::clear_familiarity() {
  familiarity_ = 0;
  clear_has_familiarity();
}
inline ::google::protobuf::int32 FriendFamiliarity::familiarity() const {
  return familiarity_;
}
inline void FriendFamiliarity::set_familiarity(::google::protobuf::int32 value) {
  set_has_familiarity();
  familiarity_ = value;
}

// -------------------------------------------------------------------

// FriendsData

// repeated string friends_list = 1;
inline int FriendsData::friends_list_size() const {
  return friends_list_.size();
}
inline void FriendsData::clear_friends_list() {
  friends_list_.Clear();
}
inline const ::std::string& FriendsData::friends_list(int index) const {
  return friends_list_.Get(index);
}
inline ::std::string* FriendsData::mutable_friends_list(int index) {
  return friends_list_.Mutable(index);
}
inline void FriendsData::set_friends_list(int index, const ::std::string& value) {
  friends_list_.Mutable(index)->assign(value);
}
inline void FriendsData::set_friends_list(int index, const char* value) {
  friends_list_.Mutable(index)->assign(value);
}
inline void FriendsData::set_friends_list(int index, const char* value, size_t size) {
  friends_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendsData::add_friends_list() {
  return friends_list_.Add();
}
inline void FriendsData::add_friends_list(const ::std::string& value) {
  friends_list_.Add()->assign(value);
}
inline void FriendsData::add_friends_list(const char* value) {
  friends_list_.Add()->assign(value);
}
inline void FriendsData::add_friends_list(const char* value, size_t size) {
  friends_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FriendsData::friends_list() const {
  return friends_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FriendsData::mutable_friends_list() {
  return &friends_list_;
}

// repeated string black_list = 2;
inline int FriendsData::black_list_size() const {
  return black_list_.size();
}
inline void FriendsData::clear_black_list() {
  black_list_.Clear();
}
inline const ::std::string& FriendsData::black_list(int index) const {
  return black_list_.Get(index);
}
inline ::std::string* FriendsData::mutable_black_list(int index) {
  return black_list_.Mutable(index);
}
inline void FriendsData::set_black_list(int index, const ::std::string& value) {
  black_list_.Mutable(index)->assign(value);
}
inline void FriendsData::set_black_list(int index, const char* value) {
  black_list_.Mutable(index)->assign(value);
}
inline void FriendsData::set_black_list(int index, const char* value, size_t size) {
  black_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendsData::add_black_list() {
  return black_list_.Add();
}
inline void FriendsData::add_black_list(const ::std::string& value) {
  black_list_.Add()->assign(value);
}
inline void FriendsData::add_black_list(const char* value) {
  black_list_.Add()->assign(value);
}
inline void FriendsData::add_black_list(const char* value, size_t size) {
  black_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FriendsData::black_list() const {
  return black_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FriendsData::mutable_black_list() {
  return &black_list_;
}

// repeated string talk_list = 3;
inline int FriendsData::talk_list_size() const {
  return talk_list_.size();
}
inline void FriendsData::clear_talk_list() {
  talk_list_.Clear();
}
inline const ::std::string& FriendsData::talk_list(int index) const {
  return talk_list_.Get(index);
}
inline ::std::string* FriendsData::mutable_talk_list(int index) {
  return talk_list_.Mutable(index);
}
inline void FriendsData::set_talk_list(int index, const ::std::string& value) {
  talk_list_.Mutable(index)->assign(value);
}
inline void FriendsData::set_talk_list(int index, const char* value) {
  talk_list_.Mutable(index)->assign(value);
}
inline void FriendsData::set_talk_list(int index, const char* value, size_t size) {
  talk_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendsData::add_talk_list() {
  return talk_list_.Add();
}
inline void FriendsData::add_talk_list(const ::std::string& value) {
  talk_list_.Add()->assign(value);
}
inline void FriendsData::add_talk_list(const char* value) {
  talk_list_.Add()->assign(value);
}
inline void FriendsData::add_talk_list(const char* value, size_t size) {
  talk_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FriendsData::talk_list() const {
  return talk_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FriendsData::mutable_talk_list() {
  return &talk_list_;
}

// repeated .FriendFamiliarity friends_familiarity = 4;
inline int FriendsData::friends_familiarity_size() const {
  return friends_familiarity_.size();
}
inline void FriendsData::clear_friends_familiarity() {
  friends_familiarity_.Clear();
}
inline const ::FriendFamiliarity& FriendsData::friends_familiarity(int index) const {
  return friends_familiarity_.Get(index);
}
inline ::FriendFamiliarity* FriendsData::mutable_friends_familiarity(int index) {
  return friends_familiarity_.Mutable(index);
}
inline ::FriendFamiliarity* FriendsData::add_friends_familiarity() {
  return friends_familiarity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FriendFamiliarity >&
FriendsData::friends_familiarity() const {
  return friends_familiarity_;
}
inline ::google::protobuf::RepeatedPtrField< ::FriendFamiliarity >*
FriendsData::mutable_friends_familiarity() {
  return &friends_familiarity_;
}

// repeated string add_tili = 5;
inline int FriendsData::add_tili_size() const {
  return add_tili_.size();
}
inline void FriendsData::clear_add_tili() {
  add_tili_.Clear();
}
inline const ::std::string& FriendsData::add_tili(int index) const {
  return add_tili_.Get(index);
}
inline ::std::string* FriendsData::mutable_add_tili(int index) {
  return add_tili_.Mutable(index);
}
inline void FriendsData::set_add_tili(int index, const ::std::string& value) {
  add_tili_.Mutable(index)->assign(value);
}
inline void FriendsData::set_add_tili(int index, const char* value) {
  add_tili_.Mutable(index)->assign(value);
}
inline void FriendsData::set_add_tili(int index, const char* value, size_t size) {
  add_tili_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendsData::add_add_tili() {
  return add_tili_.Add();
}
inline void FriendsData::add_add_tili(const ::std::string& value) {
  add_tili_.Add()->assign(value);
}
inline void FriendsData::add_add_tili(const char* value) {
  add_tili_.Add()->assign(value);
}
inline void FriendsData::add_add_tili(const char* value, size_t size) {
  add_tili_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FriendsData::add_tili() const {
  return add_tili_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FriendsData::mutable_add_tili() {
  return &add_tili_;
}

// repeated string read_tili = 6;
inline int FriendsData::read_tili_size() const {
  return read_tili_.size();
}
inline void FriendsData::clear_read_tili() {
  read_tili_.Clear();
}
inline const ::std::string& FriendsData::read_tili(int index) const {
  return read_tili_.Get(index);
}
inline ::std::string* FriendsData::mutable_read_tili(int index) {
  return read_tili_.Mutable(index);
}
inline void FriendsData::set_read_tili(int index, const ::std::string& value) {
  read_tili_.Mutable(index)->assign(value);
}
inline void FriendsData::set_read_tili(int index, const char* value) {
  read_tili_.Mutable(index)->assign(value);
}
inline void FriendsData::set_read_tili(int index, const char* value, size_t size) {
  read_tili_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendsData::add_read_tili() {
  return read_tili_.Add();
}
inline void FriendsData::add_read_tili(const ::std::string& value) {
  read_tili_.Add()->assign(value);
}
inline void FriendsData::add_read_tili(const char* value) {
  read_tili_.Add()->assign(value);
}
inline void FriendsData::add_read_tili(const char* value, size_t size) {
  read_tili_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FriendsData::read_tili() const {
  return read_tili_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FriendsData::mutable_read_tili() {
  return &read_tili_;
}

// optional int32 add_tili_count = 7;
inline bool FriendsData::has_add_tili_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FriendsData::set_has_add_tili_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FriendsData::clear_has_add_tili_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FriendsData::clear_add_tili_count() {
  add_tili_count_ = 0;
  clear_has_add_tili_count();
}
inline ::google::protobuf::int32 FriendsData::add_tili_count() const {
  return add_tili_count_;
}
inline void FriendsData::set_add_tili_count(::google::protobuf::int32 value) {
  set_has_add_tili_count();
  add_tili_count_ = value;
}

// optional int32 read_tili_count = 8;
inline bool FriendsData::has_read_tili_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FriendsData::set_has_read_tili_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FriendsData::clear_has_read_tili_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FriendsData::clear_read_tili_count() {
  read_tili_count_ = 0;
  clear_has_read_tili_count();
}
inline ::google::protobuf::int32 FriendsData::read_tili_count() const {
  return read_tili_count_;
}
inline void FriendsData::set_read_tili_count(::google::protobuf::int32 value) {
  set_has_read_tili_count();
  read_tili_count_ = value;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_UserInfo_2eproto__INCLUDED
