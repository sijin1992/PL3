// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdGroup.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CmdGroup.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_CmdGroup_2eproto() {
  delete CreateGroupReq::default_instance_;
  delete CreateGroupResp::default_instance_;
  delete GetGroupReq::default_instance_;
  delete GetGroupResp::default_instance_;
  delete GroupUpdate::default_instance_;
  delete GroupUpdate_UserUpdate::default_instance_;
  delete GroupJoinConditionReq::default_instance_;
  delete GroupJoinConditionResp::default_instance_;
  delete GroupJoinReq::default_instance_;
  delete GroupJoinResp::default_instance_;
  delete GroupAllowReq::default_instance_;
  delete GroupAllowResp::default_instance_;
  delete GroupExitGroupReq::default_instance_;
  delete GroupExitGroupResp::default_instance_;
  delete GroupKickReq::default_instance_;
  delete GroupKickResp::default_instance_;
  delete GroupBroadcastReq::default_instance_;
  delete GroupBroadcastResp::default_instance_;
  delete GroupJobReq::default_instance_;
  delete GroupJobResp::default_instance_;
  delete GroupDisbandResp::default_instance_;
  delete GroupSearchReq::default_instance_;
  delete GroupSearchResp::default_instance_;
  delete GroupContributeReq::default_instance_;
  delete GroupContributeResp::default_instance_;
  delete GroupContributeCDResp::default_instance_;
  delete GroupTechLevelupReq::default_instance_;
  delete GroupTechLevelupResp::default_instance_;
  delete GroupGetTechReq::default_instance_;
  delete GroupGetTechResp::default_instance_;
  delete GroupLevelupResp::default_instance_;
  delete GroupPVEGetInfoReq::default_instance_;
  delete GroupPVEGetInfoResp::default_instance_;
  delete GroupPVEReq::default_instance_;
  delete GroupPVEResp::default_instance_;
  delete GroupPVEOKReq::default_instance_;
  delete GroupPVEOKResp::default_instance_;
  delete GroupPVEAddTimsReq::default_instance_;
  delete GroupPVEAddTimsResp::default_instance_;
  delete GroupPVERewardReq::default_instance_;
  delete GroupPVERewardResp::default_instance_;
  delete GroupRequestHelpReq::default_instance_;
  delete GroupRequestHelpResp::default_instance_;
  delete GroupHelpListResp::default_instance_;
  delete GroupHelpReq::default_instance_;
  delete GroupHelpResp::default_instance_;
  delete NewGroupUpdate::default_instance_;
  delete GroupInviteReq::default_instance_;
  delete GroupInviteResp::default_instance_;
  delete GroupWorshipReq::default_instance_;
  delete GroupWorshipResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_CmdGroup_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_CmdGroup_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_Group_2eproto();
  ::protobuf_AddDesc_UserInfo_2eproto();
  ::protobuf_AddDesc_Item_2eproto();
  ::protobuf_AddDesc_AirShip_2eproto();
  ::protobuf_AddDesc_PvpInfo_2eproto();
  ::protobuf_AddDesc_UserSync_2eproto();
  ::protobuf_AddDesc_OtherInfo_2eproto();
  ::protobuf_AddDesc_Planet_2eproto();
  CreateGroupReq::default_instance_ = new CreateGroupReq();
  CreateGroupResp::default_instance_ = new CreateGroupResp();
  GetGroupReq::default_instance_ = new GetGroupReq();
  GetGroupResp::default_instance_ = new GetGroupResp();
  GroupUpdate::default_instance_ = new GroupUpdate();
  GroupUpdate_UserUpdate::default_instance_ = new GroupUpdate_UserUpdate();
  GroupJoinConditionReq::default_instance_ = new GroupJoinConditionReq();
  GroupJoinConditionResp::default_instance_ = new GroupJoinConditionResp();
  GroupJoinReq::default_instance_ = new GroupJoinReq();
  GroupJoinResp::default_instance_ = new GroupJoinResp();
  GroupAllowReq::default_instance_ = new GroupAllowReq();
  GroupAllowResp::default_instance_ = new GroupAllowResp();
  GroupExitGroupReq::default_instance_ = new GroupExitGroupReq();
  GroupExitGroupResp::default_instance_ = new GroupExitGroupResp();
  GroupKickReq::default_instance_ = new GroupKickReq();
  GroupKickResp::default_instance_ = new GroupKickResp();
  GroupBroadcastReq::default_instance_ = new GroupBroadcastReq();
  GroupBroadcastResp::default_instance_ = new GroupBroadcastResp();
  GroupJobReq::default_instance_ = new GroupJobReq();
  GroupJobResp::default_instance_ = new GroupJobResp();
  GroupDisbandResp::default_instance_ = new GroupDisbandResp();
  GroupSearchReq::default_instance_ = new GroupSearchReq();
  GroupSearchResp::default_instance_ = new GroupSearchResp();
  GroupContributeReq::default_instance_ = new GroupContributeReq();
  GroupContributeResp::default_instance_ = new GroupContributeResp();
  GroupContributeCDResp::default_instance_ = new GroupContributeCDResp();
  GroupTechLevelupReq::default_instance_ = new GroupTechLevelupReq();
  GroupTechLevelupResp::default_instance_ = new GroupTechLevelupResp();
  GroupGetTechReq::default_instance_ = new GroupGetTechReq();
  GroupGetTechResp::default_instance_ = new GroupGetTechResp();
  GroupLevelupResp::default_instance_ = new GroupLevelupResp();
  GroupPVEGetInfoReq::default_instance_ = new GroupPVEGetInfoReq();
  GroupPVEGetInfoResp::default_instance_ = new GroupPVEGetInfoResp();
  GroupPVEReq::default_instance_ = new GroupPVEReq();
  GroupPVEResp::default_instance_ = new GroupPVEResp();
  GroupPVEOKReq::default_instance_ = new GroupPVEOKReq();
  GroupPVEOKResp::default_instance_ = new GroupPVEOKResp();
  GroupPVEAddTimsReq::default_instance_ = new GroupPVEAddTimsReq();
  GroupPVEAddTimsResp::default_instance_ = new GroupPVEAddTimsResp();
  GroupPVERewardReq::default_instance_ = new GroupPVERewardReq();
  GroupPVERewardResp::default_instance_ = new GroupPVERewardResp();
  GroupRequestHelpReq::default_instance_ = new GroupRequestHelpReq();
  GroupRequestHelpResp::default_instance_ = new GroupRequestHelpResp();
  GroupHelpListResp::default_instance_ = new GroupHelpListResp();
  GroupHelpReq::default_instance_ = new GroupHelpReq();
  GroupHelpResp::default_instance_ = new GroupHelpResp();
  NewGroupUpdate::default_instance_ = new NewGroupUpdate();
  GroupInviteReq::default_instance_ = new GroupInviteReq();
  GroupInviteResp::default_instance_ = new GroupInviteResp();
  GroupWorshipReq::default_instance_ = new GroupWorshipReq();
  GroupWorshipResp::default_instance_ = new GroupWorshipResp();
  CreateGroupReq::default_instance_->InitAsDefaultInstance();
  CreateGroupResp::default_instance_->InitAsDefaultInstance();
  GetGroupReq::default_instance_->InitAsDefaultInstance();
  GetGroupResp::default_instance_->InitAsDefaultInstance();
  GroupUpdate::default_instance_->InitAsDefaultInstance();
  GroupUpdate_UserUpdate::default_instance_->InitAsDefaultInstance();
  GroupJoinConditionReq::default_instance_->InitAsDefaultInstance();
  GroupJoinConditionResp::default_instance_->InitAsDefaultInstance();
  GroupJoinReq::default_instance_->InitAsDefaultInstance();
  GroupJoinResp::default_instance_->InitAsDefaultInstance();
  GroupAllowReq::default_instance_->InitAsDefaultInstance();
  GroupAllowResp::default_instance_->InitAsDefaultInstance();
  GroupExitGroupReq::default_instance_->InitAsDefaultInstance();
  GroupExitGroupResp::default_instance_->InitAsDefaultInstance();
  GroupKickReq::default_instance_->InitAsDefaultInstance();
  GroupKickResp::default_instance_->InitAsDefaultInstance();
  GroupBroadcastReq::default_instance_->InitAsDefaultInstance();
  GroupBroadcastResp::default_instance_->InitAsDefaultInstance();
  GroupJobReq::default_instance_->InitAsDefaultInstance();
  GroupJobResp::default_instance_->InitAsDefaultInstance();
  GroupDisbandResp::default_instance_->InitAsDefaultInstance();
  GroupSearchReq::default_instance_->InitAsDefaultInstance();
  GroupSearchResp::default_instance_->InitAsDefaultInstance();
  GroupContributeReq::default_instance_->InitAsDefaultInstance();
  GroupContributeResp::default_instance_->InitAsDefaultInstance();
  GroupContributeCDResp::default_instance_->InitAsDefaultInstance();
  GroupTechLevelupReq::default_instance_->InitAsDefaultInstance();
  GroupTechLevelupResp::default_instance_->InitAsDefaultInstance();
  GroupGetTechReq::default_instance_->InitAsDefaultInstance();
  GroupGetTechResp::default_instance_->InitAsDefaultInstance();
  GroupLevelupResp::default_instance_->InitAsDefaultInstance();
  GroupPVEGetInfoReq::default_instance_->InitAsDefaultInstance();
  GroupPVEGetInfoResp::default_instance_->InitAsDefaultInstance();
  GroupPVEReq::default_instance_->InitAsDefaultInstance();
  GroupPVEResp::default_instance_->InitAsDefaultInstance();
  GroupPVEOKReq::default_instance_->InitAsDefaultInstance();
  GroupPVEOKResp::default_instance_->InitAsDefaultInstance();
  GroupPVEAddTimsReq::default_instance_->InitAsDefaultInstance();
  GroupPVEAddTimsResp::default_instance_->InitAsDefaultInstance();
  GroupPVERewardReq::default_instance_->InitAsDefaultInstance();
  GroupPVERewardResp::default_instance_->InitAsDefaultInstance();
  GroupRequestHelpReq::default_instance_->InitAsDefaultInstance();
  GroupRequestHelpResp::default_instance_->InitAsDefaultInstance();
  GroupHelpListResp::default_instance_->InitAsDefaultInstance();
  GroupHelpReq::default_instance_->InitAsDefaultInstance();
  GroupHelpResp::default_instance_->InitAsDefaultInstance();
  NewGroupUpdate::default_instance_->InitAsDefaultInstance();
  GroupInviteReq::default_instance_->InitAsDefaultInstance();
  GroupInviteResp::default_instance_->InitAsDefaultInstance();
  GroupWorshipReq::default_instance_->InitAsDefaultInstance();
  GroupWorshipResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CmdGroup_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_CmdGroup_2eproto_once_);
void protobuf_AddDesc_CmdGroup_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_CmdGroup_2eproto_once_,
                 &protobuf_AddDesc_CmdGroup_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CmdGroup_2eproto {
  StaticDescriptorInitializer_CmdGroup_2eproto() {
    protobuf_AddDesc_CmdGroup_2eproto();
  }
} static_descriptor_initializer_CmdGroup_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int CreateGroupReq::kNicknameFieldNumber;
const int CreateGroupReq::kIconIdFieldNumber;
#endif  // !_MSC_VER

CreateGroupReq::CreateGroupReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateGroupReq::InitAsDefaultInstance() {
}

CreateGroupReq::CreateGroupReq(const CreateGroupReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateGroupReq::SharedCtor() {
  _cached_size_ = 0;
  nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  icon_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateGroupReq::~CreateGroupReq() {
  SharedDtor();
}

void CreateGroupReq::SharedDtor() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateGroupReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateGroupReq& CreateGroupReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

CreateGroupReq* CreateGroupReq::default_instance_ = NULL;

CreateGroupReq* CreateGroupReq::New() const {
  return new CreateGroupReq;
}

void CreateGroupReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_nickname()) {
      if (nickname_ != &::google::protobuf::internal::kEmptyString) {
        nickname_->clear();
      }
    }
    icon_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateGroupReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string nickname = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nickname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_icon_id;
        break;
      }

      // optional int32 icon_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_icon_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &icon_id_)));
          set_has_icon_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateGroupReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string nickname = 1;
  if (has_nickname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->nickname(), output);
  }

  // optional int32 icon_id = 2;
  if (has_icon_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->icon_id(), output);
  }

}

int CreateGroupReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string nickname = 1;
    if (has_nickname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nickname());
    }

    // optional int32 icon_id = 2;
    if (has_icon_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->icon_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateGroupReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateGroupReq*>(&from));
}

void CreateGroupReq::MergeFrom(const CreateGroupReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nickname()) {
      set_nickname(from.nickname());
    }
    if (from.has_icon_id()) {
      set_icon_id(from.icon_id());
    }
  }
}

void CreateGroupReq::CopyFrom(const CreateGroupReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateGroupReq::IsInitialized() const {

  return true;
}

void CreateGroupReq::Swap(CreateGroupReq* other) {
  if (other != this) {
    std::swap(nickname_, other->nickname_);
    std::swap(icon_id_, other->icon_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateGroupReq::GetTypeName() const {
  return "CreateGroupReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateGroupResp::kResultFieldNumber;
const int CreateGroupResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

CreateGroupResp::CreateGroupResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateGroupResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

CreateGroupResp::CreateGroupResp(const CreateGroupResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateGroupResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateGroupResp::~CreateGroupResp() {
  SharedDtor();
}

void CreateGroupResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void CreateGroupResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateGroupResp& CreateGroupResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

CreateGroupResp* CreateGroupResp::default_instance_ = NULL;

CreateGroupResp* CreateGroupResp::New() const {
  return new CreateGroupResp;
}

void CreateGroupResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateGroupResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateGroupResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int CreateGroupResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateGroupResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateGroupResp*>(&from));
}

void CreateGroupResp::MergeFrom(const CreateGroupResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void CreateGroupResp::CopyFrom(const CreateGroupResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateGroupResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void CreateGroupResp::Swap(CreateGroupResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateGroupResp::GetTypeName() const {
  return "CreateGroupResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GetGroupReq::kGroupidFieldNumber;
#endif  // !_MSC_VER

GetGroupReq::GetGroupReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetGroupReq::InitAsDefaultInstance() {
}

GetGroupReq::GetGroupReq(const GetGroupReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetGroupReq::SharedCtor() {
  _cached_size_ = 0;
  groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetGroupReq::~GetGroupReq() {
  SharedDtor();
}

void GetGroupReq::SharedDtor() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetGroupReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetGroupReq& GetGroupReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GetGroupReq* GetGroupReq::default_instance_ = NULL;

GetGroupReq* GetGroupReq::New() const {
  return new GetGroupReq;
}

void GetGroupReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_groupid()) {
      if (groupid_ != &::google::protobuf::internal::kEmptyString) {
        groupid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetGroupReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string groupid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_groupid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetGroupReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string groupid = 1;
  if (has_groupid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->groupid(), output);
  }

}

int GetGroupReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string groupid = 1;
    if (has_groupid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->groupid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetGroupReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetGroupReq*>(&from));
}

void GetGroupReq::MergeFrom(const GetGroupReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_groupid()) {
      set_groupid(from.groupid());
    }
  }
}

void GetGroupReq::CopyFrom(const GetGroupReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetGroupReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetGroupReq::Swap(GetGroupReq* other) {
  if (other != this) {
    std::swap(groupid_, other->groupid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetGroupReq::GetTypeName() const {
  return "GetGroupReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetGroupResp::kResultFieldNumber;
const int GetGroupResp::kUserSyncFieldNumber;
const int GetGroupResp::kOtherGroupInfoFieldNumber;
#endif  // !_MSC_VER

GetGroupResp::GetGroupResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetGroupResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  other_group_info_ = const_cast< ::OtherGroupInfo*>(
      ::OtherGroupInfo::internal_default_instance());
#else
  other_group_info_ = const_cast< ::OtherGroupInfo*>(&::OtherGroupInfo::default_instance());
#endif
}

GetGroupResp::GetGroupResp(const GetGroupResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetGroupResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  other_group_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetGroupResp::~GetGroupResp() {
  SharedDtor();
}

void GetGroupResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete other_group_info_;
  }
}

void GetGroupResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetGroupResp& GetGroupResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GetGroupResp* GetGroupResp::default_instance_ = NULL;

GetGroupResp* GetGroupResp::New() const {
  return new GetGroupResp;
}

void GetGroupResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_other_group_info()) {
      if (other_group_info_ != NULL) other_group_info_->::OtherGroupInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetGroupResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_other_group_info;
        break;
      }

      // optional .OtherGroupInfo other_group_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_other_group_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_other_group_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetGroupResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional .OtherGroupInfo other_group_info = 3;
  if (has_other_group_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->other_group_info(), output);
  }

}

int GetGroupResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .OtherGroupInfo other_group_info = 3;
    if (has_other_group_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->other_group_info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetGroupResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetGroupResp*>(&from));
}

void GetGroupResp::MergeFrom(const GetGroupResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_other_group_info()) {
      mutable_other_group_info()->::OtherGroupInfo::MergeFrom(from.other_group_info());
    }
  }
}

void GetGroupResp::CopyFrom(const GetGroupResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetGroupResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  if (has_other_group_info()) {
    if (!this->other_group_info().IsInitialized()) return false;
  }
  return true;
}

void GetGroupResp::Swap(GetGroupResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(other_group_info_, other->other_group_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetGroupResp::GetTypeName() const {
  return "GetGroupResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupUpdate_UserUpdate::kUserNameFieldNumber;
const int GroupUpdate_UserUpdate::kUserSyncFieldNumber;
const int GroupUpdate_UserUpdate::kPlanetUserFieldNumber;
#endif  // !_MSC_VER

GroupUpdate_UserUpdate::GroupUpdate_UserUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupUpdate_UserUpdate::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  planet_user_ = const_cast< ::PlanetUser*>(
      ::PlanetUser::internal_default_instance());
#else
  planet_user_ = const_cast< ::PlanetUser*>(&::PlanetUser::default_instance());
#endif
}

GroupUpdate_UserUpdate::GroupUpdate_UserUpdate(const GroupUpdate_UserUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupUpdate_UserUpdate::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_sync_ = NULL;
  planet_user_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupUpdate_UserUpdate::~GroupUpdate_UserUpdate() {
  SharedDtor();
}

void GroupUpdate_UserUpdate::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete planet_user_;
  }
}

void GroupUpdate_UserUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupUpdate_UserUpdate& GroupUpdate_UserUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupUpdate_UserUpdate* GroupUpdate_UserUpdate::default_instance_ = NULL;

GroupUpdate_UserUpdate* GroupUpdate_UserUpdate::New() const {
  return new GroupUpdate_UserUpdate;
}

void GroupUpdate_UserUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_planet_user()) {
      if (planet_user_ != NULL) planet_user_->::PlanetUser::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupUpdate_UserUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_planet_user;
        break;
      }

      // optional .PlanetUser planet_user = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_planet_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_planet_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupUpdate_UserUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional .PlanetUser planet_user = 3;
  if (has_planet_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->planet_user(), output);
  }

}

int GroupUpdate_UserUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .PlanetUser planet_user = 3;
    if (has_planet_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->planet_user());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupUpdate_UserUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupUpdate_UserUpdate*>(&from));
}

void GroupUpdate_UserUpdate::MergeFrom(const GroupUpdate_UserUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_planet_user()) {
      mutable_planet_user()->::PlanetUser::MergeFrom(from.planet_user());
    }
  }
}

void GroupUpdate_UserUpdate::CopyFrom(const GroupUpdate_UserUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupUpdate_UserUpdate::IsInitialized() const {

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  if (has_planet_user()) {
    if (!this->planet_user().IsInitialized()) return false;
  }
  return true;
}

void GroupUpdate_UserUpdate::Swap(GroupUpdate_UserUpdate* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(planet_user_, other->planet_user_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupUpdate_UserUpdate::GetTypeName() const {
  return "GroupUpdate.UserUpdate";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GroupUpdate::kGroupMainFieldNumber;
const int GroupUpdate::kUserNameFieldNumber;
const int GroupUpdate::kUserUpdateListFieldNumber;
#endif  // !_MSC_VER

GroupUpdate::GroupUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupUpdate::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_main_ = const_cast< ::GroupMainData*>(
      ::GroupMainData::internal_default_instance());
#else
  group_main_ = const_cast< ::GroupMainData*>(&::GroupMainData::default_instance());
#endif
}

GroupUpdate::GroupUpdate(const GroupUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupUpdate::SharedCtor() {
  _cached_size_ = 0;
  group_main_ = NULL;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupUpdate::~GroupUpdate() {
  SharedDtor();
}

void GroupUpdate::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_main_;
  }
}

void GroupUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupUpdate& GroupUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupUpdate* GroupUpdate::default_instance_ = NULL;

GroupUpdate* GroupUpdate::New() const {
  return new GroupUpdate;
}

void GroupUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group_main()) {
      if (group_main_ != NULL) group_main_->::GroupMainData::Clear();
    }
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
  }
  user_update_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .GroupMainData group_main = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group_main()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name;
        break;
      }

      // optional string user_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_update_list;
        break;
      }

      // repeated .GroupUpdate.UserUpdate user_update_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_update_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_update_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_update_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .GroupMainData group_main = 1;
  if (has_group_main()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group_main(), output);
  }

  // optional string user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->user_name(), output);
  }

  // repeated .GroupUpdate.UserUpdate user_update_list = 3;
  for (int i = 0; i < this->user_update_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->user_update_list(i), output);
  }

}

int GroupUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .GroupMainData group_main = 1;
    if (has_group_main()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group_main());
    }

    // optional string user_name = 2;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

  }
  // repeated .GroupUpdate.UserUpdate user_update_list = 3;
  total_size += 1 * this->user_update_list_size();
  for (int i = 0; i < this->user_update_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_update_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupUpdate*>(&from));
}

void GroupUpdate::MergeFrom(const GroupUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_update_list_.MergeFrom(from.user_update_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_main()) {
      mutable_group_main()->::GroupMainData::MergeFrom(from.group_main());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
  }
}

void GroupUpdate::CopyFrom(const GroupUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupUpdate::IsInitialized() const {

  if (has_group_main()) {
    if (!this->group_main().IsInitialized()) return false;
  }
  for (int i = 0; i < user_update_list_size(); i++) {
    if (!this->user_update_list(i).IsInitialized()) return false;
  }
  return true;
}

void GroupUpdate::Swap(GroupUpdate* other) {
  if (other != this) {
    std::swap(group_main_, other->group_main_);
    std::swap(user_name_, other->user_name_);
    user_update_list_.Swap(&other->user_update_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupUpdate::GetTypeName() const {
  return "GroupUpdate";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupJoinConditionReq::kNeedAllowFieldNumber;
const int GroupJoinConditionReq::kLevelFieldNumber;
const int GroupJoinConditionReq::kPowerFieldNumber;
#endif  // !_MSC_VER

GroupJoinConditionReq::GroupJoinConditionReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupJoinConditionReq::InitAsDefaultInstance() {
}

GroupJoinConditionReq::GroupJoinConditionReq(const GroupJoinConditionReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupJoinConditionReq::SharedCtor() {
  _cached_size_ = 0;
  needallow_ = false;
  level_ = 0;
  power_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupJoinConditionReq::~GroupJoinConditionReq() {
  SharedDtor();
}

void GroupJoinConditionReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupJoinConditionReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupJoinConditionReq& GroupJoinConditionReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupJoinConditionReq* GroupJoinConditionReq::default_instance_ = NULL;

GroupJoinConditionReq* GroupJoinConditionReq::New() const {
  return new GroupJoinConditionReq;
}

void GroupJoinConditionReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    needallow_ = false;
    level_ = 0;
    power_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupJoinConditionReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool needAllow = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &needallow_)));
          set_has_needallow();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }

      // optional int32 level = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_power;
        break;
      }

      // optional int32 power = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_power:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &power_)));
          set_has_power();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupJoinConditionReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool needAllow = 1;
  if (has_needallow()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->needallow(), output);
  }

  // optional int32 level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->level(), output);
  }

  // optional int32 power = 3;
  if (has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->power(), output);
  }

}

int GroupJoinConditionReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool needAllow = 1;
    if (has_needallow()) {
      total_size += 1 + 1;
    }

    // optional int32 level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // optional int32 power = 3;
    if (has_power()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->power());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupJoinConditionReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupJoinConditionReq*>(&from));
}

void GroupJoinConditionReq::MergeFrom(const GroupJoinConditionReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_needallow()) {
      set_needallow(from.needallow());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_power()) {
      set_power(from.power());
    }
  }
}

void GroupJoinConditionReq::CopyFrom(const GroupJoinConditionReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupJoinConditionReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GroupJoinConditionReq::Swap(GroupJoinConditionReq* other) {
  if (other != this) {
    std::swap(needallow_, other->needallow_);
    std::swap(level_, other->level_);
    std::swap(power_, other->power_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupJoinConditionReq::GetTypeName() const {
  return "GroupJoinConditionReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupJoinConditionResp::kResultFieldNumber;
const int GroupJoinConditionResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupJoinConditionResp::GroupJoinConditionResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupJoinConditionResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupJoinConditionResp::GroupJoinConditionResp(const GroupJoinConditionResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupJoinConditionResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupJoinConditionResp::~GroupJoinConditionResp() {
  SharedDtor();
}

void GroupJoinConditionResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupJoinConditionResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupJoinConditionResp& GroupJoinConditionResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupJoinConditionResp* GroupJoinConditionResp::default_instance_ = NULL;

GroupJoinConditionResp* GroupJoinConditionResp::New() const {
  return new GroupJoinConditionResp;
}

void GroupJoinConditionResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupJoinConditionResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupJoinConditionResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupJoinConditionResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupJoinConditionResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupJoinConditionResp*>(&from));
}

void GroupJoinConditionResp::MergeFrom(const GroupJoinConditionResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupJoinConditionResp::CopyFrom(const GroupJoinConditionResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupJoinConditionResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupJoinConditionResp::Swap(GroupJoinConditionResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupJoinConditionResp::GetTypeName() const {
  return "GroupJoinConditionResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupJoinReq::kGroupidFieldNumber;
const int GroupJoinReq::kTypeFieldNumber;
#endif  // !_MSC_VER

GroupJoinReq::GroupJoinReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupJoinReq::InitAsDefaultInstance() {
}

GroupJoinReq::GroupJoinReq(const GroupJoinReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupJoinReq::SharedCtor() {
  _cached_size_ = 0;
  groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupJoinReq::~GroupJoinReq() {
  SharedDtor();
}

void GroupJoinReq::SharedDtor() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupJoinReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupJoinReq& GroupJoinReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupJoinReq* GroupJoinReq::default_instance_ = NULL;

GroupJoinReq* GroupJoinReq::New() const {
  return new GroupJoinReq;
}

void GroupJoinReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_groupid()) {
      if (groupid_ != &::google::protobuf::internal::kEmptyString) {
        groupid_->clear();
      }
    }
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupJoinReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string groupid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_groupid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required int32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupJoinReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string groupid = 1;
  if (has_groupid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->groupid(), output);
  }

  // required int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

}

int GroupJoinReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string groupid = 1;
    if (has_groupid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->groupid());
    }

    // required int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupJoinReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupJoinReq*>(&from));
}

void GroupJoinReq::MergeFrom(const GroupJoinReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_groupid()) {
      set_groupid(from.groupid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void GroupJoinReq::CopyFrom(const GroupJoinReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupJoinReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupJoinReq::Swap(GroupJoinReq* other) {
  if (other != this) {
    std::swap(groupid_, other->groupid_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupJoinReq::GetTypeName() const {
  return "GroupJoinReq";
}


// ===================================================================

bool GroupJoinResp_GroupJoinRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 995:
    case 997:
    case 998:
    case 999:
    case 1000:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupJoinResp_GroupJoinRet GroupJoinResp::OK;
const GroupJoinResp_GroupJoinRet GroupJoinResp::FAIL;
const GroupJoinResp_GroupJoinRet GroupJoinResp::HAS_GROUP;
const GroupJoinResp_GroupJoinRet GroupJoinResp::NO_NUMS;
const GroupJoinResp_GroupJoinRet GroupJoinResp::NO_TIME;
const GroupJoinResp_GroupJoinRet GroupJoinResp::ERROR_TYPE;
const GroupJoinResp_GroupJoinRet GroupJoinResp::DATA_ERROR;
const GroupJoinResp_GroupJoinRet GroupJoinResp::SAME_USER;
const GroupJoinResp_GroupJoinRet GroupJoinResp::STATUS_ERROR;
const GroupJoinResp_GroupJoinRet GroupJoinResp::NO_USER;
const GroupJoinResp_GroupJoinRet GroupJoinResp::NO_POWER;
const GroupJoinResp_GroupJoinRet GroupJoinResp::USER_COUNT_MAX;
const GroupJoinResp_GroupJoinRet GroupJoinResp::NO_CONDITION;
const GroupJoinResp_GroupJoinRet GroupJoinResp::GroupJoinRet_MIN;
const GroupJoinResp_GroupJoinRet GroupJoinResp::GroupJoinRet_MAX;
const int GroupJoinResp::GroupJoinRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupJoinResp::kResultFieldNumber;
const int GroupJoinResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupJoinResp::GroupJoinResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupJoinResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupJoinResp::GroupJoinResp(const GroupJoinResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupJoinResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupJoinResp::~GroupJoinResp() {
  SharedDtor();
}

void GroupJoinResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupJoinResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupJoinResp& GroupJoinResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupJoinResp* GroupJoinResp::default_instance_ = NULL;

GroupJoinResp* GroupJoinResp::New() const {
  return new GroupJoinResp;
}

void GroupJoinResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupJoinResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupJoinResp.GroupJoinRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupJoinResp_GroupJoinRet_IsValid(value)) {
            set_result(static_cast< ::GroupJoinResp_GroupJoinRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupJoinResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupJoinResp.GroupJoinRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupJoinResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupJoinResp.GroupJoinRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupJoinResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupJoinResp*>(&from));
}

void GroupJoinResp::MergeFrom(const GroupJoinResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupJoinResp::CopyFrom(const GroupJoinResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupJoinResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupJoinResp::Swap(GroupJoinResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupJoinResp::GetTypeName() const {
  return "GroupJoinResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupAllowReq::kUsernameFieldNumber;
const int GroupAllowReq::kTypeFieldNumber;
#endif  // !_MSC_VER

GroupAllowReq::GroupAllowReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupAllowReq::InitAsDefaultInstance() {
}

GroupAllowReq::GroupAllowReq(const GroupAllowReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupAllowReq::SharedCtor() {
  _cached_size_ = 0;
  username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupAllowReq::~GroupAllowReq() {
  SharedDtor();
}

void GroupAllowReq::SharedDtor() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupAllowReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupAllowReq& GroupAllowReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupAllowReq* GroupAllowReq::default_instance_ = NULL;

GroupAllowReq* GroupAllowReq::New() const {
  return new GroupAllowReq;
}

void GroupAllowReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_username()) {
      if (username_ != &::google::protobuf::internal::kEmptyString) {
        username_->clear();
      }
    }
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupAllowReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string username = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required int32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupAllowReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string username = 1;
  if (has_username()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->username(), output);
  }

  // required int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

}

int GroupAllowReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string username = 1;
    if (has_username()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->username());
    }

    // required int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupAllowReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupAllowReq*>(&from));
}

void GroupAllowReq::MergeFrom(const GroupAllowReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_username()) {
      set_username(from.username());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void GroupAllowReq::CopyFrom(const GroupAllowReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupAllowReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupAllowReq::Swap(GroupAllowReq* other) {
  if (other != this) {
    std::swap(username_, other->username_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupAllowReq::GetTypeName() const {
  return "GroupAllowReq";
}


// ===================================================================

bool GroupAllowResp_GroupAllowRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 995:
    case 997:
    case 998:
    case 999:
    case 1000:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupAllowResp_GroupAllowRet GroupAllowResp::OK;
const GroupAllowResp_GroupAllowRet GroupAllowResp::FAIL;
const GroupAllowResp_GroupAllowRet GroupAllowResp::HAS_GROUP;
const GroupAllowResp_GroupAllowRet GroupAllowResp::NO_NUMS;
const GroupAllowResp_GroupAllowRet GroupAllowResp::NO_TIME;
const GroupAllowResp_GroupAllowRet GroupAllowResp::ERROR_TYPE;
const GroupAllowResp_GroupAllowRet GroupAllowResp::DATA_ERROR;
const GroupAllowResp_GroupAllowRet GroupAllowResp::SAME_USER;
const GroupAllowResp_GroupAllowRet GroupAllowResp::STATUS_ERROR;
const GroupAllowResp_GroupAllowRet GroupAllowResp::NO_USER;
const GroupAllowResp_GroupAllowRet GroupAllowResp::NO_POWER;
const GroupAllowResp_GroupAllowRet GroupAllowResp::USER_COUNT_MAX;
const GroupAllowResp_GroupAllowRet GroupAllowResp::NO_CONDITION;
const GroupAllowResp_GroupAllowRet GroupAllowResp::GroupAllowRet_MIN;
const GroupAllowResp_GroupAllowRet GroupAllowResp::GroupAllowRet_MAX;
const int GroupAllowResp::GroupAllowRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupAllowResp::kResultFieldNumber;
const int GroupAllowResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupAllowResp::GroupAllowResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupAllowResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupAllowResp::GroupAllowResp(const GroupAllowResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupAllowResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupAllowResp::~GroupAllowResp() {
  SharedDtor();
}

void GroupAllowResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupAllowResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupAllowResp& GroupAllowResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupAllowResp* GroupAllowResp::default_instance_ = NULL;

GroupAllowResp* GroupAllowResp::New() const {
  return new GroupAllowResp;
}

void GroupAllowResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupAllowResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupAllowResp.GroupAllowRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupAllowResp_GroupAllowRet_IsValid(value)) {
            set_result(static_cast< ::GroupAllowResp_GroupAllowRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupAllowResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupAllowResp.GroupAllowRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupAllowResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupAllowResp.GroupAllowRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupAllowResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupAllowResp*>(&from));
}

void GroupAllowResp::MergeFrom(const GroupAllowResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupAllowResp::CopyFrom(const GroupAllowResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupAllowResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupAllowResp::Swap(GroupAllowResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupAllowResp::GetTypeName() const {
  return "GroupAllowResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupExitGroupReq::kResultFieldNumber;
#endif  // !_MSC_VER

GroupExitGroupReq::GroupExitGroupReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupExitGroupReq::InitAsDefaultInstance() {
}

GroupExitGroupReq::GroupExitGroupReq(const GroupExitGroupReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupExitGroupReq::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupExitGroupReq::~GroupExitGroupReq() {
  SharedDtor();
}

void GroupExitGroupReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupExitGroupReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupExitGroupReq& GroupExitGroupReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupExitGroupReq* GroupExitGroupReq::default_instance_ = NULL;

GroupExitGroupReq* GroupExitGroupReq::New() const {
  return new GroupExitGroupReq;
}

void GroupExitGroupReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupExitGroupReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupExitGroupReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int GroupExitGroupReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupExitGroupReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupExitGroupReq*>(&from));
}

void GroupExitGroupReq::MergeFrom(const GroupExitGroupReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void GroupExitGroupReq::CopyFrom(const GroupExitGroupReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupExitGroupReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GroupExitGroupReq::Swap(GroupExitGroupReq* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupExitGroupReq::GetTypeName() const {
  return "GroupExitGroupReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupExitGroupResp::kResultFieldNumber;
const int GroupExitGroupResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupExitGroupResp::GroupExitGroupResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupExitGroupResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupExitGroupResp::GroupExitGroupResp(const GroupExitGroupResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupExitGroupResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupExitGroupResp::~GroupExitGroupResp() {
  SharedDtor();
}

void GroupExitGroupResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupExitGroupResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupExitGroupResp& GroupExitGroupResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupExitGroupResp* GroupExitGroupResp::default_instance_ = NULL;

GroupExitGroupResp* GroupExitGroupResp::New() const {
  return new GroupExitGroupResp;
}

void GroupExitGroupResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupExitGroupResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupExitGroupResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupExitGroupResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupExitGroupResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupExitGroupResp*>(&from));
}

void GroupExitGroupResp::MergeFrom(const GroupExitGroupResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupExitGroupResp::CopyFrom(const GroupExitGroupResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupExitGroupResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupExitGroupResp::Swap(GroupExitGroupResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupExitGroupResp::GetTypeName() const {
  return "GroupExitGroupResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupKickReq::kUserNameFieldNumber;
#endif  // !_MSC_VER

GroupKickReq::GroupKickReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupKickReq::InitAsDefaultInstance() {
}

GroupKickReq::GroupKickReq(const GroupKickReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupKickReq::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupKickReq::~GroupKickReq() {
  SharedDtor();
}

void GroupKickReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupKickReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupKickReq& GroupKickReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupKickReq* GroupKickReq::default_instance_ = NULL;

GroupKickReq* GroupKickReq::New() const {
  return new GroupKickReq;
}

void GroupKickReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupKickReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupKickReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

}

int GroupKickReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupKickReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupKickReq*>(&from));
}

void GroupKickReq::MergeFrom(const GroupKickReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
  }
}

void GroupKickReq::CopyFrom(const GroupKickReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupKickReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GroupKickReq::Swap(GroupKickReq* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupKickReq::GetTypeName() const {
  return "GroupKickReq";
}


// ===================================================================

bool GroupKickResp_GroupKickRet_IsValid(int value) {
  switch(value) {
    case -4:
    case -3:
    case -2:
    case -1:
    case 0:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupKickResp_GroupKickRet GroupKickResp::OK;
const GroupKickResp_GroupKickRet GroupKickResp::FAIL;
const GroupKickResp_GroupKickRet GroupKickResp::LOCKED;
const GroupKickResp_GroupKickRet GroupKickResp::NOUSER;
const GroupKickResp_GroupKickRet GroupKickResp::NOPOWER;
const GroupKickResp_GroupKickRet GroupKickResp::GroupKickRet_MIN;
const GroupKickResp_GroupKickRet GroupKickResp::GroupKickRet_MAX;
const int GroupKickResp::GroupKickRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupKickResp::kResultFieldNumber;
const int GroupKickResp::kUserSyncFieldNumber;
const int GroupKickResp::kReqFieldNumber;
#endif  // !_MSC_VER

GroupKickResp::GroupKickResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupKickResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::GroupKickReq*>(
      ::GroupKickReq::internal_default_instance());
#else
  req_ = const_cast< ::GroupKickReq*>(&::GroupKickReq::default_instance());
#endif
}

GroupKickResp::GroupKickResp(const GroupKickResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupKickResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  req_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupKickResp::~GroupKickResp() {
  SharedDtor();
}

void GroupKickResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete req_;
  }
}

void GroupKickResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupKickResp& GroupKickResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupKickResp* GroupKickResp::default_instance_ = NULL;

GroupKickResp* GroupKickResp::New() const {
  return new GroupKickResp;
}

void GroupKickResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_req()) {
      if (req_ != NULL) req_->::GroupKickReq::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupKickResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupKickResp.GroupKickRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupKickResp_GroupKickRet_IsValid(value)) {
            set_result(static_cast< ::GroupKickResp_GroupKickRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_req;
        break;
      }

      // optional .GroupKickReq req = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupKickResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupKickResp.GroupKickRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional .GroupKickReq req = 3;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->req(), output);
  }

}

int GroupKickResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupKickResp.GroupKickRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .GroupKickReq req = 3;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupKickResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupKickResp*>(&from));
}

void GroupKickResp::MergeFrom(const GroupKickResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_req()) {
      mutable_req()->::GroupKickReq::MergeFrom(from.req());
    }
  }
}

void GroupKickResp::CopyFrom(const GroupKickResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupKickResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  return true;
}

void GroupKickResp::Swap(GroupKickResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(req_, other->req_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupKickResp::GetTypeName() const {
  return "GroupKickResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupBroadcastReq::kBlurbFieldNumber;
const int GroupBroadcastReq::kBroadcastFieldNumber;
#endif  // !_MSC_VER

GroupBroadcastReq::GroupBroadcastReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupBroadcastReq::InitAsDefaultInstance() {
}

GroupBroadcastReq::GroupBroadcastReq(const GroupBroadcastReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupBroadcastReq::SharedCtor() {
  _cached_size_ = 0;
  blurb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  broadcast_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupBroadcastReq::~GroupBroadcastReq() {
  SharedDtor();
}

void GroupBroadcastReq::SharedDtor() {
  if (blurb_ != &::google::protobuf::internal::kEmptyString) {
    delete blurb_;
  }
  if (broadcast_ != &::google::protobuf::internal::kEmptyString) {
    delete broadcast_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupBroadcastReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupBroadcastReq& GroupBroadcastReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupBroadcastReq* GroupBroadcastReq::default_instance_ = NULL;

GroupBroadcastReq* GroupBroadcastReq::New() const {
  return new GroupBroadcastReq;
}

void GroupBroadcastReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_blurb()) {
      if (blurb_ != &::google::protobuf::internal::kEmptyString) {
        blurb_->clear();
      }
    }
    if (has_broadcast()) {
      if (broadcast_ != &::google::protobuf::internal::kEmptyString) {
        broadcast_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupBroadcastReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string blurb = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_blurb()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_broadcast;
        break;
      }

      // optional string broadcast = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_broadcast:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_broadcast()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupBroadcastReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string blurb = 1;
  if (has_blurb()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->blurb(), output);
  }

  // optional string broadcast = 2;
  if (has_broadcast()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->broadcast(), output);
  }

}

int GroupBroadcastReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string blurb = 1;
    if (has_blurb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->blurb());
    }

    // optional string broadcast = 2;
    if (has_broadcast()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->broadcast());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupBroadcastReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupBroadcastReq*>(&from));
}

void GroupBroadcastReq::MergeFrom(const GroupBroadcastReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_blurb()) {
      set_blurb(from.blurb());
    }
    if (from.has_broadcast()) {
      set_broadcast(from.broadcast());
    }
  }
}

void GroupBroadcastReq::CopyFrom(const GroupBroadcastReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupBroadcastReq::IsInitialized() const {

  return true;
}

void GroupBroadcastReq::Swap(GroupBroadcastReq* other) {
  if (other != this) {
    std::swap(blurb_, other->blurb_);
    std::swap(broadcast_, other->broadcast_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupBroadcastReq::GetTypeName() const {
  return "GroupBroadcastReq";
}


// ===================================================================

bool GroupBroadcastResp_GroupBroadcastRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp::OK;
const GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp::FAIL;
const GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp::DIRTY;
const GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp::NOUSER;
const GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp::NOPOWER;
const GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp::NOTYPE;
const GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp::GroupBroadcastRet_MIN;
const GroupBroadcastResp_GroupBroadcastRet GroupBroadcastResp::GroupBroadcastRet_MAX;
const int GroupBroadcastResp::GroupBroadcastRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupBroadcastResp::kResultFieldNumber;
const int GroupBroadcastResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupBroadcastResp::GroupBroadcastResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupBroadcastResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupBroadcastResp::GroupBroadcastResp(const GroupBroadcastResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupBroadcastResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupBroadcastResp::~GroupBroadcastResp() {
  SharedDtor();
}

void GroupBroadcastResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupBroadcastResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupBroadcastResp& GroupBroadcastResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupBroadcastResp* GroupBroadcastResp::default_instance_ = NULL;

GroupBroadcastResp* GroupBroadcastResp::New() const {
  return new GroupBroadcastResp;
}

void GroupBroadcastResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupBroadcastResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupBroadcastResp.GroupBroadcastRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupBroadcastResp_GroupBroadcastRet_IsValid(value)) {
            set_result(static_cast< ::GroupBroadcastResp_GroupBroadcastRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupBroadcastResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupBroadcastResp.GroupBroadcastRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupBroadcastResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupBroadcastResp.GroupBroadcastRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupBroadcastResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupBroadcastResp*>(&from));
}

void GroupBroadcastResp::MergeFrom(const GroupBroadcastResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupBroadcastResp::CopyFrom(const GroupBroadcastResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupBroadcastResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupBroadcastResp::Swap(GroupBroadcastResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupBroadcastResp::GetTypeName() const {
  return "GroupBroadcastResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupJobReq::kUserNameFieldNumber;
const int GroupJobReq::kJobFieldNumber;
#endif  // !_MSC_VER

GroupJobReq::GroupJobReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupJobReq::InitAsDefaultInstance() {
}

GroupJobReq::GroupJobReq(const GroupJobReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupJobReq::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  job_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupJobReq::~GroupJobReq() {
  SharedDtor();
}

void GroupJobReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupJobReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupJobReq& GroupJobReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupJobReq* GroupJobReq::default_instance_ = NULL;

GroupJobReq* GroupJobReq::New() const {
  return new GroupJobReq;
}

void GroupJobReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    job_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupJobReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_job;
        break;
      }

      // required int32 job = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupJobReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

  // required int32 job = 2;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->job(), output);
  }

}

int GroupJobReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required int32 job = 2;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->job());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupJobReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupJobReq*>(&from));
}

void GroupJobReq::MergeFrom(const GroupJobReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_job()) {
      set_job(from.job());
    }
  }
}

void GroupJobReq::CopyFrom(const GroupJobReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupJobReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupJobReq::Swap(GroupJobReq* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(job_, other->job_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupJobReq::GetTypeName() const {
  return "GroupJobReq";
}


// ===================================================================

bool GroupJobResp_GroupJobRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupJobResp_GroupJobRet GroupJobResp::OK;
const GroupJobResp_GroupJobRet GroupJobResp::FAIL;
const GroupJobResp_GroupJobRet GroupJobResp::NOUSER;
const GroupJobResp_GroupJobRet GroupJobResp::NOPOWER;
const GroupJobResp_GroupJobRet GroupJobResp::ERROR_JOB;
const GroupJobResp_GroupJobRet GroupJobResp::FULL_MANAGER;
const GroupJobResp_GroupJobRet GroupJobResp::SAME_JOB;
const GroupJobResp_GroupJobRet GroupJobResp::GroupJobRet_MIN;
const GroupJobResp_GroupJobRet GroupJobResp::GroupJobRet_MAX;
const int GroupJobResp::GroupJobRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupJobResp::kResultFieldNumber;
const int GroupJobResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupJobResp::GroupJobResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupJobResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupJobResp::GroupJobResp(const GroupJobResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupJobResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupJobResp::~GroupJobResp() {
  SharedDtor();
}

void GroupJobResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupJobResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupJobResp& GroupJobResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupJobResp* GroupJobResp::default_instance_ = NULL;

GroupJobResp* GroupJobResp::New() const {
  return new GroupJobResp;
}

void GroupJobResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupJobResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupJobResp.GroupJobRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupJobResp_GroupJobRet_IsValid(value)) {
            set_result(static_cast< ::GroupJobResp_GroupJobRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupJobResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupJobResp.GroupJobRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupJobResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupJobResp.GroupJobRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupJobResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupJobResp*>(&from));
}

void GroupJobResp::MergeFrom(const GroupJobResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupJobResp::CopyFrom(const GroupJobResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupJobResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupJobResp::Swap(GroupJobResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupJobResp::GetTypeName() const {
  return "GroupJobResp";
}


// ===================================================================

bool GroupDisbandResp_GroupDisbandRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupDisbandResp_GroupDisbandRet GroupDisbandResp::OK;
const GroupDisbandResp_GroupDisbandRet GroupDisbandResp::FAIL;
const GroupDisbandResp_GroupDisbandRet GroupDisbandResp::LOCKED;
const GroupDisbandResp_GroupDisbandRet GroupDisbandResp::NOPOWER;
const GroupDisbandResp_GroupDisbandRet GroupDisbandResp::ERROR;
const GroupDisbandResp_GroupDisbandRet GroupDisbandResp::GroupDisbandRet_MIN;
const GroupDisbandResp_GroupDisbandRet GroupDisbandResp::GroupDisbandRet_MAX;
const int GroupDisbandResp::GroupDisbandRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupDisbandResp::kResultFieldNumber;
const int GroupDisbandResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupDisbandResp::GroupDisbandResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupDisbandResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupDisbandResp::GroupDisbandResp(const GroupDisbandResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupDisbandResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupDisbandResp::~GroupDisbandResp() {
  SharedDtor();
}

void GroupDisbandResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupDisbandResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupDisbandResp& GroupDisbandResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupDisbandResp* GroupDisbandResp::default_instance_ = NULL;

GroupDisbandResp* GroupDisbandResp::New() const {
  return new GroupDisbandResp;
}

void GroupDisbandResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupDisbandResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupDisbandResp.GroupDisbandRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupDisbandResp_GroupDisbandRet_IsValid(value)) {
            set_result(static_cast< ::GroupDisbandResp_GroupDisbandRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupDisbandResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupDisbandResp.GroupDisbandRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupDisbandResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupDisbandResp.GroupDisbandRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupDisbandResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupDisbandResp*>(&from));
}

void GroupDisbandResp::MergeFrom(const GroupDisbandResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupDisbandResp::CopyFrom(const GroupDisbandResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupDisbandResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupDisbandResp::Swap(GroupDisbandResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupDisbandResp::GetTypeName() const {
  return "GroupDisbandResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupSearchReq::kGroupidFieldNumber;
const int GroupSearchReq::kPageFieldNumber;
const int GroupSearchReq::kGroupNameFieldNumber;
#endif  // !_MSC_VER

GroupSearchReq::GroupSearchReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupSearchReq::InitAsDefaultInstance() {
}

GroupSearchReq::GroupSearchReq(const GroupSearchReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupSearchReq::SharedCtor() {
  _cached_size_ = 0;
  groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  page_ = 0;
  group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupSearchReq::~GroupSearchReq() {
  SharedDtor();
}

void GroupSearchReq::SharedDtor() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupSearchReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupSearchReq& GroupSearchReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupSearchReq* GroupSearchReq::default_instance_ = NULL;

GroupSearchReq* GroupSearchReq::New() const {
  return new GroupSearchReq;
}

void GroupSearchReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_groupid()) {
      if (groupid_ != &::google::protobuf::internal::kEmptyString) {
        groupid_->clear();
      }
    }
    page_ = 0;
    if (has_group_name()) {
      if (group_name_ != &::google::protobuf::internal::kEmptyString) {
        group_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupSearchReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string groupid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_groupid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_page;
        break;
      }

      // optional int32 page = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_page:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_group_name;
        break;
      }

      // optional string group_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupSearchReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string groupid = 1;
  if (has_groupid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->groupid(), output);
  }

  // optional int32 page = 2;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->page(), output);
  }

  // optional string group_name = 3;
  if (has_group_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->group_name(), output);
  }

}

int GroupSearchReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string groupid = 1;
    if (has_groupid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->groupid());
    }

    // optional int32 page = 2;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

    // optional string group_name = 3;
    if (has_group_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupSearchReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupSearchReq*>(&from));
}

void GroupSearchReq::MergeFrom(const GroupSearchReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_groupid()) {
      set_groupid(from.groupid());
    }
    if (from.has_page()) {
      set_page(from.page());
    }
    if (from.has_group_name()) {
      set_group_name(from.group_name());
    }
  }
}

void GroupSearchReq::CopyFrom(const GroupSearchReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupSearchReq::IsInitialized() const {

  return true;
}

void GroupSearchReq::Swap(GroupSearchReq* other) {
  if (other != this) {
    std::swap(groupid_, other->groupid_);
    std::swap(page_, other->page_);
    std::swap(group_name_, other->group_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupSearchReq::GetTypeName() const {
  return "GroupSearchReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupSearchResp::kResultFieldNumber;
const int GroupSearchResp::kUserSyncFieldNumber;
const int GroupSearchResp::kGroupListFieldNumber;
const int GroupSearchResp::kTotalPageFieldNumber;
#endif  // !_MSC_VER

GroupSearchResp::GroupSearchResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupSearchResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupSearchResp::GroupSearchResp(const GroupSearchResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupSearchResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  total_page_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupSearchResp::~GroupSearchResp() {
  SharedDtor();
}

void GroupSearchResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupSearchResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupSearchResp& GroupSearchResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupSearchResp* GroupSearchResp::default_instance_ = NULL;

GroupSearchResp* GroupSearchResp::New() const {
  return new GroupSearchResp;
}

void GroupSearchResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    total_page_ = 0;
  }
  group_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupSearchResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_group_list;
        break;
      }

      // repeated .GroupMainData group_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_group_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_group_list;
        if (input->ExpectTag(32)) goto parse_total_page;
        break;
      }

      // optional int32 total_page = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_total_page:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_page_)));
          set_has_total_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupSearchResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .GroupMainData group_list = 3;
  for (int i = 0; i < this->group_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->group_list(i), output);
  }

  // optional int32 total_page = 4;
  if (has_total_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->total_page(), output);
  }

}

int GroupSearchResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 total_page = 4;
    if (has_total_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->total_page());
    }

  }
  // repeated .GroupMainData group_list = 3;
  total_size += 1 * this->group_list_size();
  for (int i = 0; i < this->group_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->group_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupSearchResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupSearchResp*>(&from));
}

void GroupSearchResp::MergeFrom(const GroupSearchResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  group_list_.MergeFrom(from.group_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_total_page()) {
      set_total_page(from.total_page());
    }
  }
}

void GroupSearchResp::CopyFrom(const GroupSearchResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupSearchResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < group_list_size(); i++) {
    if (!this->group_list(i).IsInitialized()) return false;
  }
  return true;
}

void GroupSearchResp::Swap(GroupSearchResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    group_list_.Swap(&other->group_list_);
    std::swap(total_page_, other->total_page_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupSearchResp::GetTypeName() const {
  return "GroupSearchResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupContributeReq::kTypeFieldNumber;
const int GroupContributeReq::kTechIdFieldNumber;
#endif  // !_MSC_VER

GroupContributeReq::GroupContributeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupContributeReq::InitAsDefaultInstance() {
}

GroupContributeReq::GroupContributeReq(const GroupContributeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupContributeReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  tech_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupContributeReq::~GroupContributeReq() {
  SharedDtor();
}

void GroupContributeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupContributeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupContributeReq& GroupContributeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupContributeReq* GroupContributeReq::default_instance_ = NULL;

GroupContributeReq* GroupContributeReq::New() const {
  return new GroupContributeReq;
}

void GroupContributeReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    tech_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupContributeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_tech_id;
        break;
      }

      // required int32 tech_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tech_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tech_id_)));
          set_has_tech_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupContributeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required int32 tech_id = 2;
  if (has_tech_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->tech_id(), output);
  }

}

int GroupContributeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required int32 tech_id = 2;
    if (has_tech_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tech_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupContributeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupContributeReq*>(&from));
}

void GroupContributeReq::MergeFrom(const GroupContributeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_tech_id()) {
      set_tech_id(from.tech_id());
    }
  }
}

void GroupContributeReq::CopyFrom(const GroupContributeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupContributeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupContributeReq::Swap(GroupContributeReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(tech_id_, other->tech_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupContributeReq::GetTypeName() const {
  return "GroupContributeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupContributeResp::kResultFieldNumber;
const int GroupContributeResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupContributeResp::GroupContributeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupContributeResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupContributeResp::GroupContributeResp(const GroupContributeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupContributeResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupContributeResp::~GroupContributeResp() {
  SharedDtor();
}

void GroupContributeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupContributeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupContributeResp& GroupContributeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupContributeResp* GroupContributeResp::default_instance_ = NULL;

GroupContributeResp* GroupContributeResp::New() const {
  return new GroupContributeResp;
}

void GroupContributeResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupContributeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupContributeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupContributeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupContributeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupContributeResp*>(&from));
}

void GroupContributeResp::MergeFrom(const GroupContributeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupContributeResp::CopyFrom(const GroupContributeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupContributeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupContributeResp::Swap(GroupContributeResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupContributeResp::GetTypeName() const {
  return "GroupContributeResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupContributeCDResp::kResultFieldNumber;
const int GroupContributeCDResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupContributeCDResp::GroupContributeCDResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupContributeCDResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupContributeCDResp::GroupContributeCDResp(const GroupContributeCDResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupContributeCDResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupContributeCDResp::~GroupContributeCDResp() {
  SharedDtor();
}

void GroupContributeCDResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupContributeCDResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupContributeCDResp& GroupContributeCDResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupContributeCDResp* GroupContributeCDResp::default_instance_ = NULL;

GroupContributeCDResp* GroupContributeCDResp::New() const {
  return new GroupContributeCDResp;
}

void GroupContributeCDResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupContributeCDResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupContributeCDResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupContributeCDResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupContributeCDResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupContributeCDResp*>(&from));
}

void GroupContributeCDResp::MergeFrom(const GroupContributeCDResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupContributeCDResp::CopyFrom(const GroupContributeCDResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupContributeCDResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupContributeCDResp::Swap(GroupContributeCDResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupContributeCDResp::GetTypeName() const {
  return "GroupContributeCDResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupTechLevelupReq::kTechIdFieldNumber;
#endif  // !_MSC_VER

GroupTechLevelupReq::GroupTechLevelupReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupTechLevelupReq::InitAsDefaultInstance() {
}

GroupTechLevelupReq::GroupTechLevelupReq(const GroupTechLevelupReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupTechLevelupReq::SharedCtor() {
  _cached_size_ = 0;
  tech_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupTechLevelupReq::~GroupTechLevelupReq() {
  SharedDtor();
}

void GroupTechLevelupReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupTechLevelupReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupTechLevelupReq& GroupTechLevelupReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupTechLevelupReq* GroupTechLevelupReq::default_instance_ = NULL;

GroupTechLevelupReq* GroupTechLevelupReq::New() const {
  return new GroupTechLevelupReq;
}

void GroupTechLevelupReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tech_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupTechLevelupReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 tech_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tech_id_)));
          set_has_tech_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupTechLevelupReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 tech_id = 1;
  if (has_tech_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->tech_id(), output);
  }

}

int GroupTechLevelupReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 tech_id = 1;
    if (has_tech_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tech_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupTechLevelupReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupTechLevelupReq*>(&from));
}

void GroupTechLevelupReq::MergeFrom(const GroupTechLevelupReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tech_id()) {
      set_tech_id(from.tech_id());
    }
  }
}

void GroupTechLevelupReq::CopyFrom(const GroupTechLevelupReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupTechLevelupReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GroupTechLevelupReq::Swap(GroupTechLevelupReq* other) {
  if (other != this) {
    std::swap(tech_id_, other->tech_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupTechLevelupReq::GetTypeName() const {
  return "GroupTechLevelupReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupTechLevelupResp::kResultFieldNumber;
const int GroupTechLevelupResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupTechLevelupResp::GroupTechLevelupResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupTechLevelupResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupTechLevelupResp::GroupTechLevelupResp(const GroupTechLevelupResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupTechLevelupResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupTechLevelupResp::~GroupTechLevelupResp() {
  SharedDtor();
}

void GroupTechLevelupResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupTechLevelupResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupTechLevelupResp& GroupTechLevelupResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupTechLevelupResp* GroupTechLevelupResp::default_instance_ = NULL;

GroupTechLevelupResp* GroupTechLevelupResp::New() const {
  return new GroupTechLevelupResp;
}

void GroupTechLevelupResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupTechLevelupResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupTechLevelupResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupTechLevelupResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupTechLevelupResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupTechLevelupResp*>(&from));
}

void GroupTechLevelupResp::MergeFrom(const GroupTechLevelupResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupTechLevelupResp::CopyFrom(const GroupTechLevelupResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupTechLevelupResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupTechLevelupResp::Swap(GroupTechLevelupResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupTechLevelupResp::GetTypeName() const {
  return "GroupTechLevelupResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupGetTechReq::kTechIdFieldNumber;
#endif  // !_MSC_VER

GroupGetTechReq::GroupGetTechReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupGetTechReq::InitAsDefaultInstance() {
}

GroupGetTechReq::GroupGetTechReq(const GroupGetTechReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupGetTechReq::SharedCtor() {
  _cached_size_ = 0;
  tech_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupGetTechReq::~GroupGetTechReq() {
  SharedDtor();
}

void GroupGetTechReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupGetTechReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupGetTechReq& GroupGetTechReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupGetTechReq* GroupGetTechReq::default_instance_ = NULL;

GroupGetTechReq* GroupGetTechReq::New() const {
  return new GroupGetTechReq;
}

void GroupGetTechReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tech_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupGetTechReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 tech_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tech_id_)));
          set_has_tech_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupGetTechReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 tech_id = 1;
  if (has_tech_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->tech_id(), output);
  }

}

int GroupGetTechReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 tech_id = 1;
    if (has_tech_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tech_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupGetTechReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupGetTechReq*>(&from));
}

void GroupGetTechReq::MergeFrom(const GroupGetTechReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tech_id()) {
      set_tech_id(from.tech_id());
    }
  }
}

void GroupGetTechReq::CopyFrom(const GroupGetTechReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupGetTechReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GroupGetTechReq::Swap(GroupGetTechReq* other) {
  if (other != this) {
    std::swap(tech_id_, other->tech_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupGetTechReq::GetTypeName() const {
  return "GroupGetTechReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupGetTechResp::kResultFieldNumber;
const int GroupGetTechResp::kUserSyncFieldNumber;
const int GroupGetTechResp::kGroupTechFieldNumber;
#endif  // !_MSC_VER

GroupGetTechResp::GroupGetTechResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupGetTechResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_tech_ = const_cast< ::GroupTechnology*>(
      ::GroupTechnology::internal_default_instance());
#else
  group_tech_ = const_cast< ::GroupTechnology*>(&::GroupTechnology::default_instance());
#endif
}

GroupGetTechResp::GroupGetTechResp(const GroupGetTechResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupGetTechResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  group_tech_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupGetTechResp::~GroupGetTechResp() {
  SharedDtor();
}

void GroupGetTechResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete group_tech_;
  }
}

void GroupGetTechResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupGetTechResp& GroupGetTechResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupGetTechResp* GroupGetTechResp::default_instance_ = NULL;

GroupGetTechResp* GroupGetTechResp::New() const {
  return new GroupGetTechResp;
}

void GroupGetTechResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_group_tech()) {
      if (group_tech_ != NULL) group_tech_->::GroupTechnology::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupGetTechResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_group_tech;
        break;
      }

      // optional .GroupTechnology group_tech = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group_tech:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group_tech()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupGetTechResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional .GroupTechnology group_tech = 3;
  if (has_group_tech()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->group_tech(), output);
  }

}

int GroupGetTechResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .GroupTechnology group_tech = 3;
    if (has_group_tech()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group_tech());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupGetTechResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupGetTechResp*>(&from));
}

void GroupGetTechResp::MergeFrom(const GroupGetTechResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_group_tech()) {
      mutable_group_tech()->::GroupTechnology::MergeFrom(from.group_tech());
    }
  }
}

void GroupGetTechResp::CopyFrom(const GroupGetTechResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupGetTechResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  if (has_group_tech()) {
    if (!this->group_tech().IsInitialized()) return false;
  }
  return true;
}

void GroupGetTechResp::Swap(GroupGetTechResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(group_tech_, other->group_tech_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupGetTechResp::GetTypeName() const {
  return "GroupGetTechResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupLevelupResp::kResultFieldNumber;
const int GroupLevelupResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupLevelupResp::GroupLevelupResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupLevelupResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupLevelupResp::GroupLevelupResp(const GroupLevelupResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupLevelupResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupLevelupResp::~GroupLevelupResp() {
  SharedDtor();
}

void GroupLevelupResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupLevelupResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupLevelupResp& GroupLevelupResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupLevelupResp* GroupLevelupResp::default_instance_ = NULL;

GroupLevelupResp* GroupLevelupResp::New() const {
  return new GroupLevelupResp;
}

void GroupLevelupResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupLevelupResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupLevelupResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupLevelupResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupLevelupResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupLevelupResp*>(&from));
}

void GroupLevelupResp::MergeFrom(const GroupLevelupResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupLevelupResp::CopyFrom(const GroupLevelupResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupLevelupResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupLevelupResp::Swap(GroupLevelupResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupLevelupResp::GetTypeName() const {
  return "GroupLevelupResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupPVEGetInfoReq::kGroupBossIdFieldNumber;
#endif  // !_MSC_VER

GroupPVEGetInfoReq::GroupPVEGetInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupPVEGetInfoReq::InitAsDefaultInstance() {
}

GroupPVEGetInfoReq::GroupPVEGetInfoReq(const GroupPVEGetInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupPVEGetInfoReq::SharedCtor() {
  _cached_size_ = 0;
  group_boss_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupPVEGetInfoReq::~GroupPVEGetInfoReq() {
  SharedDtor();
}

void GroupPVEGetInfoReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupPVEGetInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupPVEGetInfoReq& GroupPVEGetInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupPVEGetInfoReq* GroupPVEGetInfoReq::default_instance_ = NULL;

GroupPVEGetInfoReq* GroupPVEGetInfoReq::New() const {
  return new GroupPVEGetInfoReq;
}

void GroupPVEGetInfoReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    group_boss_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupPVEGetInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 group_boss_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &group_boss_id_)));
          set_has_group_boss_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupPVEGetInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 group_boss_id = 1;
  if (has_group_boss_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->group_boss_id(), output);
  }

}

int GroupPVEGetInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 group_boss_id = 1;
    if (has_group_boss_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->group_boss_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupPVEGetInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupPVEGetInfoReq*>(&from));
}

void GroupPVEGetInfoReq::MergeFrom(const GroupPVEGetInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_boss_id()) {
      set_group_boss_id(from.group_boss_id());
    }
  }
}

void GroupPVEGetInfoReq::CopyFrom(const GroupPVEGetInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPVEGetInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GroupPVEGetInfoReq::Swap(GroupPVEGetInfoReq* other) {
  if (other != this) {
    std::swap(group_boss_id_, other->group_boss_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupPVEGetInfoReq::GetTypeName() const {
  return "GroupPVEGetInfoReq";
}


// ===================================================================

bool GroupPVEGetInfoResp_GroupPVEGetInfoRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupPVEGetInfoResp_GroupPVEGetInfoRet GroupPVEGetInfoResp::OK;
const GroupPVEGetInfoResp_GroupPVEGetInfoRet GroupPVEGetInfoResp::FAIL;
const GroupPVEGetInfoResp_GroupPVEGetInfoRet GroupPVEGetInfoResp::NO_GROUP;
const GroupPVEGetInfoResp_GroupPVEGetInfoRet GroupPVEGetInfoResp::GroupPVEGetInfoRet_MIN;
const GroupPVEGetInfoResp_GroupPVEGetInfoRet GroupPVEGetInfoResp::GroupPVEGetInfoRet_MAX;
const int GroupPVEGetInfoResp::GroupPVEGetInfoRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupPVEGetInfoResp::kResultFieldNumber;
const int GroupPVEGetInfoResp::kUserSyncFieldNumber;
const int GroupPVEGetInfoResp::kInfoFieldNumber;
#endif  // !_MSC_VER

GroupPVEGetInfoResp::GroupPVEGetInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupPVEGetInfoResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  info_ = const_cast< ::GroupPVECheckpoint*>(
      ::GroupPVECheckpoint::internal_default_instance());
#else
  info_ = const_cast< ::GroupPVECheckpoint*>(&::GroupPVECheckpoint::default_instance());
#endif
}

GroupPVEGetInfoResp::GroupPVEGetInfoResp(const GroupPVEGetInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupPVEGetInfoResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupPVEGetInfoResp::~GroupPVEGetInfoResp() {
  SharedDtor();
}

void GroupPVEGetInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete info_;
  }
}

void GroupPVEGetInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupPVEGetInfoResp& GroupPVEGetInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupPVEGetInfoResp* GroupPVEGetInfoResp::default_instance_ = NULL;

GroupPVEGetInfoResp* GroupPVEGetInfoResp::New() const {
  return new GroupPVEGetInfoResp;
}

void GroupPVEGetInfoResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_info()) {
      if (info_ != NULL) info_->::GroupPVECheckpoint::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupPVEGetInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupPVEGetInfoResp.GroupPVEGetInfoRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupPVEGetInfoResp_GroupPVEGetInfoRet_IsValid(value)) {
            set_result(static_cast< ::GroupPVEGetInfoResp_GroupPVEGetInfoRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_info;
        break;
      }

      // optional .GroupPVECheckpoint info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupPVEGetInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupPVEGetInfoResp.GroupPVEGetInfoRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional .GroupPVECheckpoint info = 3;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->info(), output);
  }

}

int GroupPVEGetInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupPVEGetInfoResp.GroupPVEGetInfoRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .GroupPVECheckpoint info = 3;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupPVEGetInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupPVEGetInfoResp*>(&from));
}

void GroupPVEGetInfoResp::MergeFrom(const GroupPVEGetInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_info()) {
      mutable_info()->::GroupPVECheckpoint::MergeFrom(from.info());
    }
  }
}

void GroupPVEGetInfoResp::CopyFrom(const GroupPVEGetInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPVEGetInfoResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void GroupPVEGetInfoResp::Swap(GroupPVEGetInfoResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupPVEGetInfoResp::GetTypeName() const {
  return "GroupPVEGetInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupPVEReq::kGroupBossIdFieldNumber;
#endif  // !_MSC_VER

GroupPVEReq::GroupPVEReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupPVEReq::InitAsDefaultInstance() {
}

GroupPVEReq::GroupPVEReq(const GroupPVEReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupPVEReq::SharedCtor() {
  _cached_size_ = 0;
  group_boss_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupPVEReq::~GroupPVEReq() {
  SharedDtor();
}

void GroupPVEReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupPVEReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupPVEReq& GroupPVEReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupPVEReq* GroupPVEReq::default_instance_ = NULL;

GroupPVEReq* GroupPVEReq::New() const {
  return new GroupPVEReq;
}

void GroupPVEReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    group_boss_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupPVEReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 group_boss_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &group_boss_id_)));
          set_has_group_boss_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupPVEReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 group_boss_id = 1;
  if (has_group_boss_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->group_boss_id(), output);
  }

}

int GroupPVEReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 group_boss_id = 1;
    if (has_group_boss_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->group_boss_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupPVEReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupPVEReq*>(&from));
}

void GroupPVEReq::MergeFrom(const GroupPVEReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_boss_id()) {
      set_group_boss_id(from.group_boss_id());
    }
  }
}

void GroupPVEReq::CopyFrom(const GroupPVEReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPVEReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GroupPVEReq::Swap(GroupPVEReq* other) {
  if (other != this) {
    std::swap(group_boss_id_, other->group_boss_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupPVEReq::GetTypeName() const {
  return "GroupPVEReq";
}


// ===================================================================

bool GroupPVEResp_GroupPVERet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupPVEResp_GroupPVERet GroupPVEResp::OK;
const GroupPVEResp_GroupPVERet GroupPVEResp::FAIL;
const GroupPVEResp_GroupPVERet GroupPVEResp::GROUP_LEVEL;
const GroupPVEResp_GroupPVERet GroupPVEResp::TIME_OUT;
const GroupPVEResp_GroupPVERet GroupPVEResp::WDAY;
const GroupPVEResp_GroupPVERet GroupPVEResp::CHALLENGE_TIMES;
const GroupPVEResp_GroupPVERet GroupPVEResp::NO_DURABEL;
const GroupPVEResp_GroupPVERet GroupPVEResp::SHIP_FIXING;
const GroupPVEResp_GroupPVERet GroupPVEResp::NO_STRENGTH;
const GroupPVEResp_GroupPVERet GroupPVEResp::DEAD;
const GroupPVEResp_GroupPVERet GroupPVEResp::NO_GROUP;
const GroupPVEResp_GroupPVERet GroupPVEResp::NO_DATA;
const GroupPVEResp_GroupPVERet GroupPVEResp::SHIP_OUTING;
const GroupPVEResp_GroupPVERet GroupPVEResp::GroupPVERet_MIN;
const GroupPVEResp_GroupPVERet GroupPVEResp::GroupPVERet_MAX;
const int GroupPVEResp::GroupPVERet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupPVEResp::kResultFieldNumber;
const int GroupPVEResp::kUserSyncFieldNumber;
const int GroupPVEResp::kAttackListFieldNumber;
const int GroupPVEResp::kHurterListFieldNumber;
const int GroupPVEResp::kHurterHpListFieldNumber;
const int GroupPVEResp::kGroupBossIdFieldNumber;
#endif  // !_MSC_VER

GroupPVEResp::GroupPVEResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupPVEResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupPVEResp::GroupPVEResp(const GroupPVEResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupPVEResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  group_boss_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupPVEResp::~GroupPVEResp() {
  SharedDtor();
}

void GroupPVEResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupPVEResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupPVEResp& GroupPVEResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupPVEResp* GroupPVEResp::default_instance_ = NULL;

GroupPVEResp* GroupPVEResp::New() const {
  return new GroupPVEResp;
}

void GroupPVEResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    group_boss_id_ = 0;
  }
  attack_list_.Clear();
  hurter_list_.Clear();
  hurter_hp_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupPVEResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupPVEResp.GroupPVERet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupPVEResp_GroupPVERet_IsValid(value)) {
            set_result(static_cast< ::GroupPVEResp_GroupPVERet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_attack_list;
        break;
      }

      // repeated .AirShip attack_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attack_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_attack_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_attack_list;
        if (input->ExpectTag(34)) goto parse_hurter_list;
        break;
      }

      // repeated .AirShip hurter_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hurter_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_hurter_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_hurter_list;
        if (input->ExpectTag(40)) goto parse_hurter_hp_list;
        break;
      }

      // repeated int32 hurter_hp_list = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hurter_hp_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 40, input, this->mutable_hurter_hp_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_hurter_hp_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_hurter_hp_list;
        if (input->ExpectTag(48)) goto parse_group_boss_id;
        break;
      }

      // optional int32 group_boss_id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_group_boss_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &group_boss_id_)));
          set_has_group_boss_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupPVEResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupPVEResp.GroupPVERet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .AirShip attack_list = 3;
  for (int i = 0; i < this->attack_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->attack_list(i), output);
  }

  // repeated .AirShip hurter_list = 4;
  for (int i = 0; i < this->hurter_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->hurter_list(i), output);
  }

  // repeated int32 hurter_hp_list = 5;
  for (int i = 0; i < this->hurter_hp_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      5, this->hurter_hp_list(i), output);
  }

  // optional int32 group_boss_id = 6;
  if (has_group_boss_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->group_boss_id(), output);
  }

}

int GroupPVEResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupPVEResp.GroupPVERet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 group_boss_id = 6;
    if (has_group_boss_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->group_boss_id());
    }

  }
  // repeated .AirShip attack_list = 3;
  total_size += 1 * this->attack_list_size();
  for (int i = 0; i < this->attack_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attack_list(i));
  }

  // repeated .AirShip hurter_list = 4;
  total_size += 1 * this->hurter_list_size();
  for (int i = 0; i < this->hurter_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->hurter_list(i));
  }

  // repeated int32 hurter_hp_list = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->hurter_hp_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->hurter_hp_list(i));
    }
    total_size += 1 * this->hurter_hp_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupPVEResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupPVEResp*>(&from));
}

void GroupPVEResp::MergeFrom(const GroupPVEResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  attack_list_.MergeFrom(from.attack_list_);
  hurter_list_.MergeFrom(from.hurter_list_);
  hurter_hp_list_.MergeFrom(from.hurter_hp_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_group_boss_id()) {
      set_group_boss_id(from.group_boss_id());
    }
  }
}

void GroupPVEResp::CopyFrom(const GroupPVEResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPVEResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < attack_list_size(); i++) {
    if (!this->attack_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < hurter_list_size(); i++) {
    if (!this->hurter_list(i).IsInitialized()) return false;
  }
  return true;
}

void GroupPVEResp::Swap(GroupPVEResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    attack_list_.Swap(&other->attack_list_);
    hurter_list_.Swap(&other->hurter_list_);
    hurter_hp_list_.Swap(&other->hurter_hp_list_);
    std::swap(group_boss_id_, other->group_boss_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupPVEResp::GetTypeName() const {
  return "GroupPVEResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupPVEOKReq::kGroupBossIdFieldNumber;
const int GroupPVEOKReq::kResultFieldNumber;
const int GroupPVEOKReq::kHurterHpListFieldNumber;
#endif  // !_MSC_VER

GroupPVEOKReq::GroupPVEOKReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupPVEOKReq::InitAsDefaultInstance() {
}

GroupPVEOKReq::GroupPVEOKReq(const GroupPVEOKReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupPVEOKReq::SharedCtor() {
  _cached_size_ = 0;
  group_boss_id_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupPVEOKReq::~GroupPVEOKReq() {
  SharedDtor();
}

void GroupPVEOKReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupPVEOKReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupPVEOKReq& GroupPVEOKReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupPVEOKReq* GroupPVEOKReq::default_instance_ = NULL;

GroupPVEOKReq* GroupPVEOKReq::New() const {
  return new GroupPVEOKReq;
}

void GroupPVEOKReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    group_boss_id_ = 0;
    result_ = 0;
  }
  hurter_hp_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupPVEOKReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 group_boss_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &group_boss_id_)));
          set_has_group_boss_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_result;
        break;
      }

      // required int32 result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_hurter_hp_list;
        break;
      }

      // repeated int32 hurter_hp_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hurter_hp_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_hurter_hp_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_hurter_hp_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_hurter_hp_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupPVEOKReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 group_boss_id = 1;
  if (has_group_boss_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->group_boss_id(), output);
  }

  // required int32 result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->result(), output);
  }

  // repeated int32 hurter_hp_list = 3;
  for (int i = 0; i < this->hurter_hp_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->hurter_hp_list(i), output);
  }

}

int GroupPVEOKReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 group_boss_id = 1;
    if (has_group_boss_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->group_boss_id());
    }

    // required int32 result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  // repeated int32 hurter_hp_list = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->hurter_hp_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->hurter_hp_list(i));
    }
    total_size += 1 * this->hurter_hp_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupPVEOKReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupPVEOKReq*>(&from));
}

void GroupPVEOKReq::MergeFrom(const GroupPVEOKReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  hurter_hp_list_.MergeFrom(from.hurter_hp_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_boss_id()) {
      set_group_boss_id(from.group_boss_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void GroupPVEOKReq::CopyFrom(const GroupPVEOKReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPVEOKReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupPVEOKReq::Swap(GroupPVEOKReq* other) {
  if (other != this) {
    std::swap(group_boss_id_, other->group_boss_id_);
    std::swap(result_, other->result_);
    hurter_hp_list_.Swap(&other->hurter_hp_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupPVEOKReq::GetTypeName() const {
  return "GroupPVEOKReq";
}


// ===================================================================

bool GroupPVEOKResp_GroupPVEOKRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp::OK;
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp::FAIL;
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp::NO_DATA;
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp::HP_LIST_ERROR0;
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp::HP_LIST_ERROR1;
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp::NO_GROUP;
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp::ERROR_RESULT;
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp::GroupPVEOKRet_MIN;
const GroupPVEOKResp_GroupPVEOKRet GroupPVEOKResp::GroupPVEOKRet_MAX;
const int GroupPVEOKResp::GroupPVEOKRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupPVEOKResp::kResultFieldNumber;
const int GroupPVEOKResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GroupPVEOKResp::GroupPVEOKResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupPVEOKResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupPVEOKResp::GroupPVEOKResp(const GroupPVEOKResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupPVEOKResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupPVEOKResp::~GroupPVEOKResp() {
  SharedDtor();
}

void GroupPVEOKResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupPVEOKResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupPVEOKResp& GroupPVEOKResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupPVEOKResp* GroupPVEOKResp::default_instance_ = NULL;

GroupPVEOKResp* GroupPVEOKResp::New() const {
  return new GroupPVEOKResp;
}

void GroupPVEOKResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupPVEOKResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupPVEOKResp.GroupPVEOKRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupPVEOKResp_GroupPVEOKRet_IsValid(value)) {
            set_result(static_cast< ::GroupPVEOKResp_GroupPVEOKRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupPVEOKResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupPVEOKResp.GroupPVEOKRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GroupPVEOKResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupPVEOKResp.GroupPVEOKRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupPVEOKResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupPVEOKResp*>(&from));
}

void GroupPVEOKResp::MergeFrom(const GroupPVEOKResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupPVEOKResp::CopyFrom(const GroupPVEOKResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPVEOKResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GroupPVEOKResp::Swap(GroupPVEOKResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupPVEOKResp::GetTypeName() const {
  return "GroupPVEOKResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupPVEAddTimsReq::kGroupBossIdFieldNumber;
const int GroupPVEAddTimsReq::kTimesFieldNumber;
#endif  // !_MSC_VER

GroupPVEAddTimsReq::GroupPVEAddTimsReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupPVEAddTimsReq::InitAsDefaultInstance() {
}

GroupPVEAddTimsReq::GroupPVEAddTimsReq(const GroupPVEAddTimsReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupPVEAddTimsReq::SharedCtor() {
  _cached_size_ = 0;
  group_boss_id_ = 0;
  times_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupPVEAddTimsReq::~GroupPVEAddTimsReq() {
  SharedDtor();
}

void GroupPVEAddTimsReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupPVEAddTimsReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupPVEAddTimsReq& GroupPVEAddTimsReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupPVEAddTimsReq* GroupPVEAddTimsReq::default_instance_ = NULL;

GroupPVEAddTimsReq* GroupPVEAddTimsReq::New() const {
  return new GroupPVEAddTimsReq;
}

void GroupPVEAddTimsReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    group_boss_id_ = 0;
    times_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupPVEAddTimsReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 group_boss_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &group_boss_id_)));
          set_has_group_boss_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_times;
        break;
      }

      // required int32 times = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &times_)));
          set_has_times();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupPVEAddTimsReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 group_boss_id = 1;
  if (has_group_boss_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->group_boss_id(), output);
  }

  // required int32 times = 2;
  if (has_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->times(), output);
  }

}

int GroupPVEAddTimsReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 group_boss_id = 1;
    if (has_group_boss_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->group_boss_id());
    }

    // required int32 times = 2;
    if (has_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->times());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupPVEAddTimsReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupPVEAddTimsReq*>(&from));
}

void GroupPVEAddTimsReq::MergeFrom(const GroupPVEAddTimsReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_boss_id()) {
      set_group_boss_id(from.group_boss_id());
    }
    if (from.has_times()) {
      set_times(from.times());
    }
  }
}

void GroupPVEAddTimsReq::CopyFrom(const GroupPVEAddTimsReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPVEAddTimsReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupPVEAddTimsReq::Swap(GroupPVEAddTimsReq* other) {
  if (other != this) {
    std::swap(group_boss_id_, other->group_boss_id_);
    std::swap(times_, other->times_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupPVEAddTimsReq::GetTypeName() const {
  return "GroupPVEAddTimsReq";
}


// ===================================================================

bool GroupPVEAddTimsResp_GroupPVEAddTimsRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp::OK;
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp::FAIL;
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp::NO_GROUP;
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp::NO_DATA;
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp::MAX_TIMES;
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp::ERROR_TIMES;
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp::NO_MONEY;
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp::GroupPVEAddTimsRet_MIN;
const GroupPVEAddTimsResp_GroupPVEAddTimsRet GroupPVEAddTimsResp::GroupPVEAddTimsRet_MAX;
const int GroupPVEAddTimsResp::GroupPVEAddTimsRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupPVEAddTimsResp::kResultFieldNumber;
const int GroupPVEAddTimsResp::kUserSyncFieldNumber;
const int GroupPVEAddTimsResp::kReqFieldNumber;
#endif  // !_MSC_VER

GroupPVEAddTimsResp::GroupPVEAddTimsResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupPVEAddTimsResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::GroupPVEAddTimsReq*>(
      ::GroupPVEAddTimsReq::internal_default_instance());
#else
  req_ = const_cast< ::GroupPVEAddTimsReq*>(&::GroupPVEAddTimsReq::default_instance());
#endif
}

GroupPVEAddTimsResp::GroupPVEAddTimsResp(const GroupPVEAddTimsResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupPVEAddTimsResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  req_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupPVEAddTimsResp::~GroupPVEAddTimsResp() {
  SharedDtor();
}

void GroupPVEAddTimsResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete req_;
  }
}

void GroupPVEAddTimsResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupPVEAddTimsResp& GroupPVEAddTimsResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupPVEAddTimsResp* GroupPVEAddTimsResp::default_instance_ = NULL;

GroupPVEAddTimsResp* GroupPVEAddTimsResp::New() const {
  return new GroupPVEAddTimsResp;
}

void GroupPVEAddTimsResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_req()) {
      if (req_ != NULL) req_->::GroupPVEAddTimsReq::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupPVEAddTimsResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupPVEAddTimsResp.GroupPVEAddTimsRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupPVEAddTimsResp_GroupPVEAddTimsRet_IsValid(value)) {
            set_result(static_cast< ::GroupPVEAddTimsResp_GroupPVEAddTimsRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_req;
        break;
      }

      // optional .GroupPVEAddTimsReq req = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupPVEAddTimsResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupPVEAddTimsResp.GroupPVEAddTimsRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional .GroupPVEAddTimsReq req = 3;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->req(), output);
  }

}

int GroupPVEAddTimsResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupPVEAddTimsResp.GroupPVEAddTimsRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .GroupPVEAddTimsReq req = 3;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupPVEAddTimsResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupPVEAddTimsResp*>(&from));
}

void GroupPVEAddTimsResp::MergeFrom(const GroupPVEAddTimsResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_req()) {
      mutable_req()->::GroupPVEAddTimsReq::MergeFrom(from.req());
    }
  }
}

void GroupPVEAddTimsResp::CopyFrom(const GroupPVEAddTimsResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPVEAddTimsResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  return true;
}

void GroupPVEAddTimsResp::Swap(GroupPVEAddTimsResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(req_, other->req_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupPVEAddTimsResp::GetTypeName() const {
  return "GroupPVEAddTimsResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupPVERewardReq::kGroupBossIdFieldNumber;
const int GroupPVERewardReq::kRewardIndexFieldNumber;
#endif  // !_MSC_VER

GroupPVERewardReq::GroupPVERewardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupPVERewardReq::InitAsDefaultInstance() {
}

GroupPVERewardReq::GroupPVERewardReq(const GroupPVERewardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupPVERewardReq::SharedCtor() {
  _cached_size_ = 0;
  group_boss_id_ = 0;
  reward_index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupPVERewardReq::~GroupPVERewardReq() {
  SharedDtor();
}

void GroupPVERewardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupPVERewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupPVERewardReq& GroupPVERewardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupPVERewardReq* GroupPVERewardReq::default_instance_ = NULL;

GroupPVERewardReq* GroupPVERewardReq::New() const {
  return new GroupPVERewardReq;
}

void GroupPVERewardReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    group_boss_id_ = 0;
    reward_index_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupPVERewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 group_boss_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &group_boss_id_)));
          set_has_group_boss_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_reward_index;
        break;
      }

      // required int32 reward_index = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reward_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reward_index_)));
          set_has_reward_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupPVERewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 group_boss_id = 1;
  if (has_group_boss_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->group_boss_id(), output);
  }

  // required int32 reward_index = 2;
  if (has_reward_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->reward_index(), output);
  }

}

int GroupPVERewardReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 group_boss_id = 1;
    if (has_group_boss_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->group_boss_id());
    }

    // required int32 reward_index = 2;
    if (has_reward_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reward_index());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupPVERewardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupPVERewardReq*>(&from));
}

void GroupPVERewardReq::MergeFrom(const GroupPVERewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_boss_id()) {
      set_group_boss_id(from.group_boss_id());
    }
    if (from.has_reward_index()) {
      set_reward_index(from.reward_index());
    }
  }
}

void GroupPVERewardReq::CopyFrom(const GroupPVERewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPVERewardReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupPVERewardReq::Swap(GroupPVERewardReq* other) {
  if (other != this) {
    std::swap(group_boss_id_, other->group_boss_id_);
    std::swap(reward_index_, other->reward_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupPVERewardReq::GetTypeName() const {
  return "GroupPVERewardReq";
}


// ===================================================================

bool GroupPVERewardResp_GroupPVERewardRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::OK;
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::FAIL;
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::NO_GROUP;
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::NO_DATA;
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::NO_INDEX;
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::NO_INDEX_DATA;
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::SMALL_DAMAGE;
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::GETTED;
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::GroupPVERewardRet_MIN;
const GroupPVERewardResp_GroupPVERewardRet GroupPVERewardResp::GroupPVERewardRet_MAX;
const int GroupPVERewardResp::GroupPVERewardRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupPVERewardResp::kResultFieldNumber;
const int GroupPVERewardResp::kUserSyncFieldNumber;
const int GroupPVERewardResp::kReqFieldNumber;
#endif  // !_MSC_VER

GroupPVERewardResp::GroupPVERewardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupPVERewardResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::GroupPVERewardReq*>(
      ::GroupPVERewardReq::internal_default_instance());
#else
  req_ = const_cast< ::GroupPVERewardReq*>(&::GroupPVERewardReq::default_instance());
#endif
}

GroupPVERewardResp::GroupPVERewardResp(const GroupPVERewardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupPVERewardResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  req_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupPVERewardResp::~GroupPVERewardResp() {
  SharedDtor();
}

void GroupPVERewardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete req_;
  }
}

void GroupPVERewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupPVERewardResp& GroupPVERewardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupPVERewardResp* GroupPVERewardResp::default_instance_ = NULL;

GroupPVERewardResp* GroupPVERewardResp::New() const {
  return new GroupPVERewardResp;
}

void GroupPVERewardResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_req()) {
      if (req_ != NULL) req_->::GroupPVERewardReq::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupPVERewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupPVERewardResp.GroupPVERewardRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupPVERewardResp_GroupPVERewardRet_IsValid(value)) {
            set_result(static_cast< ::GroupPVERewardResp_GroupPVERewardRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_req;
        break;
      }

      // optional .GroupPVERewardReq req = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupPVERewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupPVERewardResp.GroupPVERewardRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional .GroupPVERewardReq req = 3;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->req(), output);
  }

}

int GroupPVERewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupPVERewardResp.GroupPVERewardRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .GroupPVERewardReq req = 3;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupPVERewardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupPVERewardResp*>(&from));
}

void GroupPVERewardResp::MergeFrom(const GroupPVERewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_req()) {
      mutable_req()->::GroupPVERewardReq::MergeFrom(from.req());
    }
  }
}

void GroupPVERewardResp::CopyFrom(const GroupPVERewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPVERewardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  return true;
}

void GroupPVERewardResp::Swap(GroupPVERewardResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(req_, other->req_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupPVERewardResp::GetTypeName() const {
  return "GroupPVERewardResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupRequestHelpReq::kTypeFieldNumber;
const int GroupRequestHelpReq::kIdFieldNumber;
#endif  // !_MSC_VER

GroupRequestHelpReq::GroupRequestHelpReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupRequestHelpReq::InitAsDefaultInstance() {
}

GroupRequestHelpReq::GroupRequestHelpReq(const GroupRequestHelpReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupRequestHelpReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupRequestHelpReq::~GroupRequestHelpReq() {
  SharedDtor();
}

void GroupRequestHelpReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupRequestHelpReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupRequestHelpReq& GroupRequestHelpReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupRequestHelpReq* GroupRequestHelpReq::default_instance_ = NULL;

GroupRequestHelpReq* GroupRequestHelpReq::New() const {
  return new GroupRequestHelpReq;
}

void GroupRequestHelpReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupRequestHelpReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // repeated int32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupRequestHelpReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // repeated int32 id = 2;
  for (int i = 0; i < this->id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->id(i), output);
  }

}

int GroupRequestHelpReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated int32 id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->id(i));
    }
    total_size += 1 * this->id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupRequestHelpReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupRequestHelpReq*>(&from));
}

void GroupRequestHelpReq::MergeFrom(const GroupRequestHelpReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_.MergeFrom(from.id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void GroupRequestHelpReq::CopyFrom(const GroupRequestHelpReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupRequestHelpReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GroupRequestHelpReq::Swap(GroupRequestHelpReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    id_.Swap(&other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupRequestHelpReq::GetTypeName() const {
  return "GroupRequestHelpReq";
}


// ===================================================================

bool GroupRequestHelpResp_GroupRequestHelpRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp::OK;
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp::FAIL;
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp::NO_DATA;
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp::NO_CD;
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp::REQUESTED;
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp::REQ_DATA_ERROR;
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp::HELPED;
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp::GroupRequestHelpRet_MIN;
const GroupRequestHelpResp_GroupRequestHelpRet GroupRequestHelpResp::GroupRequestHelpRet_MAX;
const int GroupRequestHelpResp::GroupRequestHelpRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupRequestHelpResp::kResultFieldNumber;
const int GroupRequestHelpResp::kUserSyncFieldNumber;
const int GroupRequestHelpResp::kHelpListFieldNumber;
#endif  // !_MSC_VER

GroupRequestHelpResp::GroupRequestHelpResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupRequestHelpResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupRequestHelpResp::GroupRequestHelpResp(const GroupRequestHelpResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupRequestHelpResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupRequestHelpResp::~GroupRequestHelpResp() {
  SharedDtor();
}

void GroupRequestHelpResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupRequestHelpResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupRequestHelpResp& GroupRequestHelpResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupRequestHelpResp* GroupRequestHelpResp::default_instance_ = NULL;

GroupRequestHelpResp* GroupRequestHelpResp::New() const {
  return new GroupRequestHelpResp;
}

void GroupRequestHelpResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  help_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupRequestHelpResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupRequestHelpResp.GroupRequestHelpRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupRequestHelpResp_GroupRequestHelpRet_IsValid(value)) {
            set_result(static_cast< ::GroupRequestHelpResp_GroupRequestHelpRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_help_list;
        break;
      }

      // repeated .HelpInfo help_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_help_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_help_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_help_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupRequestHelpResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupRequestHelpResp.GroupRequestHelpRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .HelpInfo help_list = 3;
  for (int i = 0; i < this->help_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->help_list(i), output);
  }

}

int GroupRequestHelpResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupRequestHelpResp.GroupRequestHelpRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .HelpInfo help_list = 3;
  total_size += 1 * this->help_list_size();
  for (int i = 0; i < this->help_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->help_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupRequestHelpResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupRequestHelpResp*>(&from));
}

void GroupRequestHelpResp::MergeFrom(const GroupRequestHelpResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  help_list_.MergeFrom(from.help_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupRequestHelpResp::CopyFrom(const GroupRequestHelpResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupRequestHelpResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < help_list_size(); i++) {
    if (!this->help_list(i).IsInitialized()) return false;
  }
  return true;
}

void GroupRequestHelpResp::Swap(GroupRequestHelpResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    help_list_.Swap(&other->help_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupRequestHelpResp::GetTypeName() const {
  return "GroupRequestHelpResp";
}


// ===================================================================

bool GroupHelpListResp_GroupHelpListRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupHelpListResp_GroupHelpListRet GroupHelpListResp::OK;
const GroupHelpListResp_GroupHelpListRet GroupHelpListResp::FAIL;
const GroupHelpListResp_GroupHelpListRet GroupHelpListResp::GroupHelpListRet_MIN;
const GroupHelpListResp_GroupHelpListRet GroupHelpListResp::GroupHelpListRet_MAX;
const int GroupHelpListResp::GroupHelpListRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupHelpListResp::kResultFieldNumber;
const int GroupHelpListResp::kUserSyncFieldNumber;
const int GroupHelpListResp::kHelpListFieldNumber;
#endif  // !_MSC_VER

GroupHelpListResp::GroupHelpListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupHelpListResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupHelpListResp::GroupHelpListResp(const GroupHelpListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupHelpListResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupHelpListResp::~GroupHelpListResp() {
  SharedDtor();
}

void GroupHelpListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupHelpListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupHelpListResp& GroupHelpListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupHelpListResp* GroupHelpListResp::default_instance_ = NULL;

GroupHelpListResp* GroupHelpListResp::New() const {
  return new GroupHelpListResp;
}

void GroupHelpListResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  help_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupHelpListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupHelpListResp.GroupHelpListRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupHelpListResp_GroupHelpListRet_IsValid(value)) {
            set_result(static_cast< ::GroupHelpListResp_GroupHelpListRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_help_list;
        break;
      }

      // repeated .HelpInfo help_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_help_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_help_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_help_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupHelpListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupHelpListResp.GroupHelpListRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .HelpInfo help_list = 3;
  for (int i = 0; i < this->help_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->help_list(i), output);
  }

}

int GroupHelpListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupHelpListResp.GroupHelpListRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .HelpInfo help_list = 3;
  total_size += 1 * this->help_list_size();
  for (int i = 0; i < this->help_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->help_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupHelpListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupHelpListResp*>(&from));
}

void GroupHelpListResp::MergeFrom(const GroupHelpListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  help_list_.MergeFrom(from.help_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupHelpListResp::CopyFrom(const GroupHelpListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupHelpListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < help_list_size(); i++) {
    if (!this->help_list(i).IsInitialized()) return false;
  }
  return true;
}

void GroupHelpListResp::Swap(GroupHelpListResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    help_list_.Swap(&other->help_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupHelpListResp::GetTypeName() const {
  return "GroupHelpListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupHelpReq::kUserNameFieldNumber;
const int GroupHelpReq::kTypeFieldNumber;
const int GroupHelpReq::kIdFieldNumber;
#endif  // !_MSC_VER

GroupHelpReq::GroupHelpReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupHelpReq::InitAsDefaultInstance() {
}

GroupHelpReq::GroupHelpReq(const GroupHelpReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupHelpReq::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupHelpReq::~GroupHelpReq() {
  SharedDtor();
}

void GroupHelpReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupHelpReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupHelpReq& GroupHelpReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupHelpReq* GroupHelpReq::default_instance_ = NULL;

GroupHelpReq* GroupHelpReq::New() const {
  return new GroupHelpReq;
}

void GroupHelpReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    type_ = 0;
  }
  id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupHelpReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required int32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_id;
        break;
      }

      // repeated int32 id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupHelpReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

  // required int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // repeated int32 id = 3;
  for (int i = 0; i < this->id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->id(i), output);
  }

}

int GroupHelpReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated int32 id = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->id(i));
    }
    total_size += 1 * this->id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupHelpReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupHelpReq*>(&from));
}

void GroupHelpReq::MergeFrom(const GroupHelpReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_.MergeFrom(from.id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void GroupHelpReq::CopyFrom(const GroupHelpReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupHelpReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupHelpReq::Swap(GroupHelpReq* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(type_, other->type_);
    id_.Swap(&other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupHelpReq::GetTypeName() const {
  return "GroupHelpReq";
}


// ===================================================================

bool GroupHelpResp_GroupHelpRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupHelpResp_GroupHelpRet GroupHelpResp::OK;
const GroupHelpResp_GroupHelpRet GroupHelpResp::FAIL;
const GroupHelpResp_GroupHelpRet GroupHelpResp::HELP_TIME_MAX;
const GroupHelpResp_GroupHelpRet GroupHelpResp::NO_DATA;
const GroupHelpResp_GroupHelpRet GroupHelpResp::NO_INFO_DATA;
const GroupHelpResp_GroupHelpRet GroupHelpResp::NO_CD;
const GroupHelpResp_GroupHelpRet GroupHelpResp::REQ_DATA_ERROR;
const GroupHelpResp_GroupHelpRet GroupHelpResp::GroupHelpRet_MIN;
const GroupHelpResp_GroupHelpRet GroupHelpResp::GroupHelpRet_MAX;
const int GroupHelpResp::GroupHelpRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupHelpResp::kResultFieldNumber;
const int GroupHelpResp::kUserSyncFieldNumber;
const int GroupHelpResp::kHelpListFieldNumber;
#endif  // !_MSC_VER

GroupHelpResp::GroupHelpResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupHelpResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GroupHelpResp::GroupHelpResp(const GroupHelpResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupHelpResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupHelpResp::~GroupHelpResp() {
  SharedDtor();
}

void GroupHelpResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GroupHelpResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupHelpResp& GroupHelpResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupHelpResp* GroupHelpResp::default_instance_ = NULL;

GroupHelpResp* GroupHelpResp::New() const {
  return new GroupHelpResp;
}

void GroupHelpResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  help_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupHelpResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupHelpResp.GroupHelpRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupHelpResp_GroupHelpRet_IsValid(value)) {
            set_result(static_cast< ::GroupHelpResp_GroupHelpRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_help_list;
        break;
      }

      // repeated .HelpInfo help_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_help_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_help_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_help_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupHelpResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupHelpResp.GroupHelpRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .HelpInfo help_list = 3;
  for (int i = 0; i < this->help_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->help_list(i), output);
  }

}

int GroupHelpResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupHelpResp.GroupHelpRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .HelpInfo help_list = 3;
  total_size += 1 * this->help_list_size();
  for (int i = 0; i < this->help_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->help_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupHelpResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupHelpResp*>(&from));
}

void GroupHelpResp::MergeFrom(const GroupHelpResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  help_list_.MergeFrom(from.help_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GroupHelpResp::CopyFrom(const GroupHelpResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupHelpResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < help_list_size(); i++) {
    if (!this->help_list(i).IsInitialized()) return false;
  }
  return true;
}

void GroupHelpResp::Swap(GroupHelpResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    help_list_.Swap(&other->help_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupHelpResp::GetTypeName() const {
  return "GroupHelpResp";
}


// ===================================================================

#ifndef _MSC_VER
const int NewGroupUpdate::kSenderFieldNumber;
#endif  // !_MSC_VER

NewGroupUpdate::NewGroupUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NewGroupUpdate::InitAsDefaultInstance() {
}

NewGroupUpdate::NewGroupUpdate(const NewGroupUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NewGroupUpdate::SharedCtor() {
  _cached_size_ = 0;
  sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewGroupUpdate::~NewGroupUpdate() {
  SharedDtor();
}

void NewGroupUpdate::SharedDtor() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NewGroupUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NewGroupUpdate& NewGroupUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

NewGroupUpdate* NewGroupUpdate::default_instance_ = NULL;

NewGroupUpdate* NewGroupUpdate::New() const {
  return new NewGroupUpdate;
}

void NewGroupUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_sender()) {
      if (sender_ != &::google::protobuf::internal::kEmptyString) {
        sender_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NewGroupUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string sender = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sender()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewGroupUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string sender = 1;
  if (has_sender()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->sender(), output);
  }

}

int NewGroupUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string sender = 1;
    if (has_sender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sender());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewGroupUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NewGroupUpdate*>(&from));
}

void NewGroupUpdate::MergeFrom(const NewGroupUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sender()) {
      set_sender(from.sender());
    }
  }
}

void NewGroupUpdate::CopyFrom(const NewGroupUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewGroupUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void NewGroupUpdate::Swap(NewGroupUpdate* other) {
  if (other != this) {
    std::swap(sender_, other->sender_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NewGroupUpdate::GetTypeName() const {
  return "NewGroupUpdate";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupInviteReq::kRecverFieldNumber;
#endif  // !_MSC_VER

GroupInviteReq::GroupInviteReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupInviteReq::InitAsDefaultInstance() {
}

GroupInviteReq::GroupInviteReq(const GroupInviteReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupInviteReq::SharedCtor() {
  _cached_size_ = 0;
  recver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupInviteReq::~GroupInviteReq() {
  SharedDtor();
}

void GroupInviteReq::SharedDtor() {
  if (recver_ != &::google::protobuf::internal::kEmptyString) {
    delete recver_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupInviteReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupInviteReq& GroupInviteReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupInviteReq* GroupInviteReq::default_instance_ = NULL;

GroupInviteReq* GroupInviteReq::New() const {
  return new GroupInviteReq;
}

void GroupInviteReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_recver()) {
      if (recver_ != &::google::protobuf::internal::kEmptyString) {
        recver_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupInviteReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string recver = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_recver()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupInviteReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string recver = 1;
  if (has_recver()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->recver(), output);
  }

}

int GroupInviteReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string recver = 1;
    if (has_recver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->recver());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupInviteReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupInviteReq*>(&from));
}

void GroupInviteReq::MergeFrom(const GroupInviteReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_recver()) {
      set_recver(from.recver());
    }
  }
}

void GroupInviteReq::CopyFrom(const GroupInviteReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupInviteReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GroupInviteReq::Swap(GroupInviteReq* other) {
  if (other != this) {
    std::swap(recver_, other->recver_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupInviteReq::GetTypeName() const {
  return "GroupInviteReq";
}


// ===================================================================

bool GroupInviteResp_GroupInviteRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupInviteResp_GroupInviteRet GroupInviteResp::OK;
const GroupInviteResp_GroupInviteRet GroupInviteResp::FAIL;
const GroupInviteResp_GroupInviteRet GroupInviteResp::OTHER_BLACK;
const GroupInviteResp_GroupInviteRet GroupInviteResp::MY_BLACK;
const GroupInviteResp_GroupInviteRet GroupInviteResp::SENDED;
const GroupInviteResp_GroupInviteRet GroupInviteResp::HAS_GROUP;
const GroupInviteResp_GroupInviteRet GroupInviteResp::NO_POWER;
const GroupInviteResp_GroupInviteRet GroupInviteResp::NO_OPEN;
const GroupInviteResp_GroupInviteRet GroupInviteResp::GroupInviteRet_MIN;
const GroupInviteResp_GroupInviteRet GroupInviteResp::GroupInviteRet_MAX;
const int GroupInviteResp::GroupInviteRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupInviteResp::kResultFieldNumber;
#endif  // !_MSC_VER

GroupInviteResp::GroupInviteResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupInviteResp::InitAsDefaultInstance() {
}

GroupInviteResp::GroupInviteResp(const GroupInviteResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupInviteResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupInviteResp::~GroupInviteResp() {
  SharedDtor();
}

void GroupInviteResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupInviteResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupInviteResp& GroupInviteResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupInviteResp* GroupInviteResp::default_instance_ = NULL;

GroupInviteResp* GroupInviteResp::New() const {
  return new GroupInviteResp;
}

void GroupInviteResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupInviteResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupInviteResp.GroupInviteRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupInviteResp_GroupInviteRet_IsValid(value)) {
            set_result(static_cast< ::GroupInviteResp_GroupInviteRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupInviteResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupInviteResp.GroupInviteRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

}

int GroupInviteResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupInviteResp.GroupInviteRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupInviteResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupInviteResp*>(&from));
}

void GroupInviteResp::MergeFrom(const GroupInviteResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void GroupInviteResp::CopyFrom(const GroupInviteResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupInviteResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GroupInviteResp::Swap(GroupInviteResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupInviteResp::GetTypeName() const {
  return "GroupInviteResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupWorshipReq::kTypeFieldNumber;
const int GroupWorshipReq::kLevelFieldNumber;
#endif  // !_MSC_VER

GroupWorshipReq::GroupWorshipReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupWorshipReq::InitAsDefaultInstance() {
}

GroupWorshipReq::GroupWorshipReq(const GroupWorshipReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupWorshipReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  level_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupWorshipReq::~GroupWorshipReq() {
  SharedDtor();
}

void GroupWorshipReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupWorshipReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupWorshipReq& GroupWorshipReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupWorshipReq* GroupWorshipReq::default_instance_ = NULL;

GroupWorshipReq* GroupWorshipReq::New() const {
  return new GroupWorshipReq;
}

void GroupWorshipReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    level_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupWorshipReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }

      // required int32 level = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupWorshipReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required int32 level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->level(), output);
  }

}

int GroupWorshipReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required int32 level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupWorshipReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupWorshipReq*>(&from));
}

void GroupWorshipReq::MergeFrom(const GroupWorshipReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
  }
}

void GroupWorshipReq::CopyFrom(const GroupWorshipReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupWorshipReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupWorshipReq::Swap(GroupWorshipReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(level_, other->level_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupWorshipReq::GetTypeName() const {
  return "GroupWorshipReq";
}


// ===================================================================

bool GroupWorshipResp_GroupWorshipRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::OK;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::FAIL;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::ALREADY;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::NO_CONF;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::NO_GROUP;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::NO_RES;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::GETTED;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::LOW_POINT;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::NO_WORSHIP;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::GroupWorshipRet_MIN;
const GroupWorshipResp_GroupWorshipRet GroupWorshipResp::GroupWorshipRet_MAX;
const int GroupWorshipResp::GroupWorshipRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupWorshipResp::kResultFieldNumber;
const int GroupWorshipResp::kUserSyncFieldNumber;
const int GroupWorshipResp::kReqFieldNumber;
#endif  // !_MSC_VER

GroupWorshipResp::GroupWorshipResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GroupWorshipResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::GroupWorshipReq*>(
      ::GroupWorshipReq::internal_default_instance());
#else
  req_ = const_cast< ::GroupWorshipReq*>(&::GroupWorshipReq::default_instance());
#endif
}

GroupWorshipResp::GroupWorshipResp(const GroupWorshipResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GroupWorshipResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  req_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupWorshipResp::~GroupWorshipResp() {
  SharedDtor();
}

void GroupWorshipResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete req_;
  }
}

void GroupWorshipResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupWorshipResp& GroupWorshipResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdGroup_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdGroup_2eproto();
#endif
  return *default_instance_;
}

GroupWorshipResp* GroupWorshipResp::default_instance_ = NULL;

GroupWorshipResp* GroupWorshipResp::New() const {
  return new GroupWorshipResp;
}

void GroupWorshipResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_req()) {
      if (req_ != NULL) req_->::GroupWorshipReq::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GroupWorshipResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .GroupWorshipResp.GroupWorshipRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GroupWorshipResp_GroupWorshipRet_IsValid(value)) {
            set_result(static_cast< ::GroupWorshipResp_GroupWorshipRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_req;
        break;
      }

      // optional .GroupWorshipReq req = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GroupWorshipResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .GroupWorshipResp.GroupWorshipRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional .GroupWorshipReq req = 3;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->req(), output);
  }

}

int GroupWorshipResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .GroupWorshipResp.GroupWorshipRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .GroupWorshipReq req = 3;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupWorshipResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupWorshipResp*>(&from));
}

void GroupWorshipResp::MergeFrom(const GroupWorshipResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_req()) {
      mutable_req()->::GroupWorshipReq::MergeFrom(from.req());
    }
  }
}

void GroupWorshipResp::CopyFrom(const GroupWorshipResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupWorshipResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  return true;
}

void GroupWorshipResp::Swap(GroupWorshipResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(req_, other->req_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupWorshipResp::GetTypeName() const {
  return "GroupWorshipResp";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
