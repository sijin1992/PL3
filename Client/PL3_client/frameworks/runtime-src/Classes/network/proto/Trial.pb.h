// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Trial.proto

#ifndef PROTOBUF_Trial_2eproto__INCLUDED
#define PROTOBUF_Trial_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Trial_2eproto();
void protobuf_AssignDesc_Trial_2eproto();
void protobuf_ShutdownFile_Trial_2eproto();

class TrialLevel;
class TrialShip;
class TrialCopy;
class TrialArea;
class TrialData;

// ===================================================================

class TrialLevel : public ::google::protobuf::MessageLite {
 public:
  TrialLevel();
  virtual ~TrialLevel();

  TrialLevel(const TrialLevel& from);

  inline TrialLevel& operator=(const TrialLevel& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrialLevel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrialLevel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrialLevel* other);

  // implements Message ----------------------------------------------

  TrialLevel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrialLevel& from);
  void MergeFrom(const TrialLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 level_id = 1;
  inline bool has_level_id() const;
  inline void clear_level_id();
  static const int kLevelIdFieldNumber = 1;
  inline ::google::protobuf::int32 level_id() const;
  inline void set_level_id(::google::protobuf::int32 value);

  // required int32 star = 2;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 2;
  inline ::google::protobuf::int32 star() const;
  inline void set_star(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TrialLevel)
 private:
  inline void set_has_level_id();
  inline void clear_has_level_id();
  inline void set_has_star();
  inline void clear_has_star();

  ::google::protobuf::int32 level_id_;
  ::google::protobuf::int32 star_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Trial_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Trial_2eproto();
  #endif
  friend void protobuf_AssignDesc_Trial_2eproto();
  friend void protobuf_ShutdownFile_Trial_2eproto();

  void InitAsDefaultInstance();
  static TrialLevel* default_instance_;
};
// -------------------------------------------------------------------

class TrialShip : public ::google::protobuf::MessageLite {
 public:
  TrialShip();
  virtual ~TrialShip();

  TrialShip(const TrialShip& from);

  inline TrialShip& operator=(const TrialShip& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrialShip& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrialShip* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrialShip* other);

  // implements Message ----------------------------------------------

  TrialShip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrialShip& from);
  void MergeFrom(const TrialShip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline ::google::protobuf::int32 guid() const;
  inline void set_guid(::google::protobuf::int32 value);

  // required int32 hp = 2;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 2;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TrialShip)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::int32 guid_;
  ::google::protobuf::int32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Trial_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Trial_2eproto();
  #endif
  friend void protobuf_AssignDesc_Trial_2eproto();
  friend void protobuf_ShutdownFile_Trial_2eproto();

  void InitAsDefaultInstance();
  static TrialShip* default_instance_;
};
// -------------------------------------------------------------------

class TrialCopy : public ::google::protobuf::MessageLite {
 public:
  TrialCopy();
  virtual ~TrialCopy();

  TrialCopy(const TrialCopy& from);

  inline TrialCopy& operator=(const TrialCopy& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrialCopy& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrialCopy* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrialCopy* other);

  // implements Message ----------------------------------------------

  TrialCopy* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrialCopy& from);
  void MergeFrom(const TrialCopy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 copy_id = 1;
  inline bool has_copy_id() const;
  inline void clear_copy_id();
  static const int kCopyIdFieldNumber = 1;
  inline ::google::protobuf::int32 copy_id() const;
  inline void set_copy_id(::google::protobuf::int32 value);

  // required int32 reward_flag = 2;
  inline bool has_reward_flag() const;
  inline void clear_reward_flag();
  static const int kRewardFlagFieldNumber = 2;
  inline ::google::protobuf::int32 reward_flag() const;
  inline void set_reward_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TrialCopy)
 private:
  inline void set_has_copy_id();
  inline void clear_has_copy_id();
  inline void set_has_reward_flag();
  inline void clear_has_reward_flag();

  ::google::protobuf::int32 copy_id_;
  ::google::protobuf::int32 reward_flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Trial_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Trial_2eproto();
  #endif
  friend void protobuf_AssignDesc_Trial_2eproto();
  friend void protobuf_ShutdownFile_Trial_2eproto();

  void InitAsDefaultInstance();
  static TrialCopy* default_instance_;
};
// -------------------------------------------------------------------

class TrialArea : public ::google::protobuf::MessageLite {
 public:
  TrialArea();
  virtual ~TrialArea();

  TrialArea(const TrialArea& from);

  inline TrialArea& operator=(const TrialArea& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrialArea& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrialArea* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrialArea* other);

  // implements Message ----------------------------------------------

  TrialArea* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrialArea& from);
  void MergeFrom(const TrialArea& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 area_id = 1;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 1;
  inline ::google::protobuf::int32 area_id() const;
  inline void set_area_id(::google::protobuf::int32 value);

  // optional int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // repeated int32 lineup = 3;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 3;
  inline ::google::protobuf::int32 lineup(int index) const;
  inline void set_lineup(int index, ::google::protobuf::int32 value);
  inline void add_lineup(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lineup();

  // repeated .TrialShip ship_list = 4;
  inline int ship_list_size() const;
  inline void clear_ship_list();
  static const int kShipListFieldNumber = 4;
  inline const ::TrialShip& ship_list(int index) const;
  inline ::TrialShip* mutable_ship_list(int index);
  inline ::TrialShip* add_ship_list();
  inline const ::google::protobuf::RepeatedPtrField< ::TrialShip >&
      ship_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::TrialShip >*
      mutable_ship_list();

  // @@protoc_insertion_point(class_scope:TrialArea)
 private:
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 area_id_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lineup_;
  ::google::protobuf::RepeatedPtrField< ::TrialShip > ship_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Trial_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Trial_2eproto();
  #endif
  friend void protobuf_AssignDesc_Trial_2eproto();
  friend void protobuf_ShutdownFile_Trial_2eproto();

  void InitAsDefaultInstance();
  static TrialArea* default_instance_;
};
// -------------------------------------------------------------------

class TrialData : public ::google::protobuf::MessageLite {
 public:
  TrialData();
  virtual ~TrialData();

  TrialData(const TrialData& from);

  inline TrialData& operator=(const TrialData& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrialData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrialData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrialData* other);

  // implements Message ----------------------------------------------

  TrialData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrialData& from);
  void MergeFrom(const TrialData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ticket_num = 1;
  inline bool has_ticket_num() const;
  inline void clear_ticket_num();
  static const int kTicketNumFieldNumber = 1;
  inline ::google::protobuf::int32 ticket_num() const;
  inline void set_ticket_num(::google::protobuf::int32 value);

  // repeated .TrialArea area_list = 2;
  inline int area_list_size() const;
  inline void clear_area_list();
  static const int kAreaListFieldNumber = 2;
  inline const ::TrialArea& area_list(int index) const;
  inline ::TrialArea* mutable_area_list(int index);
  inline ::TrialArea* add_area_list();
  inline const ::google::protobuf::RepeatedPtrField< ::TrialArea >&
      area_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::TrialArea >*
      mutable_area_list();

  // repeated .TrialLevel level_list = 3;
  inline int level_list_size() const;
  inline void clear_level_list();
  static const int kLevelListFieldNumber = 3;
  inline const ::TrialLevel& level_list(int index) const;
  inline ::TrialLevel* mutable_level_list(int index);
  inline ::TrialLevel* add_level_list();
  inline const ::google::protobuf::RepeatedPtrField< ::TrialLevel >&
      level_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::TrialLevel >*
      mutable_level_list();

  // required int32 badge = 4;
  inline bool has_badge() const;
  inline void clear_badge();
  static const int kBadgeFieldNumber = 4;
  inline ::google::protobuf::int32 badge() const;
  inline void set_badge(::google::protobuf::int32 value);

  // repeated .TrialCopy copy_list = 5;
  inline int copy_list_size() const;
  inline void clear_copy_list();
  static const int kCopyListFieldNumber = 5;
  inline const ::TrialCopy& copy_list(int index) const;
  inline ::TrialCopy* mutable_copy_list(int index);
  inline ::TrialCopy* add_copy_list();
  inline const ::google::protobuf::RepeatedPtrField< ::TrialCopy >&
      copy_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::TrialCopy >*
      mutable_copy_list();

  // @@protoc_insertion_point(class_scope:TrialData)
 private:
  inline void set_has_ticket_num();
  inline void clear_has_ticket_num();
  inline void set_has_badge();
  inline void clear_has_badge();

  ::google::protobuf::RepeatedPtrField< ::TrialArea > area_list_;
  ::google::protobuf::int32 ticket_num_;
  ::google::protobuf::int32 badge_;
  ::google::protobuf::RepeatedPtrField< ::TrialLevel > level_list_;
  ::google::protobuf::RepeatedPtrField< ::TrialCopy > copy_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Trial_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Trial_2eproto();
  #endif
  friend void protobuf_AssignDesc_Trial_2eproto();
  friend void protobuf_ShutdownFile_Trial_2eproto();

  void InitAsDefaultInstance();
  static TrialData* default_instance_;
};
// ===================================================================


// ===================================================================

// TrialLevel

// required int32 level_id = 1;
inline bool TrialLevel::has_level_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrialLevel::set_has_level_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrialLevel::clear_has_level_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrialLevel::clear_level_id() {
  level_id_ = 0;
  clear_has_level_id();
}
inline ::google::protobuf::int32 TrialLevel::level_id() const {
  return level_id_;
}
inline void TrialLevel::set_level_id(::google::protobuf::int32 value) {
  set_has_level_id();
  level_id_ = value;
}

// required int32 star = 2;
inline bool TrialLevel::has_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrialLevel::set_has_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrialLevel::clear_has_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrialLevel::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 TrialLevel::star() const {
  return star_;
}
inline void TrialLevel::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
}

// -------------------------------------------------------------------

// TrialShip

// required int32 guid = 1;
inline bool TrialShip::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrialShip::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrialShip::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrialShip::clear_guid() {
  guid_ = 0;
  clear_has_guid();
}
inline ::google::protobuf::int32 TrialShip::guid() const {
  return guid_;
}
inline void TrialShip::set_guid(::google::protobuf::int32 value) {
  set_has_guid();
  guid_ = value;
}

// required int32 hp = 2;
inline bool TrialShip::has_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrialShip::set_has_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrialShip::clear_has_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrialShip::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 TrialShip::hp() const {
  return hp_;
}
inline void TrialShip::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// TrialCopy

// required int32 copy_id = 1;
inline bool TrialCopy::has_copy_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrialCopy::set_has_copy_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrialCopy::clear_has_copy_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrialCopy::clear_copy_id() {
  copy_id_ = 0;
  clear_has_copy_id();
}
inline ::google::protobuf::int32 TrialCopy::copy_id() const {
  return copy_id_;
}
inline void TrialCopy::set_copy_id(::google::protobuf::int32 value) {
  set_has_copy_id();
  copy_id_ = value;
}

// required int32 reward_flag = 2;
inline bool TrialCopy::has_reward_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrialCopy::set_has_reward_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrialCopy::clear_has_reward_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrialCopy::clear_reward_flag() {
  reward_flag_ = 0;
  clear_has_reward_flag();
}
inline ::google::protobuf::int32 TrialCopy::reward_flag() const {
  return reward_flag_;
}
inline void TrialCopy::set_reward_flag(::google::protobuf::int32 value) {
  set_has_reward_flag();
  reward_flag_ = value;
}

// -------------------------------------------------------------------

// TrialArea

// required int32 area_id = 1;
inline bool TrialArea::has_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrialArea::set_has_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrialArea::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrialArea::clear_area_id() {
  area_id_ = 0;
  clear_has_area_id();
}
inline ::google::protobuf::int32 TrialArea::area_id() const {
  return area_id_;
}
inline void TrialArea::set_area_id(::google::protobuf::int32 value) {
  set_has_area_id();
  area_id_ = value;
}

// optional int32 status = 2;
inline bool TrialArea::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrialArea::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrialArea::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrialArea::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 TrialArea::status() const {
  return status_;
}
inline void TrialArea::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// repeated int32 lineup = 3;
inline int TrialArea::lineup_size() const {
  return lineup_.size();
}
inline void TrialArea::clear_lineup() {
  lineup_.Clear();
}
inline ::google::protobuf::int32 TrialArea::lineup(int index) const {
  return lineup_.Get(index);
}
inline void TrialArea::set_lineup(int index, ::google::protobuf::int32 value) {
  lineup_.Set(index, value);
}
inline void TrialArea::add_lineup(::google::protobuf::int32 value) {
  lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TrialArea::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TrialArea::mutable_lineup() {
  return &lineup_;
}

// repeated .TrialShip ship_list = 4;
inline int TrialArea::ship_list_size() const {
  return ship_list_.size();
}
inline void TrialArea::clear_ship_list() {
  ship_list_.Clear();
}
inline const ::TrialShip& TrialArea::ship_list(int index) const {
  return ship_list_.Get(index);
}
inline ::TrialShip* TrialArea::mutable_ship_list(int index) {
  return ship_list_.Mutable(index);
}
inline ::TrialShip* TrialArea::add_ship_list() {
  return ship_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TrialShip >&
TrialArea::ship_list() const {
  return ship_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::TrialShip >*
TrialArea::mutable_ship_list() {
  return &ship_list_;
}

// -------------------------------------------------------------------

// TrialData

// required int32 ticket_num = 1;
inline bool TrialData::has_ticket_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrialData::set_has_ticket_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrialData::clear_has_ticket_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrialData::clear_ticket_num() {
  ticket_num_ = 0;
  clear_has_ticket_num();
}
inline ::google::protobuf::int32 TrialData::ticket_num() const {
  return ticket_num_;
}
inline void TrialData::set_ticket_num(::google::protobuf::int32 value) {
  set_has_ticket_num();
  ticket_num_ = value;
}

// repeated .TrialArea area_list = 2;
inline int TrialData::area_list_size() const {
  return area_list_.size();
}
inline void TrialData::clear_area_list() {
  area_list_.Clear();
}
inline const ::TrialArea& TrialData::area_list(int index) const {
  return area_list_.Get(index);
}
inline ::TrialArea* TrialData::mutable_area_list(int index) {
  return area_list_.Mutable(index);
}
inline ::TrialArea* TrialData::add_area_list() {
  return area_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TrialArea >&
TrialData::area_list() const {
  return area_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::TrialArea >*
TrialData::mutable_area_list() {
  return &area_list_;
}

// repeated .TrialLevel level_list = 3;
inline int TrialData::level_list_size() const {
  return level_list_.size();
}
inline void TrialData::clear_level_list() {
  level_list_.Clear();
}
inline const ::TrialLevel& TrialData::level_list(int index) const {
  return level_list_.Get(index);
}
inline ::TrialLevel* TrialData::mutable_level_list(int index) {
  return level_list_.Mutable(index);
}
inline ::TrialLevel* TrialData::add_level_list() {
  return level_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TrialLevel >&
TrialData::level_list() const {
  return level_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::TrialLevel >*
TrialData::mutable_level_list() {
  return &level_list_;
}

// required int32 badge = 4;
inline bool TrialData::has_badge() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrialData::set_has_badge() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrialData::clear_has_badge() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrialData::clear_badge() {
  badge_ = 0;
  clear_has_badge();
}
inline ::google::protobuf::int32 TrialData::badge() const {
  return badge_;
}
inline void TrialData::set_badge(::google::protobuf::int32 value) {
  set_has_badge();
  badge_ = value;
}

// repeated .TrialCopy copy_list = 5;
inline int TrialData::copy_list_size() const {
  return copy_list_.size();
}
inline void TrialData::clear_copy_list() {
  copy_list_.Clear();
}
inline const ::TrialCopy& TrialData::copy_list(int index) const {
  return copy_list_.Get(index);
}
inline ::TrialCopy* TrialData::mutable_copy_list(int index) {
  return copy_list_.Mutable(index);
}
inline ::TrialCopy* TrialData::add_copy_list() {
  return copy_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TrialCopy >&
TrialData::copy_list() const {
  return copy_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::TrialCopy >*
TrialData::mutable_copy_list() {
  return &copy_list_;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Trial_2eproto__INCLUDED
