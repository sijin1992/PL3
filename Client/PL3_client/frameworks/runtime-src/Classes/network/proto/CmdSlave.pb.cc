// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdSlave.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CmdSlave.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_CmdSlave_2eproto() {
  delete SlaveSyncDataReq::default_instance_;
  delete SlaveSyncDataResp::default_instance_;
  delete SlaveGetResReq::default_instance_;
  delete SlaveGetResResp::default_instance_;
  delete SlaveFreeReq::default_instance_;
  delete SlaveFreeResp::default_instance_;
  delete SlaveShowReq::default_instance_;
  delete SlaveShowResp::default_instance_;
  delete SlaveWorkReq::default_instance_;
  delete SlaveWorkResp::default_instance_;
  delete SlaveFawnOnReq::default_instance_;
  delete SlaveFawnOnResp::default_instance_;
  delete SlaveHelpReq::default_instance_;
  delete SlaveHelpResp::default_instance_;
  delete SlaveSearchReq::default_instance_;
  delete SlaveSearchResp::default_instance_;
  delete SlaveAddTimesReq::default_instance_;
  delete SlaveAddTimesResp::default_instance_;
  delete SlaveAttackReq::default_instance_;
  delete SlaveAttackResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_CmdSlave_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_CmdSlave_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_Item_2eproto();
  ::protobuf_AddDesc_AirShip_2eproto();
  ::protobuf_AddDesc_Slave_2eproto();
  ::protobuf_AddDesc_UserSync_2eproto();
  ::protobuf_AddDesc_PvpInfo_2eproto();
  SlaveSyncDataReq::default_instance_ = new SlaveSyncDataReq();
  SlaveSyncDataResp::default_instance_ = new SlaveSyncDataResp();
  SlaveGetResReq::default_instance_ = new SlaveGetResReq();
  SlaveGetResResp::default_instance_ = new SlaveGetResResp();
  SlaveFreeReq::default_instance_ = new SlaveFreeReq();
  SlaveFreeResp::default_instance_ = new SlaveFreeResp();
  SlaveShowReq::default_instance_ = new SlaveShowReq();
  SlaveShowResp::default_instance_ = new SlaveShowResp();
  SlaveWorkReq::default_instance_ = new SlaveWorkReq();
  SlaveWorkResp::default_instance_ = new SlaveWorkResp();
  SlaveFawnOnReq::default_instance_ = new SlaveFawnOnReq();
  SlaveFawnOnResp::default_instance_ = new SlaveFawnOnResp();
  SlaveHelpReq::default_instance_ = new SlaveHelpReq();
  SlaveHelpResp::default_instance_ = new SlaveHelpResp();
  SlaveSearchReq::default_instance_ = new SlaveSearchReq();
  SlaveSearchResp::default_instance_ = new SlaveSearchResp();
  SlaveAddTimesReq::default_instance_ = new SlaveAddTimesReq();
  SlaveAddTimesResp::default_instance_ = new SlaveAddTimesResp();
  SlaveAttackReq::default_instance_ = new SlaveAttackReq();
  SlaveAttackResp::default_instance_ = new SlaveAttackResp();
  SlaveSyncDataReq::default_instance_->InitAsDefaultInstance();
  SlaveSyncDataResp::default_instance_->InitAsDefaultInstance();
  SlaveGetResReq::default_instance_->InitAsDefaultInstance();
  SlaveGetResResp::default_instance_->InitAsDefaultInstance();
  SlaveFreeReq::default_instance_->InitAsDefaultInstance();
  SlaveFreeResp::default_instance_->InitAsDefaultInstance();
  SlaveShowReq::default_instance_->InitAsDefaultInstance();
  SlaveShowResp::default_instance_->InitAsDefaultInstance();
  SlaveWorkReq::default_instance_->InitAsDefaultInstance();
  SlaveWorkResp::default_instance_->InitAsDefaultInstance();
  SlaveFawnOnReq::default_instance_->InitAsDefaultInstance();
  SlaveFawnOnResp::default_instance_->InitAsDefaultInstance();
  SlaveHelpReq::default_instance_->InitAsDefaultInstance();
  SlaveHelpResp::default_instance_->InitAsDefaultInstance();
  SlaveSearchReq::default_instance_->InitAsDefaultInstance();
  SlaveSearchResp::default_instance_->InitAsDefaultInstance();
  SlaveAddTimesReq::default_instance_->InitAsDefaultInstance();
  SlaveAddTimesResp::default_instance_->InitAsDefaultInstance();
  SlaveAttackReq::default_instance_->InitAsDefaultInstance();
  SlaveAttackResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CmdSlave_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_CmdSlave_2eproto_once_);
void protobuf_AddDesc_CmdSlave_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_CmdSlave_2eproto_once_,
                 &protobuf_AddDesc_CmdSlave_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CmdSlave_2eproto {
  StaticDescriptorInitializer_CmdSlave_2eproto() {
    protobuf_AddDesc_CmdSlave_2eproto();
  }
} static_descriptor_initializer_CmdSlave_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int SlaveSyncDataReq::kTypeFieldNumber;
const int SlaveSyncDataReq::kUserNameListFieldNumber;
#endif  // !_MSC_VER

SlaveSyncDataReq::SlaveSyncDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveSyncDataReq::InitAsDefaultInstance() {
}

SlaveSyncDataReq::SlaveSyncDataReq(const SlaveSyncDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveSyncDataReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveSyncDataReq::~SlaveSyncDataReq() {
  SharedDtor();
}

void SlaveSyncDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SlaveSyncDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveSyncDataReq& SlaveSyncDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveSyncDataReq* SlaveSyncDataReq::default_instance_ = NULL;

SlaveSyncDataReq* SlaveSyncDataReq::New() const {
  return new SlaveSyncDataReq;
}

void SlaveSyncDataReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  user_name_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveSyncDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name_list;
        break;
      }

      // repeated string user_name_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_user_name_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveSyncDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // repeated string user_name_list = 2;
  for (int i = 0; i < this->user_name_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->user_name_list(i), output);
  }

}

int SlaveSyncDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated string user_name_list = 2;
  total_size += 1 * this->user_name_list_size();
  for (int i = 0; i < this->user_name_list_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->user_name_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveSyncDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveSyncDataReq*>(&from));
}

void SlaveSyncDataReq::MergeFrom(const SlaveSyncDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_name_list_.MergeFrom(from.user_name_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void SlaveSyncDataReq::CopyFrom(const SlaveSyncDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveSyncDataReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveSyncDataReq::Swap(SlaveSyncDataReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    user_name_list_.Swap(&other->user_name_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveSyncDataReq::GetTypeName() const {
  return "SlaveSyncDataReq";
}


// ===================================================================

bool SlaveSyncDataResp_SlaveSyncDataRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp::OK;
const SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp::FAIL;
const SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp::SlaveSyncDataRet_MIN;
const SlaveSyncDataResp_SlaveSyncDataRet SlaveSyncDataResp::SlaveSyncDataRet_MAX;
const int SlaveSyncDataResp::SlaveSyncDataRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveSyncDataResp::kResultFieldNumber;
const int SlaveSyncDataResp::kUserSyncFieldNumber;
const int SlaveSyncDataResp::kSlaveDataListFieldNumber;
const int SlaveSyncDataResp::kInfoListFieldNumber;
#endif  // !_MSC_VER

SlaveSyncDataResp::SlaveSyncDataResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveSyncDataResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

SlaveSyncDataResp::SlaveSyncDataResp(const SlaveSyncDataResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveSyncDataResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveSyncDataResp::~SlaveSyncDataResp() {
  SharedDtor();
}

void SlaveSyncDataResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void SlaveSyncDataResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveSyncDataResp& SlaveSyncDataResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveSyncDataResp* SlaveSyncDataResp::default_instance_ = NULL;

SlaveSyncDataResp* SlaveSyncDataResp::New() const {
  return new SlaveSyncDataResp;
}

void SlaveSyncDataResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  slave_data_list_.Clear();
  info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveSyncDataResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveSyncDataResp.SlaveSyncDataRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveSyncDataResp_SlaveSyncDataRet_IsValid(value)) {
            set_result(static_cast< ::SlaveSyncDataResp_SlaveSyncDataRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_slave_data_list;
        break;
      }

      // repeated .SlaveData slave_data_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_data_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_slave_data_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_slave_data_list;
        if (input->ExpectTag(34)) goto parse_info_list;
        break;
      }

      // repeated .SlaveBriefInfo info_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_info_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_info_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveSyncDataResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveSyncDataResp.SlaveSyncDataRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .SlaveData slave_data_list = 3;
  for (int i = 0; i < this->slave_data_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->slave_data_list(i), output);
  }

  // repeated .SlaveBriefInfo info_list = 4;
  for (int i = 0; i < this->info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->info_list(i), output);
  }

}

int SlaveSyncDataResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveSyncDataResp.SlaveSyncDataRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .SlaveData slave_data_list = 3;
  total_size += 1 * this->slave_data_list_size();
  for (int i = 0; i < this->slave_data_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->slave_data_list(i));
  }

  // repeated .SlaveBriefInfo info_list = 4;
  total_size += 1 * this->info_list_size();
  for (int i = 0; i < this->info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->info_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveSyncDataResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveSyncDataResp*>(&from));
}

void SlaveSyncDataResp::MergeFrom(const SlaveSyncDataResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  slave_data_list_.MergeFrom(from.slave_data_list_);
  info_list_.MergeFrom(from.info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void SlaveSyncDataResp::CopyFrom(const SlaveSyncDataResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveSyncDataResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < slave_data_list_size(); i++) {
    if (!this->slave_data_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < info_list_size(); i++) {
    if (!this->info_list(i).IsInitialized()) return false;
  }
  return true;
}

void SlaveSyncDataResp::Swap(SlaveSyncDataResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    slave_data_list_.Swap(&other->slave_data_list_);
    info_list_.Swap(&other->info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveSyncDataResp::GetTypeName() const {
  return "SlaveSyncDataResp";
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveGetResReq::kTypeFieldNumber;
const int SlaveGetResReq::kSlaveNameFieldNumber;
#endif  // !_MSC_VER

SlaveGetResReq::SlaveGetResReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveGetResReq::InitAsDefaultInstance() {
}

SlaveGetResReq::SlaveGetResReq(const SlaveGetResReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveGetResReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveGetResReq::~SlaveGetResReq() {
  SharedDtor();
}

void SlaveGetResReq::SharedDtor() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SlaveGetResReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveGetResReq& SlaveGetResReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveGetResReq* SlaveGetResReq::default_instance_ = NULL;

SlaveGetResReq* SlaveGetResReq::New() const {
  return new SlaveGetResReq;
}

void SlaveGetResReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_slave_name()) {
      if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
        slave_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveGetResReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slave_name;
        break;
      }

      // required string slave_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_slave_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveGetResReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required string slave_name = 2;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->slave_name(), output);
  }

}

int SlaveGetResReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required string slave_name = 2;
    if (has_slave_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->slave_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveGetResReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveGetResReq*>(&from));
}

void SlaveGetResReq::MergeFrom(const SlaveGetResReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_slave_name()) {
      set_slave_name(from.slave_name());
    }
  }
}

void SlaveGetResReq::CopyFrom(const SlaveGetResReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveGetResReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SlaveGetResReq::Swap(SlaveGetResReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(slave_name_, other->slave_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveGetResReq::GetTypeName() const {
  return "SlaveGetResReq";
}


// ===================================================================

bool SlaveGetResResp_SlaveGetResRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::OK;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::FAIL;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::NOT_MY_SLAVE;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::CD_TIME;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::SlaveGetResRet_MIN;
const SlaveGetResResp_SlaveGetResRet SlaveGetResResp::SlaveGetResRet_MAX;
const int SlaveGetResResp::SlaveGetResRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveGetResResp::kResultFieldNumber;
const int SlaveGetResResp::kUserSyncFieldNumber;
const int SlaveGetResResp::kResFieldNumber;
const int SlaveGetResResp::kExpFieldNumber;
#endif  // !_MSC_VER

SlaveGetResResp::SlaveGetResResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveGetResResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

SlaveGetResResp::SlaveGetResResp(const SlaveGetResResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveGetResResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  exp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveGetResResp::~SlaveGetResResp() {
  SharedDtor();
}

void SlaveGetResResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void SlaveGetResResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveGetResResp& SlaveGetResResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveGetResResp* SlaveGetResResp::default_instance_ = NULL;

SlaveGetResResp* SlaveGetResResp::New() const {
  return new SlaveGetResResp;
}

void SlaveGetResResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    exp_ = 0;
  }
  res_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveGetResResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveGetResResp.SlaveGetResRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveGetResResp_SlaveGetResRet_IsValid(value)) {
            set_result(static_cast< ::SlaveGetResResp_SlaveGetResRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_res;
        break;
      }

      // repeated int32 res = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_res:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_res())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_res())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_res;
        if (input->ExpectTag(32)) goto parse_exp;
        break;
      }

      // optional int32 exp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveGetResResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveGetResResp.SlaveGetResRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated int32 res = 3;
  for (int i = 0; i < this->res_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->res(i), output);
  }

  // optional int32 exp = 4;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->exp(), output);
  }

}

int SlaveGetResResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveGetResResp.SlaveGetResRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 exp = 4;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

  }
  // repeated int32 res = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->res_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->res(i));
    }
    total_size += 1 * this->res_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveGetResResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveGetResResp*>(&from));
}

void SlaveGetResResp::MergeFrom(const SlaveGetResResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  res_.MergeFrom(from.res_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
  }
}

void SlaveGetResResp::CopyFrom(const SlaveGetResResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveGetResResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void SlaveGetResResp::Swap(SlaveGetResResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    res_.Swap(&other->res_);
    std::swap(exp_, other->exp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveGetResResp::GetTypeName() const {
  return "SlaveGetResResp";
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveFreeReq::kTypeFieldNumber;
const int SlaveFreeReq::kSlaveNameFieldNumber;
#endif  // !_MSC_VER

SlaveFreeReq::SlaveFreeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveFreeReq::InitAsDefaultInstance() {
}

SlaveFreeReq::SlaveFreeReq(const SlaveFreeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveFreeReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveFreeReq::~SlaveFreeReq() {
  SharedDtor();
}

void SlaveFreeReq::SharedDtor() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SlaveFreeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveFreeReq& SlaveFreeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveFreeReq* SlaveFreeReq::default_instance_ = NULL;

SlaveFreeReq* SlaveFreeReq::New() const {
  return new SlaveFreeReq;
}

void SlaveFreeReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_slave_name()) {
      if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
        slave_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveFreeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slave_name;
        break;
      }

      // required string slave_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_slave_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveFreeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required string slave_name = 2;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->slave_name(), output);
  }

}

int SlaveFreeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required string slave_name = 2;
    if (has_slave_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->slave_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveFreeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveFreeReq*>(&from));
}

void SlaveFreeReq::MergeFrom(const SlaveFreeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_slave_name()) {
      set_slave_name(from.slave_name());
    }
  }
}

void SlaveFreeReq::CopyFrom(const SlaveFreeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveFreeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SlaveFreeReq::Swap(SlaveFreeReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(slave_name_, other->slave_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveFreeReq::GetTypeName() const {
  return "SlaveFreeReq";
}


// ===================================================================

bool SlaveFreeResp_SlaveFreeRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::OK;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::FAIL;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::NOT_MY_SLAVE;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::FREE_SLAVE_ERROR;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::SlaveFreeRet_MIN;
const SlaveFreeResp_SlaveFreeRet SlaveFreeResp::SlaveFreeRet_MAX;
const int SlaveFreeResp::SlaveFreeRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveFreeResp::kResultFieldNumber;
const int SlaveFreeResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

SlaveFreeResp::SlaveFreeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveFreeResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

SlaveFreeResp::SlaveFreeResp(const SlaveFreeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveFreeResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveFreeResp::~SlaveFreeResp() {
  SharedDtor();
}

void SlaveFreeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void SlaveFreeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveFreeResp& SlaveFreeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveFreeResp* SlaveFreeResp::default_instance_ = NULL;

SlaveFreeResp* SlaveFreeResp::New() const {
  return new SlaveFreeResp;
}

void SlaveFreeResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveFreeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveFreeResp.SlaveFreeRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveFreeResp_SlaveFreeRet_IsValid(value)) {
            set_result(static_cast< ::SlaveFreeResp_SlaveFreeRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveFreeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveFreeResp.SlaveFreeRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int SlaveFreeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveFreeResp.SlaveFreeRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveFreeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveFreeResp*>(&from));
}

void SlaveFreeResp::MergeFrom(const SlaveFreeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void SlaveFreeResp::CopyFrom(const SlaveFreeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveFreeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void SlaveFreeResp::Swap(SlaveFreeResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveFreeResp::GetTypeName() const {
  return "SlaveFreeResp";
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveShowReq::kTypeFieldNumber;
const int SlaveShowReq::kSlaveNameFieldNumber;
#endif  // !_MSC_VER

SlaveShowReq::SlaveShowReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveShowReq::InitAsDefaultInstance() {
}

SlaveShowReq::SlaveShowReq(const SlaveShowReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveShowReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveShowReq::~SlaveShowReq() {
  SharedDtor();
}

void SlaveShowReq::SharedDtor() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SlaveShowReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveShowReq& SlaveShowReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveShowReq* SlaveShowReq::default_instance_ = NULL;

SlaveShowReq* SlaveShowReq::New() const {
  return new SlaveShowReq;
}

void SlaveShowReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_slave_name()) {
      if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
        slave_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveShowReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slave_name;
        break;
      }

      // required string slave_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_slave_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveShowReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required string slave_name = 2;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->slave_name(), output);
  }

}

int SlaveShowReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required string slave_name = 2;
    if (has_slave_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->slave_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveShowReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveShowReq*>(&from));
}

void SlaveShowReq::MergeFrom(const SlaveShowReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_slave_name()) {
      set_slave_name(from.slave_name());
    }
  }
}

void SlaveShowReq::CopyFrom(const SlaveShowReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveShowReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SlaveShowReq::Swap(SlaveShowReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(slave_name_, other->slave_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveShowReq::GetTypeName() const {
  return "SlaveShowReq";
}


// ===================================================================

bool SlaveShowResp_SlaveShowRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveShowResp_SlaveShowRet SlaveShowResp::OK;
const SlaveShowResp_SlaveShowRet SlaveShowResp::FAIL;
const SlaveShowResp_SlaveShowRet SlaveShowResp::NOT_MY_SLAVE;
const SlaveShowResp_SlaveShowRet SlaveShowResp::NO_MONEY;
const SlaveShowResp_SlaveShowRet SlaveShowResp::STATE_ERROR;
const SlaveShowResp_SlaveShowRet SlaveShowResp::TYPE_ERROR;
const SlaveShowResp_SlaveShowRet SlaveShowResp::NO_MASTER;
const SlaveShowResp_SlaveShowRet SlaveShowResp::WATCH_NUM_MAX;
const SlaveShowResp_SlaveShowRet SlaveShowResp::WATCHED;
const SlaveShowResp_SlaveShowRet SlaveShowResp::SlaveShowRet_MIN;
const SlaveShowResp_SlaveShowRet SlaveShowResp::SlaveShowRet_MAX;
const int SlaveShowResp::SlaveShowRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveShowResp::kResultFieldNumber;
const int SlaveShowResp::kUserSyncFieldNumber;
const int SlaveShowResp::kGetItemListFieldNumber;
#endif  // !_MSC_VER

SlaveShowResp::SlaveShowResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveShowResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

SlaveShowResp::SlaveShowResp(const SlaveShowResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveShowResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveShowResp::~SlaveShowResp() {
  SharedDtor();
}

void SlaveShowResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void SlaveShowResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveShowResp& SlaveShowResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveShowResp* SlaveShowResp::default_instance_ = NULL;

SlaveShowResp* SlaveShowResp::New() const {
  return new SlaveShowResp;
}

void SlaveShowResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveShowResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveShowResp.SlaveShowRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveShowResp_SlaveShowRet_IsValid(value)) {
            set_result(static_cast< ::SlaveShowResp_SlaveShowRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveShowResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveShowResp.SlaveShowRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .Pair get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->get_item_list(i), output);
  }

}

int SlaveShowResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveShowResp.SlaveShowRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .Pair get_item_list = 3;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveShowResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveShowResp*>(&from));
}

void SlaveShowResp::MergeFrom(const SlaveShowResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void SlaveShowResp::CopyFrom(const SlaveShowResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveShowResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  return true;
}

void SlaveShowResp::Swap(SlaveShowResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveShowResp::GetTypeName() const {
  return "SlaveShowResp";
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveWorkReq::kSlaveNameFieldNumber;
#endif  // !_MSC_VER

SlaveWorkReq::SlaveWorkReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveWorkReq::InitAsDefaultInstance() {
}

SlaveWorkReq::SlaveWorkReq(const SlaveWorkReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveWorkReq::SharedCtor() {
  _cached_size_ = 0;
  slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveWorkReq::~SlaveWorkReq() {
  SharedDtor();
}

void SlaveWorkReq::SharedDtor() {
  if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
    delete slave_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SlaveWorkReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveWorkReq& SlaveWorkReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveWorkReq* SlaveWorkReq::default_instance_ = NULL;

SlaveWorkReq* SlaveWorkReq::New() const {
  return new SlaveWorkReq;
}

void SlaveWorkReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_name()) {
      if (slave_name_ != &::google::protobuf::internal::kEmptyString) {
        slave_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveWorkReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string slave_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_slave_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveWorkReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string slave_name = 1;
  if (has_slave_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->slave_name(), output);
  }

}

int SlaveWorkReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string slave_name = 1;
    if (has_slave_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->slave_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveWorkReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveWorkReq*>(&from));
}

void SlaveWorkReq::MergeFrom(const SlaveWorkReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_name()) {
      set_slave_name(from.slave_name());
    }
  }
}

void SlaveWorkReq::CopyFrom(const SlaveWorkReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveWorkReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveWorkReq::Swap(SlaveWorkReq* other) {
  if (other != this) {
    std::swap(slave_name_, other->slave_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveWorkReq::GetTypeName() const {
  return "SlaveWorkReq";
}


// ===================================================================

bool SlaveWorkResp_SlaveWorkRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::OK;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::FAIL;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::NOT_MY_SLAVE;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::CD_TIME;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::SlaveWorkRet_MIN;
const SlaveWorkResp_SlaveWorkRet SlaveWorkResp::SlaveWorkRet_MAX;
const int SlaveWorkResp::SlaveWorkRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveWorkResp::kResultFieldNumber;
const int SlaveWorkResp::kUserSyncFieldNumber;
const int SlaveWorkResp::kGetItemListFieldNumber;
const int SlaveWorkResp::kNoteInfoFieldNumber;
#endif  // !_MSC_VER

SlaveWorkResp::SlaveWorkResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveWorkResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  note_info_ = const_cast< ::SlaveNoteInfo*>(
      ::SlaveNoteInfo::internal_default_instance());
#else
  note_info_ = const_cast< ::SlaveNoteInfo*>(&::SlaveNoteInfo::default_instance());
#endif
}

SlaveWorkResp::SlaveWorkResp(const SlaveWorkResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveWorkResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  note_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveWorkResp::~SlaveWorkResp() {
  SharedDtor();
}

void SlaveWorkResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete note_info_;
  }
}

void SlaveWorkResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveWorkResp& SlaveWorkResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveWorkResp* SlaveWorkResp::default_instance_ = NULL;

SlaveWorkResp* SlaveWorkResp::New() const {
  return new SlaveWorkResp;
}

void SlaveWorkResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_note_info()) {
      if (note_info_ != NULL) note_info_->::SlaveNoteInfo::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveWorkResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveWorkResp.SlaveWorkRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveWorkResp_SlaveWorkRet_IsValid(value)) {
            set_result(static_cast< ::SlaveWorkResp_SlaveWorkRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        if (input->ExpectTag(34)) goto parse_note_info;
        break;
      }

      // optional .SlaveNoteInfo note_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_note_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_note_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveWorkResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveWorkResp.SlaveWorkRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .Pair get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->get_item_list(i), output);
  }

  // optional .SlaveNoteInfo note_info = 4;
  if (has_note_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->note_info(), output);
  }

}

int SlaveWorkResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveWorkResp.SlaveWorkRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .SlaveNoteInfo note_info = 4;
    if (has_note_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->note_info());
    }

  }
  // repeated .Pair get_item_list = 3;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveWorkResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveWorkResp*>(&from));
}

void SlaveWorkResp::MergeFrom(const SlaveWorkResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_note_info()) {
      mutable_note_info()->::SlaveNoteInfo::MergeFrom(from.note_info());
    }
  }
}

void SlaveWorkResp::CopyFrom(const SlaveWorkResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveWorkResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  if (has_note_info()) {
    if (!this->note_info().IsInitialized()) return false;
  }
  return true;
}

void SlaveWorkResp::Swap(SlaveWorkResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(note_info_, other->note_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveWorkResp::GetTypeName() const {
  return "SlaveWorkResp";
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveFawnOnReq::kTypeFieldNumber;
#endif  // !_MSC_VER

SlaveFawnOnReq::SlaveFawnOnReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveFawnOnReq::InitAsDefaultInstance() {
}

SlaveFawnOnReq::SlaveFawnOnReq(const SlaveFawnOnReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveFawnOnReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveFawnOnReq::~SlaveFawnOnReq() {
  SharedDtor();
}

void SlaveFawnOnReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SlaveFawnOnReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveFawnOnReq& SlaveFawnOnReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveFawnOnReq* SlaveFawnOnReq::default_instance_ = NULL;

SlaveFawnOnReq* SlaveFawnOnReq::New() const {
  return new SlaveFawnOnReq;
}

void SlaveFawnOnReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveFawnOnReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveFawnOnReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

}

int SlaveFawnOnReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveFawnOnReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveFawnOnReq*>(&from));
}

void SlaveFawnOnReq::MergeFrom(const SlaveFawnOnReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void SlaveFawnOnReq::CopyFrom(const SlaveFawnOnReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveFawnOnReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveFawnOnReq::Swap(SlaveFawnOnReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveFawnOnReq::GetTypeName() const {
  return "SlaveFawnOnReq";
}


// ===================================================================

bool SlaveFawnOnResp_SlaveFawnOnRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::OK;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::FAIL;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::NO_MASTER;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::CD_TIME;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::SlaveFawnOnRet_MIN;
const SlaveFawnOnResp_SlaveFawnOnRet SlaveFawnOnResp::SlaveFawnOnRet_MAX;
const int SlaveFawnOnResp::SlaveFawnOnRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveFawnOnResp::kResultFieldNumber;
const int SlaveFawnOnResp::kUserSyncFieldNumber;
const int SlaveFawnOnResp::kGetItemListFieldNumber;
const int SlaveFawnOnResp::kNoteInfoFieldNumber;
#endif  // !_MSC_VER

SlaveFawnOnResp::SlaveFawnOnResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveFawnOnResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  note_info_ = const_cast< ::SlaveNoteInfo*>(
      ::SlaveNoteInfo::internal_default_instance());
#else
  note_info_ = const_cast< ::SlaveNoteInfo*>(&::SlaveNoteInfo::default_instance());
#endif
}

SlaveFawnOnResp::SlaveFawnOnResp(const SlaveFawnOnResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveFawnOnResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  note_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveFawnOnResp::~SlaveFawnOnResp() {
  SharedDtor();
}

void SlaveFawnOnResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete note_info_;
  }
}

void SlaveFawnOnResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveFawnOnResp& SlaveFawnOnResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveFawnOnResp* SlaveFawnOnResp::default_instance_ = NULL;

SlaveFawnOnResp* SlaveFawnOnResp::New() const {
  return new SlaveFawnOnResp;
}

void SlaveFawnOnResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_note_info()) {
      if (note_info_ != NULL) note_info_->::SlaveNoteInfo::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveFawnOnResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveFawnOnResp.SlaveFawnOnRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveFawnOnResp_SlaveFawnOnRet_IsValid(value)) {
            set_result(static_cast< ::SlaveFawnOnResp_SlaveFawnOnRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        if (input->ExpectTag(34)) goto parse_note_info;
        break;
      }

      // optional .SlaveNoteInfo note_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_note_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_note_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveFawnOnResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveFawnOnResp.SlaveFawnOnRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .Pair get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->get_item_list(i), output);
  }

  // optional .SlaveNoteInfo note_info = 4;
  if (has_note_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->note_info(), output);
  }

}

int SlaveFawnOnResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveFawnOnResp.SlaveFawnOnRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .SlaveNoteInfo note_info = 4;
    if (has_note_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->note_info());
    }

  }
  // repeated .Pair get_item_list = 3;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveFawnOnResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveFawnOnResp*>(&from));
}

void SlaveFawnOnResp::MergeFrom(const SlaveFawnOnResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_note_info()) {
      mutable_note_info()->::SlaveNoteInfo::MergeFrom(from.note_info());
    }
  }
}

void SlaveFawnOnResp::CopyFrom(const SlaveFawnOnResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveFawnOnResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  if (has_note_info()) {
    if (!this->note_info().IsInitialized()) return false;
  }
  return true;
}

void SlaveFawnOnResp::Swap(SlaveFawnOnResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(note_info_, other->note_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveFawnOnResp::GetTypeName() const {
  return "SlaveFawnOnResp";
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveHelpReq::kTypeFieldNumber;
#endif  // !_MSC_VER

SlaveHelpReq::SlaveHelpReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveHelpReq::InitAsDefaultInstance() {
}

SlaveHelpReq::SlaveHelpReq(const SlaveHelpReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveHelpReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveHelpReq::~SlaveHelpReq() {
  SharedDtor();
}

void SlaveHelpReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SlaveHelpReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveHelpReq& SlaveHelpReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveHelpReq* SlaveHelpReq::default_instance_ = NULL;

SlaveHelpReq* SlaveHelpReq::New() const {
  return new SlaveHelpReq;
}

void SlaveHelpReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveHelpReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveHelpReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

}

int SlaveHelpReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveHelpReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveHelpReq*>(&from));
}

void SlaveHelpReq::MergeFrom(const SlaveHelpReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void SlaveHelpReq::CopyFrom(const SlaveHelpReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveHelpReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveHelpReq::Swap(SlaveHelpReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveHelpReq::GetTypeName() const {
  return "SlaveHelpReq";
}


// ===================================================================

bool SlaveHelpResp_SlaveHelpRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::OK;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::FAIL;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::NO_MASTER;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::CD_TIME;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::SEND_LIST_EMPTY;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::SlaveHelpRet_MIN;
const SlaveHelpResp_SlaveHelpRet SlaveHelpResp::SlaveHelpRet_MAX;
const int SlaveHelpResp::SlaveHelpRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveHelpResp::kResultFieldNumber;
const int SlaveHelpResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

SlaveHelpResp::SlaveHelpResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveHelpResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

SlaveHelpResp::SlaveHelpResp(const SlaveHelpResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveHelpResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveHelpResp::~SlaveHelpResp() {
  SharedDtor();
}

void SlaveHelpResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void SlaveHelpResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveHelpResp& SlaveHelpResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveHelpResp* SlaveHelpResp::default_instance_ = NULL;

SlaveHelpResp* SlaveHelpResp::New() const {
  return new SlaveHelpResp;
}

void SlaveHelpResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveHelpResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveHelpResp.SlaveHelpRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveHelpResp_SlaveHelpRet_IsValid(value)) {
            set_result(static_cast< ::SlaveHelpResp_SlaveHelpRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveHelpResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveHelpResp.SlaveHelpRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int SlaveHelpResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveHelpResp.SlaveHelpRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveHelpResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveHelpResp*>(&from));
}

void SlaveHelpResp::MergeFrom(const SlaveHelpResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void SlaveHelpResp::CopyFrom(const SlaveHelpResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveHelpResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void SlaveHelpResp::Swap(SlaveHelpResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveHelpResp::GetTypeName() const {
  return "SlaveHelpResp";
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveSearchReq::kTypeFieldNumber;
#endif  // !_MSC_VER

SlaveSearchReq::SlaveSearchReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveSearchReq::InitAsDefaultInstance() {
}

SlaveSearchReq::SlaveSearchReq(const SlaveSearchReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveSearchReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveSearchReq::~SlaveSearchReq() {
  SharedDtor();
}

void SlaveSearchReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SlaveSearchReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveSearchReq& SlaveSearchReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveSearchReq* SlaveSearchReq::default_instance_ = NULL;

SlaveSearchReq* SlaveSearchReq::New() const {
  return new SlaveSearchReq;
}

void SlaveSearchReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveSearchReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveSearchReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

}

int SlaveSearchReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveSearchReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveSearchReq*>(&from));
}

void SlaveSearchReq::MergeFrom(const SlaveSearchReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void SlaveSearchReq::CopyFrom(const SlaveSearchReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveSearchReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveSearchReq::Swap(SlaveSearchReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveSearchReq::GetTypeName() const {
  return "SlaveSearchReq";
}


// ===================================================================

bool SlaveSearchResp_SlaveSearchRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::OK;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::FAIL;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::EMPTY;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::HAS_MASTER;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::ERROR_TYPE;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::SlaveSearchRet_MIN;
const SlaveSearchResp_SlaveSearchRet SlaveSearchResp::SlaveSearchRet_MAX;
const int SlaveSearchResp::SlaveSearchRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveSearchResp::kResultFieldNumber;
const int SlaveSearchResp::kUserSyncFieldNumber;
const int SlaveSearchResp::kInfoListFieldNumber;
#endif  // !_MSC_VER

SlaveSearchResp::SlaveSearchResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveSearchResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

SlaveSearchResp::SlaveSearchResp(const SlaveSearchResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveSearchResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveSearchResp::~SlaveSearchResp() {
  SharedDtor();
}

void SlaveSearchResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void SlaveSearchResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveSearchResp& SlaveSearchResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveSearchResp* SlaveSearchResp::default_instance_ = NULL;

SlaveSearchResp* SlaveSearchResp::New() const {
  return new SlaveSearchResp;
}

void SlaveSearchResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveSearchResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveSearchResp.SlaveSearchRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveSearchResp_SlaveSearchRet_IsValid(value)) {
            set_result(static_cast< ::SlaveSearchResp_SlaveSearchRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_info_list;
        break;
      }

      // repeated .SlaveBriefInfo info_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_info_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_info_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveSearchResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveSearchResp.SlaveSearchRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .SlaveBriefInfo info_list = 3;
  for (int i = 0; i < this->info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->info_list(i), output);
  }

}

int SlaveSearchResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveSearchResp.SlaveSearchRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .SlaveBriefInfo info_list = 3;
  total_size += 1 * this->info_list_size();
  for (int i = 0; i < this->info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->info_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveSearchResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveSearchResp*>(&from));
}

void SlaveSearchResp::MergeFrom(const SlaveSearchResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  info_list_.MergeFrom(from.info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void SlaveSearchResp::CopyFrom(const SlaveSearchResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveSearchResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < info_list_size(); i++) {
    if (!this->info_list(i).IsInitialized()) return false;
  }
  return true;
}

void SlaveSearchResp::Swap(SlaveSearchResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    info_list_.Swap(&other->info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveSearchResp::GetTypeName() const {
  return "SlaveSearchResp";
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveAddTimesReq::kTypeFieldNumber;
#endif  // !_MSC_VER

SlaveAddTimesReq::SlaveAddTimesReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveAddTimesReq::InitAsDefaultInstance() {
}

SlaveAddTimesReq::SlaveAddTimesReq(const SlaveAddTimesReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveAddTimesReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveAddTimesReq::~SlaveAddTimesReq() {
  SharedDtor();
}

void SlaveAddTimesReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SlaveAddTimesReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveAddTimesReq& SlaveAddTimesReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveAddTimesReq* SlaveAddTimesReq::default_instance_ = NULL;

SlaveAddTimesReq* SlaveAddTimesReq::New() const {
  return new SlaveAddTimesReq;
}

void SlaveAddTimesReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveAddTimesReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveAddTimesReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

}

int SlaveAddTimesReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveAddTimesReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveAddTimesReq*>(&from));
}

void SlaveAddTimesReq::MergeFrom(const SlaveAddTimesReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void SlaveAddTimesReq::CopyFrom(const SlaveAddTimesReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveAddTimesReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveAddTimesReq::Swap(SlaveAddTimesReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveAddTimesReq::GetTypeName() const {
  return "SlaveAddTimesReq";
}


// ===================================================================

bool SlaveAddTimesResp_SlaveAddTimesRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::OK;
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::FAIL;
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::NO_MONEY;
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::SlaveAddTimesRet_MIN;
const SlaveAddTimesResp_SlaveAddTimesRet SlaveAddTimesResp::SlaveAddTimesRet_MAX;
const int SlaveAddTimesResp::SlaveAddTimesRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveAddTimesResp::kResultFieldNumber;
const int SlaveAddTimesResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

SlaveAddTimesResp::SlaveAddTimesResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveAddTimesResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

SlaveAddTimesResp::SlaveAddTimesResp(const SlaveAddTimesResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveAddTimesResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveAddTimesResp::~SlaveAddTimesResp() {
  SharedDtor();
}

void SlaveAddTimesResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void SlaveAddTimesResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveAddTimesResp& SlaveAddTimesResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveAddTimesResp* SlaveAddTimesResp::default_instance_ = NULL;

SlaveAddTimesResp* SlaveAddTimesResp::New() const {
  return new SlaveAddTimesResp;
}

void SlaveAddTimesResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveAddTimesResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveAddTimesResp.SlaveAddTimesRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveAddTimesResp_SlaveAddTimesRet_IsValid(value)) {
            set_result(static_cast< ::SlaveAddTimesResp_SlaveAddTimesRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveAddTimesResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveAddTimesResp.SlaveAddTimesRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int SlaveAddTimesResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveAddTimesResp.SlaveAddTimesRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveAddTimesResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveAddTimesResp*>(&from));
}

void SlaveAddTimesResp::MergeFrom(const SlaveAddTimesResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void SlaveAddTimesResp::CopyFrom(const SlaveAddTimesResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveAddTimesResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void SlaveAddTimesResp::Swap(SlaveAddTimesResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveAddTimesResp::GetTypeName() const {
  return "SlaveAddTimesResp";
}


// ===================================================================

#ifndef _MSC_VER
const int SlaveAttackReq::kTypeFieldNumber;
const int SlaveAttackReq::kUserNameFieldNumber;
const int SlaveAttackReq::kLineupFieldNumber;
#endif  // !_MSC_VER

SlaveAttackReq::SlaveAttackReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveAttackReq::InitAsDefaultInstance() {
}

SlaveAttackReq::SlaveAttackReq(const SlaveAttackReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveAttackReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveAttackReq::~SlaveAttackReq() {
  SharedDtor();
}

void SlaveAttackReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SlaveAttackReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveAttackReq& SlaveAttackReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveAttackReq* SlaveAttackReq::default_instance_ = NULL;

SlaveAttackReq* SlaveAttackReq::New() const {
  return new SlaveAttackReq;
}

void SlaveAttackReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
  }
  lineup_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveAttackReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name;
        break;
      }

      // required string user_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lineup;
        break;
      }

      // repeated int32 lineup = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lineup:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_lineup())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_lineup())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lineup;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveAttackReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required string user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->user_name(), output);
  }

  // repeated int32 lineup = 3;
  for (int i = 0; i < this->lineup_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->lineup(i), output);
  }

}

int SlaveAttackReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required string user_name = 2;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

  }
  // repeated int32 lineup = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->lineup_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->lineup(i));
    }
    total_size += 1 * this->lineup_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveAttackReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveAttackReq*>(&from));
}

void SlaveAttackReq::MergeFrom(const SlaveAttackReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  lineup_.MergeFrom(from.lineup_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
  }
}

void SlaveAttackReq::CopyFrom(const SlaveAttackReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveAttackReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SlaveAttackReq::Swap(SlaveAttackReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(user_name_, other->user_name_);
    lineup_.Swap(&other->lineup_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveAttackReq::GetTypeName() const {
  return "SlaveAttackReq";
}


// ===================================================================

bool SlaveAttackResp_SlaveAttackRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::OK;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::FAIL;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NO_EMEMY;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::ATTACK_SELF;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::ERROR_TYPE;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::HAS_MASTER;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NO_TIMES;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::CD_TIME;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NO_SHIPS;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NO_DURABLE;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::FIXING;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NOT_SLAVE_MASTER;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::MAX_SLAVE;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::NO_MASTER;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::HAS_SLAVE;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::SHOWING;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::CATCH_ERROR;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::OUTING;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::SlaveAttackRet_MIN;
const SlaveAttackResp_SlaveAttackRet SlaveAttackResp::SlaveAttackRet_MAX;
const int SlaveAttackResp::SlaveAttackRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SlaveAttackResp::kResultFieldNumber;
const int SlaveAttackResp::kUserSyncFieldNumber;
const int SlaveAttackResp::kAttackListFieldNumber;
const int SlaveAttackResp::kHurterListFieldNumber;
const int SlaveAttackResp::kEventListFieldNumber;
const int SlaveAttackResp::kIsWinFieldNumber;
const int SlaveAttackResp::kIsCatchFieldNumber;
const int SlaveAttackResp::kGetItemListFieldNumber;
const int SlaveAttackResp::kReqFieldNumber;
#endif  // !_MSC_VER

SlaveAttackResp::SlaveAttackResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SlaveAttackResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::SlaveAttackReq*>(
      ::SlaveAttackReq::internal_default_instance());
#else
  req_ = const_cast< ::SlaveAttackReq*>(&::SlaveAttackReq::default_instance());
#endif
}

SlaveAttackResp::SlaveAttackResp(const SlaveAttackResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SlaveAttackResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  iswin_ = false;
  iscatch_ = false;
  req_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveAttackResp::~SlaveAttackResp() {
  SharedDtor();
}

void SlaveAttackResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete req_;
  }
}

void SlaveAttackResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SlaveAttackResp& SlaveAttackResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdSlave_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdSlave_2eproto();
#endif
  return *default_instance_;
}

SlaveAttackResp* SlaveAttackResp::default_instance_ = NULL;

SlaveAttackResp* SlaveAttackResp::New() const {
  return new SlaveAttackResp;
}

void SlaveAttackResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    iswin_ = false;
    iscatch_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::SlaveAttackReq::Clear();
    }
  }
  attack_list_.Clear();
  hurter_list_.Clear();
  event_list_.Clear();
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SlaveAttackResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SlaveAttackResp.SlaveAttackRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SlaveAttackResp_SlaveAttackRet_IsValid(value)) {
            set_result(static_cast< ::SlaveAttackResp_SlaveAttackRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_attack_list;
        break;
      }

      // repeated .AirShip attack_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attack_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_attack_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_attack_list;
        if (input->ExpectTag(34)) goto parse_hurter_list;
        break;
      }

      // repeated .AirShip hurter_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hurter_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_hurter_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_hurter_list;
        if (input->ExpectTag(42)) goto parse_event_list;
        break;
      }

      // repeated .EventInfo event_list = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_event_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_event_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_event_list;
        if (input->ExpectTag(48)) goto parse_isWin;
        break;
      }

      // optional bool isWin = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isWin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &iswin_)));
          set_has_iswin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_isCatch;
        break;
      }

      // optional bool isCatch = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isCatch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &iscatch_)));
          set_has_iscatch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_get_item_list;
        if (input->ExpectTag(74)) goto parse_req;
        break;
      }

      // optional .SlaveAttackReq req = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SlaveAttackResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .SlaveAttackResp.SlaveAttackRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .AirShip attack_list = 3;
  for (int i = 0; i < this->attack_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->attack_list(i), output);
  }

  // repeated .AirShip hurter_list = 4;
  for (int i = 0; i < this->hurter_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->hurter_list(i), output);
  }

  // repeated .EventInfo event_list = 5;
  for (int i = 0; i < this->event_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->event_list(i), output);
  }

  // optional bool isWin = 6;
  if (has_iswin()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->iswin(), output);
  }

  // optional bool isCatch = 7;
  if (has_iscatch()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->iscatch(), output);
  }

  // repeated .Pair get_item_list = 8;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->get_item_list(i), output);
  }

  // optional .SlaveAttackReq req = 9;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->req(), output);
  }

}

int SlaveAttackResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .SlaveAttackResp.SlaveAttackRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional bool isWin = 6;
    if (has_iswin()) {
      total_size += 1 + 1;
    }

    // optional bool isCatch = 7;
    if (has_iscatch()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .SlaveAttackReq req = 9;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

  }
  // repeated .AirShip attack_list = 3;
  total_size += 1 * this->attack_list_size();
  for (int i = 0; i < this->attack_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attack_list(i));
  }

  // repeated .AirShip hurter_list = 4;
  total_size += 1 * this->hurter_list_size();
  for (int i = 0; i < this->hurter_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->hurter_list(i));
  }

  // repeated .EventInfo event_list = 5;
  total_size += 1 * this->event_list_size();
  for (int i = 0; i < this->event_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->event_list(i));
  }

  // repeated .Pair get_item_list = 8;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveAttackResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SlaveAttackResp*>(&from));
}

void SlaveAttackResp::MergeFrom(const SlaveAttackResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  attack_list_.MergeFrom(from.attack_list_);
  hurter_list_.MergeFrom(from.hurter_list_);
  event_list_.MergeFrom(from.event_list_);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_iswin()) {
      set_iswin(from.iswin());
    }
    if (from.has_iscatch()) {
      set_iscatch(from.iscatch());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_req()) {
      mutable_req()->::SlaveAttackReq::MergeFrom(from.req());
    }
  }
}

void SlaveAttackResp::CopyFrom(const SlaveAttackResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveAttackResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < attack_list_size(); i++) {
    if (!this->attack_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < hurter_list_size(); i++) {
    if (!this->hurter_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < event_list_size(); i++) {
    if (!this->event_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  return true;
}

void SlaveAttackResp::Swap(SlaveAttackResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    attack_list_.Swap(&other->attack_list_);
    hurter_list_.Swap(&other->hurter_list_);
    event_list_.Swap(&other->event_list_);
    std::swap(iswin_, other->iswin_);
    std::swap(iscatch_, other->iscatch_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(req_, other->req_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SlaveAttackResp::GetTypeName() const {
  return "SlaveAttackResp";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
