// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdLogin.proto

#ifndef PROTOBUF_CmdLogin_2eproto__INCLUDED
#define PROTOBUF_CmdLogin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "UserInfo.pb.h"
#include "Item.pb.h"
#include "AirShip.pb.h"
#include "UserSync.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdLogin_2eproto();
void protobuf_AssignDesc_CmdLogin_2eproto();
void protobuf_ShutdownFile_CmdLogin_2eproto();

class LoginReq;
class LoginExtData;
class LoginResp;
class RegistReq;
class RegistReq_ExtInfo;
class ReRegistReq;
class RegistInitShipReq;
class RegistInitShipResp;

enum LoginResp_LoginRet {
  LoginResp_LoginRet_OK = 0,
  LoginResp_LoginRet_FAIL = -1,
  LoginResp_LoginRet_NODATA = 1,
  LoginResp_LoginRet_NOAUTH = 2,
  LoginResp_LoginRet_FULL = 3,
  LoginResp_LoginRet_VER_ERR = 4,
  LoginResp_LoginRet_NICKNAME_EXIST = 5,
  LoginResp_LoginRet_NICKNAME_ERR = 6,
  LoginResp_LoginRet_BLOCKED = 7
};
bool LoginResp_LoginRet_IsValid(int value);
const LoginResp_LoginRet LoginResp_LoginRet_LoginRet_MIN = LoginResp_LoginRet_FAIL;
const LoginResp_LoginRet LoginResp_LoginRet_LoginRet_MAX = LoginResp_LoginRet_BLOCKED;
const int LoginResp_LoginRet_LoginRet_ARRAYSIZE = LoginResp_LoginRet_LoginRet_MAX + 1;

// ===================================================================

class LoginReq : public ::google::protobuf::MessageLite {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string domain = 3;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 3;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // required int32 server = 4;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 4;
  inline ::google::protobuf::int32 server() const;
  inline void set_server(::google::protobuf::int32 value);

  // required int32 platform = 5;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 5;
  inline ::google::protobuf::int32 platform() const;
  inline void set_platform(::google::protobuf::int32 value);

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional int32 userip = 7;
  inline bool has_userip() const;
  inline void clear_userip();
  static const int kUseripFieldNumber = 7;
  inline ::google::protobuf::int32 userip() const;
  inline void set_userip(::google::protobuf::int32 value);

  // optional string device_type = 8;
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 8;
  inline const ::std::string& device_type() const;
  inline void set_device_type(const ::std::string& value);
  inline void set_device_type(const char* value);
  inline void set_device_type(const char* value, size_t size);
  inline ::std::string* mutable_device_type();
  inline ::std::string* release_device_type();
  inline void set_allocated_device_type(::std::string* device_type);

  // optional string resolution = 9;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 9;
  inline const ::std::string& resolution() const;
  inline void set_resolution(const ::std::string& value);
  inline void set_resolution(const char* value);
  inline void set_resolution(const char* value, size_t size);
  inline ::std::string* mutable_resolution();
  inline ::std::string* release_resolution();
  inline void set_allocated_resolution(::std::string* resolution);

  // optional string os_type = 10;
  inline bool has_os_type() const;
  inline void clear_os_type();
  static const int kOsTypeFieldNumber = 10;
  inline const ::std::string& os_type() const;
  inline void set_os_type(const ::std::string& value);
  inline void set_os_type(const char* value);
  inline void set_os_type(const char* value, size_t size);
  inline ::std::string* mutable_os_type();
  inline ::std::string* release_os_type();
  inline void set_allocated_os_type(::std::string* os_type);

  // optional string ISP = 11;
  inline bool has_isp() const;
  inline void clear_isp();
  static const int kISPFieldNumber = 11;
  inline const ::std::string& isp() const;
  inline void set_isp(const ::std::string& value);
  inline void set_isp(const char* value);
  inline void set_isp(const char* value, size_t size);
  inline ::std::string* mutable_isp();
  inline ::std::string* release_isp();
  inline void set_allocated_isp(::std::string* isp);

  // optional string net = 12;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 12;
  inline const ::std::string& net() const;
  inline void set_net(const ::std::string& value);
  inline void set_net(const char* value);
  inline void set_net(const char* value, size_t size);
  inline ::std::string* mutable_net();
  inline ::std::string* release_net();
  inline void set_allocated_net(::std::string* net);

  // optional string MCC = 13;
  inline bool has_mcc() const;
  inline void clear_mcc();
  static const int kMCCFieldNumber = 13;
  inline const ::std::string& mcc() const;
  inline void set_mcc(const ::std::string& value);
  inline void set_mcc(const char* value);
  inline void set_mcc(const char* value, size_t size);
  inline ::std::string* mutable_mcc();
  inline ::std::string* release_mcc();
  inline void set_allocated_mcc(::std::string* mcc);

  // optional string ip = 14;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 14;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string sid = 15;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 15;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // @@protoc_insertion_point(class_scope:LoginReq)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_userip();
  inline void clear_has_userip();
  inline void set_has_device_type();
  inline void clear_has_device_type();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_os_type();
  inline void clear_has_os_type();
  inline void set_has_isp();
  inline void clear_has_isp();
  inline void set_has_net();
  inline void clear_has_net();
  inline void set_has_mcc();
  inline void clear_has_mcc();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_sid();
  inline void clear_has_sid();

  ::std::string* user_name_;
  ::std::string* key_;
  ::std::string* domain_;
  ::google::protobuf::int32 server_;
  ::google::protobuf::int32 platform_;
  ::std::string* version_;
  ::std::string* device_type_;
  ::std::string* resolution_;
  ::std::string* os_type_;
  ::std::string* isp_;
  ::std::string* net_;
  ::std::string* mcc_;
  ::std::string* ip_;
  ::std::string* sid_;
  ::google::protobuf::int32 userip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdLogin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdLogin_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdLogin_2eproto();
  friend void protobuf_ShutdownFile_CmdLogin_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class LoginExtData : public ::google::protobuf::MessageLite {
 public:
  LoginExtData();
  virtual ~LoginExtData();

  LoginExtData(const LoginExtData& from);

  inline LoginExtData& operator=(const LoginExtData& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginExtData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginExtData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginExtData* other);

  // implements Message ----------------------------------------------

  LoginExtData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginExtData& from);
  void MergeFrom(const LoginExtData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 un_read_mail_num = 1;
  inline bool has_un_read_mail_num() const;
  inline void clear_un_read_mail_num();
  static const int kUnReadMailNumFieldNumber = 1;
  inline ::google::protobuf::int32 un_read_mail_num() const;
  inline void set_un_read_mail_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginExtData)
 private:
  inline void set_has_un_read_mail_num();
  inline void clear_has_un_read_mail_num();

  ::google::protobuf::int32 un_read_mail_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdLogin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdLogin_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdLogin_2eproto();
  friend void protobuf_ShutdownFile_CmdLogin_2eproto();

  void InitAsDefaultInstance();
  static LoginExtData* default_instance_;
};
// -------------------------------------------------------------------

class LoginResp : public ::google::protobuf::MessageLite {
 public:
  LoginResp();
  virtual ~LoginResp();

  LoginResp(const LoginResp& from);

  inline LoginResp& operator=(const LoginResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginResp* other);

  // implements Message ----------------------------------------------

  LoginResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginResp& from);
  void MergeFrom(const LoginResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LoginResp_LoginRet LoginRet;
  static const LoginRet OK = LoginResp_LoginRet_OK;
  static const LoginRet FAIL = LoginResp_LoginRet_FAIL;
  static const LoginRet NODATA = LoginResp_LoginRet_NODATA;
  static const LoginRet NOAUTH = LoginResp_LoginRet_NOAUTH;
  static const LoginRet FULL = LoginResp_LoginRet_FULL;
  static const LoginRet VER_ERR = LoginResp_LoginRet_VER_ERR;
  static const LoginRet NICKNAME_EXIST = LoginResp_LoginRet_NICKNAME_EXIST;
  static const LoginRet NICKNAME_ERR = LoginResp_LoginRet_NICKNAME_ERR;
  static const LoginRet BLOCKED = LoginResp_LoginRet_BLOCKED;
  static inline bool LoginRet_IsValid(int value) {
    return LoginResp_LoginRet_IsValid(value);
  }
  static const LoginRet LoginRet_MIN =
    LoginResp_LoginRet_LoginRet_MIN;
  static const LoginRet LoginRet_MAX =
    LoginResp_LoginRet_LoginRet_MAX;
  static const int LoginRet_ARRAYSIZE =
    LoginResp_LoginRet_LoginRet_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .LoginResp.LoginRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::LoginResp_LoginRet result() const;
  inline void set_result(::LoginResp_LoginRet value);

  // optional string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bool isInit = 4;
  inline bool has_isinit() const;
  inline void clear_isinit();
  static const int kIsInitFieldNumber = 4;
  inline bool isinit() const;
  inline void set_isinit(bool value);

  // optional .UserInfo user_info = 5;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 5;
  inline const ::UserInfo& user_info() const;
  inline ::UserInfo* mutable_user_info();
  inline ::UserInfo* release_user_info();
  inline void set_allocated_user_info(::UserInfo* user_info);

  // optional int64 nowtime = 6;
  inline bool has_nowtime() const;
  inline void clear_nowtime();
  static const int kNowtimeFieldNumber = 6;
  inline ::google::protobuf::int64 nowtime() const;
  inline void set_nowtime(::google::protobuf::int64 value);

  // optional .ShipList ship_list = 7;
  inline bool has_ship_list() const;
  inline void clear_ship_list();
  static const int kShipListFieldNumber = 7;
  inline const ::ShipList& ship_list() const;
  inline ::ShipList* mutable_ship_list();
  inline ::ShipList* release_ship_list();
  inline void set_allocated_ship_list(::ShipList* ship_list);

  // optional .ItemList item_list = 8;
  inline bool has_item_list() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 8;
  inline const ::ItemList& item_list() const;
  inline ::ItemList* mutable_item_list();
  inline ::ItemList* release_item_list();
  inline void set_allocated_item_list(::ItemList* item_list);

  // optional .LoginExtData ext_data = 9;
  inline bool has_ext_data() const;
  inline void clear_ext_data();
  static const int kExtDataFieldNumber = 9;
  inline const ::LoginExtData& ext_data() const;
  inline ::LoginExtData* mutable_ext_data();
  inline ::LoginExtData* release_ext_data();
  inline void set_allocated_ext_data(::LoginExtData* ext_data);

  // optional string version = 10;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 10;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional int32 unrecharge = 11;
  inline bool has_unrecharge() const;
  inline void clear_unrecharge();
  static const int kUnrechargeFieldNumber = 11;
  inline ::google::protobuf::int32 unrecharge() const;
  inline void set_unrecharge(::google::protobuf::int32 value);

  // optional int32 anti_cdkey = 12;
  inline bool has_anti_cdkey() const;
  inline void clear_anti_cdkey();
  static const int kAntiCdkeyFieldNumber = 12;
  inline ::google::protobuf::int32 anti_cdkey() const;
  inline void set_anti_cdkey(::google::protobuf::int32 value);

  // optional int32 anti_weichat = 13;
  inline bool has_anti_weichat() const;
  inline void clear_anti_weichat();
  static const int kAntiWeichatFieldNumber = 13;
  inline ::google::protobuf::int32 anti_weichat() const;
  inline void set_anti_weichat(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_isinit();
  inline void clear_has_isinit();
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_nowtime();
  inline void clear_has_nowtime();
  inline void set_has_ship_list();
  inline void clear_has_ship_list();
  inline void set_has_item_list();
  inline void clear_has_item_list();
  inline void set_has_ext_data();
  inline void clear_has_ext_data();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_unrecharge();
  inline void clear_has_unrecharge();
  inline void set_has_anti_cdkey();
  inline void clear_has_anti_cdkey();
  inline void set_has_anti_weichat();
  inline void clear_has_anti_weichat();

  ::std::string* user_name_;
  int result_;
  bool isinit_;
  ::std::string* key_;
  ::UserInfo* user_info_;
  ::google::protobuf::int64 nowtime_;
  ::ShipList* ship_list_;
  ::ItemList* item_list_;
  ::LoginExtData* ext_data_;
  ::std::string* version_;
  ::google::protobuf::int32 unrecharge_;
  ::google::protobuf::int32 anti_cdkey_;
  ::google::protobuf::int32 anti_weichat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdLogin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdLogin_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdLogin_2eproto();
  friend void protobuf_ShutdownFile_CmdLogin_2eproto();

  void InitAsDefaultInstance();
  static LoginResp* default_instance_;
};
// -------------------------------------------------------------------

class RegistReq_ExtInfo : public ::google::protobuf::MessageLite {
 public:
  RegistReq_ExtInfo();
  virtual ~RegistReq_ExtInfo();

  RegistReq_ExtInfo(const RegistReq_ExtInfo& from);

  inline RegistReq_ExtInfo& operator=(const RegistReq_ExtInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegistReq_ExtInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegistReq_ExtInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegistReq_ExtInfo* other);

  // implements Message ----------------------------------------------

  RegistReq_ExtInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegistReq_ExtInfo& from);
  void MergeFrom(const RegistReq_ExtInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 real_money = 1;
  inline bool has_real_money() const;
  inline void clear_real_money();
  static const int kRealMoneyFieldNumber = 1;
  inline ::google::protobuf::int32 real_money() const;
  inline void set_real_money(::google::protobuf::int32 value);

  // optional int32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RegistReq.ExtInfo)
 private:
  inline void set_has_real_money();
  inline void clear_has_real_money();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::int32 real_money_;
  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdLogin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdLogin_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdLogin_2eproto();
  friend void protobuf_ShutdownFile_CmdLogin_2eproto();

  void InitAsDefaultInstance();
  static RegistReq_ExtInfo* default_instance_;
};
// -------------------------------------------------------------------

class RegistReq : public ::google::protobuf::MessageLite {
 public:
  RegistReq();
  virtual ~RegistReq();

  RegistReq(const RegistReq& from);

  inline RegistReq& operator=(const RegistReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegistReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegistReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegistReq* other);

  // implements Message ----------------------------------------------

  RegistReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegistReq& from);
  void MergeFrom(const RegistReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RegistReq_ExtInfo ExtInfo;

  // accessors -------------------------------------------------------

  // required string roleName = 1;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 1;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  inline void set_allocated_rolename(::std::string* rolename);

  // required int32 lead = 2;
  inline bool has_lead() const;
  inline void clear_lead();
  static const int kLeadFieldNumber = 2;
  inline ::google::protobuf::int32 lead() const;
  inline void set_lead(::google::protobuf::int32 value);

  // required int32 server = 3;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 3;
  inline ::google::protobuf::int32 server() const;
  inline void set_server(::google::protobuf::int32 value);

  // optional string device_type = 4;
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 4;
  inline const ::std::string& device_type() const;
  inline void set_device_type(const ::std::string& value);
  inline void set_device_type(const char* value);
  inline void set_device_type(const char* value, size_t size);
  inline ::std::string* mutable_device_type();
  inline ::std::string* release_device_type();
  inline void set_allocated_device_type(::std::string* device_type);

  // optional string resolution = 5;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 5;
  inline const ::std::string& resolution() const;
  inline void set_resolution(const ::std::string& value);
  inline void set_resolution(const char* value);
  inline void set_resolution(const char* value, size_t size);
  inline ::std::string* mutable_resolution();
  inline ::std::string* release_resolution();
  inline void set_allocated_resolution(::std::string* resolution);

  // optional string os_type = 6;
  inline bool has_os_type() const;
  inline void clear_os_type();
  static const int kOsTypeFieldNumber = 6;
  inline const ::std::string& os_type() const;
  inline void set_os_type(const ::std::string& value);
  inline void set_os_type(const char* value);
  inline void set_os_type(const char* value, size_t size);
  inline ::std::string* mutable_os_type();
  inline ::std::string* release_os_type();
  inline void set_allocated_os_type(::std::string* os_type);

  // optional string ISP = 7;
  inline bool has_isp() const;
  inline void clear_isp();
  static const int kISPFieldNumber = 7;
  inline const ::std::string& isp() const;
  inline void set_isp(const ::std::string& value);
  inline void set_isp(const char* value);
  inline void set_isp(const char* value, size_t size);
  inline ::std::string* mutable_isp();
  inline ::std::string* release_isp();
  inline void set_allocated_isp(::std::string* isp);

  // optional string net = 8;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 8;
  inline const ::std::string& net() const;
  inline void set_net(const ::std::string& value);
  inline void set_net(const char* value);
  inline void set_net(const char* value, size_t size);
  inline ::std::string* mutable_net();
  inline ::std::string* release_net();
  inline void set_allocated_net(::std::string* net);

  // optional string MCC = 9;
  inline bool has_mcc() const;
  inline void clear_mcc();
  static const int kMCCFieldNumber = 9;
  inline const ::std::string& mcc() const;
  inline void set_mcc(const ::std::string& value);
  inline void set_mcc(const char* value);
  inline void set_mcc(const char* value, size_t size);
  inline ::std::string* mutable_mcc();
  inline ::std::string* release_mcc();
  inline void set_allocated_mcc(::std::string* mcc);

  // optional string account = 10;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 10;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string ip = 11;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 11;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 platform = 12;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 12;
  inline ::google::protobuf::int32 platform() const;
  inline void set_platform(::google::protobuf::int32 value);

  // optional string real_name = 13;
  inline bool has_real_name() const;
  inline void clear_real_name();
  static const int kRealNameFieldNumber = 13;
  inline const ::std::string& real_name() const;
  inline void set_real_name(const ::std::string& value);
  inline void set_real_name(const char* value);
  inline void set_real_name(const char* value, size_t size);
  inline ::std::string* mutable_real_name();
  inline ::std::string* release_real_name();
  inline void set_allocated_real_name(::std::string* real_name);

  // optional .RegistReq.ExtInfo ext_info = 14;
  inline bool has_ext_info() const;
  inline void clear_ext_info();
  static const int kExtInfoFieldNumber = 14;
  inline const ::RegistReq_ExtInfo& ext_info() const;
  inline ::RegistReq_ExtInfo* mutable_ext_info();
  inline ::RegistReq_ExtInfo* release_ext_info();
  inline void set_allocated_ext_info(::RegistReq_ExtInfo* ext_info);

  // optional string version = 15;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 15;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:RegistReq)
 private:
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_lead();
  inline void clear_has_lead();
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_device_type();
  inline void clear_has_device_type();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_os_type();
  inline void clear_has_os_type();
  inline void set_has_isp();
  inline void clear_has_isp();
  inline void set_has_net();
  inline void clear_has_net();
  inline void set_has_mcc();
  inline void clear_has_mcc();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_real_name();
  inline void clear_has_real_name();
  inline void set_has_ext_info();
  inline void clear_has_ext_info();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string* rolename_;
  ::google::protobuf::int32 lead_;
  ::google::protobuf::int32 server_;
  ::std::string* device_type_;
  ::std::string* resolution_;
  ::std::string* os_type_;
  ::std::string* isp_;
  ::std::string* net_;
  ::std::string* mcc_;
  ::std::string* account_;
  ::std::string* ip_;
  ::std::string* real_name_;
  ::RegistReq_ExtInfo* ext_info_;
  ::std::string* version_;
  ::google::protobuf::int32 platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdLogin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdLogin_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdLogin_2eproto();
  friend void protobuf_ShutdownFile_CmdLogin_2eproto();

  void InitAsDefaultInstance();
  static RegistReq* default_instance_;
};
// -------------------------------------------------------------------

class ReRegistReq : public ::google::protobuf::MessageLite {
 public:
  ReRegistReq();
  virtual ~ReRegistReq();

  ReRegistReq(const ReRegistReq& from);

  inline ReRegistReq& operator=(const ReRegistReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReRegistReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReRegistReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReRegistReq* other);

  // implements Message ----------------------------------------------

  ReRegistReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReRegistReq& from);
  void MergeFrom(const ReRegistReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roleName = 1;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 1;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  inline void set_allocated_rolename(::std::string* rolename);

  // required int32 face = 2;
  inline bool has_face() const;
  inline void clear_face();
  static const int kFaceFieldNumber = 2;
  inline ::google::protobuf::int32 face() const;
  inline void set_face(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ReRegistReq)
 private:
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_face();
  inline void clear_has_face();

  ::std::string* rolename_;
  ::google::protobuf::int32 face_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdLogin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdLogin_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdLogin_2eproto();
  friend void protobuf_ShutdownFile_CmdLogin_2eproto();

  void InitAsDefaultInstance();
  static ReRegistReq* default_instance_;
};
// -------------------------------------------------------------------

class RegistInitShipReq : public ::google::protobuf::MessageLite {
 public:
  RegistInitShipReq();
  virtual ~RegistInitShipReq();

  RegistInitShipReq(const RegistInitShipReq& from);

  inline RegistInitShipReq& operator=(const RegistInitShipReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegistInitShipReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegistInitShipReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegistInitShipReq* other);

  // implements Message ----------------------------------------------

  RegistInitShipReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegistInitShipReq& from);
  void MergeFrom(const RegistInitShipReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 init_index = 1;
  inline bool has_init_index() const;
  inline void clear_init_index();
  static const int kInitIndexFieldNumber = 1;
  inline ::google::protobuf::int32 init_index() const;
  inline void set_init_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RegistInitShipReq)
 private:
  inline void set_has_init_index();
  inline void clear_has_init_index();

  ::google::protobuf::int32 init_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdLogin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdLogin_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdLogin_2eproto();
  friend void protobuf_ShutdownFile_CmdLogin_2eproto();

  void InitAsDefaultInstance();
  static RegistInitShipReq* default_instance_;
};
// -------------------------------------------------------------------

class RegistInitShipResp : public ::google::protobuf::MessageLite {
 public:
  RegistInitShipResp();
  virtual ~RegistInitShipResp();

  RegistInitShipResp(const RegistInitShipResp& from);

  inline RegistInitShipResp& operator=(const RegistInitShipResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegistInitShipResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegistInitShipResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegistInitShipResp* other);

  // implements Message ----------------------------------------------

  RegistInitShipResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegistInitShipResp& from);
  void MergeFrom(const RegistInitShipResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:RegistInitShipResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdLogin_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdLogin_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdLogin_2eproto();
  friend void protobuf_ShutdownFile_CmdLogin_2eproto();

  void InitAsDefaultInstance();
  static RegistInitShipResp* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginReq

// required string user_name = 1;
inline bool LoginReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& LoginReq::user_name() const {
  return *user_name_;
}
inline void LoginReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* LoginReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string key = 2;
inline bool LoginReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& LoginReq::key() const {
  return *key_;
}
inline void LoginReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LoginReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LoginReq::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* LoginReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domain = 3;
inline bool LoginReq::has_domain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReq::set_has_domain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReq::clear_has_domain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReq::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& LoginReq::domain() const {
  return *domain_;
}
inline void LoginReq::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void LoginReq::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void LoginReq::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* LoginReq::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 server = 4;
inline bool LoginReq::has_server() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginReq::set_has_server() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginReq::clear_has_server() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginReq::clear_server() {
  server_ = 0;
  clear_has_server();
}
inline ::google::protobuf::int32 LoginReq::server() const {
  return server_;
}
inline void LoginReq::set_server(::google::protobuf::int32 value) {
  set_has_server();
  server_ = value;
}

// required int32 platform = 5;
inline bool LoginReq::has_platform() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginReq::set_has_platform() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginReq::clear_has_platform() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginReq::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::google::protobuf::int32 LoginReq::platform() const {
  return platform_;
}
inline void LoginReq::set_platform(::google::protobuf::int32 value) {
  set_has_platform();
  platform_ = value;
}

// optional string version = 6;
inline bool LoginReq::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginReq::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginReq::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginReq::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& LoginReq::version() const {
  return *version_;
}
inline void LoginReq::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginReq::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginReq::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* LoginReq::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 userip = 7;
inline bool LoginReq::has_userip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginReq::set_has_userip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginReq::clear_has_userip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginReq::clear_userip() {
  userip_ = 0;
  clear_has_userip();
}
inline ::google::protobuf::int32 LoginReq::userip() const {
  return userip_;
}
inline void LoginReq::set_userip(::google::protobuf::int32 value) {
  set_has_userip();
  userip_ = value;
}

// optional string device_type = 8;
inline bool LoginReq::has_device_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginReq::set_has_device_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginReq::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginReq::clear_device_type() {
  if (device_type_ != &::google::protobuf::internal::kEmptyString) {
    device_type_->clear();
  }
  clear_has_device_type();
}
inline const ::std::string& LoginReq::device_type() const {
  return *device_type_;
}
inline void LoginReq::set_device_type(const ::std::string& value) {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(value);
}
inline void LoginReq::set_device_type(const char* value) {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(value);
}
inline void LoginReq::set_device_type(const char* value, size_t size) {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_device_type() {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  return device_type_;
}
inline ::std::string* LoginReq::release_device_type() {
  clear_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_type_;
    device_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_device_type(::std::string* device_type) {
  if (device_type_ != &::google::protobuf::internal::kEmptyString) {
    delete device_type_;
  }
  if (device_type) {
    set_has_device_type();
    device_type_ = device_type;
  } else {
    clear_has_device_type();
    device_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resolution = 9;
inline bool LoginReq::has_resolution() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginReq::set_has_resolution() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginReq::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginReq::clear_resolution() {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    resolution_->clear();
  }
  clear_has_resolution();
}
inline const ::std::string& LoginReq::resolution() const {
  return *resolution_;
}
inline void LoginReq::set_resolution(const ::std::string& value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void LoginReq::set_resolution(const char* value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void LoginReq::set_resolution(const char* value, size_t size) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_resolution() {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  return resolution_;
}
inline ::std::string* LoginReq::release_resolution() {
  clear_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resolution_;
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_resolution(::std::string* resolution) {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    delete resolution_;
  }
  if (resolution) {
    set_has_resolution();
    resolution_ = resolution;
  } else {
    clear_has_resolution();
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os_type = 10;
inline bool LoginReq::has_os_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginReq::set_has_os_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginReq::clear_has_os_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginReq::clear_os_type() {
  if (os_type_ != &::google::protobuf::internal::kEmptyString) {
    os_type_->clear();
  }
  clear_has_os_type();
}
inline const ::std::string& LoginReq::os_type() const {
  return *os_type_;
}
inline void LoginReq::set_os_type(const ::std::string& value) {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  os_type_->assign(value);
}
inline void LoginReq::set_os_type(const char* value) {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  os_type_->assign(value);
}
inline void LoginReq::set_os_type(const char* value, size_t size) {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  os_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_os_type() {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  return os_type_;
}
inline ::std::string* LoginReq::release_os_type() {
  clear_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_type_;
    os_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_os_type(::std::string* os_type) {
  if (os_type_ != &::google::protobuf::internal::kEmptyString) {
    delete os_type_;
  }
  if (os_type) {
    set_has_os_type();
    os_type_ = os_type;
  } else {
    clear_has_os_type();
    os_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ISP = 11;
inline bool LoginReq::has_isp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginReq::set_has_isp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginReq::clear_has_isp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginReq::clear_isp() {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    isp_->clear();
  }
  clear_has_isp();
}
inline const ::std::string& LoginReq::isp() const {
  return *isp_;
}
inline void LoginReq::set_isp(const ::std::string& value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void LoginReq::set_isp(const char* value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void LoginReq::set_isp(const char* value, size_t size) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_isp() {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  return isp_;
}
inline ::std::string* LoginReq::release_isp() {
  clear_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isp_;
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_isp(::std::string* isp) {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    delete isp_;
  }
  if (isp) {
    set_has_isp();
    isp_ = isp;
  } else {
    clear_has_isp();
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string net = 12;
inline bool LoginReq::has_net() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LoginReq::set_has_net() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LoginReq::clear_has_net() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LoginReq::clear_net() {
  if (net_ != &::google::protobuf::internal::kEmptyString) {
    net_->clear();
  }
  clear_has_net();
}
inline const ::std::string& LoginReq::net() const {
  return *net_;
}
inline void LoginReq::set_net(const ::std::string& value) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  net_->assign(value);
}
inline void LoginReq::set_net(const char* value) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  net_->assign(value);
}
inline void LoginReq::set_net(const char* value, size_t size) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_net() {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  return net_;
}
inline ::std::string* LoginReq::release_net() {
  clear_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = net_;
    net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_net(::std::string* net) {
  if (net_ != &::google::protobuf::internal::kEmptyString) {
    delete net_;
  }
  if (net) {
    set_has_net();
    net_ = net;
  } else {
    clear_has_net();
    net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MCC = 13;
inline bool LoginReq::has_mcc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LoginReq::set_has_mcc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LoginReq::clear_has_mcc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LoginReq::clear_mcc() {
  if (mcc_ != &::google::protobuf::internal::kEmptyString) {
    mcc_->clear();
  }
  clear_has_mcc();
}
inline const ::std::string& LoginReq::mcc() const {
  return *mcc_;
}
inline void LoginReq::set_mcc(const ::std::string& value) {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  mcc_->assign(value);
}
inline void LoginReq::set_mcc(const char* value) {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  mcc_->assign(value);
}
inline void LoginReq::set_mcc(const char* value, size_t size) {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  mcc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_mcc() {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  return mcc_;
}
inline ::std::string* LoginReq::release_mcc() {
  clear_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mcc_;
    mcc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_mcc(::std::string* mcc) {
  if (mcc_ != &::google::protobuf::internal::kEmptyString) {
    delete mcc_;
  }
  if (mcc) {
    set_has_mcc();
    mcc_ = mcc;
  } else {
    clear_has_mcc();
    mcc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 14;
inline bool LoginReq::has_ip() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LoginReq::set_has_ip() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LoginReq::clear_has_ip() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LoginReq::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& LoginReq::ip() const {
  return *ip_;
}
inline void LoginReq::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void LoginReq::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void LoginReq::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* LoginReq::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sid = 15;
inline bool LoginReq::has_sid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LoginReq::set_has_sid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LoginReq::clear_has_sid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LoginReq::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& LoginReq::sid() const {
  return *sid_;
}
inline void LoginReq::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void LoginReq::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void LoginReq::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* LoginReq::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginExtData

// required int32 un_read_mail_num = 1;
inline bool LoginExtData::has_un_read_mail_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginExtData::set_has_un_read_mail_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginExtData::clear_has_un_read_mail_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginExtData::clear_un_read_mail_num() {
  un_read_mail_num_ = 0;
  clear_has_un_read_mail_num();
}
inline ::google::protobuf::int32 LoginExtData::un_read_mail_num() const {
  return un_read_mail_num_;
}
inline void LoginExtData::set_un_read_mail_num(::google::protobuf::int32 value) {
  set_has_un_read_mail_num();
  un_read_mail_num_ = value;
}

// -------------------------------------------------------------------

// LoginResp

// required .LoginResp.LoginRet result = 1;
inline bool LoginResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::LoginResp_LoginRet LoginResp::result() const {
  return static_cast< ::LoginResp_LoginRet >(result_);
}
inline void LoginResp::set_result(::LoginResp_LoginRet value) {
  assert(::LoginResp_LoginRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional string user_name = 2;
inline bool LoginResp::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResp::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResp::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResp::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& LoginResp::user_name() const {
  return *user_name_;
}
inline void LoginResp::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginResp::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginResp::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResp::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* LoginResp::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResp::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 3;
inline bool LoginResp::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResp::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResp::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResp::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& LoginResp::key() const {
  return *key_;
}
inline void LoginResp::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LoginResp::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LoginResp::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResp::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* LoginResp::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResp::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool isInit = 4;
inline bool LoginResp::has_isinit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResp::set_has_isinit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResp::clear_has_isinit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResp::clear_isinit() {
  isinit_ = false;
  clear_has_isinit();
}
inline bool LoginResp::isinit() const {
  return isinit_;
}
inline void LoginResp::set_isinit(bool value) {
  set_has_isinit();
  isinit_ = value;
}

// optional .UserInfo user_info = 5;
inline bool LoginResp::has_user_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResp::set_has_user_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResp::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResp::clear_user_info() {
  if (user_info_ != NULL) user_info_->::UserInfo::Clear();
  clear_has_user_info();
}
inline const ::UserInfo& LoginResp::user_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_info_ != NULL ? *user_info_ : *default_instance().user_info_;
#else
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
#endif
}
inline ::UserInfo* LoginResp::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::UserInfo;
  return user_info_;
}
inline ::UserInfo* LoginResp::release_user_info() {
  clear_has_user_info();
  ::UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void LoginResp::set_allocated_user_info(::UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
}

// optional int64 nowtime = 6;
inline bool LoginResp::has_nowtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResp::set_has_nowtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginResp::clear_has_nowtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginResp::clear_nowtime() {
  nowtime_ = GOOGLE_LONGLONG(0);
  clear_has_nowtime();
}
inline ::google::protobuf::int64 LoginResp::nowtime() const {
  return nowtime_;
}
inline void LoginResp::set_nowtime(::google::protobuf::int64 value) {
  set_has_nowtime();
  nowtime_ = value;
}

// optional .ShipList ship_list = 7;
inline bool LoginResp::has_ship_list() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginResp::set_has_ship_list() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginResp::clear_has_ship_list() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginResp::clear_ship_list() {
  if (ship_list_ != NULL) ship_list_->::ShipList::Clear();
  clear_has_ship_list();
}
inline const ::ShipList& LoginResp::ship_list() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ship_list_ != NULL ? *ship_list_ : *default_instance().ship_list_;
#else
  return ship_list_ != NULL ? *ship_list_ : *default_instance_->ship_list_;
#endif
}
inline ::ShipList* LoginResp::mutable_ship_list() {
  set_has_ship_list();
  if (ship_list_ == NULL) ship_list_ = new ::ShipList;
  return ship_list_;
}
inline ::ShipList* LoginResp::release_ship_list() {
  clear_has_ship_list();
  ::ShipList* temp = ship_list_;
  ship_list_ = NULL;
  return temp;
}
inline void LoginResp::set_allocated_ship_list(::ShipList* ship_list) {
  delete ship_list_;
  ship_list_ = ship_list;
  if (ship_list) {
    set_has_ship_list();
  } else {
    clear_has_ship_list();
  }
}

// optional .ItemList item_list = 8;
inline bool LoginResp::has_item_list() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginResp::set_has_item_list() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginResp::clear_has_item_list() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginResp::clear_item_list() {
  if (item_list_ != NULL) item_list_->::ItemList::Clear();
  clear_has_item_list();
}
inline const ::ItemList& LoginResp::item_list() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_list_ != NULL ? *item_list_ : *default_instance().item_list_;
#else
  return item_list_ != NULL ? *item_list_ : *default_instance_->item_list_;
#endif
}
inline ::ItemList* LoginResp::mutable_item_list() {
  set_has_item_list();
  if (item_list_ == NULL) item_list_ = new ::ItemList;
  return item_list_;
}
inline ::ItemList* LoginResp::release_item_list() {
  clear_has_item_list();
  ::ItemList* temp = item_list_;
  item_list_ = NULL;
  return temp;
}
inline void LoginResp::set_allocated_item_list(::ItemList* item_list) {
  delete item_list_;
  item_list_ = item_list;
  if (item_list) {
    set_has_item_list();
  } else {
    clear_has_item_list();
  }
}

// optional .LoginExtData ext_data = 9;
inline bool LoginResp::has_ext_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginResp::set_has_ext_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginResp::clear_has_ext_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginResp::clear_ext_data() {
  if (ext_data_ != NULL) ext_data_->::LoginExtData::Clear();
  clear_has_ext_data();
}
inline const ::LoginExtData& LoginResp::ext_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ext_data_ != NULL ? *ext_data_ : *default_instance().ext_data_;
#else
  return ext_data_ != NULL ? *ext_data_ : *default_instance_->ext_data_;
#endif
}
inline ::LoginExtData* LoginResp::mutable_ext_data() {
  set_has_ext_data();
  if (ext_data_ == NULL) ext_data_ = new ::LoginExtData;
  return ext_data_;
}
inline ::LoginExtData* LoginResp::release_ext_data() {
  clear_has_ext_data();
  ::LoginExtData* temp = ext_data_;
  ext_data_ = NULL;
  return temp;
}
inline void LoginResp::set_allocated_ext_data(::LoginExtData* ext_data) {
  delete ext_data_;
  ext_data_ = ext_data;
  if (ext_data) {
    set_has_ext_data();
  } else {
    clear_has_ext_data();
  }
}

// optional string version = 10;
inline bool LoginResp::has_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginResp::set_has_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginResp::clear_has_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginResp::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& LoginResp::version() const {
  return *version_;
}
inline void LoginResp::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginResp::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginResp::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResp::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* LoginResp::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResp::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 unrecharge = 11;
inline bool LoginResp::has_unrecharge() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginResp::set_has_unrecharge() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginResp::clear_has_unrecharge() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginResp::clear_unrecharge() {
  unrecharge_ = 0;
  clear_has_unrecharge();
}
inline ::google::protobuf::int32 LoginResp::unrecharge() const {
  return unrecharge_;
}
inline void LoginResp::set_unrecharge(::google::protobuf::int32 value) {
  set_has_unrecharge();
  unrecharge_ = value;
}

// optional int32 anti_cdkey = 12;
inline bool LoginResp::has_anti_cdkey() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LoginResp::set_has_anti_cdkey() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LoginResp::clear_has_anti_cdkey() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LoginResp::clear_anti_cdkey() {
  anti_cdkey_ = 0;
  clear_has_anti_cdkey();
}
inline ::google::protobuf::int32 LoginResp::anti_cdkey() const {
  return anti_cdkey_;
}
inline void LoginResp::set_anti_cdkey(::google::protobuf::int32 value) {
  set_has_anti_cdkey();
  anti_cdkey_ = value;
}

// optional int32 anti_weichat = 13;
inline bool LoginResp::has_anti_weichat() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LoginResp::set_has_anti_weichat() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LoginResp::clear_has_anti_weichat() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LoginResp::clear_anti_weichat() {
  anti_weichat_ = 0;
  clear_has_anti_weichat();
}
inline ::google::protobuf::int32 LoginResp::anti_weichat() const {
  return anti_weichat_;
}
inline void LoginResp::set_anti_weichat(::google::protobuf::int32 value) {
  set_has_anti_weichat();
  anti_weichat_ = value;
}

// -------------------------------------------------------------------

// RegistReq_ExtInfo

// optional int32 real_money = 1;
inline bool RegistReq_ExtInfo::has_real_money() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistReq_ExtInfo::set_has_real_money() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistReq_ExtInfo::clear_has_real_money() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistReq_ExtInfo::clear_real_money() {
  real_money_ = 0;
  clear_has_real_money();
}
inline ::google::protobuf::int32 RegistReq_ExtInfo::real_money() const {
  return real_money_;
}
inline void RegistReq_ExtInfo::set_real_money(::google::protobuf::int32 value) {
  set_has_real_money();
  real_money_ = value;
}

// optional int32 money = 2;
inline bool RegistReq_ExtInfo::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistReq_ExtInfo::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistReq_ExtInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistReq_ExtInfo::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 RegistReq_ExtInfo::money() const {
  return money_;
}
inline void RegistReq_ExtInfo::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// RegistReq

// required string roleName = 1;
inline bool RegistReq::has_rolename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistReq::set_has_rolename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistReq::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistReq::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& RegistReq::rolename() const {
  return *rolename_;
}
inline void RegistReq::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void RegistReq::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void RegistReq::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* RegistReq::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_rolename(::std::string* rolename) {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    delete rolename_;
  }
  if (rolename) {
    set_has_rolename();
    rolename_ = rolename;
  } else {
    clear_has_rolename();
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 lead = 2;
inline bool RegistReq::has_lead() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistReq::set_has_lead() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistReq::clear_has_lead() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistReq::clear_lead() {
  lead_ = 0;
  clear_has_lead();
}
inline ::google::protobuf::int32 RegistReq::lead() const {
  return lead_;
}
inline void RegistReq::set_lead(::google::protobuf::int32 value) {
  set_has_lead();
  lead_ = value;
}

// required int32 server = 3;
inline bool RegistReq::has_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegistReq::set_has_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegistReq::clear_has_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegistReq::clear_server() {
  server_ = 0;
  clear_has_server();
}
inline ::google::protobuf::int32 RegistReq::server() const {
  return server_;
}
inline void RegistReq::set_server(::google::protobuf::int32 value) {
  set_has_server();
  server_ = value;
}

// optional string device_type = 4;
inline bool RegistReq::has_device_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegistReq::set_has_device_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegistReq::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegistReq::clear_device_type() {
  if (device_type_ != &::google::protobuf::internal::kEmptyString) {
    device_type_->clear();
  }
  clear_has_device_type();
}
inline const ::std::string& RegistReq::device_type() const {
  return *device_type_;
}
inline void RegistReq::set_device_type(const ::std::string& value) {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(value);
}
inline void RegistReq::set_device_type(const char* value) {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(value);
}
inline void RegistReq::set_device_type(const char* value, size_t size) {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  device_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_device_type() {
  set_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    device_type_ = new ::std::string;
  }
  return device_type_;
}
inline ::std::string* RegistReq::release_device_type() {
  clear_has_device_type();
  if (device_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_type_;
    device_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_device_type(::std::string* device_type) {
  if (device_type_ != &::google::protobuf::internal::kEmptyString) {
    delete device_type_;
  }
  if (device_type) {
    set_has_device_type();
    device_type_ = device_type;
  } else {
    clear_has_device_type();
    device_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resolution = 5;
inline bool RegistReq::has_resolution() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegistReq::set_has_resolution() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegistReq::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegistReq::clear_resolution() {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    resolution_->clear();
  }
  clear_has_resolution();
}
inline const ::std::string& RegistReq::resolution() const {
  return *resolution_;
}
inline void RegistReq::set_resolution(const ::std::string& value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void RegistReq::set_resolution(const char* value) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(value);
}
inline void RegistReq::set_resolution(const char* value, size_t size) {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  resolution_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_resolution() {
  set_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    resolution_ = new ::std::string;
  }
  return resolution_;
}
inline ::std::string* RegistReq::release_resolution() {
  clear_has_resolution();
  if (resolution_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resolution_;
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_resolution(::std::string* resolution) {
  if (resolution_ != &::google::protobuf::internal::kEmptyString) {
    delete resolution_;
  }
  if (resolution) {
    set_has_resolution();
    resolution_ = resolution;
  } else {
    clear_has_resolution();
    resolution_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os_type = 6;
inline bool RegistReq::has_os_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegistReq::set_has_os_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegistReq::clear_has_os_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegistReq::clear_os_type() {
  if (os_type_ != &::google::protobuf::internal::kEmptyString) {
    os_type_->clear();
  }
  clear_has_os_type();
}
inline const ::std::string& RegistReq::os_type() const {
  return *os_type_;
}
inline void RegistReq::set_os_type(const ::std::string& value) {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  os_type_->assign(value);
}
inline void RegistReq::set_os_type(const char* value) {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  os_type_->assign(value);
}
inline void RegistReq::set_os_type(const char* value, size_t size) {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  os_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_os_type() {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  return os_type_;
}
inline ::std::string* RegistReq::release_os_type() {
  clear_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_type_;
    os_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_os_type(::std::string* os_type) {
  if (os_type_ != &::google::protobuf::internal::kEmptyString) {
    delete os_type_;
  }
  if (os_type) {
    set_has_os_type();
    os_type_ = os_type;
  } else {
    clear_has_os_type();
    os_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ISP = 7;
inline bool RegistReq::has_isp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegistReq::set_has_isp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegistReq::clear_has_isp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegistReq::clear_isp() {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    isp_->clear();
  }
  clear_has_isp();
}
inline const ::std::string& RegistReq::isp() const {
  return *isp_;
}
inline void RegistReq::set_isp(const ::std::string& value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void RegistReq::set_isp(const char* value) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(value);
}
inline void RegistReq::set_isp(const char* value, size_t size) {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  isp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_isp() {
  set_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    isp_ = new ::std::string;
  }
  return isp_;
}
inline ::std::string* RegistReq::release_isp() {
  clear_has_isp();
  if (isp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isp_;
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_isp(::std::string* isp) {
  if (isp_ != &::google::protobuf::internal::kEmptyString) {
    delete isp_;
  }
  if (isp) {
    set_has_isp();
    isp_ = isp;
  } else {
    clear_has_isp();
    isp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string net = 8;
inline bool RegistReq::has_net() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegistReq::set_has_net() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegistReq::clear_has_net() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegistReq::clear_net() {
  if (net_ != &::google::protobuf::internal::kEmptyString) {
    net_->clear();
  }
  clear_has_net();
}
inline const ::std::string& RegistReq::net() const {
  return *net_;
}
inline void RegistReq::set_net(const ::std::string& value) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  net_->assign(value);
}
inline void RegistReq::set_net(const char* value) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  net_->assign(value);
}
inline void RegistReq::set_net(const char* value, size_t size) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  net_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_net() {
  set_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    net_ = new ::std::string;
  }
  return net_;
}
inline ::std::string* RegistReq::release_net() {
  clear_has_net();
  if (net_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = net_;
    net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_net(::std::string* net) {
  if (net_ != &::google::protobuf::internal::kEmptyString) {
    delete net_;
  }
  if (net) {
    set_has_net();
    net_ = net;
  } else {
    clear_has_net();
    net_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MCC = 9;
inline bool RegistReq::has_mcc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RegistReq::set_has_mcc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RegistReq::clear_has_mcc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RegistReq::clear_mcc() {
  if (mcc_ != &::google::protobuf::internal::kEmptyString) {
    mcc_->clear();
  }
  clear_has_mcc();
}
inline const ::std::string& RegistReq::mcc() const {
  return *mcc_;
}
inline void RegistReq::set_mcc(const ::std::string& value) {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  mcc_->assign(value);
}
inline void RegistReq::set_mcc(const char* value) {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  mcc_->assign(value);
}
inline void RegistReq::set_mcc(const char* value, size_t size) {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  mcc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_mcc() {
  set_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    mcc_ = new ::std::string;
  }
  return mcc_;
}
inline ::std::string* RegistReq::release_mcc() {
  clear_has_mcc();
  if (mcc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mcc_;
    mcc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_mcc(::std::string* mcc) {
  if (mcc_ != &::google::protobuf::internal::kEmptyString) {
    delete mcc_;
  }
  if (mcc) {
    set_has_mcc();
    mcc_ = mcc;
  } else {
    clear_has_mcc();
    mcc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 10;
inline bool RegistReq::has_account() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RegistReq::set_has_account() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RegistReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RegistReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& RegistReq::account() const {
  return *account_;
}
inline void RegistReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RegistReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RegistReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* RegistReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 11;
inline bool RegistReq::has_ip() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RegistReq::set_has_ip() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RegistReq::clear_has_ip() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RegistReq::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RegistReq::ip() const {
  return *ip_;
}
inline void RegistReq::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RegistReq::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RegistReq::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RegistReq::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 platform = 12;
inline bool RegistReq::has_platform() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RegistReq::set_has_platform() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RegistReq::clear_has_platform() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RegistReq::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::google::protobuf::int32 RegistReq::platform() const {
  return platform_;
}
inline void RegistReq::set_platform(::google::protobuf::int32 value) {
  set_has_platform();
  platform_ = value;
}

// optional string real_name = 13;
inline bool RegistReq::has_real_name() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RegistReq::set_has_real_name() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RegistReq::clear_has_real_name() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RegistReq::clear_real_name() {
  if (real_name_ != &::google::protobuf::internal::kEmptyString) {
    real_name_->clear();
  }
  clear_has_real_name();
}
inline const ::std::string& RegistReq::real_name() const {
  return *real_name_;
}
inline void RegistReq::set_real_name(const ::std::string& value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::kEmptyString) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
}
inline void RegistReq::set_real_name(const char* value) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::kEmptyString) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(value);
}
inline void RegistReq::set_real_name(const char* value, size_t size) {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::kEmptyString) {
    real_name_ = new ::std::string;
  }
  real_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_real_name() {
  set_has_real_name();
  if (real_name_ == &::google::protobuf::internal::kEmptyString) {
    real_name_ = new ::std::string;
  }
  return real_name_;
}
inline ::std::string* RegistReq::release_real_name() {
  clear_has_real_name();
  if (real_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = real_name_;
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_real_name(::std::string* real_name) {
  if (real_name_ != &::google::protobuf::internal::kEmptyString) {
    delete real_name_;
  }
  if (real_name) {
    set_has_real_name();
    real_name_ = real_name;
  } else {
    clear_has_real_name();
    real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .RegistReq.ExtInfo ext_info = 14;
inline bool RegistReq::has_ext_info() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RegistReq::set_has_ext_info() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RegistReq::clear_has_ext_info() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RegistReq::clear_ext_info() {
  if (ext_info_ != NULL) ext_info_->::RegistReq_ExtInfo::Clear();
  clear_has_ext_info();
}
inline const ::RegistReq_ExtInfo& RegistReq::ext_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ext_info_ != NULL ? *ext_info_ : *default_instance().ext_info_;
#else
  return ext_info_ != NULL ? *ext_info_ : *default_instance_->ext_info_;
#endif
}
inline ::RegistReq_ExtInfo* RegistReq::mutable_ext_info() {
  set_has_ext_info();
  if (ext_info_ == NULL) ext_info_ = new ::RegistReq_ExtInfo;
  return ext_info_;
}
inline ::RegistReq_ExtInfo* RegistReq::release_ext_info() {
  clear_has_ext_info();
  ::RegistReq_ExtInfo* temp = ext_info_;
  ext_info_ = NULL;
  return temp;
}
inline void RegistReq::set_allocated_ext_info(::RegistReq_ExtInfo* ext_info) {
  delete ext_info_;
  ext_info_ = ext_info;
  if (ext_info) {
    set_has_ext_info();
  } else {
    clear_has_ext_info();
  }
}

// optional string version = 15;
inline bool RegistReq::has_version() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RegistReq::set_has_version() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RegistReq::clear_has_version() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RegistReq::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& RegistReq::version() const {
  return *version_;
}
inline void RegistReq::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RegistReq::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RegistReq::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* RegistReq::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReRegistReq

// required string roleName = 1;
inline bool ReRegistReq::has_rolename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReRegistReq::set_has_rolename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReRegistReq::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReRegistReq::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& ReRegistReq::rolename() const {
  return *rolename_;
}
inline void ReRegistReq::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ReRegistReq::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ReRegistReq::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReRegistReq::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* ReRegistReq::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReRegistReq::set_allocated_rolename(::std::string* rolename) {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    delete rolename_;
  }
  if (rolename) {
    set_has_rolename();
    rolename_ = rolename;
  } else {
    clear_has_rolename();
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 face = 2;
inline bool ReRegistReq::has_face() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReRegistReq::set_has_face() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReRegistReq::clear_has_face() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReRegistReq::clear_face() {
  face_ = 0;
  clear_has_face();
}
inline ::google::protobuf::int32 ReRegistReq::face() const {
  return face_;
}
inline void ReRegistReq::set_face(::google::protobuf::int32 value) {
  set_has_face();
  face_ = value;
}

// -------------------------------------------------------------------

// RegistInitShipReq

// required int32 init_index = 1;
inline bool RegistInitShipReq::has_init_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistInitShipReq::set_has_init_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistInitShipReq::clear_has_init_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistInitShipReq::clear_init_index() {
  init_index_ = 0;
  clear_has_init_index();
}
inline ::google::protobuf::int32 RegistInitShipReq::init_index() const {
  return init_index_;
}
inline void RegistInitShipReq::set_init_index(::google::protobuf::int32 value) {
  set_has_init_index();
  init_index_ = value;
}

// -------------------------------------------------------------------

// RegistInitShipResp

// required int32 result = 1;
inline bool RegistInitShipResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistInitShipResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistInitShipResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistInitShipResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RegistInitShipResp::result() const {
  return result_;
}
inline void RegistInitShipResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool RegistInitShipResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistInitShipResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistInitShipResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistInitShipResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& RegistInitShipResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* RegistInitShipResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* RegistInitShipResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void RegistInitShipResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdLogin_2eproto__INCLUDED
