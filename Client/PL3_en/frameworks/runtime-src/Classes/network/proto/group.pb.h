// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Group.proto

#ifndef PROTOBUF_Group_2eproto__INCLUDED
#define PROTOBUF_Group_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Item.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Group_2eproto();
void protobuf_AssignDesc_Group_2eproto();
void protobuf_ShutdownFile_Group_2eproto();

class HelpInfo;
class GroupTechnology;
class GroupUser;
class GroupMainData;
class GroupMainData_JoinInfo;
class GroupMainData_JoinCondition;

// ===================================================================

class HelpInfo : public ::google::protobuf::MessageLite {
 public:
  HelpInfo();
  virtual ~HelpInfo();

  HelpInfo(const HelpInfo& from);

  inline HelpInfo& operator=(const HelpInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const HelpInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HelpInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HelpInfo* other);

  // implements Message ----------------------------------------------

  HelpInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HelpInfo& from);
  void MergeFrom(const HelpInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int32 id = 3;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::int32 value);
  inline void add_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id();

  // repeated string help_user_name_list = 4;
  inline int help_user_name_list_size() const;
  inline void clear_help_user_name_list();
  static const int kHelpUserNameListFieldNumber = 4;
  inline const ::std::string& help_user_name_list(int index) const;
  inline ::std::string* mutable_help_user_name_list(int index);
  inline void set_help_user_name_list(int index, const ::std::string& value);
  inline void set_help_user_name_list(int index, const char* value);
  inline void set_help_user_name_list(int index, const char* value, size_t size);
  inline ::std::string* add_help_user_name_list();
  inline void add_help_user_name_list(const ::std::string& value);
  inline void add_help_user_name_list(const char* value);
  inline void add_help_user_name_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& help_user_name_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_help_user_name_list();

  // required int32 max_help_times = 5;
  inline bool has_max_help_times() const;
  inline void clear_max_help_times();
  static const int kMaxHelpTimesFieldNumber = 5;
  inline ::google::protobuf::int32 max_help_times() const;
  inline void set_max_help_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:HelpInfo)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_max_help_times();
  inline void clear_has_max_help_times();

  ::std::string* user_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 max_help_times_;
  ::google::protobuf::RepeatedPtrField< ::std::string> help_user_name_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Group_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Group_2eproto();
  #endif
  friend void protobuf_AssignDesc_Group_2eproto();
  friend void protobuf_ShutdownFile_Group_2eproto();

  void InitAsDefaultInstance();
  static HelpInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupTechnology : public ::google::protobuf::MessageLite {
 public:
  GroupTechnology();
  virtual ~GroupTechnology();

  GroupTechnology(const GroupTechnology& from);

  inline GroupTechnology& operator=(const GroupTechnology& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupTechnology& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupTechnology* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupTechnology* other);

  // implements Message ----------------------------------------------

  GroupTechnology* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupTechnology& from);
  void MergeFrom(const GroupTechnology& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tech_id = 1;
  inline bool has_tech_id() const;
  inline void clear_tech_id();
  static const int kTechIdFieldNumber = 1;
  inline ::google::protobuf::int32 tech_id() const;
  inline void set_tech_id(::google::protobuf::int32 value);

  // optional int32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int64 begin_upgrade_time = 3;
  inline bool has_begin_upgrade_time() const;
  inline void clear_begin_upgrade_time();
  static const int kBeginUpgradeTimeFieldNumber = 3;
  inline ::google::protobuf::int64 begin_upgrade_time() const;
  inline void set_begin_upgrade_time(::google::protobuf::int64 value);

  // required int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional int32 city_buff_count = 5;
  inline bool has_city_buff_count() const;
  inline void clear_city_buff_count();
  static const int kCityBuffCountFieldNumber = 5;
  inline ::google::protobuf::int32 city_buff_count() const;
  inline void set_city_buff_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupTechnology)
 private:
  inline void set_has_tech_id();
  inline void clear_has_tech_id();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_begin_upgrade_time();
  inline void clear_has_begin_upgrade_time();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_city_buff_count();
  inline void clear_has_city_buff_count();

  ::google::protobuf::int32 tech_id_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int64 begin_upgrade_time_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 city_buff_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Group_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Group_2eproto();
  #endif
  friend void protobuf_AssignDesc_Group_2eproto();
  friend void protobuf_ShutdownFile_Group_2eproto();

  void InitAsDefaultInstance();
  static GroupTechnology* default_instance_;
};
// -------------------------------------------------------------------

class GroupUser : public ::google::protobuf::MessageLite {
 public:
  GroupUser();
  virtual ~GroupUser();

  GroupUser(const GroupUser& from);

  inline GroupUser& operator=(const GroupUser& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupUser& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupUser* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupUser* other);

  // implements Message ----------------------------------------------

  GroupUser* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupUser& from);
  void MergeFrom(const GroupUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline ::google::protobuf::int32 guid() const;
  inline void set_guid(::google::protobuf::int32 value);

  // required string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required int32 job = 4;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 4;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // required int32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional uint64 last_act = 6;
  inline bool has_last_act() const;
  inline void clear_last_act();
  static const int kLastActFieldNumber = 6;
  inline ::google::protobuf::uint64 last_act() const;
  inline void set_last_act(::google::protobuf::uint64 value);

  // repeated int32 last_gongxian = 7;
  inline int last_gongxian_size() const;
  inline void clear_last_gongxian();
  static const int kLastGongxianFieldNumber = 7;
  inline ::google::protobuf::int32 last_gongxian(int index) const;
  inline void set_last_gongxian(int index, ::google::protobuf::int32 value);
  inline void add_last_gongxian(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      last_gongxian() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_last_gongxian();

  // optional int64 unlock_time = 8;
  inline bool has_unlock_time() const;
  inline void clear_unlock_time();
  static const int kUnlockTimeFieldNumber = 8;
  inline ::google::protobuf::int64 unlock_time() const;
  inline void set_unlock_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GroupUser)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_last_act();
  inline void clear_has_last_act();
  inline void set_has_unlock_time();
  inline void clear_has_unlock_time();

  ::std::string* user_name_;
  ::google::protobuf::int32 guid_;
  ::google::protobuf::int32 job_;
  ::std::string* nickname_;
  ::google::protobuf::uint64 last_act_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > last_gongxian_;
  ::google::protobuf::int64 unlock_time_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Group_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Group_2eproto();
  #endif
  friend void protobuf_AssignDesc_Group_2eproto();
  friend void protobuf_ShutdownFile_Group_2eproto();

  void InitAsDefaultInstance();
  static GroupUser* default_instance_;
};
// -------------------------------------------------------------------

class GroupMainData_JoinInfo : public ::google::protobuf::MessageLite {
 public:
  GroupMainData_JoinInfo();
  virtual ~GroupMainData_JoinInfo();

  GroupMainData_JoinInfo(const GroupMainData_JoinInfo& from);

  inline GroupMainData_JoinInfo& operator=(const GroupMainData_JoinInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupMainData_JoinInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupMainData_JoinInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupMainData_JoinInfo* other);

  // implements Message ----------------------------------------------

  GroupMainData_JoinInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupMainData_JoinInfo& from);
  void MergeFrom(const GroupMainData_JoinInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required int64 join_time = 3;
  inline bool has_join_time() const;
  inline void clear_join_time();
  static const int kJoinTimeFieldNumber = 3;
  inline ::google::protobuf::int64 join_time() const;
  inline void set_join_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GroupMainData.JoinInfo)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_join_time();
  inline void clear_has_join_time();

  ::std::string* user_name_;
  ::std::string* nickname_;
  ::google::protobuf::int64 join_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Group_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Group_2eproto();
  #endif
  friend void protobuf_AssignDesc_Group_2eproto();
  friend void protobuf_ShutdownFile_Group_2eproto();

  void InitAsDefaultInstance();
  static GroupMainData_JoinInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupMainData_JoinCondition : public ::google::protobuf::MessageLite {
 public:
  GroupMainData_JoinCondition();
  virtual ~GroupMainData_JoinCondition();

  GroupMainData_JoinCondition(const GroupMainData_JoinCondition& from);

  inline GroupMainData_JoinCondition& operator=(const GroupMainData_JoinCondition& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupMainData_JoinCondition& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupMainData_JoinCondition* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupMainData_JoinCondition* other);

  // implements Message ----------------------------------------------

  GroupMainData_JoinCondition* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupMainData_JoinCondition& from);
  void MergeFrom(const GroupMainData_JoinCondition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool needAllow = 1;
  inline bool has_needallow() const;
  inline void clear_needallow();
  static const int kNeedAllowFieldNumber = 1;
  inline bool needallow() const;
  inline void set_needallow(bool value);

  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 power = 3;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 3;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupMainData.JoinCondition)
 private:
  inline void set_has_needallow();
  inline void clear_has_needallow();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_power();
  inline void clear_has_power();

  bool needallow_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Group_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Group_2eproto();
  #endif
  friend void protobuf_AssignDesc_Group_2eproto();
  friend void protobuf_ShutdownFile_Group_2eproto();

  void InitAsDefaultInstance();
  static GroupMainData_JoinCondition* default_instance_;
};
// -------------------------------------------------------------------

class GroupMainData : public ::google::protobuf::MessageLite {
 public:
  GroupMainData();
  virtual ~GroupMainData();

  GroupMainData(const GroupMainData& from);

  inline GroupMainData& operator=(const GroupMainData& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupMainData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupMainData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupMainData* other);

  // implements Message ----------------------------------------------

  GroupMainData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupMainData& from);
  void MergeFrom(const GroupMainData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GroupMainData_JoinInfo JoinInfo;
  typedef GroupMainData_JoinCondition JoinCondition;

  // accessors -------------------------------------------------------

  // required string groupid = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 1;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // required string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional int32 icon_id = 4;
  inline bool has_icon_id() const;
  inline void clear_icon_id();
  static const int kIconIdFieldNumber = 4;
  inline ::google::protobuf::int32 icon_id() const;
  inline void set_icon_id(::google::protobuf::int32 value);

  // optional int32 contribute = 5;
  inline bool has_contribute() const;
  inline void clear_contribute();
  static const int kContributeFieldNumber = 5;
  inline ::google::protobuf::int32 contribute() const;
  inline void set_contribute(::google::protobuf::int32 value);

  // optional int32 exp = 6;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 6;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 level = 7;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 7;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional uint32 dayid = 8;
  inline bool has_dayid() const;
  inline void clear_dayid();
  static const int kDayidFieldNumber = 8;
  inline ::google::protobuf::uint32 dayid() const;
  inline void set_dayid(::google::protobuf::uint32 value);

  // repeated .GroupUser user_list = 9;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 9;
  inline const ::GroupUser& user_list(int index) const;
  inline ::GroupUser* mutable_user_list(int index);
  inline ::GroupUser* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::GroupUser >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::GroupUser >*
      mutable_user_list();

  // optional string broadcast = 10;
  inline bool has_broadcast() const;
  inline void clear_broadcast();
  static const int kBroadcastFieldNumber = 10;
  inline const ::std::string& broadcast() const;
  inline void set_broadcast(const ::std::string& value);
  inline void set_broadcast(const char* value);
  inline void set_broadcast(const char* value, size_t size);
  inline ::std::string* mutable_broadcast();
  inline ::std::string* release_broadcast();
  inline void set_allocated_broadcast(::std::string* broadcast);

  // optional string blurb = 11;
  inline bool has_blurb() const;
  inline void clear_blurb();
  static const int kBlurbFieldNumber = 11;
  inline const ::std::string& blurb() const;
  inline void set_blurb(const ::std::string& value);
  inline void set_blurb(const char* value);
  inline void set_blurb(const char* value, size_t size);
  inline ::std::string* mutable_blurb();
  inline ::std::string* release_blurb();
  inline void set_allocated_blurb(::std::string* blurb);

  // optional int32 guid = 12;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 12;
  inline ::google::protobuf::int32 guid() const;
  inline void set_guid(::google::protobuf::int32 value);

  // optional int32 rank = 13;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 13;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // optional int64 create_time = 14;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 14;
  inline ::google::protobuf::int64 create_time() const;
  inline void set_create_time(::google::protobuf::int64 value);

  // optional int64 unlock_time = 15;
  inline bool has_unlock_time() const;
  inline void clear_unlock_time();
  static const int kUnlockTimeFieldNumber = 15;
  inline ::google::protobuf::int64 unlock_time() const;
  inline void set_unlock_time(::google::protobuf::int64 value);

  // repeated .GroupMainData.JoinInfo join_list = 16;
  inline int join_list_size() const;
  inline void clear_join_list();
  static const int kJoinListFieldNumber = 16;
  inline const ::GroupMainData_JoinInfo& join_list(int index) const;
  inline ::GroupMainData_JoinInfo* mutable_join_list(int index);
  inline ::GroupMainData_JoinInfo* add_join_list();
  inline const ::google::protobuf::RepeatedPtrField< ::GroupMainData_JoinInfo >&
      join_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::GroupMainData_JoinInfo >*
      mutable_join_list();

  // required .GroupMainData.JoinCondition join_condition = 17;
  inline bool has_join_condition() const;
  inline void clear_join_condition();
  static const int kJoinConditionFieldNumber = 17;
  inline const ::GroupMainData_JoinCondition& join_condition() const;
  inline ::GroupMainData_JoinCondition* mutable_join_condition();
  inline ::GroupMainData_JoinCondition* release_join_condition();
  inline void set_allocated_join_condition(::GroupMainData_JoinCondition* join_condition);

  // repeated .GroupTechnology tech_list = 18;
  inline int tech_list_size() const;
  inline void clear_tech_list();
  static const int kTechListFieldNumber = 18;
  inline const ::GroupTechnology& tech_list(int index) const;
  inline ::GroupTechnology* mutable_tech_list(int index);
  inline ::GroupTechnology* add_tech_list();
  inline const ::google::protobuf::RepeatedPtrField< ::GroupTechnology >&
      tech_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::GroupTechnology >*
      mutable_tech_list();

  // repeated .HelpInfo help_list = 19;
  inline int help_list_size() const;
  inline void clear_help_list();
  static const int kHelpListFieldNumber = 19;
  inline const ::HelpInfo& help_list(int index) const;
  inline ::HelpInfo* mutable_help_list(int index);
  inline ::HelpInfo* add_help_list();
  inline const ::google::protobuf::RepeatedPtrField< ::HelpInfo >&
      help_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelpInfo >*
      mutable_help_list();

  // optional int32 worship_value = 20;
  inline bool has_worship_value() const;
  inline void clear_worship_value();
  static const int kWorshipValueFieldNumber = 20;
  inline ::google::protobuf::int32 worship_value() const;
  inline void set_worship_value(::google::protobuf::int32 value);

  // optional int32 today_worship_times = 21;
  inline bool has_today_worship_times() const;
  inline void clear_today_worship_times();
  static const int kTodayWorshipTimesFieldNumber = 21;
  inline ::google::protobuf::int32 today_worship_times() const;
  inline void set_today_worship_times(::google::protobuf::int32 value);

  // repeated string occupy_city_list = 22;
  inline int occupy_city_list_size() const;
  inline void clear_occupy_city_list();
  static const int kOccupyCityListFieldNumber = 22;
  inline const ::std::string& occupy_city_list(int index) const;
  inline ::std::string* mutable_occupy_city_list(int index);
  inline void set_occupy_city_list(int index, const ::std::string& value);
  inline void set_occupy_city_list(int index, const char* value);
  inline void set_occupy_city_list(int index, const char* value, size_t size);
  inline ::std::string* add_occupy_city_list();
  inline void add_occupy_city_list(const ::std::string& value);
  inline void add_occupy_city_list(const char* value);
  inline void add_occupy_city_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& occupy_city_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_occupy_city_list();

  // repeated string enlist_list = 23;
  inline int enlist_list_size() const;
  inline void clear_enlist_list();
  static const int kEnlistListFieldNumber = 23;
  inline const ::std::string& enlist_list(int index) const;
  inline ::std::string* mutable_enlist_list(int index);
  inline void set_enlist_list(int index, const ::std::string& value);
  inline void set_enlist_list(int index, const char* value);
  inline void set_enlist_list(int index, const char* value, size_t size);
  inline ::std::string* add_enlist_list();
  inline void add_enlist_list(const ::std::string& value);
  inline void add_enlist_list(const char* value);
  inline void add_enlist_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& enlist_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_enlist_list();

  // repeated string attack_our_list = 24;
  inline int attack_our_list_size() const;
  inline void clear_attack_our_list();
  static const int kAttackOurListFieldNumber = 24;
  inline const ::std::string& attack_our_list(int index) const;
  inline ::std::string* mutable_attack_our_list(int index);
  inline void set_attack_our_list(int index, const ::std::string& value);
  inline void set_attack_our_list(int index, const char* value);
  inline void set_attack_our_list(int index, const char* value, size_t size);
  inline ::std::string* add_attack_our_list();
  inline void add_attack_our_list(const ::std::string& value);
  inline void add_attack_our_list(const char* value);
  inline void add_attack_our_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attack_our_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attack_our_list();

  // @@protoc_insertion_point(class_scope:GroupMainData)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_icon_id();
  inline void clear_has_icon_id();
  inline void set_has_contribute();
  inline void clear_has_contribute();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_dayid();
  inline void clear_has_dayid();
  inline void set_has_broadcast();
  inline void clear_has_broadcast();
  inline void set_has_blurb();
  inline void clear_has_blurb();
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_unlock_time();
  inline void clear_has_unlock_time();
  inline void set_has_join_condition();
  inline void clear_has_join_condition();
  inline void set_has_worship_value();
  inline void clear_has_worship_value();
  inline void set_has_today_worship_times();
  inline void clear_has_today_worship_times();

  ::std::string* groupid_;
  ::std::string* nickname_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 icon_id_;
  ::google::protobuf::int32 contribute_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::uint32 dayid_;
  ::google::protobuf::RepeatedPtrField< ::GroupUser > user_list_;
  ::std::string* broadcast_;
  ::std::string* blurb_;
  ::google::protobuf::int32 guid_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int64 create_time_;
  ::google::protobuf::int64 unlock_time_;
  ::google::protobuf::RepeatedPtrField< ::GroupMainData_JoinInfo > join_list_;
  ::GroupMainData_JoinCondition* join_condition_;
  ::google::protobuf::RepeatedPtrField< ::GroupTechnology > tech_list_;
  ::google::protobuf::RepeatedPtrField< ::HelpInfo > help_list_;
  ::google::protobuf::int32 worship_value_;
  ::google::protobuf::int32 today_worship_times_;
  ::google::protobuf::RepeatedPtrField< ::std::string> occupy_city_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> enlist_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attack_our_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Group_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Group_2eproto();
  #endif
  friend void protobuf_AssignDesc_Group_2eproto();
  friend void protobuf_ShutdownFile_Group_2eproto();

  void InitAsDefaultInstance();
  static GroupMainData* default_instance_;
};
// ===================================================================


// ===================================================================

// HelpInfo

// required string user_name = 1;
inline bool HelpInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelpInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelpInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelpInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& HelpInfo::user_name() const {
  return *user_name_;
}
inline void HelpInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void HelpInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void HelpInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HelpInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* HelpInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HelpInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 2;
inline bool HelpInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HelpInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HelpInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HelpInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 HelpInfo::type() const {
  return type_;
}
inline void HelpInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 id = 3;
inline int HelpInfo::id_size() const {
  return id_.size();
}
inline void HelpInfo::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int32 HelpInfo::id(int index) const {
  return id_.Get(index);
}
inline void HelpInfo::set_id(int index, ::google::protobuf::int32 value) {
  id_.Set(index, value);
}
inline void HelpInfo::add_id(::google::protobuf::int32 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
HelpInfo::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
HelpInfo::mutable_id() {
  return &id_;
}

// repeated string help_user_name_list = 4;
inline int HelpInfo::help_user_name_list_size() const {
  return help_user_name_list_.size();
}
inline void HelpInfo::clear_help_user_name_list() {
  help_user_name_list_.Clear();
}
inline const ::std::string& HelpInfo::help_user_name_list(int index) const {
  return help_user_name_list_.Get(index);
}
inline ::std::string* HelpInfo::mutable_help_user_name_list(int index) {
  return help_user_name_list_.Mutable(index);
}
inline void HelpInfo::set_help_user_name_list(int index, const ::std::string& value) {
  help_user_name_list_.Mutable(index)->assign(value);
}
inline void HelpInfo::set_help_user_name_list(int index, const char* value) {
  help_user_name_list_.Mutable(index)->assign(value);
}
inline void HelpInfo::set_help_user_name_list(int index, const char* value, size_t size) {
  help_user_name_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HelpInfo::add_help_user_name_list() {
  return help_user_name_list_.Add();
}
inline void HelpInfo::add_help_user_name_list(const ::std::string& value) {
  help_user_name_list_.Add()->assign(value);
}
inline void HelpInfo::add_help_user_name_list(const char* value) {
  help_user_name_list_.Add()->assign(value);
}
inline void HelpInfo::add_help_user_name_list(const char* value, size_t size) {
  help_user_name_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HelpInfo::help_user_name_list() const {
  return help_user_name_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HelpInfo::mutable_help_user_name_list() {
  return &help_user_name_list_;
}

// required int32 max_help_times = 5;
inline bool HelpInfo::has_max_help_times() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HelpInfo::set_has_max_help_times() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HelpInfo::clear_has_max_help_times() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HelpInfo::clear_max_help_times() {
  max_help_times_ = 0;
  clear_has_max_help_times();
}
inline ::google::protobuf::int32 HelpInfo::max_help_times() const {
  return max_help_times_;
}
inline void HelpInfo::set_max_help_times(::google::protobuf::int32 value) {
  set_has_max_help_times();
  max_help_times_ = value;
}

// -------------------------------------------------------------------

// GroupTechnology

// required int32 tech_id = 1;
inline bool GroupTechnology::has_tech_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupTechnology::set_has_tech_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupTechnology::clear_has_tech_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupTechnology::clear_tech_id() {
  tech_id_ = 0;
  clear_has_tech_id();
}
inline ::google::protobuf::int32 GroupTechnology::tech_id() const {
  return tech_id_;
}
inline void GroupTechnology::set_tech_id(::google::protobuf::int32 value) {
  set_has_tech_id();
  tech_id_ = value;
}

// optional int32 exp = 2;
inline bool GroupTechnology::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupTechnology::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupTechnology::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupTechnology::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 GroupTechnology::exp() const {
  return exp_;
}
inline void GroupTechnology::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int64 begin_upgrade_time = 3;
inline bool GroupTechnology::has_begin_upgrade_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupTechnology::set_has_begin_upgrade_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupTechnology::clear_has_begin_upgrade_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupTechnology::clear_begin_upgrade_time() {
  begin_upgrade_time_ = GOOGLE_LONGLONG(0);
  clear_has_begin_upgrade_time();
}
inline ::google::protobuf::int64 GroupTechnology::begin_upgrade_time() const {
  return begin_upgrade_time_;
}
inline void GroupTechnology::set_begin_upgrade_time(::google::protobuf::int64 value) {
  set_has_begin_upgrade_time();
  begin_upgrade_time_ = value;
}

// required int32 status = 4;
inline bool GroupTechnology::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupTechnology::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupTechnology::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupTechnology::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 GroupTechnology::status() const {
  return status_;
}
inline void GroupTechnology::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 city_buff_count = 5;
inline bool GroupTechnology::has_city_buff_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupTechnology::set_has_city_buff_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupTechnology::clear_has_city_buff_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupTechnology::clear_city_buff_count() {
  city_buff_count_ = 0;
  clear_has_city_buff_count();
}
inline ::google::protobuf::int32 GroupTechnology::city_buff_count() const {
  return city_buff_count_;
}
inline void GroupTechnology::set_city_buff_count(::google::protobuf::int32 value) {
  set_has_city_buff_count();
  city_buff_count_ = value;
}

// -------------------------------------------------------------------

// GroupUser

// required int32 guid = 1;
inline bool GroupUser::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUser::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUser::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUser::clear_guid() {
  guid_ = 0;
  clear_has_guid();
}
inline ::google::protobuf::int32 GroupUser::guid() const {
  return guid_;
}
inline void GroupUser::set_guid(::google::protobuf::int32 value) {
  set_has_guid();
  guid_ = value;
}

// required string user_name = 2;
inline bool GroupUser::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUser::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUser::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUser::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& GroupUser::user_name() const {
  return *user_name_;
}
inline void GroupUser::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupUser::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupUser::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupUser::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* GroupUser::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupUser::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string nickname = 3;
inline bool GroupUser::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUser::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUser::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUser::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& GroupUser::nickname() const {
  return *nickname_;
}
inline void GroupUser::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void GroupUser::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void GroupUser::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupUser::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* GroupUser::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupUser::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 job = 4;
inline bool GroupUser::has_job() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupUser::set_has_job() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupUser::clear_has_job() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupUser::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 GroupUser::job() const {
  return job_;
}
inline void GroupUser::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// required int32 status = 5;
inline bool GroupUser::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupUser::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupUser::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupUser::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 GroupUser::status() const {
  return status_;
}
inline void GroupUser::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional uint64 last_act = 6;
inline bool GroupUser::has_last_act() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupUser::set_has_last_act() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupUser::clear_has_last_act() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupUser::clear_last_act() {
  last_act_ = GOOGLE_ULONGLONG(0);
  clear_has_last_act();
}
inline ::google::protobuf::uint64 GroupUser::last_act() const {
  return last_act_;
}
inline void GroupUser::set_last_act(::google::protobuf::uint64 value) {
  set_has_last_act();
  last_act_ = value;
}

// repeated int32 last_gongxian = 7;
inline int GroupUser::last_gongxian_size() const {
  return last_gongxian_.size();
}
inline void GroupUser::clear_last_gongxian() {
  last_gongxian_.Clear();
}
inline ::google::protobuf::int32 GroupUser::last_gongxian(int index) const {
  return last_gongxian_.Get(index);
}
inline void GroupUser::set_last_gongxian(int index, ::google::protobuf::int32 value) {
  last_gongxian_.Set(index, value);
}
inline void GroupUser::add_last_gongxian(::google::protobuf::int32 value) {
  last_gongxian_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GroupUser::last_gongxian() const {
  return last_gongxian_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GroupUser::mutable_last_gongxian() {
  return &last_gongxian_;
}

// optional int64 unlock_time = 8;
inline bool GroupUser::has_unlock_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupUser::set_has_unlock_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupUser::clear_has_unlock_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupUser::clear_unlock_time() {
  unlock_time_ = GOOGLE_LONGLONG(0);
  clear_has_unlock_time();
}
inline ::google::protobuf::int64 GroupUser::unlock_time() const {
  return unlock_time_;
}
inline void GroupUser::set_unlock_time(::google::protobuf::int64 value) {
  set_has_unlock_time();
  unlock_time_ = value;
}

// -------------------------------------------------------------------

// GroupMainData_JoinInfo

// required string user_name = 1;
inline bool GroupMainData_JoinInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMainData_JoinInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMainData_JoinInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMainData_JoinInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& GroupMainData_JoinInfo::user_name() const {
  return *user_name_;
}
inline void GroupMainData_JoinInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupMainData_JoinInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void GroupMainData_JoinInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMainData_JoinInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* GroupMainData_JoinInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMainData_JoinInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string nickname = 2;
inline bool GroupMainData_JoinInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMainData_JoinInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMainData_JoinInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMainData_JoinInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& GroupMainData_JoinInfo::nickname() const {
  return *nickname_;
}
inline void GroupMainData_JoinInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void GroupMainData_JoinInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void GroupMainData_JoinInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMainData_JoinInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* GroupMainData_JoinInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMainData_JoinInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 join_time = 3;
inline bool GroupMainData_JoinInfo::has_join_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMainData_JoinInfo::set_has_join_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMainData_JoinInfo::clear_has_join_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMainData_JoinInfo::clear_join_time() {
  join_time_ = GOOGLE_LONGLONG(0);
  clear_has_join_time();
}
inline ::google::protobuf::int64 GroupMainData_JoinInfo::join_time() const {
  return join_time_;
}
inline void GroupMainData_JoinInfo::set_join_time(::google::protobuf::int64 value) {
  set_has_join_time();
  join_time_ = value;
}

// -------------------------------------------------------------------

// GroupMainData_JoinCondition

// required bool needAllow = 1;
inline bool GroupMainData_JoinCondition::has_needallow() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMainData_JoinCondition::set_has_needallow() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMainData_JoinCondition::clear_has_needallow() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMainData_JoinCondition::clear_needallow() {
  needallow_ = false;
  clear_has_needallow();
}
inline bool GroupMainData_JoinCondition::needallow() const {
  return needallow_;
}
inline void GroupMainData_JoinCondition::set_needallow(bool value) {
  set_has_needallow();
  needallow_ = value;
}

// optional int32 level = 2;
inline bool GroupMainData_JoinCondition::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMainData_JoinCondition::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMainData_JoinCondition::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMainData_JoinCondition::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GroupMainData_JoinCondition::level() const {
  return level_;
}
inline void GroupMainData_JoinCondition::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 power = 3;
inline bool GroupMainData_JoinCondition::has_power() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMainData_JoinCondition::set_has_power() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMainData_JoinCondition::clear_has_power() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMainData_JoinCondition::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 GroupMainData_JoinCondition::power() const {
  return power_;
}
inline void GroupMainData_JoinCondition::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// -------------------------------------------------------------------

// GroupMainData

// required string groupid = 1;
inline bool GroupMainData::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMainData::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMainData::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMainData::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& GroupMainData::groupid() const {
  return *groupid_;
}
inline void GroupMainData::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GroupMainData::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void GroupMainData::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMainData::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* GroupMainData::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMainData::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string nickname = 2;
inline bool GroupMainData::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMainData::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMainData::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMainData::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& GroupMainData::nickname() const {
  return *nickname_;
}
inline void GroupMainData::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void GroupMainData::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void GroupMainData::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMainData::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* GroupMainData::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMainData::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 3;
inline bool GroupMainData::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMainData::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMainData::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMainData::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 GroupMainData::status() const {
  return status_;
}
inline void GroupMainData::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 icon_id = 4;
inline bool GroupMainData::has_icon_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMainData::set_has_icon_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMainData::clear_has_icon_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMainData::clear_icon_id() {
  icon_id_ = 0;
  clear_has_icon_id();
}
inline ::google::protobuf::int32 GroupMainData::icon_id() const {
  return icon_id_;
}
inline void GroupMainData::set_icon_id(::google::protobuf::int32 value) {
  set_has_icon_id();
  icon_id_ = value;
}

// optional int32 contribute = 5;
inline bool GroupMainData::has_contribute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMainData::set_has_contribute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMainData::clear_has_contribute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMainData::clear_contribute() {
  contribute_ = 0;
  clear_has_contribute();
}
inline ::google::protobuf::int32 GroupMainData::contribute() const {
  return contribute_;
}
inline void GroupMainData::set_contribute(::google::protobuf::int32 value) {
  set_has_contribute();
  contribute_ = value;
}

// optional int32 exp = 6;
inline bool GroupMainData::has_exp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupMainData::set_has_exp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupMainData::clear_has_exp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupMainData::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 GroupMainData::exp() const {
  return exp_;
}
inline void GroupMainData::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 level = 7;
inline bool GroupMainData::has_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupMainData::set_has_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupMainData::clear_has_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupMainData::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GroupMainData::level() const {
  return level_;
}
inline void GroupMainData::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 dayid = 8;
inline bool GroupMainData::has_dayid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupMainData::set_has_dayid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupMainData::clear_has_dayid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupMainData::clear_dayid() {
  dayid_ = 0u;
  clear_has_dayid();
}
inline ::google::protobuf::uint32 GroupMainData::dayid() const {
  return dayid_;
}
inline void GroupMainData::set_dayid(::google::protobuf::uint32 value) {
  set_has_dayid();
  dayid_ = value;
}

// repeated .GroupUser user_list = 9;
inline int GroupMainData::user_list_size() const {
  return user_list_.size();
}
inline void GroupMainData::clear_user_list() {
  user_list_.Clear();
}
inline const ::GroupUser& GroupMainData::user_list(int index) const {
  return user_list_.Get(index);
}
inline ::GroupUser* GroupMainData::mutable_user_list(int index) {
  return user_list_.Mutable(index);
}
inline ::GroupUser* GroupMainData::add_user_list() {
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GroupUser >&
GroupMainData::user_list() const {
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::GroupUser >*
GroupMainData::mutable_user_list() {
  return &user_list_;
}

// optional string broadcast = 10;
inline bool GroupMainData::has_broadcast() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupMainData::set_has_broadcast() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupMainData::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupMainData::clear_broadcast() {
  if (broadcast_ != &::google::protobuf::internal::kEmptyString) {
    broadcast_->clear();
  }
  clear_has_broadcast();
}
inline const ::std::string& GroupMainData::broadcast() const {
  return *broadcast_;
}
inline void GroupMainData::set_broadcast(const ::std::string& value) {
  set_has_broadcast();
  if (broadcast_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_ = new ::std::string;
  }
  broadcast_->assign(value);
}
inline void GroupMainData::set_broadcast(const char* value) {
  set_has_broadcast();
  if (broadcast_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_ = new ::std::string;
  }
  broadcast_->assign(value);
}
inline void GroupMainData::set_broadcast(const char* value, size_t size) {
  set_has_broadcast();
  if (broadcast_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_ = new ::std::string;
  }
  broadcast_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMainData::mutable_broadcast() {
  set_has_broadcast();
  if (broadcast_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_ = new ::std::string;
  }
  return broadcast_;
}
inline ::std::string* GroupMainData::release_broadcast() {
  clear_has_broadcast();
  if (broadcast_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = broadcast_;
    broadcast_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMainData::set_allocated_broadcast(::std::string* broadcast) {
  if (broadcast_ != &::google::protobuf::internal::kEmptyString) {
    delete broadcast_;
  }
  if (broadcast) {
    set_has_broadcast();
    broadcast_ = broadcast;
  } else {
    clear_has_broadcast();
    broadcast_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string blurb = 11;
inline bool GroupMainData::has_blurb() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GroupMainData::set_has_blurb() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GroupMainData::clear_has_blurb() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GroupMainData::clear_blurb() {
  if (blurb_ != &::google::protobuf::internal::kEmptyString) {
    blurb_->clear();
  }
  clear_has_blurb();
}
inline const ::std::string& GroupMainData::blurb() const {
  return *blurb_;
}
inline void GroupMainData::set_blurb(const ::std::string& value) {
  set_has_blurb();
  if (blurb_ == &::google::protobuf::internal::kEmptyString) {
    blurb_ = new ::std::string;
  }
  blurb_->assign(value);
}
inline void GroupMainData::set_blurb(const char* value) {
  set_has_blurb();
  if (blurb_ == &::google::protobuf::internal::kEmptyString) {
    blurb_ = new ::std::string;
  }
  blurb_->assign(value);
}
inline void GroupMainData::set_blurb(const char* value, size_t size) {
  set_has_blurb();
  if (blurb_ == &::google::protobuf::internal::kEmptyString) {
    blurb_ = new ::std::string;
  }
  blurb_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMainData::mutable_blurb() {
  set_has_blurb();
  if (blurb_ == &::google::protobuf::internal::kEmptyString) {
    blurb_ = new ::std::string;
  }
  return blurb_;
}
inline ::std::string* GroupMainData::release_blurb() {
  clear_has_blurb();
  if (blurb_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = blurb_;
    blurb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMainData::set_allocated_blurb(::std::string* blurb) {
  if (blurb_ != &::google::protobuf::internal::kEmptyString) {
    delete blurb_;
  }
  if (blurb) {
    set_has_blurb();
    blurb_ = blurb;
  } else {
    clear_has_blurb();
    blurb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 guid = 12;
inline bool GroupMainData::has_guid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GroupMainData::set_has_guid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GroupMainData::clear_has_guid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GroupMainData::clear_guid() {
  guid_ = 0;
  clear_has_guid();
}
inline ::google::protobuf::int32 GroupMainData::guid() const {
  return guid_;
}
inline void GroupMainData::set_guid(::google::protobuf::int32 value) {
  set_has_guid();
  guid_ = value;
}

// optional int32 rank = 13;
inline bool GroupMainData::has_rank() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GroupMainData::set_has_rank() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GroupMainData::clear_has_rank() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GroupMainData::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 GroupMainData::rank() const {
  return rank_;
}
inline void GroupMainData::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional int64 create_time = 14;
inline bool GroupMainData::has_create_time() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GroupMainData::set_has_create_time() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GroupMainData::clear_has_create_time() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GroupMainData::clear_create_time() {
  create_time_ = GOOGLE_LONGLONG(0);
  clear_has_create_time();
}
inline ::google::protobuf::int64 GroupMainData::create_time() const {
  return create_time_;
}
inline void GroupMainData::set_create_time(::google::protobuf::int64 value) {
  set_has_create_time();
  create_time_ = value;
}

// optional int64 unlock_time = 15;
inline bool GroupMainData::has_unlock_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GroupMainData::set_has_unlock_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GroupMainData::clear_has_unlock_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GroupMainData::clear_unlock_time() {
  unlock_time_ = GOOGLE_LONGLONG(0);
  clear_has_unlock_time();
}
inline ::google::protobuf::int64 GroupMainData::unlock_time() const {
  return unlock_time_;
}
inline void GroupMainData::set_unlock_time(::google::protobuf::int64 value) {
  set_has_unlock_time();
  unlock_time_ = value;
}

// repeated .GroupMainData.JoinInfo join_list = 16;
inline int GroupMainData::join_list_size() const {
  return join_list_.size();
}
inline void GroupMainData::clear_join_list() {
  join_list_.Clear();
}
inline const ::GroupMainData_JoinInfo& GroupMainData::join_list(int index) const {
  return join_list_.Get(index);
}
inline ::GroupMainData_JoinInfo* GroupMainData::mutable_join_list(int index) {
  return join_list_.Mutable(index);
}
inline ::GroupMainData_JoinInfo* GroupMainData::add_join_list() {
  return join_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GroupMainData_JoinInfo >&
GroupMainData::join_list() const {
  return join_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::GroupMainData_JoinInfo >*
GroupMainData::mutable_join_list() {
  return &join_list_;
}

// required .GroupMainData.JoinCondition join_condition = 17;
inline bool GroupMainData::has_join_condition() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GroupMainData::set_has_join_condition() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GroupMainData::clear_has_join_condition() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GroupMainData::clear_join_condition() {
  if (join_condition_ != NULL) join_condition_->::GroupMainData_JoinCondition::Clear();
  clear_has_join_condition();
}
inline const ::GroupMainData_JoinCondition& GroupMainData::join_condition() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return join_condition_ != NULL ? *join_condition_ : *default_instance().join_condition_;
#else
  return join_condition_ != NULL ? *join_condition_ : *default_instance_->join_condition_;
#endif
}
inline ::GroupMainData_JoinCondition* GroupMainData::mutable_join_condition() {
  set_has_join_condition();
  if (join_condition_ == NULL) join_condition_ = new ::GroupMainData_JoinCondition;
  return join_condition_;
}
inline ::GroupMainData_JoinCondition* GroupMainData::release_join_condition() {
  clear_has_join_condition();
  ::GroupMainData_JoinCondition* temp = join_condition_;
  join_condition_ = NULL;
  return temp;
}
inline void GroupMainData::set_allocated_join_condition(::GroupMainData_JoinCondition* join_condition) {
  delete join_condition_;
  join_condition_ = join_condition;
  if (join_condition) {
    set_has_join_condition();
  } else {
    clear_has_join_condition();
  }
}

// repeated .GroupTechnology tech_list = 18;
inline int GroupMainData::tech_list_size() const {
  return tech_list_.size();
}
inline void GroupMainData::clear_tech_list() {
  tech_list_.Clear();
}
inline const ::GroupTechnology& GroupMainData::tech_list(int index) const {
  return tech_list_.Get(index);
}
inline ::GroupTechnology* GroupMainData::mutable_tech_list(int index) {
  return tech_list_.Mutable(index);
}
inline ::GroupTechnology* GroupMainData::add_tech_list() {
  return tech_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GroupTechnology >&
GroupMainData::tech_list() const {
  return tech_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::GroupTechnology >*
GroupMainData::mutable_tech_list() {
  return &tech_list_;
}

// repeated .HelpInfo help_list = 19;
inline int GroupMainData::help_list_size() const {
  return help_list_.size();
}
inline void GroupMainData::clear_help_list() {
  help_list_.Clear();
}
inline const ::HelpInfo& GroupMainData::help_list(int index) const {
  return help_list_.Get(index);
}
inline ::HelpInfo* GroupMainData::mutable_help_list(int index) {
  return help_list_.Mutable(index);
}
inline ::HelpInfo* GroupMainData::add_help_list() {
  return help_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelpInfo >&
GroupMainData::help_list() const {
  return help_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelpInfo >*
GroupMainData::mutable_help_list() {
  return &help_list_;
}

// optional int32 worship_value = 20;
inline bool GroupMainData::has_worship_value() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GroupMainData::set_has_worship_value() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GroupMainData::clear_has_worship_value() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GroupMainData::clear_worship_value() {
  worship_value_ = 0;
  clear_has_worship_value();
}
inline ::google::protobuf::int32 GroupMainData::worship_value() const {
  return worship_value_;
}
inline void GroupMainData::set_worship_value(::google::protobuf::int32 value) {
  set_has_worship_value();
  worship_value_ = value;
}

// optional int32 today_worship_times = 21;
inline bool GroupMainData::has_today_worship_times() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GroupMainData::set_has_today_worship_times() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GroupMainData::clear_has_today_worship_times() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GroupMainData::clear_today_worship_times() {
  today_worship_times_ = 0;
  clear_has_today_worship_times();
}
inline ::google::protobuf::int32 GroupMainData::today_worship_times() const {
  return today_worship_times_;
}
inline void GroupMainData::set_today_worship_times(::google::protobuf::int32 value) {
  set_has_today_worship_times();
  today_worship_times_ = value;
}

// repeated string occupy_city_list = 22;
inline int GroupMainData::occupy_city_list_size() const {
  return occupy_city_list_.size();
}
inline void GroupMainData::clear_occupy_city_list() {
  occupy_city_list_.Clear();
}
inline const ::std::string& GroupMainData::occupy_city_list(int index) const {
  return occupy_city_list_.Get(index);
}
inline ::std::string* GroupMainData::mutable_occupy_city_list(int index) {
  return occupy_city_list_.Mutable(index);
}
inline void GroupMainData::set_occupy_city_list(int index, const ::std::string& value) {
  occupy_city_list_.Mutable(index)->assign(value);
}
inline void GroupMainData::set_occupy_city_list(int index, const char* value) {
  occupy_city_list_.Mutable(index)->assign(value);
}
inline void GroupMainData::set_occupy_city_list(int index, const char* value, size_t size) {
  occupy_city_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMainData::add_occupy_city_list() {
  return occupy_city_list_.Add();
}
inline void GroupMainData::add_occupy_city_list(const ::std::string& value) {
  occupy_city_list_.Add()->assign(value);
}
inline void GroupMainData::add_occupy_city_list(const char* value) {
  occupy_city_list_.Add()->assign(value);
}
inline void GroupMainData::add_occupy_city_list(const char* value, size_t size) {
  occupy_city_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupMainData::occupy_city_list() const {
  return occupy_city_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupMainData::mutable_occupy_city_list() {
  return &occupy_city_list_;
}

// repeated string enlist_list = 23;
inline int GroupMainData::enlist_list_size() const {
  return enlist_list_.size();
}
inline void GroupMainData::clear_enlist_list() {
  enlist_list_.Clear();
}
inline const ::std::string& GroupMainData::enlist_list(int index) const {
  return enlist_list_.Get(index);
}
inline ::std::string* GroupMainData::mutable_enlist_list(int index) {
  return enlist_list_.Mutable(index);
}
inline void GroupMainData::set_enlist_list(int index, const ::std::string& value) {
  enlist_list_.Mutable(index)->assign(value);
}
inline void GroupMainData::set_enlist_list(int index, const char* value) {
  enlist_list_.Mutable(index)->assign(value);
}
inline void GroupMainData::set_enlist_list(int index, const char* value, size_t size) {
  enlist_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMainData::add_enlist_list() {
  return enlist_list_.Add();
}
inline void GroupMainData::add_enlist_list(const ::std::string& value) {
  enlist_list_.Add()->assign(value);
}
inline void GroupMainData::add_enlist_list(const char* value) {
  enlist_list_.Add()->assign(value);
}
inline void GroupMainData::add_enlist_list(const char* value, size_t size) {
  enlist_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupMainData::enlist_list() const {
  return enlist_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupMainData::mutable_enlist_list() {
  return &enlist_list_;
}

// repeated string attack_our_list = 24;
inline int GroupMainData::attack_our_list_size() const {
  return attack_our_list_.size();
}
inline void GroupMainData::clear_attack_our_list() {
  attack_our_list_.Clear();
}
inline const ::std::string& GroupMainData::attack_our_list(int index) const {
  return attack_our_list_.Get(index);
}
inline ::std::string* GroupMainData::mutable_attack_our_list(int index) {
  return attack_our_list_.Mutable(index);
}
inline void GroupMainData::set_attack_our_list(int index, const ::std::string& value) {
  attack_our_list_.Mutable(index)->assign(value);
}
inline void GroupMainData::set_attack_our_list(int index, const char* value) {
  attack_our_list_.Mutable(index)->assign(value);
}
inline void GroupMainData::set_attack_our_list(int index, const char* value, size_t size) {
  attack_our_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMainData::add_attack_our_list() {
  return attack_our_list_.Add();
}
inline void GroupMainData::add_attack_our_list(const ::std::string& value) {
  attack_our_list_.Add()->assign(value);
}
inline void GroupMainData::add_attack_our_list(const char* value) {
  attack_our_list_.Add()->assign(value);
}
inline void GroupMainData::add_attack_our_list(const char* value, size_t size) {
  attack_our_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupMainData::attack_our_list() const {
  return attack_our_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupMainData::mutable_attack_our_list() {
  return &attack_our_list_;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Group_2eproto__INCLUDED
