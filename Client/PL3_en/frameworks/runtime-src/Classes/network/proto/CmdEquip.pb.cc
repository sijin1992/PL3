// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdEquip.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CmdEquip.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_CmdEquip_2eproto() {
  delete EquipLevelUpReq::default_instance_;
  delete EquipLevelUpResp::default_instance_;
  delete EquipEnchaseReq::default_instance_;
  delete EquipEnchaseResp::default_instance_;
  delete ShipEquipReq::default_instance_;
  delete ShipEquipResp::default_instance_;
  delete StrengthEquipReq::default_instance_;
  delete StrengthEquipResp::default_instance_;
  delete ResolveEquipReq::default_instance_;
  delete ResolveEquipResp::default_instance_;
  delete CreateEquipReq::default_instance_;
  delete CreateEquipResp::default_instance_;
  delete ResolveBlueprintReq::default_instance_;
  delete ResolveBlueprintResp::default_instance_;
  delete GemEquipReq::default_instance_;
  delete GemEquipResp::default_instance_;
  delete MixGemReq::default_instance_;
  delete MixGemResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_CmdEquip_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_CmdEquip_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_Equip_2eproto();
  ::protobuf_AddDesc_Item_2eproto();
  ::protobuf_AddDesc_UserSync_2eproto();
  EquipLevelUpReq::default_instance_ = new EquipLevelUpReq();
  EquipLevelUpResp::default_instance_ = new EquipLevelUpResp();
  EquipEnchaseReq::default_instance_ = new EquipEnchaseReq();
  EquipEnchaseResp::default_instance_ = new EquipEnchaseResp();
  ShipEquipReq::default_instance_ = new ShipEquipReq();
  ShipEquipResp::default_instance_ = new ShipEquipResp();
  StrengthEquipReq::default_instance_ = new StrengthEquipReq();
  StrengthEquipResp::default_instance_ = new StrengthEquipResp();
  ResolveEquipReq::default_instance_ = new ResolveEquipReq();
  ResolveEquipResp::default_instance_ = new ResolveEquipResp();
  CreateEquipReq::default_instance_ = new CreateEquipReq();
  CreateEquipResp::default_instance_ = new CreateEquipResp();
  ResolveBlueprintReq::default_instance_ = new ResolveBlueprintReq();
  ResolveBlueprintResp::default_instance_ = new ResolveBlueprintResp();
  GemEquipReq::default_instance_ = new GemEquipReq();
  GemEquipResp::default_instance_ = new GemEquipResp();
  MixGemReq::default_instance_ = new MixGemReq();
  MixGemResp::default_instance_ = new MixGemResp();
  EquipLevelUpReq::default_instance_->InitAsDefaultInstance();
  EquipLevelUpResp::default_instance_->InitAsDefaultInstance();
  EquipEnchaseReq::default_instance_->InitAsDefaultInstance();
  EquipEnchaseResp::default_instance_->InitAsDefaultInstance();
  ShipEquipReq::default_instance_->InitAsDefaultInstance();
  ShipEquipResp::default_instance_->InitAsDefaultInstance();
  StrengthEquipReq::default_instance_->InitAsDefaultInstance();
  StrengthEquipResp::default_instance_->InitAsDefaultInstance();
  ResolveEquipReq::default_instance_->InitAsDefaultInstance();
  ResolveEquipResp::default_instance_->InitAsDefaultInstance();
  CreateEquipReq::default_instance_->InitAsDefaultInstance();
  CreateEquipResp::default_instance_->InitAsDefaultInstance();
  ResolveBlueprintReq::default_instance_->InitAsDefaultInstance();
  ResolveBlueprintResp::default_instance_->InitAsDefaultInstance();
  GemEquipReq::default_instance_->InitAsDefaultInstance();
  GemEquipResp::default_instance_->InitAsDefaultInstance();
  MixGemReq::default_instance_->InitAsDefaultInstance();
  MixGemResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CmdEquip_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_CmdEquip_2eproto_once_);
void protobuf_AddDesc_CmdEquip_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_CmdEquip_2eproto_once_,
                 &protobuf_AddDesc_CmdEquip_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CmdEquip_2eproto {
  StaticDescriptorInitializer_CmdEquip_2eproto() {
    protobuf_AddDesc_CmdEquip_2eproto();
  }
} static_descriptor_initializer_CmdEquip_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int EquipLevelUpReq::kIdFieldNumber;
const int EquipLevelUpReq::kAddValueFieldNumber;
const int EquipLevelUpReq::kAddNewPlayerFieldNumber;
#endif  // !_MSC_VER

EquipLevelUpReq::EquipLevelUpReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EquipLevelUpReq::InitAsDefaultInstance() {
}

EquipLevelUpReq::EquipLevelUpReq(const EquipLevelUpReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EquipLevelUpReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  add_value_ = 0;
  add_new_player_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EquipLevelUpReq::~EquipLevelUpReq() {
  SharedDtor();
}

void EquipLevelUpReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EquipLevelUpReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EquipLevelUpReq& EquipLevelUpReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

EquipLevelUpReq* EquipLevelUpReq::default_instance_ = NULL;

EquipLevelUpReq* EquipLevelUpReq::New() const {
  return new EquipLevelUpReq;
}

void EquipLevelUpReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    add_value_ = 0;
    add_new_player_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EquipLevelUpReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_add_value;
        break;
      }

      // required int32 add_value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_add_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &add_value_)));
          set_has_add_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_add_new_player;
        break;
      }

      // optional int32 add_new_player = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_add_new_player:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &add_new_player_)));
          set_has_add_new_player();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EquipLevelUpReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // required int32 add_value = 2;
  if (has_add_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->add_value(), output);
  }

  // optional int32 add_new_player = 3;
  if (has_add_new_player()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->add_new_player(), output);
  }

}

int EquipLevelUpReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required int32 add_value = 2;
    if (has_add_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->add_value());
    }

    // optional int32 add_new_player = 3;
    if (has_add_new_player()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->add_new_player());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EquipLevelUpReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EquipLevelUpReq*>(&from));
}

void EquipLevelUpReq::MergeFrom(const EquipLevelUpReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_add_value()) {
      set_add_value(from.add_value());
    }
    if (from.has_add_new_player()) {
      set_add_new_player(from.add_new_player());
    }
  }
}

void EquipLevelUpReq::CopyFrom(const EquipLevelUpReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EquipLevelUpReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void EquipLevelUpReq::Swap(EquipLevelUpReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(add_value_, other->add_value_);
    std::swap(add_new_player_, other->add_new_player_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EquipLevelUpReq::GetTypeName() const {
  return "EquipLevelUpReq";
}


// ===================================================================

#ifndef _MSC_VER
const int EquipLevelUpResp::kResultFieldNumber;
const int EquipLevelUpResp::kEquipFieldNumber;
const int EquipLevelUpResp::kAddNewPlayerFieldNumber;
#endif  // !_MSC_VER

EquipLevelUpResp::EquipLevelUpResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EquipLevelUpResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  equip_ = const_cast< ::Equip*>(
      ::Equip::internal_default_instance());
#else
  equip_ = const_cast< ::Equip*>(&::Equip::default_instance());
#endif
}

EquipLevelUpResp::EquipLevelUpResp(const EquipLevelUpResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EquipLevelUpResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  equip_ = NULL;
  add_new_player_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EquipLevelUpResp::~EquipLevelUpResp() {
  SharedDtor();
}

void EquipLevelUpResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete equip_;
  }
}

void EquipLevelUpResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EquipLevelUpResp& EquipLevelUpResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

EquipLevelUpResp* EquipLevelUpResp::default_instance_ = NULL;

EquipLevelUpResp* EquipLevelUpResp::New() const {
  return new EquipLevelUpResp;
}

void EquipLevelUpResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_equip()) {
      if (equip_ != NULL) equip_->::Equip::Clear();
    }
    add_new_player_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EquipLevelUpResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_equip;
        break;
      }

      // optional .Equip equip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_equip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_equip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_add_new_player;
        break;
      }

      // optional int32 add_new_player = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_add_new_player:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &add_new_player_)));
          set_has_add_new_player();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EquipLevelUpResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .Equip equip = 2;
  if (has_equip()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->equip(), output);
  }

  // optional int32 add_new_player = 3;
  if (has_add_new_player()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->add_new_player(), output);
  }

}

int EquipLevelUpResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .Equip equip = 2;
    if (has_equip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->equip());
    }

    // optional int32 add_new_player = 3;
    if (has_add_new_player()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->add_new_player());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EquipLevelUpResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EquipLevelUpResp*>(&from));
}

void EquipLevelUpResp::MergeFrom(const EquipLevelUpResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_equip()) {
      mutable_equip()->::Equip::MergeFrom(from.equip());
    }
    if (from.has_add_new_player()) {
      set_add_new_player(from.add_new_player());
    }
  }
}

void EquipLevelUpResp::CopyFrom(const EquipLevelUpResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EquipLevelUpResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_equip()) {
    if (!this->equip().IsInitialized()) return false;
  }
  return true;
}

void EquipLevelUpResp::Swap(EquipLevelUpResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(equip_, other->equip_);
    std::swap(add_new_player_, other->add_new_player_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EquipLevelUpResp::GetTypeName() const {
  return "EquipLevelUpResp";
}


// ===================================================================

#ifndef _MSC_VER
const int EquipEnchaseReq::kIdFieldNumber;
#endif  // !_MSC_VER

EquipEnchaseReq::EquipEnchaseReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EquipEnchaseReq::InitAsDefaultInstance() {
}

EquipEnchaseReq::EquipEnchaseReq(const EquipEnchaseReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EquipEnchaseReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EquipEnchaseReq::~EquipEnchaseReq() {
  SharedDtor();
}

void EquipEnchaseReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EquipEnchaseReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EquipEnchaseReq& EquipEnchaseReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

EquipEnchaseReq* EquipEnchaseReq::default_instance_ = NULL;

EquipEnchaseReq* EquipEnchaseReq::New() const {
  return new EquipEnchaseReq;
}

void EquipEnchaseReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EquipEnchaseReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EquipEnchaseReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

}

int EquipEnchaseReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EquipEnchaseReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EquipEnchaseReq*>(&from));
}

void EquipEnchaseReq::MergeFrom(const EquipEnchaseReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void EquipEnchaseReq::CopyFrom(const EquipEnchaseReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EquipEnchaseReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EquipEnchaseReq::Swap(EquipEnchaseReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EquipEnchaseReq::GetTypeName() const {
  return "EquipEnchaseReq";
}


// ===================================================================

#ifndef _MSC_VER
const int EquipEnchaseResp::kResultFieldNumber;
#endif  // !_MSC_VER

EquipEnchaseResp::EquipEnchaseResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EquipEnchaseResp::InitAsDefaultInstance() {
}

EquipEnchaseResp::EquipEnchaseResp(const EquipEnchaseResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EquipEnchaseResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EquipEnchaseResp::~EquipEnchaseResp() {
  SharedDtor();
}

void EquipEnchaseResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EquipEnchaseResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EquipEnchaseResp& EquipEnchaseResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

EquipEnchaseResp* EquipEnchaseResp::default_instance_ = NULL;

EquipEnchaseResp* EquipEnchaseResp::New() const {
  return new EquipEnchaseResp;
}

void EquipEnchaseResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EquipEnchaseResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EquipEnchaseResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int EquipEnchaseResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EquipEnchaseResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EquipEnchaseResp*>(&from));
}

void EquipEnchaseResp::MergeFrom(const EquipEnchaseResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void EquipEnchaseResp::CopyFrom(const EquipEnchaseResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EquipEnchaseResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EquipEnchaseResp::Swap(EquipEnchaseResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EquipEnchaseResp::GetTypeName() const {
  return "EquipEnchaseResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipEquipReq::kShipGuidFieldNumber;
const int ShipEquipReq::kEquipIndexListFieldNumber;
const int ShipEquipReq::kEquipGuidListFieldNumber;
#endif  // !_MSC_VER

ShipEquipReq::ShipEquipReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipEquipReq::InitAsDefaultInstance() {
}

ShipEquipReq::ShipEquipReq(const ShipEquipReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipEquipReq::SharedCtor() {
  _cached_size_ = 0;
  ship_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipEquipReq::~ShipEquipReq() {
  SharedDtor();
}

void ShipEquipReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShipEquipReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipEquipReq& ShipEquipReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

ShipEquipReq* ShipEquipReq::default_instance_ = NULL;

ShipEquipReq* ShipEquipReq::New() const {
  return new ShipEquipReq;
}

void ShipEquipReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ship_guid_ = 0;
  }
  equip_index_list_.Clear();
  equip_guid_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipEquipReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ship_guid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_guid_)));
          set_has_ship_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_equip_index_list;
        break;
      }

      // repeated int32 equip_index_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_equip_index_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_equip_index_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_equip_index_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_equip_index_list;
        if (input->ExpectTag(24)) goto parse_equip_guid_list;
        break;
      }

      // repeated int32 equip_guid_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_equip_guid_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_equip_guid_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_equip_guid_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_equip_guid_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipEquipReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ship_guid = 1;
  if (has_ship_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ship_guid(), output);
  }

  // repeated int32 equip_index_list = 2;
  for (int i = 0; i < this->equip_index_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->equip_index_list(i), output);
  }

  // repeated int32 equip_guid_list = 3;
  for (int i = 0; i < this->equip_guid_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->equip_guid_list(i), output);
  }

}

int ShipEquipReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ship_guid = 1;
    if (has_ship_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_guid());
    }

  }
  // repeated int32 equip_index_list = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->equip_index_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->equip_index_list(i));
    }
    total_size += 1 * this->equip_index_list_size() + data_size;
  }

  // repeated int32 equip_guid_list = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->equip_guid_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->equip_guid_list(i));
    }
    total_size += 1 * this->equip_guid_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipEquipReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipEquipReq*>(&from));
}

void ShipEquipReq::MergeFrom(const ShipEquipReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  equip_index_list_.MergeFrom(from.equip_index_list_);
  equip_guid_list_.MergeFrom(from.equip_guid_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ship_guid()) {
      set_ship_guid(from.ship_guid());
    }
  }
}

void ShipEquipReq::CopyFrom(const ShipEquipReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipEquipReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ShipEquipReq::Swap(ShipEquipReq* other) {
  if (other != this) {
    std::swap(ship_guid_, other->ship_guid_);
    equip_index_list_.Swap(&other->equip_index_list_);
    equip_guid_list_.Swap(&other->equip_guid_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipEquipReq::GetTypeName() const {
  return "ShipEquipReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipEquipResp::kResultFieldNumber;
const int ShipEquipResp::kUserSyncFieldNumber;
const int ShipEquipResp::kShipGuidFieldNumber;
const int ShipEquipResp::kEquipIndexListFieldNumber;
const int ShipEquipResp::kEquipGuidListFieldNumber;
#endif  // !_MSC_VER

ShipEquipResp::ShipEquipResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipEquipResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ShipEquipResp::ShipEquipResp(const ShipEquipResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipEquipResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ship_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipEquipResp::~ShipEquipResp() {
  SharedDtor();
}

void ShipEquipResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ShipEquipResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipEquipResp& ShipEquipResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

ShipEquipResp* ShipEquipResp::default_instance_ = NULL;

ShipEquipResp* ShipEquipResp::New() const {
  return new ShipEquipResp;
}

void ShipEquipResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    ship_guid_ = 0;
  }
  equip_index_list_.Clear();
  equip_guid_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipEquipResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ship_guid;
        break;
      }

      // required int32 ship_guid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ship_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_guid_)));
          set_has_ship_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_equip_index_list;
        break;
      }

      // repeated int32 equip_index_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_equip_index_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32, input, this->mutable_equip_index_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_equip_index_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_equip_index_list;
        if (input->ExpectTag(40)) goto parse_equip_guid_list;
        break;
      }

      // repeated int32 equip_guid_list = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_equip_guid_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 40, input, this->mutable_equip_guid_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_equip_guid_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_equip_guid_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipEquipResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // required int32 ship_guid = 3;
  if (has_ship_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->ship_guid(), output);
  }

  // repeated int32 equip_index_list = 4;
  for (int i = 0; i < this->equip_index_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->equip_index_list(i), output);
  }

  // repeated int32 equip_guid_list = 5;
  for (int i = 0; i < this->equip_guid_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      5, this->equip_guid_list(i), output);
  }

}

int ShipEquipResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // required int32 ship_guid = 3;
    if (has_ship_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_guid());
    }

  }
  // repeated int32 equip_index_list = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->equip_index_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->equip_index_list(i));
    }
    total_size += 1 * this->equip_index_list_size() + data_size;
  }

  // repeated int32 equip_guid_list = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->equip_guid_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->equip_guid_list(i));
    }
    total_size += 1 * this->equip_guid_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipEquipResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipEquipResp*>(&from));
}

void ShipEquipResp::MergeFrom(const ShipEquipResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  equip_index_list_.MergeFrom(from.equip_index_list_);
  equip_guid_list_.MergeFrom(from.equip_guid_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_ship_guid()) {
      set_ship_guid(from.ship_guid());
    }
  }
}

void ShipEquipResp::CopyFrom(const ShipEquipResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipEquipResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ShipEquipResp::Swap(ShipEquipResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(ship_guid_, other->ship_guid_);
    equip_index_list_.Swap(&other->equip_index_list_);
    equip_guid_list_.Swap(&other->equip_guid_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipEquipResp::GetTypeName() const {
  return "ShipEquipResp";
}


// ===================================================================

#ifndef _MSC_VER
const int StrengthEquipReq::kEquipGuidFieldNumber;
const int StrengthEquipReq::kCountFieldNumber;
#endif  // !_MSC_VER

StrengthEquipReq::StrengthEquipReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StrengthEquipReq::InitAsDefaultInstance() {
}

StrengthEquipReq::StrengthEquipReq(const StrengthEquipReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StrengthEquipReq::SharedCtor() {
  _cached_size_ = 0;
  equip_guid_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StrengthEquipReq::~StrengthEquipReq() {
  SharedDtor();
}

void StrengthEquipReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StrengthEquipReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StrengthEquipReq& StrengthEquipReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

StrengthEquipReq* StrengthEquipReq::default_instance_ = NULL;

StrengthEquipReq* StrengthEquipReq::New() const {
  return new StrengthEquipReq;
}

void StrengthEquipReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    equip_guid_ = 0;
    count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StrengthEquipReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 equip_guid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &equip_guid_)));
          set_has_equip_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // optional int32 count = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StrengthEquipReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 equip_guid = 1;
  if (has_equip_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->equip_guid(), output);
  }

  // optional int32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->count(), output);
  }

}

int StrengthEquipReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 equip_guid = 1;
    if (has_equip_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->equip_guid());
    }

    // optional int32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StrengthEquipReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StrengthEquipReq*>(&from));
}

void StrengthEquipReq::MergeFrom(const StrengthEquipReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_equip_guid()) {
      set_equip_guid(from.equip_guid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
}

void StrengthEquipReq::CopyFrom(const StrengthEquipReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrengthEquipReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StrengthEquipReq::Swap(StrengthEquipReq* other) {
  if (other != this) {
    std::swap(equip_guid_, other->equip_guid_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StrengthEquipReq::GetTypeName() const {
  return "StrengthEquipReq";
}


// ===================================================================

#ifndef _MSC_VER
const int StrengthEquipResp::kResultFieldNumber;
const int StrengthEquipResp::kUserSyncFieldNumber;
const int StrengthEquipResp::kEquipGuidFieldNumber;
#endif  // !_MSC_VER

StrengthEquipResp::StrengthEquipResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StrengthEquipResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

StrengthEquipResp::StrengthEquipResp(const StrengthEquipResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StrengthEquipResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  equip_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StrengthEquipResp::~StrengthEquipResp() {
  SharedDtor();
}

void StrengthEquipResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void StrengthEquipResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StrengthEquipResp& StrengthEquipResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

StrengthEquipResp* StrengthEquipResp::default_instance_ = NULL;

StrengthEquipResp* StrengthEquipResp::New() const {
  return new StrengthEquipResp;
}

void StrengthEquipResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    equip_guid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StrengthEquipResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_equip_guid;
        break;
      }

      // optional int32 equip_guid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_equip_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &equip_guid_)));
          set_has_equip_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StrengthEquipResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional int32 equip_guid = 3;
  if (has_equip_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->equip_guid(), output);
  }

}

int StrengthEquipResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 equip_guid = 3;
    if (has_equip_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->equip_guid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StrengthEquipResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StrengthEquipResp*>(&from));
}

void StrengthEquipResp::MergeFrom(const StrengthEquipResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_equip_guid()) {
      set_equip_guid(from.equip_guid());
    }
  }
}

void StrengthEquipResp::CopyFrom(const StrengthEquipResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrengthEquipResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void StrengthEquipResp::Swap(StrengthEquipResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(equip_guid_, other->equip_guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StrengthEquipResp::GetTypeName() const {
  return "StrengthEquipResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ResolveEquipReq::kEquipGuidListFieldNumber;
#endif  // !_MSC_VER

ResolveEquipReq::ResolveEquipReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResolveEquipReq::InitAsDefaultInstance() {
}

ResolveEquipReq::ResolveEquipReq(const ResolveEquipReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResolveEquipReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveEquipReq::~ResolveEquipReq() {
  SharedDtor();
}

void ResolveEquipReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResolveEquipReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResolveEquipReq& ResolveEquipReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

ResolveEquipReq* ResolveEquipReq::default_instance_ = NULL;

ResolveEquipReq* ResolveEquipReq::New() const {
  return new ResolveEquipReq;
}

void ResolveEquipReq::Clear() {
  equip_guid_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResolveEquipReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 equip_guid_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_equip_guid_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_equip_guid_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_equip_guid_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_equip_guid_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResolveEquipReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 equip_guid_list = 1;
  for (int i = 0; i < this->equip_guid_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->equip_guid_list(i), output);
  }

}

int ResolveEquipReq::ByteSize() const {
  int total_size = 0;

  // repeated int32 equip_guid_list = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->equip_guid_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->equip_guid_list(i));
    }
    total_size += 1 * this->equip_guid_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveEquipReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResolveEquipReq*>(&from));
}

void ResolveEquipReq::MergeFrom(const ResolveEquipReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  equip_guid_list_.MergeFrom(from.equip_guid_list_);
}

void ResolveEquipReq::CopyFrom(const ResolveEquipReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveEquipReq::IsInitialized() const {

  return true;
}

void ResolveEquipReq::Swap(ResolveEquipReq* other) {
  if (other != this) {
    equip_guid_list_.Swap(&other->equip_guid_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResolveEquipReq::GetTypeName() const {
  return "ResolveEquipReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ResolveEquipResp::kResultFieldNumber;
const int ResolveEquipResp::kUserSyncFieldNumber;
const int ResolveEquipResp::kGetItemListFieldNumber;
#endif  // !_MSC_VER

ResolveEquipResp::ResolveEquipResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResolveEquipResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ResolveEquipResp::ResolveEquipResp(const ResolveEquipResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResolveEquipResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveEquipResp::~ResolveEquipResp() {
  SharedDtor();
}

void ResolveEquipResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ResolveEquipResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResolveEquipResp& ResolveEquipResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

ResolveEquipResp* ResolveEquipResp::default_instance_ = NULL;

ResolveEquipResp* ResolveEquipResp::New() const {
  return new ResolveEquipResp;
}

void ResolveEquipResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResolveEquipResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        break;
      }

      // repeated .Item get_item_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResolveEquipResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .Item get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->get_item_list(i), output);
  }

}

int ResolveEquipResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .Item get_item_list = 3;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveEquipResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResolveEquipResp*>(&from));
}

void ResolveEquipResp::MergeFrom(const ResolveEquipResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void ResolveEquipResp::CopyFrom(const ResolveEquipResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveEquipResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  return true;
}

void ResolveEquipResp::Swap(ResolveEquipResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResolveEquipResp::GetTypeName() const {
  return "ResolveEquipResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateEquipReq::kTypeFieldNumber;
const int CreateEquipReq::kEquipIdFieldNumber;
const int CreateEquipReq::kForgeGuidFieldNumber;
#endif  // !_MSC_VER

CreateEquipReq::CreateEquipReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateEquipReq::InitAsDefaultInstance() {
}

CreateEquipReq::CreateEquipReq(const CreateEquipReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateEquipReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  equip_id_ = 0;
  forge_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateEquipReq::~CreateEquipReq() {
  SharedDtor();
}

void CreateEquipReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateEquipReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateEquipReq& CreateEquipReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

CreateEquipReq* CreateEquipReq::default_instance_ = NULL;

CreateEquipReq* CreateEquipReq::New() const {
  return new CreateEquipReq;
}

void CreateEquipReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    equip_id_ = 0;
    forge_guid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateEquipReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_equip_id;
        break;
      }

      // optional int32 equip_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_equip_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &equip_id_)));
          set_has_equip_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_forge_guid;
        break;
      }

      // optional int32 forge_guid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_forge_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &forge_guid_)));
          set_has_forge_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateEquipReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional int32 equip_id = 2;
  if (has_equip_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->equip_id(), output);
  }

  // optional int32 forge_guid = 3;
  if (has_forge_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->forge_guid(), output);
  }

}

int CreateEquipReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 equip_id = 2;
    if (has_equip_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->equip_id());
    }

    // optional int32 forge_guid = 3;
    if (has_forge_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->forge_guid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateEquipReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateEquipReq*>(&from));
}

void CreateEquipReq::MergeFrom(const CreateEquipReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_equip_id()) {
      set_equip_id(from.equip_id());
    }
    if (from.has_forge_guid()) {
      set_forge_guid(from.forge_guid());
    }
  }
}

void CreateEquipReq::CopyFrom(const CreateEquipReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateEquipReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CreateEquipReq::Swap(CreateEquipReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(equip_id_, other->equip_id_);
    std::swap(forge_guid_, other->forge_guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateEquipReq::GetTypeName() const {
  return "CreateEquipReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateEquipResp::kResultFieldNumber;
const int CreateEquipResp::kUserSyncFieldNumber;
const int CreateEquipResp::kGetEquipGuidFieldNumber;
#endif  // !_MSC_VER

CreateEquipResp::CreateEquipResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateEquipResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

CreateEquipResp::CreateEquipResp(const CreateEquipResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateEquipResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  get_equip_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateEquipResp::~CreateEquipResp() {
  SharedDtor();
}

void CreateEquipResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void CreateEquipResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateEquipResp& CreateEquipResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

CreateEquipResp* CreateEquipResp::default_instance_ = NULL;

CreateEquipResp* CreateEquipResp::New() const {
  return new CreateEquipResp;
}

void CreateEquipResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    get_equip_guid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateEquipResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_get_equip_guid;
        break;
      }

      // optional int32 get_equip_guid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_get_equip_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &get_equip_guid_)));
          set_has_get_equip_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateEquipResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional int32 get_equip_guid = 3;
  if (has_get_equip_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->get_equip_guid(), output);
  }

}

int CreateEquipResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 get_equip_guid = 3;
    if (has_get_equip_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->get_equip_guid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateEquipResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateEquipResp*>(&from));
}

void CreateEquipResp::MergeFrom(const CreateEquipResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_get_equip_guid()) {
      set_get_equip_guid(from.get_equip_guid());
    }
  }
}

void CreateEquipResp::CopyFrom(const CreateEquipResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateEquipResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void CreateEquipResp::Swap(CreateEquipResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(get_equip_guid_, other->get_equip_guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateEquipResp::GetTypeName() const {
  return "CreateEquipResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ResolveBlueprintReq::kItemListFieldNumber;
#endif  // !_MSC_VER

ResolveBlueprintReq::ResolveBlueprintReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResolveBlueprintReq::InitAsDefaultInstance() {
}

ResolveBlueprintReq::ResolveBlueprintReq(const ResolveBlueprintReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResolveBlueprintReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveBlueprintReq::~ResolveBlueprintReq() {
  SharedDtor();
}

void ResolveBlueprintReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResolveBlueprintReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResolveBlueprintReq& ResolveBlueprintReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

ResolveBlueprintReq* ResolveBlueprintReq::default_instance_ = NULL;

ResolveBlueprintReq* ResolveBlueprintReq::New() const {
  return new ResolveBlueprintReq;
}

void ResolveBlueprintReq::Clear() {
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResolveBlueprintReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Pair item_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResolveBlueprintReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Pair item_list = 1;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->item_list(i), output);
  }

}

int ResolveBlueprintReq::ByteSize() const {
  int total_size = 0;

  // repeated .Pair item_list = 1;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveBlueprintReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResolveBlueprintReq*>(&from));
}

void ResolveBlueprintReq::MergeFrom(const ResolveBlueprintReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
}

void ResolveBlueprintReq::CopyFrom(const ResolveBlueprintReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveBlueprintReq::IsInitialized() const {

  for (int i = 0; i < item_list_size(); i++) {
    if (!this->item_list(i).IsInitialized()) return false;
  }
  return true;
}

void ResolveBlueprintReq::Swap(ResolveBlueprintReq* other) {
  if (other != this) {
    item_list_.Swap(&other->item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResolveBlueprintReq::GetTypeName() const {
  return "ResolveBlueprintReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ResolveBlueprintResp::kResultFieldNumber;
const int ResolveBlueprintResp::kUserSyncFieldNumber;
const int ResolveBlueprintResp::kGetItemListFieldNumber;
#endif  // !_MSC_VER

ResolveBlueprintResp::ResolveBlueprintResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResolveBlueprintResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ResolveBlueprintResp::ResolveBlueprintResp(const ResolveBlueprintResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResolveBlueprintResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveBlueprintResp::~ResolveBlueprintResp() {
  SharedDtor();
}

void ResolveBlueprintResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ResolveBlueprintResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResolveBlueprintResp& ResolveBlueprintResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

ResolveBlueprintResp* ResolveBlueprintResp::default_instance_ = NULL;

ResolveBlueprintResp* ResolveBlueprintResp::New() const {
  return new ResolveBlueprintResp;
}

void ResolveBlueprintResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResolveBlueprintResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        break;
      }

      // repeated .Pair get_item_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResolveBlueprintResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .Pair get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->get_item_list(i), output);
  }

}

int ResolveBlueprintResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .Pair get_item_list = 3;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveBlueprintResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResolveBlueprintResp*>(&from));
}

void ResolveBlueprintResp::MergeFrom(const ResolveBlueprintResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void ResolveBlueprintResp::CopyFrom(const ResolveBlueprintResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveBlueprintResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  return true;
}

void ResolveBlueprintResp::Swap(ResolveBlueprintResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResolveBlueprintResp::GetTypeName() const {
  return "ResolveBlueprintResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GemEquipReq::kTypeFieldNumber;
const int GemEquipReq::kShipGuidFieldNumber;
const int GemEquipReq::kIndexFieldNumber;
const int GemEquipReq::kGemIdFieldNumber;
#endif  // !_MSC_VER

GemEquipReq::GemEquipReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GemEquipReq::InitAsDefaultInstance() {
}

GemEquipReq::GemEquipReq(const GemEquipReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GemEquipReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ship_guid_ = 0;
  index_ = 0;
  gem_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GemEquipReq::~GemEquipReq() {
  SharedDtor();
}

void GemEquipReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GemEquipReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GemEquipReq& GemEquipReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

GemEquipReq* GemEquipReq::default_instance_ = NULL;

GemEquipReq* GemEquipReq::New() const {
  return new GemEquipReq;
}

void GemEquipReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    ship_guid_ = 0;
    index_ = 0;
    gem_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GemEquipReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ship_guid;
        break;
      }

      // required int32 ship_guid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ship_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_guid_)));
          set_has_ship_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }

      // required int32 index = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_gem_id;
        break;
      }

      // required int32 gem_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gem_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gem_id_)));
          set_has_gem_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GemEquipReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required int32 ship_guid = 2;
  if (has_ship_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ship_guid(), output);
  }

  // required int32 index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->index(), output);
  }

  // required int32 gem_id = 4;
  if (has_gem_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->gem_id(), output);
  }

}

int GemEquipReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required int32 ship_guid = 2;
    if (has_ship_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_guid());
    }

    // required int32 index = 3;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // required int32 gem_id = 4;
    if (has_gem_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gem_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GemEquipReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GemEquipReq*>(&from));
}

void GemEquipReq::MergeFrom(const GemEquipReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ship_guid()) {
      set_ship_guid(from.ship_guid());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_gem_id()) {
      set_gem_id(from.gem_id());
    }
  }
}

void GemEquipReq::CopyFrom(const GemEquipReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GemEquipReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void GemEquipReq::Swap(GemEquipReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(ship_guid_, other->ship_guid_);
    std::swap(index_, other->index_);
    std::swap(gem_id_, other->gem_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GemEquipReq::GetTypeName() const {
  return "GemEquipReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GemEquipResp::kResultFieldNumber;
const int GemEquipResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GemEquipResp::GemEquipResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GemEquipResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GemEquipResp::GemEquipResp(const GemEquipResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GemEquipResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GemEquipResp::~GemEquipResp() {
  SharedDtor();
}

void GemEquipResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GemEquipResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GemEquipResp& GemEquipResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

GemEquipResp* GemEquipResp::default_instance_ = NULL;

GemEquipResp* GemEquipResp::New() const {
  return new GemEquipResp;
}

void GemEquipResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GemEquipResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GemEquipResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GemEquipResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GemEquipResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GemEquipResp*>(&from));
}

void GemEquipResp::MergeFrom(const GemEquipResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GemEquipResp::CopyFrom(const GemEquipResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GemEquipResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GemEquipResp::Swap(GemEquipResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GemEquipResp::GetTypeName() const {
  return "GemEquipResp";
}


// ===================================================================

#ifndef _MSC_VER
const int MixGemReq::kGemListFieldNumber;
const int MixGemReq::kCountFieldNumber;
#endif  // !_MSC_VER

MixGemReq::MixGemReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MixGemReq::InitAsDefaultInstance() {
}

MixGemReq::MixGemReq(const MixGemReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MixGemReq::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MixGemReq::~MixGemReq() {
  SharedDtor();
}

void MixGemReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MixGemReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MixGemReq& MixGemReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

MixGemReq* MixGemReq::default_instance_ = NULL;

MixGemReq* MixGemReq::New() const {
  return new MixGemReq;
}

void MixGemReq::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    count_ = 0;
  }
  gem_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MixGemReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Gem gem_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gem_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_gem_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_gem_list;
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // optional int32 count = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MixGemReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Gem gem_list = 1;
  for (int i = 0; i < this->gem_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->gem_list(i), output);
  }

  // optional int32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->count(), output);
  }

}

int MixGemReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  // repeated .Gem gem_list = 1;
  total_size += 1 * this->gem_list_size();
  for (int i = 0; i < this->gem_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->gem_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MixGemReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MixGemReq*>(&from));
}

void MixGemReq::MergeFrom(const MixGemReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  gem_list_.MergeFrom(from.gem_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
}

void MixGemReq::CopyFrom(const MixGemReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MixGemReq::IsInitialized() const {

  for (int i = 0; i < gem_list_size(); i++) {
    if (!this->gem_list(i).IsInitialized()) return false;
  }
  return true;
}

void MixGemReq::Swap(MixGemReq* other) {
  if (other != this) {
    gem_list_.Swap(&other->gem_list_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MixGemReq::GetTypeName() const {
  return "MixGemReq";
}


// ===================================================================

#ifndef _MSC_VER
const int MixGemResp::kResultFieldNumber;
const int MixGemResp::kUserSyncFieldNumber;
const int MixGemResp::kMixResultFieldNumber;
const int MixGemResp::kRemainListFieldNumber;
#endif  // !_MSC_VER

MixGemResp::MixGemResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MixGemResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

MixGemResp::MixGemResp(const MixGemResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MixGemResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  mix_result_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MixGemResp::~MixGemResp() {
  SharedDtor();
}

void MixGemResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void MixGemResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MixGemResp& MixGemResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdEquip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdEquip_2eproto();
#endif
  return *default_instance_;
}

MixGemResp* MixGemResp::default_instance_ = NULL;

MixGemResp* MixGemResp::New() const {
  return new MixGemResp;
}

void MixGemResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    mix_result_ = false;
  }
  remain_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MixGemResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_mix_result;
        break;
      }

      // optional bool mix_result = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mix_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mix_result_)));
          set_has_mix_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_remain_list;
        break;
      }

      // repeated .Gem remain_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_remain_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_remain_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_remain_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MixGemResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional bool mix_result = 3;
  if (has_mix_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->mix_result(), output);
  }

  // repeated .Gem remain_list = 4;
  for (int i = 0; i < this->remain_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->remain_list(i), output);
  }

}

int MixGemResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional bool mix_result = 3;
    if (has_mix_result()) {
      total_size += 1 + 1;
    }

  }
  // repeated .Gem remain_list = 4;
  total_size += 1 * this->remain_list_size();
  for (int i = 0; i < this->remain_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->remain_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MixGemResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MixGemResp*>(&from));
}

void MixGemResp::MergeFrom(const MixGemResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  remain_list_.MergeFrom(from.remain_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_mix_result()) {
      set_mix_result(from.mix_result());
    }
  }
}

void MixGemResp::CopyFrom(const MixGemResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MixGemResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < remain_list_size(); i++) {
    if (!this->remain_list(i).IsInitialized()) return false;
  }
  return true;
}

void MixGemResp::Swap(MixGemResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(mix_result_, other->mix_result_);
    remain_list_.Swap(&other->remain_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MixGemResp::GetTypeName() const {
  return "MixGemResp";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
