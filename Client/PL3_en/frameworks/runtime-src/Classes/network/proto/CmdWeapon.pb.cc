// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdWeapon.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CmdWeapon.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_CmdWeapon_2eproto() {
  delete GetShipListReq::default_instance_;
  delete GetShipListResp::default_instance_;
  delete ChangeLineupReq::default_instance_;
  delete ChangeLineupResp::default_instance_;
  delete ChangeWeaponReq::default_instance_;
  delete ChangeWeaponResp::default_instance_;
  delete ShipDevelopeReq::default_instance_;
  delete ShipDevelopeResp::default_instance_;
  delete BlueprintDevelopeReq::default_instance_;
  delete BlueprintDevelopeResp::default_instance_;
  delete ShipRemoveReq::default_instance_;
  delete ShipRemoveResp::default_instance_;
  delete WeaponUpgradeReq::default_instance_;
  delete WeaponUpgradeResp::default_instance_;
  delete ShipBreakReq::default_instance_;
  delete ShipBreakResp::default_instance_;
  delete ShipAddExpReq::default_instance_;
  delete ShipAddExpResp::default_instance_;
  delete ShipFixReq::default_instance_;
  delete ShipFixResp::default_instance_;
  delete ShipAddEnergyExpReq::default_instance_;
  delete ShipAddEnergyExpResp::default_instance_;
  delete ShipLockEnergyTimeReq::default_instance_;
  delete ShipLockEnergyTimeResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_CmdWeapon_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_CmdWeapon_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_AirShip_2eproto();
  ::protobuf_AddDesc_UserSync_2eproto();
  GetShipListReq::default_instance_ = new GetShipListReq();
  GetShipListResp::default_instance_ = new GetShipListResp();
  ChangeLineupReq::default_instance_ = new ChangeLineupReq();
  ChangeLineupResp::default_instance_ = new ChangeLineupResp();
  ChangeWeaponReq::default_instance_ = new ChangeWeaponReq();
  ChangeWeaponResp::default_instance_ = new ChangeWeaponResp();
  ShipDevelopeReq::default_instance_ = new ShipDevelopeReq();
  ShipDevelopeResp::default_instance_ = new ShipDevelopeResp();
  BlueprintDevelopeReq::default_instance_ = new BlueprintDevelopeReq();
  BlueprintDevelopeResp::default_instance_ = new BlueprintDevelopeResp();
  ShipRemoveReq::default_instance_ = new ShipRemoveReq();
  ShipRemoveResp::default_instance_ = new ShipRemoveResp();
  WeaponUpgradeReq::default_instance_ = new WeaponUpgradeReq();
  WeaponUpgradeResp::default_instance_ = new WeaponUpgradeResp();
  ShipBreakReq::default_instance_ = new ShipBreakReq();
  ShipBreakResp::default_instance_ = new ShipBreakResp();
  ShipAddExpReq::default_instance_ = new ShipAddExpReq();
  ShipAddExpResp::default_instance_ = new ShipAddExpResp();
  ShipFixReq::default_instance_ = new ShipFixReq();
  ShipFixResp::default_instance_ = new ShipFixResp();
  ShipAddEnergyExpReq::default_instance_ = new ShipAddEnergyExpReq();
  ShipAddEnergyExpResp::default_instance_ = new ShipAddEnergyExpResp();
  ShipLockEnergyTimeReq::default_instance_ = new ShipLockEnergyTimeReq();
  ShipLockEnergyTimeResp::default_instance_ = new ShipLockEnergyTimeResp();
  GetShipListReq::default_instance_->InitAsDefaultInstance();
  GetShipListResp::default_instance_->InitAsDefaultInstance();
  ChangeLineupReq::default_instance_->InitAsDefaultInstance();
  ChangeLineupResp::default_instance_->InitAsDefaultInstance();
  ChangeWeaponReq::default_instance_->InitAsDefaultInstance();
  ChangeWeaponResp::default_instance_->InitAsDefaultInstance();
  ShipDevelopeReq::default_instance_->InitAsDefaultInstance();
  ShipDevelopeResp::default_instance_->InitAsDefaultInstance();
  BlueprintDevelopeReq::default_instance_->InitAsDefaultInstance();
  BlueprintDevelopeResp::default_instance_->InitAsDefaultInstance();
  ShipRemoveReq::default_instance_->InitAsDefaultInstance();
  ShipRemoveResp::default_instance_->InitAsDefaultInstance();
  WeaponUpgradeReq::default_instance_->InitAsDefaultInstance();
  WeaponUpgradeResp::default_instance_->InitAsDefaultInstance();
  ShipBreakReq::default_instance_->InitAsDefaultInstance();
  ShipBreakResp::default_instance_->InitAsDefaultInstance();
  ShipAddExpReq::default_instance_->InitAsDefaultInstance();
  ShipAddExpResp::default_instance_->InitAsDefaultInstance();
  ShipFixReq::default_instance_->InitAsDefaultInstance();
  ShipFixResp::default_instance_->InitAsDefaultInstance();
  ShipAddEnergyExpReq::default_instance_->InitAsDefaultInstance();
  ShipAddEnergyExpResp::default_instance_->InitAsDefaultInstance();
  ShipLockEnergyTimeReq::default_instance_->InitAsDefaultInstance();
  ShipLockEnergyTimeResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CmdWeapon_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_CmdWeapon_2eproto_once_);
void protobuf_AddDesc_CmdWeapon_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_CmdWeapon_2eproto_once_,
                 &protobuf_AddDesc_CmdWeapon_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CmdWeapon_2eproto {
  StaticDescriptorInitializer_CmdWeapon_2eproto() {
    protobuf_AddDesc_CmdWeapon_2eproto();
  }
} static_descriptor_initializer_CmdWeapon_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int GetShipListReq::kShipIdFieldNumber;
#endif  // !_MSC_VER

GetShipListReq::GetShipListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetShipListReq::InitAsDefaultInstance() {
}

GetShipListReq::GetShipListReq(const GetShipListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetShipListReq::SharedCtor() {
  _cached_size_ = 0;
  ship_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetShipListReq::~GetShipListReq() {
  SharedDtor();
}

void GetShipListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetShipListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetShipListReq& GetShipListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

GetShipListReq* GetShipListReq::default_instance_ = NULL;

GetShipListReq* GetShipListReq::New() const {
  return new GetShipListReq;
}

void GetShipListReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ship_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetShipListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ship_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_id_)));
          set_has_ship_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetShipListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ship_id = 1;
  if (has_ship_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ship_id(), output);
  }

}

int GetShipListReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ship_id = 1;
    if (has_ship_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetShipListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetShipListReq*>(&from));
}

void GetShipListReq::MergeFrom(const GetShipListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ship_id()) {
      set_ship_id(from.ship_id());
    }
  }
}

void GetShipListReq::CopyFrom(const GetShipListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetShipListReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetShipListReq::Swap(GetShipListReq* other) {
  if (other != this) {
    std::swap(ship_id_, other->ship_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetShipListReq::GetTypeName() const {
  return "GetShipListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetShipListResp::kResultFieldNumber;
const int GetShipListResp::kShipInfoFieldNumber;
const int GetShipListResp::kShipListFieldNumber;
#endif  // !_MSC_VER

GetShipListResp::GetShipListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetShipListResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ship_info_ = const_cast< ::AirShip*>(
      ::AirShip::internal_default_instance());
#else
  ship_info_ = const_cast< ::AirShip*>(&::AirShip::default_instance());
#endif
}

GetShipListResp::GetShipListResp(const GetShipListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetShipListResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ship_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetShipListResp::~GetShipListResp() {
  SharedDtor();
}

void GetShipListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete ship_info_;
  }
}

void GetShipListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetShipListResp& GetShipListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

GetShipListResp* GetShipListResp::default_instance_ = NULL;

GetShipListResp* GetShipListResp::New() const {
  return new GetShipListResp;
}

void GetShipListResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_ship_info()) {
      if (ship_info_ != NULL) ship_info_->::AirShip::Clear();
    }
  }
  ship_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetShipListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ship_info;
        break;
      }

      // optional .AirShip ship_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ship_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ship_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ship_list;
        break;
      }

      // repeated .AirShip ship_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ship_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ship_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ship_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetShipListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .AirShip ship_info = 2;
  if (has_ship_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->ship_info(), output);
  }

  // repeated .AirShip ship_list = 3;
  for (int i = 0; i < this->ship_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->ship_list(i), output);
  }

}

int GetShipListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .AirShip ship_info = 2;
    if (has_ship_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ship_info());
    }

  }
  // repeated .AirShip ship_list = 3;
  total_size += 1 * this->ship_list_size();
  for (int i = 0; i < this->ship_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ship_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetShipListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetShipListResp*>(&from));
}

void GetShipListResp::MergeFrom(const GetShipListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  ship_list_.MergeFrom(from.ship_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_ship_info()) {
      mutable_ship_info()->::AirShip::MergeFrom(from.ship_info());
    }
  }
}

void GetShipListResp::CopyFrom(const GetShipListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetShipListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_ship_info()) {
    if (!this->ship_info().IsInitialized()) return false;
  }
  for (int i = 0; i < ship_list_size(); i++) {
    if (!this->ship_list(i).IsInitialized()) return false;
  }
  return true;
}

void GetShipListResp::Swap(GetShipListResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(ship_info_, other->ship_info_);
    ship_list_.Swap(&other->ship_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetShipListResp::GetTypeName() const {
  return "GetShipListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeLineupReq::kTypeFieldNumber;
const int ChangeLineupReq::kLineupFieldNumber;
const int ChangeLineupReq::kIndexFieldNumber;
const int ChangeLineupReq::kLineNameFieldNumber;
#endif  // !_MSC_VER

ChangeLineupReq::ChangeLineupReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChangeLineupReq::InitAsDefaultInstance() {
}

ChangeLineupReq::ChangeLineupReq(const ChangeLineupReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChangeLineupReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  index_ = 0;
  line_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeLineupReq::~ChangeLineupReq() {
  SharedDtor();
}

void ChangeLineupReq::SharedDtor() {
  if (line_name_ != &::google::protobuf::internal::kEmptyString) {
    delete line_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeLineupReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeLineupReq& ChangeLineupReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ChangeLineupReq* ChangeLineupReq::default_instance_ = NULL;

ChangeLineupReq* ChangeLineupReq::New() const {
  return new ChangeLineupReq;
}

void ChangeLineupReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    index_ = 0;
    if (has_line_name()) {
      if (line_name_ != &::google::protobuf::internal::kEmptyString) {
        line_name_->clear();
      }
    }
  }
  lineup_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChangeLineupReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_lineup;
        break;
      }

      // repeated int32 lineup = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lineup:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_lineup())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_lineup())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_lineup;
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }

      // optional int32 index = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_line_name;
        break;
      }

      // optional string line_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_line_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_line_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangeLineupReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // repeated int32 lineup = 2;
  for (int i = 0; i < this->lineup_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->lineup(i), output);
  }

  // optional int32 index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->index(), output);
  }

  // optional string line_name = 4;
  if (has_line_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->line_name(), output);
  }

}

int ChangeLineupReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 index = 3;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional string line_name = 4;
    if (has_line_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->line_name());
    }

  }
  // repeated int32 lineup = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->lineup_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->lineup(i));
    }
    total_size += 1 * this->lineup_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeLineupReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeLineupReq*>(&from));
}

void ChangeLineupReq::MergeFrom(const ChangeLineupReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  lineup_.MergeFrom(from.lineup_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_line_name()) {
      set_line_name(from.line_name());
    }
  }
}

void ChangeLineupReq::CopyFrom(const ChangeLineupReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeLineupReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ChangeLineupReq::Swap(ChangeLineupReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    lineup_.Swap(&other->lineup_);
    std::swap(index_, other->index_);
    std::swap(line_name_, other->line_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeLineupReq::GetTypeName() const {
  return "ChangeLineupReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeLineupResp::kResultFieldNumber;
const int ChangeLineupResp::kUserSyncFieldNumber;
const int ChangeLineupResp::kLineupFieldNumber;
const int ChangeLineupResp::kTypeFieldNumber;
#endif  // !_MSC_VER

ChangeLineupResp::ChangeLineupResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChangeLineupResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ChangeLineupResp::ChangeLineupResp(const ChangeLineupResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChangeLineupResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeLineupResp::~ChangeLineupResp() {
  SharedDtor();
}

void ChangeLineupResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ChangeLineupResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeLineupResp& ChangeLineupResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ChangeLineupResp* ChangeLineupResp::default_instance_ = NULL;

ChangeLineupResp* ChangeLineupResp::New() const {
  return new ChangeLineupResp;
}

void ChangeLineupResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    type_ = 0;
  }
  lineup_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChangeLineupResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lineup;
        break;
      }

      // repeated int32 lineup = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lineup:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_lineup())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_lineup())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lineup;
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // required int32 type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangeLineupResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated int32 lineup = 3;
  for (int i = 0; i < this->lineup_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->lineup(i), output);
  }

  // required int32 type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->type(), output);
  }

}

int ChangeLineupResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // required int32 type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated int32 lineup = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->lineup_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->lineup(i));
    }
    total_size += 1 * this->lineup_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeLineupResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeLineupResp*>(&from));
}

void ChangeLineupResp::MergeFrom(const ChangeLineupResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  lineup_.MergeFrom(from.lineup_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void ChangeLineupResp::CopyFrom(const ChangeLineupResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeLineupResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ChangeLineupResp::Swap(ChangeLineupResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    lineup_.Swap(&other->lineup_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeLineupResp::GetTypeName() const {
  return "ChangeLineupResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeWeaponReq::kTypeFieldNumber;
const int ChangeWeaponReq::kShipIdFieldNumber;
const int ChangeWeaponReq::kGiftFieldNumber;
const int ChangeWeaponReq::kSkillFieldNumber;
const int ChangeWeaponReq::kWeaponListFieldNumber;
#endif  // !_MSC_VER

ChangeWeaponReq::ChangeWeaponReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChangeWeaponReq::InitAsDefaultInstance() {
}

ChangeWeaponReq::ChangeWeaponReq(const ChangeWeaponReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChangeWeaponReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ship_id_ = 0;
  gift_ = 0;
  skill_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeWeaponReq::~ChangeWeaponReq() {
  SharedDtor();
}

void ChangeWeaponReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeWeaponReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeWeaponReq& ChangeWeaponReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ChangeWeaponReq* ChangeWeaponReq::default_instance_ = NULL;

ChangeWeaponReq* ChangeWeaponReq::New() const {
  return new ChangeWeaponReq;
}

void ChangeWeaponReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    ship_id_ = 0;
    gift_ = 0;
    skill_ = 0;
  }
  weapon_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChangeWeaponReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ship_id;
        break;
      }

      // optional int32 ship_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ship_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_id_)));
          set_has_ship_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_gift;
        break;
      }

      // optional int32 gift = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gift:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gift_)));
          set_has_gift();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_skill;
        break;
      }

      // optional int32 skill = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skill_)));
          set_has_skill();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_weapon_list;
        break;
      }

      // repeated int32 weapon_list = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weapon_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 40, input, this->mutable_weapon_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_weapon_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_weapon_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangeWeaponReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional int32 ship_id = 2;
  if (has_ship_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ship_id(), output);
  }

  // optional int32 gift = 3;
  if (has_gift()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->gift(), output);
  }

  // optional int32 skill = 4;
  if (has_skill()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->skill(), output);
  }

  // repeated int32 weapon_list = 5;
  for (int i = 0; i < this->weapon_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      5, this->weapon_list(i), output);
  }

}

int ChangeWeaponReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 ship_id = 2;
    if (has_ship_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_id());
    }

    // optional int32 gift = 3;
    if (has_gift()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gift());
    }

    // optional int32 skill = 4;
    if (has_skill()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skill());
    }

  }
  // repeated int32 weapon_list = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->weapon_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->weapon_list(i));
    }
    total_size += 1 * this->weapon_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeWeaponReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeWeaponReq*>(&from));
}

void ChangeWeaponReq::MergeFrom(const ChangeWeaponReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  weapon_list_.MergeFrom(from.weapon_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ship_id()) {
      set_ship_id(from.ship_id());
    }
    if (from.has_gift()) {
      set_gift(from.gift());
    }
    if (from.has_skill()) {
      set_skill(from.skill());
    }
  }
}

void ChangeWeaponReq::CopyFrom(const ChangeWeaponReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeWeaponReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ChangeWeaponReq::Swap(ChangeWeaponReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(ship_id_, other->ship_id_);
    std::swap(gift_, other->gift_);
    std::swap(skill_, other->skill_);
    weapon_list_.Swap(&other->weapon_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeWeaponReq::GetTypeName() const {
  return "ChangeWeaponReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeWeaponResp::kResultFieldNumber;
const int ChangeWeaponResp::kUserSyncFieldNumber;
const int ChangeWeaponResp::kShipIdFieldNumber;
const int ChangeWeaponResp::kGiftFieldNumber;
const int ChangeWeaponResp::kSkillFieldNumber;
const int ChangeWeaponResp::kWeaponListFieldNumber;
#endif  // !_MSC_VER

ChangeWeaponResp::ChangeWeaponResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChangeWeaponResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ChangeWeaponResp::ChangeWeaponResp(const ChangeWeaponResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChangeWeaponResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ship_id_ = 0;
  gift_ = 0;
  skill_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeWeaponResp::~ChangeWeaponResp() {
  SharedDtor();
}

void ChangeWeaponResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ChangeWeaponResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeWeaponResp& ChangeWeaponResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ChangeWeaponResp* ChangeWeaponResp::default_instance_ = NULL;

ChangeWeaponResp* ChangeWeaponResp::New() const {
  return new ChangeWeaponResp;
}

void ChangeWeaponResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    ship_id_ = 0;
    gift_ = 0;
    skill_ = 0;
  }
  weapon_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChangeWeaponResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ship_id;
        break;
      }

      // optional int32 ship_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ship_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_id_)));
          set_has_ship_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_gift;
        break;
      }

      // optional int32 gift = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gift:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gift_)));
          set_has_gift();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_skill;
        break;
      }

      // optional int32 skill = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skill:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skill_)));
          set_has_skill();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_weapon_list;
        break;
      }

      // repeated int32 weapon_list = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weapon_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 48, input, this->mutable_weapon_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_weapon_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_weapon_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangeWeaponResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional int32 ship_id = 3;
  if (has_ship_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->ship_id(), output);
  }

  // optional int32 gift = 4;
  if (has_gift()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->gift(), output);
  }

  // optional int32 skill = 5;
  if (has_skill()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->skill(), output);
  }

  // repeated int32 weapon_list = 6;
  for (int i = 0; i < this->weapon_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      6, this->weapon_list(i), output);
  }

}

int ChangeWeaponResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 ship_id = 3;
    if (has_ship_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_id());
    }

    // optional int32 gift = 4;
    if (has_gift()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gift());
    }

    // optional int32 skill = 5;
    if (has_skill()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skill());
    }

  }
  // repeated int32 weapon_list = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->weapon_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->weapon_list(i));
    }
    total_size += 1 * this->weapon_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeWeaponResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeWeaponResp*>(&from));
}

void ChangeWeaponResp::MergeFrom(const ChangeWeaponResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  weapon_list_.MergeFrom(from.weapon_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_ship_id()) {
      set_ship_id(from.ship_id());
    }
    if (from.has_gift()) {
      set_gift(from.gift());
    }
    if (from.has_skill()) {
      set_skill(from.skill());
    }
  }
}

void ChangeWeaponResp::CopyFrom(const ChangeWeaponResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeWeaponResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ChangeWeaponResp::Swap(ChangeWeaponResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(ship_id_, other->ship_id_);
    std::swap(gift_, other->gift_);
    std::swap(skill_, other->skill_);
    weapon_list_.Swap(&other->weapon_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeWeaponResp::GetTypeName() const {
  return "ChangeWeaponResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipDevelopeReq::kTypeFieldNumber;
const int ShipDevelopeReq::kShipIdFieldNumber;
#endif  // !_MSC_VER

ShipDevelopeReq::ShipDevelopeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipDevelopeReq::InitAsDefaultInstance() {
}

ShipDevelopeReq::ShipDevelopeReq(const ShipDevelopeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipDevelopeReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ship_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipDevelopeReq::~ShipDevelopeReq() {
  SharedDtor();
}

void ShipDevelopeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShipDevelopeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipDevelopeReq& ShipDevelopeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipDevelopeReq* ShipDevelopeReq::default_instance_ = NULL;

ShipDevelopeReq* ShipDevelopeReq::New() const {
  return new ShipDevelopeReq;
}

void ShipDevelopeReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    ship_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipDevelopeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ship_id;
        break;
      }

      // required int32 ship_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ship_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_id_)));
          set_has_ship_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipDevelopeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required int32 ship_id = 2;
  if (has_ship_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ship_id(), output);
  }

}

int ShipDevelopeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required int32 ship_id = 2;
    if (has_ship_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipDevelopeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipDevelopeReq*>(&from));
}

void ShipDevelopeReq::MergeFrom(const ShipDevelopeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ship_id()) {
      set_ship_id(from.ship_id());
    }
  }
}

void ShipDevelopeReq::CopyFrom(const ShipDevelopeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipDevelopeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ShipDevelopeReq::Swap(ShipDevelopeReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(ship_id_, other->ship_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipDevelopeReq::GetTypeName() const {
  return "ShipDevelopeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipDevelopeResp::kResultFieldNumber;
const int ShipDevelopeResp::kUserSyncFieldNumber;
const int ShipDevelopeResp::kShipIdFieldNumber;
const int ShipDevelopeResp::kShipGuidFieldNumber;
#endif  // !_MSC_VER

ShipDevelopeResp::ShipDevelopeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipDevelopeResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ShipDevelopeResp::ShipDevelopeResp(const ShipDevelopeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipDevelopeResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ship_id_ = 0;
  ship_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipDevelopeResp::~ShipDevelopeResp() {
  SharedDtor();
}

void ShipDevelopeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ShipDevelopeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipDevelopeResp& ShipDevelopeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipDevelopeResp* ShipDevelopeResp::default_instance_ = NULL;

ShipDevelopeResp* ShipDevelopeResp::New() const {
  return new ShipDevelopeResp;
}

void ShipDevelopeResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    ship_id_ = 0;
    ship_guid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipDevelopeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ship_id;
        break;
      }

      // optional int32 ship_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ship_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_id_)));
          set_has_ship_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ship_guid;
        break;
      }

      // optional int32 ship_guid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ship_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_guid_)));
          set_has_ship_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipDevelopeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional int32 ship_id = 3;
  if (has_ship_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->ship_id(), output);
  }

  // optional int32 ship_guid = 4;
  if (has_ship_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->ship_guid(), output);
  }

}

int ShipDevelopeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 ship_id = 3;
    if (has_ship_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_id());
    }

    // optional int32 ship_guid = 4;
    if (has_ship_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_guid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipDevelopeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipDevelopeResp*>(&from));
}

void ShipDevelopeResp::MergeFrom(const ShipDevelopeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_ship_id()) {
      set_ship_id(from.ship_id());
    }
    if (from.has_ship_guid()) {
      set_ship_guid(from.ship_guid());
    }
  }
}

void ShipDevelopeResp::CopyFrom(const ShipDevelopeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipDevelopeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ShipDevelopeResp::Swap(ShipDevelopeResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(ship_id_, other->ship_id_);
    std::swap(ship_guid_, other->ship_guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipDevelopeResp::GetTypeName() const {
  return "ShipDevelopeResp";
}


// ===================================================================

#ifndef _MSC_VER
const int BlueprintDevelopeReq::kTypeFieldNumber;
const int BlueprintDevelopeReq::kBlueprintIdFieldNumber;
#endif  // !_MSC_VER

BlueprintDevelopeReq::BlueprintDevelopeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BlueprintDevelopeReq::InitAsDefaultInstance() {
}

BlueprintDevelopeReq::BlueprintDevelopeReq(const BlueprintDevelopeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BlueprintDevelopeReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  blueprint_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlueprintDevelopeReq::~BlueprintDevelopeReq() {
  SharedDtor();
}

void BlueprintDevelopeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BlueprintDevelopeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BlueprintDevelopeReq& BlueprintDevelopeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

BlueprintDevelopeReq* BlueprintDevelopeReq::default_instance_ = NULL;

BlueprintDevelopeReq* BlueprintDevelopeReq::New() const {
  return new BlueprintDevelopeReq;
}

void BlueprintDevelopeReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    blueprint_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BlueprintDevelopeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_blueprint_id;
        break;
      }

      // required int32 blueprint_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blueprint_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &blueprint_id_)));
          set_has_blueprint_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BlueprintDevelopeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required int32 blueprint_id = 2;
  if (has_blueprint_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->blueprint_id(), output);
  }

}

int BlueprintDevelopeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required int32 blueprint_id = 2;
    if (has_blueprint_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->blueprint_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlueprintDevelopeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BlueprintDevelopeReq*>(&from));
}

void BlueprintDevelopeReq::MergeFrom(const BlueprintDevelopeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_blueprint_id()) {
      set_blueprint_id(from.blueprint_id());
    }
  }
}

void BlueprintDevelopeReq::CopyFrom(const BlueprintDevelopeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlueprintDevelopeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BlueprintDevelopeReq::Swap(BlueprintDevelopeReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(blueprint_id_, other->blueprint_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BlueprintDevelopeReq::GetTypeName() const {
  return "BlueprintDevelopeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int BlueprintDevelopeResp::kResultFieldNumber;
const int BlueprintDevelopeResp::kUserSyncFieldNumber;
const int BlueprintDevelopeResp::kBlueprintIdFieldNumber;
const int BlueprintDevelopeResp::kTypeFieldNumber;
const int BlueprintDevelopeResp::kCritFieldNumber;
const int BlueprintDevelopeResp::kNumFieldNumber;
#endif  // !_MSC_VER

BlueprintDevelopeResp::BlueprintDevelopeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BlueprintDevelopeResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

BlueprintDevelopeResp::BlueprintDevelopeResp(const BlueprintDevelopeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BlueprintDevelopeResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  blueprint_id_ = 0;
  type_ = 0;
  crit_ = false;
  num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlueprintDevelopeResp::~BlueprintDevelopeResp() {
  SharedDtor();
}

void BlueprintDevelopeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void BlueprintDevelopeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BlueprintDevelopeResp& BlueprintDevelopeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

BlueprintDevelopeResp* BlueprintDevelopeResp::default_instance_ = NULL;

BlueprintDevelopeResp* BlueprintDevelopeResp::New() const {
  return new BlueprintDevelopeResp;
}

void BlueprintDevelopeResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    blueprint_id_ = 0;
    type_ = 0;
    crit_ = false;
    num_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BlueprintDevelopeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_blueprint_id;
        break;
      }

      // optional int32 blueprint_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blueprint_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &blueprint_id_)));
          set_has_blueprint_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // optional int32 type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_crit;
        break;
      }

      // optional bool crit = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_crit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &crit_)));
          set_has_crit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_num;
        break;
      }

      // optional int32 num = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BlueprintDevelopeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional int32 blueprint_id = 3;
  if (has_blueprint_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->blueprint_id(), output);
  }

  // optional int32 type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->type(), output);
  }

  // optional bool crit = 5;
  if (has_crit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->crit(), output);
  }

  // optional int32 num = 6;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->num(), output);
  }

}

int BlueprintDevelopeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 blueprint_id = 3;
    if (has_blueprint_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->blueprint_id());
    }

    // optional int32 type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional bool crit = 5;
    if (has_crit()) {
      total_size += 1 + 1;
    }

    // optional int32 num = 6;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlueprintDevelopeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BlueprintDevelopeResp*>(&from));
}

void BlueprintDevelopeResp::MergeFrom(const BlueprintDevelopeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_blueprint_id()) {
      set_blueprint_id(from.blueprint_id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_crit()) {
      set_crit(from.crit());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
}

void BlueprintDevelopeResp::CopyFrom(const BlueprintDevelopeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlueprintDevelopeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void BlueprintDevelopeResp::Swap(BlueprintDevelopeResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(blueprint_id_, other->blueprint_id_);
    std::swap(type_, other->type_);
    std::swap(crit_, other->crit_);
    std::swap(num_, other->num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BlueprintDevelopeResp::GetTypeName() const {
  return "BlueprintDevelopeResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipRemoveReq::kTypeFieldNumber;
const int ShipRemoveReq::kShipGuidFieldNumber;
#endif  // !_MSC_VER

ShipRemoveReq::ShipRemoveReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipRemoveReq::InitAsDefaultInstance() {
}

ShipRemoveReq::ShipRemoveReq(const ShipRemoveReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipRemoveReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ship_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipRemoveReq::~ShipRemoveReq() {
  SharedDtor();
}

void ShipRemoveReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShipRemoveReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipRemoveReq& ShipRemoveReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipRemoveReq* ShipRemoveReq::default_instance_ = NULL;

ShipRemoveReq* ShipRemoveReq::New() const {
  return new ShipRemoveReq;
}

void ShipRemoveReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    ship_guid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipRemoveReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ship_guid;
        break;
      }

      // optional int32 ship_guid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ship_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_guid_)));
          set_has_ship_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipRemoveReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional int32 ship_guid = 2;
  if (has_ship_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ship_guid(), output);
  }

}

int ShipRemoveReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 ship_guid = 2;
    if (has_ship_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_guid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipRemoveReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipRemoveReq*>(&from));
}

void ShipRemoveReq::MergeFrom(const ShipRemoveReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ship_guid()) {
      set_ship_guid(from.ship_guid());
    }
  }
}

void ShipRemoveReq::CopyFrom(const ShipRemoveReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipRemoveReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ShipRemoveReq::Swap(ShipRemoveReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(ship_guid_, other->ship_guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipRemoveReq::GetTypeName() const {
  return "ShipRemoveReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipRemoveResp::kResultFieldNumber;
const int ShipRemoveResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

ShipRemoveResp::ShipRemoveResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipRemoveResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ShipRemoveResp::ShipRemoveResp(const ShipRemoveResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipRemoveResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipRemoveResp::~ShipRemoveResp() {
  SharedDtor();
}

void ShipRemoveResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ShipRemoveResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipRemoveResp& ShipRemoveResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipRemoveResp* ShipRemoveResp::default_instance_ = NULL;

ShipRemoveResp* ShipRemoveResp::New() const {
  return new ShipRemoveResp;
}

void ShipRemoveResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipRemoveResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipRemoveResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int ShipRemoveResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipRemoveResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipRemoveResp*>(&from));
}

void ShipRemoveResp::MergeFrom(const ShipRemoveResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void ShipRemoveResp::CopyFrom(const ShipRemoveResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipRemoveResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ShipRemoveResp::Swap(ShipRemoveResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipRemoveResp::GetTypeName() const {
  return "ShipRemoveResp";
}


// ===================================================================

#ifndef _MSC_VER
const int WeaponUpgradeReq::kTypeFieldNumber;
const int WeaponUpgradeReq::kGuidFieldNumber;
const int WeaponUpgradeReq::kWeaponIdFieldNumber;
#endif  // !_MSC_VER

WeaponUpgradeReq::WeaponUpgradeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void WeaponUpgradeReq::InitAsDefaultInstance() {
}

WeaponUpgradeReq::WeaponUpgradeReq(const WeaponUpgradeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void WeaponUpgradeReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  guid_ = 0;
  weapon_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WeaponUpgradeReq::~WeaponUpgradeReq() {
  SharedDtor();
}

void WeaponUpgradeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void WeaponUpgradeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const WeaponUpgradeReq& WeaponUpgradeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

WeaponUpgradeReq* WeaponUpgradeReq::default_instance_ = NULL;

WeaponUpgradeReq* WeaponUpgradeReq::New() const {
  return new WeaponUpgradeReq;
}

void WeaponUpgradeReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    guid_ = 0;
    weapon_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool WeaponUpgradeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_guid;
        break;
      }

      // optional int32 guid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &guid_)));
          set_has_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_weapon_id;
        break;
      }

      // optional int32 weapon_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weapon_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &weapon_id_)));
          set_has_weapon_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WeaponUpgradeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional int32 guid = 2;
  if (has_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->guid(), output);
  }

  // optional int32 weapon_id = 3;
  if (has_weapon_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->weapon_id(), output);
  }

}

int WeaponUpgradeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 guid = 2;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->guid());
    }

    // optional int32 weapon_id = 3;
    if (has_weapon_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->weapon_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WeaponUpgradeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const WeaponUpgradeReq*>(&from));
}

void WeaponUpgradeReq::MergeFrom(const WeaponUpgradeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_guid()) {
      set_guid(from.guid());
    }
    if (from.has_weapon_id()) {
      set_weapon_id(from.weapon_id());
    }
  }
}

void WeaponUpgradeReq::CopyFrom(const WeaponUpgradeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WeaponUpgradeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WeaponUpgradeReq::Swap(WeaponUpgradeReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(guid_, other->guid_);
    std::swap(weapon_id_, other->weapon_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string WeaponUpgradeReq::GetTypeName() const {
  return "WeaponUpgradeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int WeaponUpgradeResp::kResultFieldNumber;
const int WeaponUpgradeResp::kUserSyncFieldNumber;
const int WeaponUpgradeResp::kTypeFieldNumber;
const int WeaponUpgradeResp::kGuidFieldNumber;
const int WeaponUpgradeResp::kWeaponIdFieldNumber;
#endif  // !_MSC_VER

WeaponUpgradeResp::WeaponUpgradeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void WeaponUpgradeResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

WeaponUpgradeResp::WeaponUpgradeResp(const WeaponUpgradeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void WeaponUpgradeResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  type_ = 0;
  guid_ = 0;
  weapon_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WeaponUpgradeResp::~WeaponUpgradeResp() {
  SharedDtor();
}

void WeaponUpgradeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void WeaponUpgradeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const WeaponUpgradeResp& WeaponUpgradeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

WeaponUpgradeResp* WeaponUpgradeResp::default_instance_ = NULL;

WeaponUpgradeResp* WeaponUpgradeResp::New() const {
  return new WeaponUpgradeResp;
}

void WeaponUpgradeResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    type_ = 0;
    guid_ = 0;
    weapon_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool WeaponUpgradeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional int32 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_guid;
        break;
      }

      // optional int32 guid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &guid_)));
          set_has_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_weapon_id;
        break;
      }

      // optional int32 weapon_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weapon_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &weapon_id_)));
          set_has_weapon_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WeaponUpgradeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional int32 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->type(), output);
  }

  // optional int32 guid = 4;
  if (has_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->guid(), output);
  }

  // optional int32 weapon_id = 5;
  if (has_weapon_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->weapon_id(), output);
  }

}

int WeaponUpgradeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 guid = 4;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->guid());
    }

    // optional int32 weapon_id = 5;
    if (has_weapon_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->weapon_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WeaponUpgradeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const WeaponUpgradeResp*>(&from));
}

void WeaponUpgradeResp::MergeFrom(const WeaponUpgradeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_guid()) {
      set_guid(from.guid());
    }
    if (from.has_weapon_id()) {
      set_weapon_id(from.weapon_id());
    }
  }
}

void WeaponUpgradeResp::CopyFrom(const WeaponUpgradeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WeaponUpgradeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void WeaponUpgradeResp::Swap(WeaponUpgradeResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(type_, other->type_);
    std::swap(guid_, other->guid_);
    std::swap(weapon_id_, other->weapon_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string WeaponUpgradeResp::GetTypeName() const {
  return "WeaponUpgradeResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipBreakReq::kShipGuidFieldNumber;
#endif  // !_MSC_VER

ShipBreakReq::ShipBreakReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipBreakReq::InitAsDefaultInstance() {
}

ShipBreakReq::ShipBreakReq(const ShipBreakReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipBreakReq::SharedCtor() {
  _cached_size_ = 0;
  ship_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipBreakReq::~ShipBreakReq() {
  SharedDtor();
}

void ShipBreakReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShipBreakReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipBreakReq& ShipBreakReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipBreakReq* ShipBreakReq::default_instance_ = NULL;

ShipBreakReq* ShipBreakReq::New() const {
  return new ShipBreakReq;
}

void ShipBreakReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ship_guid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipBreakReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ship_guid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_guid_)));
          set_has_ship_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipBreakReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ship_guid = 1;
  if (has_ship_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ship_guid(), output);
  }

}

int ShipBreakReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ship_guid = 1;
    if (has_ship_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_guid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipBreakReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipBreakReq*>(&from));
}

void ShipBreakReq::MergeFrom(const ShipBreakReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ship_guid()) {
      set_ship_guid(from.ship_guid());
    }
  }
}

void ShipBreakReq::CopyFrom(const ShipBreakReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipBreakReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ShipBreakReq::Swap(ShipBreakReq* other) {
  if (other != this) {
    std::swap(ship_guid_, other->ship_guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipBreakReq::GetTypeName() const {
  return "ShipBreakReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipBreakResp::kResultFieldNumber;
const int ShipBreakResp::kUserSyncFieldNumber;
const int ShipBreakResp::kShipGuidFieldNumber;
const int ShipBreakResp::kShipBreakFieldNumber;
#endif  // !_MSC_VER

ShipBreakResp::ShipBreakResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipBreakResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ShipBreakResp::ShipBreakResp(const ShipBreakResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipBreakResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ship_guid_ = 0;
  ship_break_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipBreakResp::~ShipBreakResp() {
  SharedDtor();
}

void ShipBreakResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ShipBreakResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipBreakResp& ShipBreakResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipBreakResp* ShipBreakResp::default_instance_ = NULL;

ShipBreakResp* ShipBreakResp::New() const {
  return new ShipBreakResp;
}

void ShipBreakResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    ship_guid_ = 0;
    ship_break_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipBreakResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ship_guid;
        break;
      }

      // optional int32 ship_guid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ship_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_guid_)));
          set_has_ship_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ship_break;
        break;
      }

      // optional int32 ship_break = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ship_break:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_break_)));
          set_has_ship_break();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipBreakResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional int32 ship_guid = 3;
  if (has_ship_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->ship_guid(), output);
  }

  // optional int32 ship_break = 4;
  if (has_ship_break()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->ship_break(), output);
  }

}

int ShipBreakResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 ship_guid = 3;
    if (has_ship_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_guid());
    }

    // optional int32 ship_break = 4;
    if (has_ship_break()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_break());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipBreakResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipBreakResp*>(&from));
}

void ShipBreakResp::MergeFrom(const ShipBreakResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_ship_guid()) {
      set_ship_guid(from.ship_guid());
    }
    if (from.has_ship_break()) {
      set_ship_break(from.ship_break());
    }
  }
}

void ShipBreakResp::CopyFrom(const ShipBreakResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipBreakResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ShipBreakResp::Swap(ShipBreakResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(ship_guid_, other->ship_guid_);
    std::swap(ship_break_, other->ship_break_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipBreakResp::GetTypeName() const {
  return "ShipBreakResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipAddExpReq::kShipGuidFieldNumber;
const int ShipAddExpReq::kItemIdListFieldNumber;
const int ShipAddExpReq::kItemNumListFieldNumber;
#endif  // !_MSC_VER

ShipAddExpReq::ShipAddExpReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipAddExpReq::InitAsDefaultInstance() {
}

ShipAddExpReq::ShipAddExpReq(const ShipAddExpReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipAddExpReq::SharedCtor() {
  _cached_size_ = 0;
  ship_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipAddExpReq::~ShipAddExpReq() {
  SharedDtor();
}

void ShipAddExpReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShipAddExpReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipAddExpReq& ShipAddExpReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipAddExpReq* ShipAddExpReq::default_instance_ = NULL;

ShipAddExpReq* ShipAddExpReq::New() const {
  return new ShipAddExpReq;
}

void ShipAddExpReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ship_guid_ = 0;
  }
  item_id_list_.Clear();
  item_num_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipAddExpReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ship_guid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_guid_)));
          set_has_ship_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_id_list;
        break;
      }

      // repeated int32 item_id_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_item_id_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_item_id_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_id_list;
        if (input->ExpectTag(24)) goto parse_item_num_list;
        break;
      }

      // repeated int32 item_num_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_item_num_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_item_num_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_num_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipAddExpReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ship_guid = 1;
  if (has_ship_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ship_guid(), output);
  }

  // repeated int32 item_id_list = 2;
  for (int i = 0; i < this->item_id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->item_id_list(i), output);
  }

  // repeated int32 item_num_list = 3;
  for (int i = 0; i < this->item_num_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->item_num_list(i), output);
  }

}

int ShipAddExpReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ship_guid = 1;
    if (has_ship_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_guid());
    }

  }
  // repeated int32 item_id_list = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_id_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->item_id_list(i));
    }
    total_size += 1 * this->item_id_list_size() + data_size;
  }

  // repeated int32 item_num_list = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->item_num_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->item_num_list(i));
    }
    total_size += 1 * this->item_num_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipAddExpReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipAddExpReq*>(&from));
}

void ShipAddExpReq::MergeFrom(const ShipAddExpReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_id_list_.MergeFrom(from.item_id_list_);
  item_num_list_.MergeFrom(from.item_num_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ship_guid()) {
      set_ship_guid(from.ship_guid());
    }
  }
}

void ShipAddExpReq::CopyFrom(const ShipAddExpReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipAddExpReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ShipAddExpReq::Swap(ShipAddExpReq* other) {
  if (other != this) {
    std::swap(ship_guid_, other->ship_guid_);
    item_id_list_.Swap(&other->item_id_list_);
    item_num_list_.Swap(&other->item_num_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipAddExpReq::GetTypeName() const {
  return "ShipAddExpReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipAddExpResp::kResultFieldNumber;
const int ShipAddExpResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

ShipAddExpResp::ShipAddExpResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipAddExpResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ShipAddExpResp::ShipAddExpResp(const ShipAddExpResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipAddExpResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipAddExpResp::~ShipAddExpResp() {
  SharedDtor();
}

void ShipAddExpResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ShipAddExpResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipAddExpResp& ShipAddExpResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipAddExpResp* ShipAddExpResp::default_instance_ = NULL;

ShipAddExpResp* ShipAddExpResp::New() const {
  return new ShipAddExpResp;
}

void ShipAddExpResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipAddExpResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipAddExpResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int ShipAddExpResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipAddExpResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipAddExpResp*>(&from));
}

void ShipAddExpResp::MergeFrom(const ShipAddExpResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void ShipAddExpResp::CopyFrom(const ShipAddExpResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipAddExpResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ShipAddExpResp::Swap(ShipAddExpResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipAddExpResp::GetTypeName() const {
  return "ShipAddExpResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipFixReq::kTypeFieldNumber;
const int ShipFixReq::kGuidsFieldNumber;
#endif  // !_MSC_VER

ShipFixReq::ShipFixReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipFixReq::InitAsDefaultInstance() {
}

ShipFixReq::ShipFixReq(const ShipFixReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipFixReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipFixReq::~ShipFixReq() {
  SharedDtor();
}

void ShipFixReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShipFixReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipFixReq& ShipFixReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipFixReq* ShipFixReq::default_instance_ = NULL;

ShipFixReq* ShipFixReq::New() const {
  return new ShipFixReq;
}

void ShipFixReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  guids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipFixReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_guids;
        break;
      }

      // repeated int32 guids = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_guids())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_guids())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_guids;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipFixReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // repeated int32 guids = 2;
  for (int i = 0; i < this->guids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->guids(i), output);
  }

}

int ShipFixReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated int32 guids = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->guids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->guids(i));
    }
    total_size += 1 * this->guids_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipFixReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipFixReq*>(&from));
}

void ShipFixReq::MergeFrom(const ShipFixReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  guids_.MergeFrom(from.guids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void ShipFixReq::CopyFrom(const ShipFixReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipFixReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ShipFixReq::Swap(ShipFixReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    guids_.Swap(&other->guids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipFixReq::GetTypeName() const {
  return "ShipFixReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipFixResp::kResultFieldNumber;
const int ShipFixResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

ShipFixResp::ShipFixResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipFixResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ShipFixResp::ShipFixResp(const ShipFixResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipFixResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipFixResp::~ShipFixResp() {
  SharedDtor();
}

void ShipFixResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ShipFixResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipFixResp& ShipFixResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipFixResp* ShipFixResp::default_instance_ = NULL;

ShipFixResp* ShipFixResp::New() const {
  return new ShipFixResp;
}

void ShipFixResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipFixResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipFixResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int ShipFixResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipFixResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipFixResp*>(&from));
}

void ShipFixResp::MergeFrom(const ShipFixResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void ShipFixResp::CopyFrom(const ShipFixResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipFixResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ShipFixResp::Swap(ShipFixResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipFixResp::GetTypeName() const {
  return "ShipFixResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipAddEnergyExpReq::kShipGuidFieldNumber;
const int ShipAddEnergyExpReq::kResListFieldNumber;
#endif  // !_MSC_VER

ShipAddEnergyExpReq::ShipAddEnergyExpReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipAddEnergyExpReq::InitAsDefaultInstance() {
}

ShipAddEnergyExpReq::ShipAddEnergyExpReq(const ShipAddEnergyExpReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipAddEnergyExpReq::SharedCtor() {
  _cached_size_ = 0;
  ship_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipAddEnergyExpReq::~ShipAddEnergyExpReq() {
  SharedDtor();
}

void ShipAddEnergyExpReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShipAddEnergyExpReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipAddEnergyExpReq& ShipAddEnergyExpReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipAddEnergyExpReq* ShipAddEnergyExpReq::default_instance_ = NULL;

ShipAddEnergyExpReq* ShipAddEnergyExpReq::New() const {
  return new ShipAddEnergyExpReq;
}

void ShipAddEnergyExpReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ship_guid_ = 0;
  }
  res_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipAddEnergyExpReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ship_guid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ship_guid_)));
          set_has_ship_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_res_list;
        break;
      }

      // repeated int32 res_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_res_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_res_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_res_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_res_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipAddEnergyExpReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ship_guid = 1;
  if (has_ship_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ship_guid(), output);
  }

  // repeated int32 res_list = 2;
  for (int i = 0; i < this->res_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->res_list(i), output);
  }

}

int ShipAddEnergyExpReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ship_guid = 1;
    if (has_ship_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ship_guid());
    }

  }
  // repeated int32 res_list = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->res_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->res_list(i));
    }
    total_size += 1 * this->res_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipAddEnergyExpReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipAddEnergyExpReq*>(&from));
}

void ShipAddEnergyExpReq::MergeFrom(const ShipAddEnergyExpReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  res_list_.MergeFrom(from.res_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ship_guid()) {
      set_ship_guid(from.ship_guid());
    }
  }
}

void ShipAddEnergyExpReq::CopyFrom(const ShipAddEnergyExpReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipAddEnergyExpReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ShipAddEnergyExpReq::Swap(ShipAddEnergyExpReq* other) {
  if (other != this) {
    std::swap(ship_guid_, other->ship_guid_);
    res_list_.Swap(&other->res_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipAddEnergyExpReq::GetTypeName() const {
  return "ShipAddEnergyExpReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipAddEnergyExpResp::kResultFieldNumber;
const int ShipAddEnergyExpResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

ShipAddEnergyExpResp::ShipAddEnergyExpResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipAddEnergyExpResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ShipAddEnergyExpResp::ShipAddEnergyExpResp(const ShipAddEnergyExpResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipAddEnergyExpResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipAddEnergyExpResp::~ShipAddEnergyExpResp() {
  SharedDtor();
}

void ShipAddEnergyExpResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ShipAddEnergyExpResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipAddEnergyExpResp& ShipAddEnergyExpResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipAddEnergyExpResp* ShipAddEnergyExpResp::default_instance_ = NULL;

ShipAddEnergyExpResp* ShipAddEnergyExpResp::New() const {
  return new ShipAddEnergyExpResp;
}

void ShipAddEnergyExpResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipAddEnergyExpResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipAddEnergyExpResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int ShipAddEnergyExpResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipAddEnergyExpResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipAddEnergyExpResp*>(&from));
}

void ShipAddEnergyExpResp::MergeFrom(const ShipAddEnergyExpResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void ShipAddEnergyExpResp::CopyFrom(const ShipAddEnergyExpResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipAddEnergyExpResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ShipAddEnergyExpResp::Swap(ShipAddEnergyExpResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipAddEnergyExpResp::GetTypeName() const {
  return "ShipAddEnergyExpResp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ShipLockEnergyTimeReq::ShipLockEnergyTimeReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipLockEnergyTimeReq::InitAsDefaultInstance() {
}

ShipLockEnergyTimeReq::ShipLockEnergyTimeReq(const ShipLockEnergyTimeReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipLockEnergyTimeReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipLockEnergyTimeReq::~ShipLockEnergyTimeReq() {
  SharedDtor();
}

void ShipLockEnergyTimeReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShipLockEnergyTimeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipLockEnergyTimeReq& ShipLockEnergyTimeReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipLockEnergyTimeReq* ShipLockEnergyTimeReq::default_instance_ = NULL;

ShipLockEnergyTimeReq* ShipLockEnergyTimeReq::New() const {
  return new ShipLockEnergyTimeReq;
}

void ShipLockEnergyTimeReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipLockEnergyTimeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void ShipLockEnergyTimeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int ShipLockEnergyTimeReq::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipLockEnergyTimeReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipLockEnergyTimeReq*>(&from));
}

void ShipLockEnergyTimeReq::MergeFrom(const ShipLockEnergyTimeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void ShipLockEnergyTimeReq::CopyFrom(const ShipLockEnergyTimeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipLockEnergyTimeReq::IsInitialized() const {

  return true;
}

void ShipLockEnergyTimeReq::Swap(ShipLockEnergyTimeReq* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipLockEnergyTimeReq::GetTypeName() const {
  return "ShipLockEnergyTimeReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipLockEnergyTimeResp::kResultFieldNumber;
const int ShipLockEnergyTimeResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

ShipLockEnergyTimeResp::ShipLockEnergyTimeResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipLockEnergyTimeResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ShipLockEnergyTimeResp::ShipLockEnergyTimeResp(const ShipLockEnergyTimeResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipLockEnergyTimeResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipLockEnergyTimeResp::~ShipLockEnergyTimeResp() {
  SharedDtor();
}

void ShipLockEnergyTimeResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ShipLockEnergyTimeResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipLockEnergyTimeResp& ShipLockEnergyTimeResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdWeapon_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdWeapon_2eproto();
#endif
  return *default_instance_;
}

ShipLockEnergyTimeResp* ShipLockEnergyTimeResp::default_instance_ = NULL;

ShipLockEnergyTimeResp* ShipLockEnergyTimeResp::New() const {
  return new ShipLockEnergyTimeResp;
}

void ShipLockEnergyTimeResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipLockEnergyTimeResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipLockEnergyTimeResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int ShipLockEnergyTimeResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipLockEnergyTimeResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipLockEnergyTimeResp*>(&from));
}

void ShipLockEnergyTimeResp::MergeFrom(const ShipLockEnergyTimeResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void ShipLockEnergyTimeResp::CopyFrom(const ShipLockEnergyTimeResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipLockEnergyTimeResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ShipLockEnergyTimeResp::Swap(ShipLockEnergyTimeResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipLockEnergyTimeResp::GetTypeName() const {
  return "ShipLockEnergyTimeResp";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
