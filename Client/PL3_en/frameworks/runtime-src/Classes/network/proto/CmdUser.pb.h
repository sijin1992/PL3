// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdUser.proto

#ifndef PROTOBUF_CmdUser_2eproto__INCLUDED
#define PROTOBUF_CmdUser_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "OtherInfo.pb.h"
#include "UserInfo.pb.h"
#include "UserSync.pb.h"
#include "Item.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdUser_2eproto();
void protobuf_AssignDesc_CmdUser_2eproto();
void protobuf_ShutdownFile_CmdUser_2eproto();

class AddMoneyCallBack;
class UpdateTimeStampResp;
class UpdateResReq;
class UpdateResResp;
class ChatLog;
class ChatLogList;
class GetChatLogReq;
class GetChatLogResp;
class ChatUserInfo;
class ChatReq;
class ChatResp;
class ChatMsg_t;
class ChatMsg;
class CmdClientGMReq;
class CmdClientGMResp;
class CmdGetOtherUserInfoReq;
class CmdGetOtherUserInfoResp;
class CmdGetOtherUserInfoListReq;
class CmdGetOtherUserInfoListResp;
class NewFriendUpdate;
class BeFriendUpdate;
class GetFriendsInfoReq;
class GetFriendsInfoResp;
class ApplyFriendReq;
class ApplyFriendResp;
class AcceptFriendReq;
class AcceptFriendResp;
class RemoveFriendReq;
class RemoveFriendResp;
class FriendAddTiliReq;
class FriendAddTiliResp;
class FriendAddTiliUpdate;
class FriendReadTiliReq;
class FriendReadTiliResp;
class BlackListReq;
class BlackListResp;
class TalkListReq;
class TalkListResp;
class TaskListResp;
class TaskRewardReq;
class TaskRewardResp;
class GetStrengthResp;
class AddStrengthReq;
class AddStrengthResp;
class RankReq;
class RankResp;
class ShopTimeItemListResp;
class ShopTimeItemListResp_TimeItem;
class ShopBuyReq;
class ShopBuyResp;
class ShipLotteryReq;
class ShipLotteryResp;
class IsOnlineReq;
class IsOnlineResp;
class GuideStepReq;
class GuideStepResp;
class AidAwardReq;
class AidAwardResp;
class OpenGiftReq;
class OpenGiftResp;

enum ChatResp_ChatRet {
  ChatResp_ChatRet_OK = 0,
  ChatResp_ChatRet_FAIL = -1,
  ChatResp_ChatRet_DIRTY = -2,
  ChatResp_ChatRet_BLACK = -3,
  ChatResp_ChatRet_SELF = -4,
  ChatResp_ChatRet_NOMONEY = -5
};
bool ChatResp_ChatRet_IsValid(int value);
const ChatResp_ChatRet ChatResp_ChatRet_ChatRet_MIN = ChatResp_ChatRet_NOMONEY;
const ChatResp_ChatRet ChatResp_ChatRet_ChatRet_MAX = ChatResp_ChatRet_OK;
const int ChatResp_ChatRet_ChatRet_ARRAYSIZE = ChatResp_ChatRet_ChatRet_MAX + 1;

enum ApplyFriendResp_ApplyFriendRet {
  ApplyFriendResp_ApplyFriendRet_OK = 0,
  ApplyFriendResp_ApplyFriendRet_FAIL = -1,
  ApplyFriendResp_ApplyFriendRet_FRIEND = 1,
  ApplyFriendResp_ApplyFriendRet_OTHER_BLACK = 2,
  ApplyFriendResp_ApplyFriendRet_MY_BLACK = 3,
  ApplyFriendResp_ApplyFriendRet_FIREND_FULL = 4,
  ApplyFriendResp_ApplyFriendRet_SENDED = 5
};
bool ApplyFriendResp_ApplyFriendRet_IsValid(int value);
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp_ApplyFriendRet_ApplyFriendRet_MIN = ApplyFriendResp_ApplyFriendRet_FAIL;
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp_ApplyFriendRet_ApplyFriendRet_MAX = ApplyFriendResp_ApplyFriendRet_SENDED;
const int ApplyFriendResp_ApplyFriendRet_ApplyFriendRet_ARRAYSIZE = ApplyFriendResp_ApplyFriendRet_ApplyFriendRet_MAX + 1;

enum AcceptFriendResp_AcceptFriendRet {
  AcceptFriendResp_AcceptFriendRet_OK = 0,
  AcceptFriendResp_AcceptFriendRet_FAIL = -1,
  AcceptFriendResp_AcceptFriendRet_FRIEND = 1,
  AcceptFriendResp_AcceptFriendRet_NO_MAIL = 2,
  AcceptFriendResp_AcceptFriendRet_SELF = 3,
  AcceptFriendResp_AcceptFriendRet_OTHER_BLACK = 4,
  AcceptFriendResp_AcceptFriendRet_MY_BLACK = 5,
  AcceptFriendResp_AcceptFriendRet_MY_FRIEND_FULL = 6,
  AcceptFriendResp_AcceptFriendRet_OTHER_FRIEND_FULL = 7
};
bool AcceptFriendResp_AcceptFriendRet_IsValid(int value);
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp_AcceptFriendRet_AcceptFriendRet_MIN = AcceptFriendResp_AcceptFriendRet_FAIL;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp_AcceptFriendRet_AcceptFriendRet_MAX = AcceptFriendResp_AcceptFriendRet_OTHER_FRIEND_FULL;
const int AcceptFriendResp_AcceptFriendRet_AcceptFriendRet_ARRAYSIZE = AcceptFriendResp_AcceptFriendRet_AcceptFriendRet_MAX + 1;

enum AddStrengthResp_AddStrengthRet {
  AddStrengthResp_AddStrengthRet_OK = 0,
  AddStrengthResp_AddStrengthRet_FAIL = -1,
  AddStrengthResp_AddStrengthRet_REQ_DATA_ERROR = 1,
  AddStrengthResp_AddStrengthRet_NO_ITEM = 2,
  AddStrengthResp_AddStrengthRet_ITEM_KEY_ERROR = 3,
  AddStrengthResp_AddStrengthRet_MAX_TIMES = 4,
  AddStrengthResp_AddStrengthRet_NO_MONEY = 5
};
bool AddStrengthResp_AddStrengthRet_IsValid(int value);
const AddStrengthResp_AddStrengthRet AddStrengthResp_AddStrengthRet_AddStrengthRet_MIN = AddStrengthResp_AddStrengthRet_FAIL;
const AddStrengthResp_AddStrengthRet AddStrengthResp_AddStrengthRet_AddStrengthRet_MAX = AddStrengthResp_AddStrengthRet_NO_MONEY;
const int AddStrengthResp_AddStrengthRet_AddStrengthRet_ARRAYSIZE = AddStrengthResp_AddStrengthRet_AddStrengthRet_MAX + 1;

enum RankReq_RankType {
  RankReq_RankType_PLAYER_LEVEL = 1,
  RankReq_RankType_PLAYER_POWER = 2,
  RankReq_RankType_MAIN_CITY_LEVEL = 3,
  RankReq_RankType_GROUP_POWER = 4,
  RankReq_RankType_ARENA = 5,
  RankReq_RankType_TRIAL = 6
};
bool RankReq_RankType_IsValid(int value);
const RankReq_RankType RankReq_RankType_RankType_MIN = RankReq_RankType_PLAYER_LEVEL;
const RankReq_RankType RankReq_RankType_RankType_MAX = RankReq_RankType_TRIAL;
const int RankReq_RankType_RankType_ARRAYSIZE = RankReq_RankType_RankType_MAX + 1;

// ===================================================================

class AddMoneyCallBack : public ::google::protobuf::MessageLite {
 public:
  AddMoneyCallBack();
  virtual ~AddMoneyCallBack();

  AddMoneyCallBack(const AddMoneyCallBack& from);

  inline AddMoneyCallBack& operator=(const AddMoneyCallBack& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddMoneyCallBack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddMoneyCallBack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddMoneyCallBack* other);

  // implements Message ----------------------------------------------

  AddMoneyCallBack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddMoneyCallBack& from);
  void MergeFrom(const AddMoneyCallBack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // required string orderno = 2;
  inline bool has_orderno() const;
  inline void clear_orderno();
  static const int kOrdernoFieldNumber = 2;
  inline const ::std::string& orderno() const;
  inline void set_orderno(const ::std::string& value);
  inline void set_orderno(const char* value);
  inline void set_orderno(const char* value, size_t size);
  inline ::std::string* mutable_orderno();
  inline ::std::string* release_orderno();
  inline void set_allocated_orderno(::std::string* orderno);

  // required int32 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::int32 amount() const;
  inline void set_amount(::google::protobuf::int32 value);

  // required int32 cur_money = 4;
  inline bool has_cur_money() const;
  inline void clear_cur_money();
  static const int kCurMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 cur_money() const;
  inline void set_cur_money(::google::protobuf::int32 value);

  // required int32 cur_vip = 5;
  inline bool has_cur_vip() const;
  inline void clear_cur_vip();
  static const int kCurVipFieldNumber = 5;
  inline ::google::protobuf::int32 cur_vip() const;
  inline void set_cur_vip(::google::protobuf::int32 value);

  // required int32 total_money = 6;
  inline bool has_total_money() const;
  inline void clear_total_money();
  static const int kTotalMoneyFieldNumber = 6;
  inline ::google::protobuf::int32 total_money() const;
  inline void set_total_money(::google::protobuf::int32 value);

  // required int32 item_id = 7;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 7;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // required int32 buqian = 8;
  inline bool has_buqian() const;
  inline void clear_buqian();
  static const int kBuqianFieldNumber = 8;
  inline ::google::protobuf::int32 buqian() const;
  inline void set_buqian(::google::protobuf::int32 value);

  // optional int32 zsyk = 10;
  inline bool has_zsyk() const;
  inline void clear_zsyk();
  static const int kZsykFieldNumber = 10;
  inline ::google::protobuf::int32 zsyk() const;
  inline void set_zsyk(::google::protobuf::int32 value);

  // optional int32 new_item_id = 11;
  inline bool has_new_item_id() const;
  inline void clear_new_item_id();
  static const int kNewItemIdFieldNumber = 11;
  inline ::google::protobuf::int32 new_item_id() const;
  inline void set_new_item_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AddMoneyCallBack)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_orderno();
  inline void clear_has_orderno();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_cur_money();
  inline void clear_has_cur_money();
  inline void set_has_cur_vip();
  inline void clear_has_cur_vip();
  inline void set_has_total_money();
  inline void clear_has_total_money();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_buqian();
  inline void clear_has_buqian();
  inline void set_has_zsyk();
  inline void clear_has_zsyk();
  inline void set_has_new_item_id();
  inline void clear_has_new_item_id();

  ::std::string* sid_;
  ::std::string* orderno_;
  ::google::protobuf::int32 amount_;
  ::google::protobuf::int32 cur_money_;
  ::google::protobuf::int32 cur_vip_;
  ::google::protobuf::int32 total_money_;
  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 buqian_;
  ::google::protobuf::int32 zsyk_;
  ::google::protobuf::int32 new_item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static AddMoneyCallBack* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTimeStampResp : public ::google::protobuf::MessageLite {
 public:
  UpdateTimeStampResp();
  virtual ~UpdateTimeStampResp();

  UpdateTimeStampResp(const UpdateTimeStampResp& from);

  inline UpdateTimeStampResp& operator=(const UpdateTimeStampResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateTimeStampResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateTimeStampResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateTimeStampResp* other);

  // implements Message ----------------------------------------------

  UpdateTimeStampResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateTimeStampResp& from);
  void MergeFrom(const UpdateTimeStampResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:UpdateTimeStampResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static UpdateTimeStampResp* default_instance_;
};
// -------------------------------------------------------------------

class UpdateResReq : public ::google::protobuf::MessageLite {
 public:
  UpdateResReq();
  virtual ~UpdateResReq();

  UpdateResReq(const UpdateResReq& from);

  inline UpdateResReq& operator=(const UpdateResReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateResReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateResReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateResReq* other);

  // implements Message ----------------------------------------------

  UpdateResReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateResReq& from);
  void MergeFrom(const UpdateResReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UpdateResReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static UpdateResReq* default_instance_;
};
// -------------------------------------------------------------------

class UpdateResResp : public ::google::protobuf::MessageLite {
 public:
  UpdateResResp();
  virtual ~UpdateResResp();

  UpdateResResp(const UpdateResResp& from);

  inline UpdateResResp& operator=(const UpdateResResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateResResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateResResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateResResp* other);

  // implements Message ----------------------------------------------

  UpdateResResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateResResp& from);
  void MergeFrom(const UpdateResResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int64 credit = 3;
  inline bool has_credit() const;
  inline void clear_credit();
  static const int kCreditFieldNumber = 3;
  inline ::google::protobuf::int64 credit() const;
  inline void set_credit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:UpdateResResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_credit();
  inline void clear_has_credit();

  ::UserSync* user_sync_;
  ::google::protobuf::int64 credit_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static UpdateResResp* default_instance_;
};
// -------------------------------------------------------------------

class ChatLog : public ::google::protobuf::MessageLite {
 public:
  ChatLog();
  virtual ~ChatLog();

  ChatLog(const ChatLog& from);

  inline ChatLog& operator=(const ChatLog& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChatLog& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatLog* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatLog* other);

  // implements Message ----------------------------------------------

  ChatLog* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatLog& from);
  void MergeFrom(const ChatLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 stamp = 1;
  inline bool has_stamp() const;
  inline void clear_stamp();
  static const int kStampFieldNumber = 1;
  inline ::google::protobuf::int32 stamp() const;
  inline void set_stamp(::google::protobuf::int32 value);

  // required string chat = 2;
  inline bool has_chat() const;
  inline void clear_chat();
  static const int kChatFieldNumber = 2;
  inline const ::std::string& chat() const;
  inline void set_chat(const ::std::string& value);
  inline void set_chat(const char* value);
  inline void set_chat(const char* value, size_t size);
  inline ::std::string* mutable_chat();
  inline ::std::string* release_chat();
  inline void set_allocated_chat(::std::string* chat);

  // required string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string group_name = 4;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 4;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // required string user_name = 5;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 5;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:ChatLog)
 private:
  inline void set_has_stamp();
  inline void clear_has_stamp();
  inline void set_has_chat();
  inline void clear_has_chat();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::std::string* chat_;
  ::std::string* nickname_;
  ::std::string* group_name_;
  ::std::string* user_name_;
  ::google::protobuf::int32 stamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ChatLog* default_instance_;
};
// -------------------------------------------------------------------

class ChatLogList : public ::google::protobuf::MessageLite {
 public:
  ChatLogList();
  virtual ~ChatLogList();

  ChatLogList(const ChatLogList& from);

  inline ChatLogList& operator=(const ChatLogList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChatLogList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatLogList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatLogList* other);

  // implements Message ----------------------------------------------

  ChatLogList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatLogList& from);
  void MergeFrom(const ChatLogList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ChatLog log_list = 1;
  inline int log_list_size() const;
  inline void clear_log_list();
  static const int kLogListFieldNumber = 1;
  inline const ::ChatLog& log_list(int index) const;
  inline ::ChatLog* mutable_log_list(int index);
  inline ::ChatLog* add_log_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ChatLog >&
      log_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ChatLog >*
      mutable_log_list();

  // @@protoc_insertion_point(class_scope:ChatLogList)
 private:

  ::google::protobuf::RepeatedPtrField< ::ChatLog > log_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ChatLogList* default_instance_;
};
// -------------------------------------------------------------------

class GetChatLogReq : public ::google::protobuf::MessageLite {
 public:
  GetChatLogReq();
  virtual ~GetChatLogReq();

  GetChatLogReq(const GetChatLogReq& from);

  inline GetChatLogReq& operator=(const GetChatLogReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetChatLogReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetChatLogReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetChatLogReq* other);

  // implements Message ----------------------------------------------

  GetChatLogReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetChatLogReq& from);
  void MergeFrom(const GetChatLogReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string chat_id = 1;
  inline bool has_chat_id() const;
  inline void clear_chat_id();
  static const int kChatIdFieldNumber = 1;
  inline const ::std::string& chat_id() const;
  inline void set_chat_id(const ::std::string& value);
  inline void set_chat_id(const char* value);
  inline void set_chat_id(const char* value, size_t size);
  inline ::std::string* mutable_chat_id();
  inline ::std::string* release_chat_id();
  inline void set_allocated_chat_id(::std::string* chat_id);

  // repeated int32 minor = 2;
  inline int minor_size() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 2;
  inline ::google::protobuf::int32 minor(int index) const;
  inline void set_minor(int index, ::google::protobuf::int32 value);
  inline void add_minor(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      minor() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_minor();

  // @@protoc_insertion_point(class_scope:GetChatLogReq)
 private:
  inline void set_has_chat_id();
  inline void clear_has_chat_id();

  ::std::string* chat_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > minor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static GetChatLogReq* default_instance_;
};
// -------------------------------------------------------------------

class GetChatLogResp : public ::google::protobuf::MessageLite {
 public:
  GetChatLogResp();
  virtual ~GetChatLogResp();

  GetChatLogResp(const GetChatLogResp& from);

  inline GetChatLogResp& operator=(const GetChatLogResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetChatLogResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetChatLogResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetChatLogResp* other);

  // implements Message ----------------------------------------------

  GetChatLogResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetChatLogResp& from);
  void MergeFrom(const GetChatLogResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .ChatLog log_list = 3;
  inline int log_list_size() const;
  inline void clear_log_list();
  static const int kLogListFieldNumber = 3;
  inline const ::ChatLog& log_list(int index) const;
  inline ::ChatLog* mutable_log_list(int index);
  inline ::ChatLog* add_log_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ChatLog >&
      log_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ChatLog >*
      mutable_log_list();

  // @@protoc_insertion_point(class_scope:GetChatLogResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::ChatLog > log_list_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static GetChatLogResp* default_instance_;
};
// -------------------------------------------------------------------

class ChatUserInfo : public ::google::protobuf::MessageLite {
 public:
  ChatUserInfo();
  virtual ~ChatUserInfo();

  ChatUserInfo(const ChatUserInfo& from);

  inline ChatUserInfo& operator=(const ChatUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChatUserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatUserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatUserInfo* other);

  // implements Message ----------------------------------------------

  ChatUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatUserInfo& from);
  void MergeFrom(const ChatUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional int32 vip = 3;
  inline bool has_vip() const;
  inline void clear_vip();
  static const int kVipFieldNumber = 3;
  inline ::google::protobuf::int32 vip() const;
  inline void set_vip(::google::protobuf::int32 value);

  // optional int32 sex = 4;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 4;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional int32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional string group_nickname = 6;
  inline bool has_group_nickname() const;
  inline void clear_group_nickname();
  static const int kGroupNicknameFieldNumber = 6;
  inline const ::std::string& group_nickname() const;
  inline void set_group_nickname(const ::std::string& value);
  inline void set_group_nickname(const char* value);
  inline void set_group_nickname(const char* value, size_t size);
  inline ::std::string* mutable_group_nickname();
  inline ::std::string* release_group_nickname();
  inline void set_allocated_group_nickname(::std::string* group_nickname);

  // @@protoc_insertion_point(class_scope:ChatUserInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_vip();
  inline void clear_has_vip();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_group_nickname();
  inline void clear_has_group_nickname();

  ::std::string* uid_;
  ::std::string* nickname_;
  ::google::protobuf::int32 vip_;
  ::google::protobuf::int32 sex_;
  ::std::string* group_nickname_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ChatUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class ChatReq : public ::google::protobuf::MessageLite {
 public:
  ChatReq();
  virtual ~ChatReq();

  ChatReq(const ChatReq& from);

  inline ChatReq& operator=(const ChatReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChatReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatReq* other);

  // implements Message ----------------------------------------------

  ChatReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatReq& from);
  void MergeFrom(const ChatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ChatUserInfo recver = 1;
  inline bool has_recver() const;
  inline void clear_recver();
  static const int kRecverFieldNumber = 1;
  inline const ::ChatUserInfo& recver() const;
  inline ::ChatUserInfo* mutable_recver();
  inline ::ChatUserInfo* release_recver();
  inline void set_allocated_recver(::ChatUserInfo* recver);

  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional int32 channel = 3;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 3;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional .ChatUserInfo sender = 4;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 4;
  inline const ::ChatUserInfo& sender() const;
  inline ::ChatUserInfo* mutable_sender();
  inline ::ChatUserInfo* release_sender();
  inline void set_allocated_sender(::ChatUserInfo* sender);

  // optional int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int32 minor = 6;
  inline int minor_size() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 6;
  inline ::google::protobuf::int32 minor(int index) const;
  inline void set_minor(int index, ::google::protobuf::int32 value);
  inline void add_minor(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      minor() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_minor();

  // @@protoc_insertion_point(class_scope:ChatReq)
 private:
  inline void set_has_recver();
  inline void clear_has_recver();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_type();
  inline void clear_has_type();

  ::ChatUserInfo* recver_;
  ::std::string* msg_;
  ::ChatUserInfo* sender_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > minor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ChatReq* default_instance_;
};
// -------------------------------------------------------------------

class ChatResp : public ::google::protobuf::MessageLite {
 public:
  ChatResp();
  virtual ~ChatResp();

  ChatResp(const ChatResp& from);

  inline ChatResp& operator=(const ChatResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChatResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatResp* other);

  // implements Message ----------------------------------------------

  ChatResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatResp& from);
  void MergeFrom(const ChatResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ChatResp_ChatRet ChatRet;
  static const ChatRet OK = ChatResp_ChatRet_OK;
  static const ChatRet FAIL = ChatResp_ChatRet_FAIL;
  static const ChatRet DIRTY = ChatResp_ChatRet_DIRTY;
  static const ChatRet BLACK = ChatResp_ChatRet_BLACK;
  static const ChatRet SELF = ChatResp_ChatRet_SELF;
  static const ChatRet NOMONEY = ChatResp_ChatRet_NOMONEY;
  static inline bool ChatRet_IsValid(int value) {
    return ChatResp_ChatRet_IsValid(value);
  }
  static const ChatRet ChatRet_MIN =
    ChatResp_ChatRet_ChatRet_MIN;
  static const ChatRet ChatRet_MAX =
    ChatResp_ChatRet_ChatRet_MAX;
  static const int ChatRet_ARRAYSIZE =
    ChatResp_ChatRet_ChatRet_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .ChatResp.ChatRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::ChatResp_ChatRet result() const;
  inline void set_result(::ChatResp_ChatRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ChatResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ChatResp* default_instance_;
};
// -------------------------------------------------------------------

class ChatMsg_t : public ::google::protobuf::MessageLite {
 public:
  ChatMsg_t();
  virtual ~ChatMsg_t();

  ChatMsg_t(const ChatMsg_t& from);

  inline ChatMsg_t& operator=(const ChatMsg_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChatMsg_t& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatMsg_t* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatMsg_t* other);

  // implements Message ----------------------------------------------

  ChatMsg_t* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatMsg_t& from);
  void MergeFrom(const ChatMsg_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string msg = 1;
  inline int msg_size() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg(int index) const;
  inline ::std::string* mutable_msg(int index);
  inline void set_msg(int index, const ::std::string& value);
  inline void set_msg(int index, const char* value);
  inline void set_msg(int index, const char* value, size_t size);
  inline ::std::string* add_msg();
  inline void add_msg(const ::std::string& value);
  inline void add_msg(const char* value);
  inline void add_msg(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& msg() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_msg();

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional .ChatUserInfo sender = 3;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 3;
  inline const ::ChatUserInfo& sender() const;
  inline ::ChatUserInfo* mutable_sender();
  inline ::ChatUserInfo* release_sender();
  inline void set_allocated_sender(::ChatUserInfo* sender);

  // optional .ChatUserInfo recver = 4;
  inline bool has_recver() const;
  inline void clear_recver();
  static const int kRecverFieldNumber = 4;
  inline const ::ChatUserInfo& recver() const;
  inline ::ChatUserInfo* mutable_recver();
  inline ::ChatUserInfo* release_recver();
  inline void set_allocated_recver(::ChatUserInfo* recver);

  // repeated string recvs = 5;
  inline int recvs_size() const;
  inline void clear_recvs();
  static const int kRecvsFieldNumber = 5;
  inline const ::std::string& recvs(int index) const;
  inline ::std::string* mutable_recvs(int index);
  inline void set_recvs(int index, const ::std::string& value);
  inline void set_recvs(int index, const char* value);
  inline void set_recvs(int index, const char* value, size_t size);
  inline ::std::string* add_recvs();
  inline void add_recvs(const ::std::string& value);
  inline void add_recvs(const char* value);
  inline void add_recvs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& recvs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_recvs();

  // optional int32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int32 minor = 7;
  inline int minor_size() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 7;
  inline ::google::protobuf::int32 minor(int index) const;
  inline void set_minor(int index, ::google::protobuf::int32 value);
  inline void add_minor(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      minor() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_minor();

  // @@protoc_insertion_point(class_scope:ChatMsg_t)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_recver();
  inline void clear_has_recver();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::RepeatedPtrField< ::std::string> msg_;
  ::ChatUserInfo* sender_;
  ::ChatUserInfo* recver_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> recvs_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > minor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ChatMsg_t* default_instance_;
};
// -------------------------------------------------------------------

class ChatMsg : public ::google::protobuf::MessageLite {
 public:
  ChatMsg();
  virtual ~ChatMsg();

  ChatMsg(const ChatMsg& from);

  inline ChatMsg& operator=(const ChatMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChatMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatMsg* other);

  // implements Message ----------------------------------------------

  ChatMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatMsg& from);
  void MergeFrom(const ChatMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional .ChatUserInfo sender = 3;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 3;
  inline const ::ChatUserInfo& sender() const;
  inline ::ChatUserInfo* mutable_sender();
  inline ::ChatUserInfo* release_sender();
  inline void set_allocated_sender(::ChatUserInfo* sender);

  // optional .ChatUserInfo recver = 4;
  inline bool has_recver() const;
  inline void clear_recver();
  static const int kRecverFieldNumber = 4;
  inline const ::ChatUserInfo& recver() const;
  inline ::ChatUserInfo* mutable_recver();
  inline ::ChatUserInfo* release_recver();
  inline void set_allocated_recver(::ChatUserInfo* recver);

  // repeated string recvs = 5;
  inline int recvs_size() const;
  inline void clear_recvs();
  static const int kRecvsFieldNumber = 5;
  inline const ::std::string& recvs(int index) const;
  inline ::std::string* mutable_recvs(int index);
  inline void set_recvs(int index, const ::std::string& value);
  inline void set_recvs(int index, const char* value);
  inline void set_recvs(int index, const char* value, size_t size);
  inline ::std::string* add_recvs();
  inline void add_recvs(const ::std::string& value);
  inline void add_recvs(const char* value);
  inline void add_recvs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& recvs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_recvs();

  // optional int32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int32 minor = 7;
  inline int minor_size() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 7;
  inline ::google::protobuf::int32 minor(int index) const;
  inline void set_minor(int index, ::google::protobuf::int32 value);
  inline void add_minor(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      minor() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_minor();

  // @@protoc_insertion_point(class_scope:ChatMsg)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_recver();
  inline void clear_has_recver();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string* msg_;
  ::ChatUserInfo* sender_;
  ::ChatUserInfo* recver_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> recvs_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > minor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ChatMsg* default_instance_;
};
// -------------------------------------------------------------------

class CmdClientGMReq : public ::google::protobuf::MessageLite {
 public:
  CmdClientGMReq();
  virtual ~CmdClientGMReq();

  CmdClientGMReq(const CmdClientGMReq& from);

  inline CmdClientGMReq& operator=(const CmdClientGMReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const CmdClientGMReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CmdClientGMReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CmdClientGMReq* other);

  // implements Message ----------------------------------------------

  CmdClientGMReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CmdClientGMReq& from);
  void MergeFrom(const CmdClientGMReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // @@protoc_insertion_point(class_scope:CmdClientGMReq)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::std::string* cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static CmdClientGMReq* default_instance_;
};
// -------------------------------------------------------------------

class CmdClientGMResp : public ::google::protobuf::MessageLite {
 public:
  CmdClientGMResp();
  virtual ~CmdClientGMResp();

  CmdClientGMResp(const CmdClientGMResp& from);

  inline CmdClientGMResp& operator=(const CmdClientGMResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CmdClientGMResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CmdClientGMResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CmdClientGMResp* other);

  // implements Message ----------------------------------------------

  CmdClientGMResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CmdClientGMResp& from);
  void MergeFrom(const CmdClientGMResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:CmdClientGMResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static CmdClientGMResp* default_instance_;
};
// -------------------------------------------------------------------

class CmdGetOtherUserInfoReq : public ::google::protobuf::MessageLite {
 public:
  CmdGetOtherUserInfoReq();
  virtual ~CmdGetOtherUserInfoReq();

  CmdGetOtherUserInfoReq(const CmdGetOtherUserInfoReq& from);

  inline CmdGetOtherUserInfoReq& operator=(const CmdGetOtherUserInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const CmdGetOtherUserInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CmdGetOtherUserInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CmdGetOtherUserInfoReq* other);

  // implements Message ----------------------------------------------

  CmdGetOtherUserInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CmdGetOtherUserInfoReq& from);
  void MergeFrom(const CmdGetOtherUserInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required int32 sid = 2;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 2;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);

  // repeated int32 lineup = 3;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 3;
  inline ::google::protobuf::int32 lineup(int index) const;
  inline void set_lineup(int index, ::google::protobuf::int32 value);
  inline void add_lineup(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lineup();

  // @@protoc_insertion_point(class_scope:CmdGetOtherUserInfoReq)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_sid();
  inline void clear_has_sid();

  ::std::string* user_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lineup_;
  ::google::protobuf::int32 sid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static CmdGetOtherUserInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CmdGetOtherUserInfoResp : public ::google::protobuf::MessageLite {
 public:
  CmdGetOtherUserInfoResp();
  virtual ~CmdGetOtherUserInfoResp();

  CmdGetOtherUserInfoResp(const CmdGetOtherUserInfoResp& from);

  inline CmdGetOtherUserInfoResp& operator=(const CmdGetOtherUserInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CmdGetOtherUserInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CmdGetOtherUserInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CmdGetOtherUserInfoResp* other);

  // implements Message ----------------------------------------------

  CmdGetOtherUserInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CmdGetOtherUserInfoResp& from);
  void MergeFrom(const CmdGetOtherUserInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .OtherUserInfo info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::OtherUserInfo& info() const;
  inline ::OtherUserInfo* mutable_info();
  inline ::OtherUserInfo* release_info();
  inline void set_allocated_info(::OtherUserInfo* info);

  // @@protoc_insertion_point(class_scope:CmdGetOtherUserInfoResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 type_;
  ::OtherUserInfo* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static CmdGetOtherUserInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class CmdGetOtherUserInfoListReq : public ::google::protobuf::MessageLite {
 public:
  CmdGetOtherUserInfoListReq();
  virtual ~CmdGetOtherUserInfoListReq();

  CmdGetOtherUserInfoListReq(const CmdGetOtherUserInfoListReq& from);

  inline CmdGetOtherUserInfoListReq& operator=(const CmdGetOtherUserInfoListReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const CmdGetOtherUserInfoListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CmdGetOtherUserInfoListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CmdGetOtherUserInfoListReq* other);

  // implements Message ----------------------------------------------

  CmdGetOtherUserInfoListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CmdGetOtherUserInfoListReq& from);
  void MergeFrom(const CmdGetOtherUserInfoListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string user_name_list = 1;
  inline int user_name_list_size() const;
  inline void clear_user_name_list();
  static const int kUserNameListFieldNumber = 1;
  inline const ::std::string& user_name_list(int index) const;
  inline ::std::string* mutable_user_name_list(int index);
  inline void set_user_name_list(int index, const ::std::string& value);
  inline void set_user_name_list(int index, const char* value);
  inline void set_user_name_list(int index, const char* value, size_t size);
  inline ::std::string* add_user_name_list();
  inline void add_user_name_list(const ::std::string& value);
  inline void add_user_name_list(const char* value);
  inline void add_user_name_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_name_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_name_list();

  // required int32 sid = 2;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 2;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CmdGetOtherUserInfoListReq)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();

  ::google::protobuf::RepeatedPtrField< ::std::string> user_name_list_;
  ::google::protobuf::int32 sid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static CmdGetOtherUserInfoListReq* default_instance_;
};
// -------------------------------------------------------------------

class CmdGetOtherUserInfoListResp : public ::google::protobuf::MessageLite {
 public:
  CmdGetOtherUserInfoListResp();
  virtual ~CmdGetOtherUserInfoListResp();

  CmdGetOtherUserInfoListResp(const CmdGetOtherUserInfoListResp& from);

  inline CmdGetOtherUserInfoListResp& operator=(const CmdGetOtherUserInfoListResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CmdGetOtherUserInfoListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CmdGetOtherUserInfoListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CmdGetOtherUserInfoListResp* other);

  // implements Message ----------------------------------------------

  CmdGetOtherUserInfoListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CmdGetOtherUserInfoListResp& from);
  void MergeFrom(const CmdGetOtherUserInfoListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated .OtherUserInfo info_list = 3;
  inline int info_list_size() const;
  inline void clear_info_list();
  static const int kInfoListFieldNumber = 3;
  inline const ::OtherUserInfo& info_list(int index) const;
  inline ::OtherUserInfo* mutable_info_list(int index);
  inline ::OtherUserInfo* add_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >&
      info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >*
      mutable_info_list();

  // @@protoc_insertion_point(class_scope:CmdGetOtherUserInfoListResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::RepeatedPtrField< ::OtherUserInfo > info_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static CmdGetOtherUserInfoListResp* default_instance_;
};
// -------------------------------------------------------------------

class NewFriendUpdate : public ::google::protobuf::MessageLite {
 public:
  NewFriendUpdate();
  virtual ~NewFriendUpdate();

  NewFriendUpdate(const NewFriendUpdate& from);

  inline NewFriendUpdate& operator=(const NewFriendUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const NewFriendUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewFriendUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewFriendUpdate* other);

  // implements Message ----------------------------------------------

  NewFriendUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewFriendUpdate& from);
  void MergeFrom(const NewFriendUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // @@protoc_insertion_point(class_scope:NewFriendUpdate)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();

  ::std::string* sender_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static NewFriendUpdate* default_instance_;
};
// -------------------------------------------------------------------

class BeFriendUpdate : public ::google::protobuf::MessageLite {
 public:
  BeFriendUpdate();
  virtual ~BeFriendUpdate();

  BeFriendUpdate(const BeFriendUpdate& from);

  inline BeFriendUpdate& operator=(const BeFriendUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const BeFriendUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BeFriendUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BeFriendUpdate* other);

  // implements Message ----------------------------------------------

  BeFriendUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BeFriendUpdate& from);
  void MergeFrom(const BeFriendUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BeFriendUpdate)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static BeFriendUpdate* default_instance_;
};
// -------------------------------------------------------------------

class GetFriendsInfoReq : public ::google::protobuf::MessageLite {
 public:
  GetFriendsInfoReq();
  virtual ~GetFriendsInfoReq();

  GetFriendsInfoReq(const GetFriendsInfoReq& from);

  inline GetFriendsInfoReq& operator=(const GetFriendsInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetFriendsInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetFriendsInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetFriendsInfoReq* other);

  // implements Message ----------------------------------------------

  GetFriendsInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetFriendsInfoReq& from);
  void MergeFrom(const GetFriendsInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional string nickname = 4;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 4;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:GetFriendsInfoReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 index_;
  ::std::string* nickname_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static GetFriendsInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class GetFriendsInfoResp : public ::google::protobuf::MessageLite {
 public:
  GetFriendsInfoResp();
  virtual ~GetFriendsInfoResp();

  GetFriendsInfoResp(const GetFriendsInfoResp& from);

  inline GetFriendsInfoResp& operator=(const GetFriendsInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetFriendsInfoResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetFriendsInfoResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetFriendsInfoResp* other);

  // implements Message ----------------------------------------------

  GetFriendsInfoResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetFriendsInfoResp& from);
  void MergeFrom(const GetFriendsInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated .OtherUserInfo list = 3;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 3;
  inline const ::OtherUserInfo& list(int index) const;
  inline ::OtherUserInfo* mutable_list(int index);
  inline ::OtherUserInfo* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:GetFriendsInfoResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::RepeatedPtrField< ::OtherUserInfo > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static GetFriendsInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class ApplyFriendReq : public ::google::protobuf::MessageLite {
 public:
  ApplyFriendReq();
  virtual ~ApplyFriendReq();

  ApplyFriendReq(const ApplyFriendReq& from);

  inline ApplyFriendReq& operator=(const ApplyFriendReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ApplyFriendReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ApplyFriendReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ApplyFriendReq* other);

  // implements Message ----------------------------------------------

  ApplyFriendReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ApplyFriendReq& from);
  void MergeFrom(const ApplyFriendReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string recver = 1;
  inline bool has_recver() const;
  inline void clear_recver();
  static const int kRecverFieldNumber = 1;
  inline const ::std::string& recver() const;
  inline void set_recver(const ::std::string& value);
  inline void set_recver(const char* value);
  inline void set_recver(const char* value, size_t size);
  inline ::std::string* mutable_recver();
  inline ::std::string* release_recver();
  inline void set_allocated_recver(::std::string* recver);

  // @@protoc_insertion_point(class_scope:ApplyFriendReq)
 private:
  inline void set_has_recver();
  inline void clear_has_recver();

  ::std::string* recver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ApplyFriendReq* default_instance_;
};
// -------------------------------------------------------------------

class ApplyFriendResp : public ::google::protobuf::MessageLite {
 public:
  ApplyFriendResp();
  virtual ~ApplyFriendResp();

  ApplyFriendResp(const ApplyFriendResp& from);

  inline ApplyFriendResp& operator=(const ApplyFriendResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ApplyFriendResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ApplyFriendResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ApplyFriendResp* other);

  // implements Message ----------------------------------------------

  ApplyFriendResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ApplyFriendResp& from);
  void MergeFrom(const ApplyFriendResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ApplyFriendResp_ApplyFriendRet ApplyFriendRet;
  static const ApplyFriendRet OK = ApplyFriendResp_ApplyFriendRet_OK;
  static const ApplyFriendRet FAIL = ApplyFriendResp_ApplyFriendRet_FAIL;
  static const ApplyFriendRet FRIEND = ApplyFriendResp_ApplyFriendRet_FRIEND;
  static const ApplyFriendRet OTHER_BLACK = ApplyFriendResp_ApplyFriendRet_OTHER_BLACK;
  static const ApplyFriendRet MY_BLACK = ApplyFriendResp_ApplyFriendRet_MY_BLACK;
  static const ApplyFriendRet FIREND_FULL = ApplyFriendResp_ApplyFriendRet_FIREND_FULL;
  static const ApplyFriendRet SENDED = ApplyFriendResp_ApplyFriendRet_SENDED;
  static inline bool ApplyFriendRet_IsValid(int value) {
    return ApplyFriendResp_ApplyFriendRet_IsValid(value);
  }
  static const ApplyFriendRet ApplyFriendRet_MIN =
    ApplyFriendResp_ApplyFriendRet_ApplyFriendRet_MIN;
  static const ApplyFriendRet ApplyFriendRet_MAX =
    ApplyFriendResp_ApplyFriendRet_ApplyFriendRet_MAX;
  static const int ApplyFriendRet_ARRAYSIZE =
    ApplyFriendResp_ApplyFriendRet_ApplyFriendRet_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .ApplyFriendResp.ApplyFriendRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::ApplyFriendResp_ApplyFriendRet result() const;
  inline void set_result(::ApplyFriendResp_ApplyFriendRet value);

  // @@protoc_insertion_point(class_scope:ApplyFriendResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ApplyFriendResp* default_instance_;
};
// -------------------------------------------------------------------

class AcceptFriendReq : public ::google::protobuf::MessageLite {
 public:
  AcceptFriendReq();
  virtual ~AcceptFriendReq();

  AcceptFriendReq(const AcceptFriendReq& from);

  inline AcceptFriendReq& operator=(const AcceptFriendReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const AcceptFriendReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AcceptFriendReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AcceptFriendReq* other);

  // implements Message ----------------------------------------------

  AcceptFriendReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AcceptFriendReq& from);
  void MergeFrom(const AcceptFriendReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // required int32 mail_guid = 2;
  inline bool has_mail_guid() const;
  inline void clear_mail_guid();
  static const int kMailGuidFieldNumber = 2;
  inline ::google::protobuf::int32 mail_guid() const;
  inline void set_mail_guid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AcceptFriendReq)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_mail_guid();
  inline void clear_has_mail_guid();

  ::std::string* sender_;
  ::google::protobuf::int32 mail_guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static AcceptFriendReq* default_instance_;
};
// -------------------------------------------------------------------

class AcceptFriendResp : public ::google::protobuf::MessageLite {
 public:
  AcceptFriendResp();
  virtual ~AcceptFriendResp();

  AcceptFriendResp(const AcceptFriendResp& from);

  inline AcceptFriendResp& operator=(const AcceptFriendResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const AcceptFriendResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AcceptFriendResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AcceptFriendResp* other);

  // implements Message ----------------------------------------------

  AcceptFriendResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AcceptFriendResp& from);
  void MergeFrom(const AcceptFriendResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AcceptFriendResp_AcceptFriendRet AcceptFriendRet;
  static const AcceptFriendRet OK = AcceptFriendResp_AcceptFriendRet_OK;
  static const AcceptFriendRet FAIL = AcceptFriendResp_AcceptFriendRet_FAIL;
  static const AcceptFriendRet FRIEND = AcceptFriendResp_AcceptFriendRet_FRIEND;
  static const AcceptFriendRet NO_MAIL = AcceptFriendResp_AcceptFriendRet_NO_MAIL;
  static const AcceptFriendRet SELF = AcceptFriendResp_AcceptFriendRet_SELF;
  static const AcceptFriendRet OTHER_BLACK = AcceptFriendResp_AcceptFriendRet_OTHER_BLACK;
  static const AcceptFriendRet MY_BLACK = AcceptFriendResp_AcceptFriendRet_MY_BLACK;
  static const AcceptFriendRet MY_FRIEND_FULL = AcceptFriendResp_AcceptFriendRet_MY_FRIEND_FULL;
  static const AcceptFriendRet OTHER_FRIEND_FULL = AcceptFriendResp_AcceptFriendRet_OTHER_FRIEND_FULL;
  static inline bool AcceptFriendRet_IsValid(int value) {
    return AcceptFriendResp_AcceptFriendRet_IsValid(value);
  }
  static const AcceptFriendRet AcceptFriendRet_MIN =
    AcceptFriendResp_AcceptFriendRet_AcceptFriendRet_MIN;
  static const AcceptFriendRet AcceptFriendRet_MAX =
    AcceptFriendResp_AcceptFriendRet_AcceptFriendRet_MAX;
  static const int AcceptFriendRet_ARRAYSIZE =
    AcceptFriendResp_AcceptFriendRet_AcceptFriendRet_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .AcceptFriendResp.AcceptFriendRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::AcceptFriendResp_AcceptFriendRet result() const;
  inline void set_result(::AcceptFriendResp_AcceptFriendRet value);

  // @@protoc_insertion_point(class_scope:AcceptFriendResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static AcceptFriendResp* default_instance_;
};
// -------------------------------------------------------------------

class RemoveFriendReq : public ::google::protobuf::MessageLite {
 public:
  RemoveFriendReq();
  virtual ~RemoveFriendReq();

  RemoveFriendReq(const RemoveFriendReq& from);

  inline RemoveFriendReq& operator=(const RemoveFriendReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RemoveFriendReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveFriendReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveFriendReq* other);

  // implements Message ----------------------------------------------

  RemoveFriendReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveFriendReq& from);
  void MergeFrom(const RemoveFriendReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:RemoveFriendReq)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::std::string* user_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static RemoveFriendReq* default_instance_;
};
// -------------------------------------------------------------------

class RemoveFriendResp : public ::google::protobuf::MessageLite {
 public:
  RemoveFriendResp();
  virtual ~RemoveFriendResp();

  RemoveFriendResp(const RemoveFriendResp& from);

  inline RemoveFriendResp& operator=(const RemoveFriendResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RemoveFriendResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveFriendResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveFriendResp* other);

  // implements Message ----------------------------------------------

  RemoveFriendResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveFriendResp& from);
  void MergeFrom(const RemoveFriendResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RemoveFriendResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static RemoveFriendResp* default_instance_;
};
// -------------------------------------------------------------------

class FriendAddTiliReq : public ::google::protobuf::MessageLite {
 public:
  FriendAddTiliReq();
  virtual ~FriendAddTiliReq();

  FriendAddTiliReq(const FriendAddTiliReq& from);

  inline FriendAddTiliReq& operator=(const FriendAddTiliReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendAddTiliReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendAddTiliReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendAddTiliReq* other);

  // implements Message ----------------------------------------------

  FriendAddTiliReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendAddTiliReq& from);
  void MergeFrom(const FriendAddTiliReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:FriendAddTiliReq)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::std::string* user_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static FriendAddTiliReq* default_instance_;
};
// -------------------------------------------------------------------

class FriendAddTiliResp : public ::google::protobuf::MessageLite {
 public:
  FriendAddTiliResp();
  virtual ~FriendAddTiliResp();

  FriendAddTiliResp(const FriendAddTiliResp& from);

  inline FriendAddTiliResp& operator=(const FriendAddTiliResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendAddTiliResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendAddTiliResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendAddTiliResp* other);

  // implements Message ----------------------------------------------

  FriendAddTiliResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendAddTiliResp& from);
  void MergeFrom(const FriendAddTiliResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:FriendAddTiliResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static FriendAddTiliResp* default_instance_;
};
// -------------------------------------------------------------------

class FriendAddTiliUpdate : public ::google::protobuf::MessageLite {
 public:
  FriendAddTiliUpdate();
  virtual ~FriendAddTiliUpdate();

  FriendAddTiliUpdate(const FriendAddTiliUpdate& from);

  inline FriendAddTiliUpdate& operator=(const FriendAddTiliUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendAddTiliUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendAddTiliUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendAddTiliUpdate* other);

  // implements Message ----------------------------------------------

  FriendAddTiliUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendAddTiliUpdate& from);
  void MergeFrom(const FriendAddTiliUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required .OtherUserInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::OtherUserInfo& info() const;
  inline ::OtherUserInfo* mutable_info();
  inline ::OtherUserInfo* release_info();
  inline void set_allocated_info(::OtherUserInfo* info);

  // @@protoc_insertion_point(class_scope:FriendAddTiliUpdate)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_info();
  inline void clear_has_info();

  ::OtherUserInfo* info_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static FriendAddTiliUpdate* default_instance_;
};
// -------------------------------------------------------------------

class FriendReadTiliReq : public ::google::protobuf::MessageLite {
 public:
  FriendReadTiliReq();
  virtual ~FriendReadTiliReq();

  FriendReadTiliReq(const FriendReadTiliReq& from);

  inline FriendReadTiliReq& operator=(const FriendReadTiliReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendReadTiliReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendReadTiliReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendReadTiliReq* other);

  // implements Message ----------------------------------------------

  FriendReadTiliReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendReadTiliReq& from);
  void MergeFrom(const FriendReadTiliReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string user_name = 1;
  inline int user_name_size() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name(int index) const;
  inline ::std::string* mutable_user_name(int index);
  inline void set_user_name(int index, const ::std::string& value);
  inline void set_user_name(int index, const char* value);
  inline void set_user_name(int index, const char* value, size_t size);
  inline ::std::string* add_user_name();
  inline void add_user_name(const ::std::string& value);
  inline void add_user_name(const char* value);
  inline void add_user_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_name();

  // @@protoc_insertion_point(class_scope:FriendReadTiliReq)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> user_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static FriendReadTiliReq* default_instance_;
};
// -------------------------------------------------------------------

class FriendReadTiliResp : public ::google::protobuf::MessageLite {
 public:
  FriendReadTiliResp();
  virtual ~FriendReadTiliResp();

  FriendReadTiliResp(const FriendReadTiliResp& from);

  inline FriendReadTiliResp& operator=(const FriendReadTiliResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendReadTiliResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendReadTiliResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendReadTiliResp* other);

  // implements Message ----------------------------------------------

  FriendReadTiliResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendReadTiliResp& from);
  void MergeFrom(const FriendReadTiliResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 all_tili = 3;
  inline bool has_all_tili() const;
  inline void clear_all_tili();
  static const int kAllTiliFieldNumber = 3;
  inline ::google::protobuf::int32 all_tili() const;
  inline void set_all_tili(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FriendReadTiliResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_all_tili();
  inline void clear_has_all_tili();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 all_tili_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static FriendReadTiliResp* default_instance_;
};
// -------------------------------------------------------------------

class BlackListReq : public ::google::protobuf::MessageLite {
 public:
  BlackListReq();
  virtual ~BlackListReq();

  BlackListReq(const BlackListReq& from);

  inline BlackListReq& operator=(const BlackListReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const BlackListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BlackListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BlackListReq* other);

  // implements Message ----------------------------------------------

  BlackListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BlackListReq& from);
  void MergeFrom(const BlackListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:BlackListReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::std::string* user_name_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static BlackListReq* default_instance_;
};
// -------------------------------------------------------------------

class BlackListResp : public ::google::protobuf::MessageLite {
 public:
  BlackListResp();
  virtual ~BlackListResp();

  BlackListResp(const BlackListResp& from);

  inline BlackListResp& operator=(const BlackListResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const BlackListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BlackListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BlackListResp* other);

  // implements Message ----------------------------------------------

  BlackListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BlackListResp& from);
  void MergeFrom(const BlackListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BlackListResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static BlackListResp* default_instance_;
};
// -------------------------------------------------------------------

class TalkListReq : public ::google::protobuf::MessageLite {
 public:
  TalkListReq();
  virtual ~TalkListReq();

  TalkListReq(const TalkListReq& from);

  inline TalkListReq& operator=(const TalkListReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const TalkListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TalkListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TalkListReq* other);

  // implements Message ----------------------------------------------

  TalkListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TalkListReq& from);
  void MergeFrom(const TalkListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:TalkListReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::std::string* user_name_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static TalkListReq* default_instance_;
};
// -------------------------------------------------------------------

class TalkListResp : public ::google::protobuf::MessageLite {
 public:
  TalkListResp();
  virtual ~TalkListResp();

  TalkListResp(const TalkListResp& from);

  inline TalkListResp& operator=(const TalkListResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const TalkListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TalkListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TalkListResp* other);

  // implements Message ----------------------------------------------

  TalkListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TalkListResp& from);
  void MergeFrom(const TalkListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TalkListResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static TalkListResp* default_instance_;
};
// -------------------------------------------------------------------

class TaskListResp : public ::google::protobuf::MessageLite {
 public:
  TaskListResp();
  virtual ~TaskListResp();

  TaskListResp(const TaskListResp& from);

  inline TaskListResp& operator=(const TaskListResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const TaskListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TaskListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TaskListResp* other);

  // implements Message ----------------------------------------------

  TaskListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TaskListResp& from);
  void MergeFrom(const TaskListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .TaskInfo task_list = 3;
  inline int task_list_size() const;
  inline void clear_task_list();
  static const int kTaskListFieldNumber = 3;
  inline const ::TaskInfo& task_list(int index) const;
  inline ::TaskInfo* mutable_task_list(int index);
  inline ::TaskInfo* add_task_list();
  inline const ::google::protobuf::RepeatedPtrField< ::TaskInfo >&
      task_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::TaskInfo >*
      mutable_task_list();

  // @@protoc_insertion_point(class_scope:TaskListResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::TaskInfo > task_list_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static TaskListResp* default_instance_;
};
// -------------------------------------------------------------------

class TaskRewardReq : public ::google::protobuf::MessageLite {
 public:
  TaskRewardReq();
  virtual ~TaskRewardReq();

  TaskRewardReq(const TaskRewardReq& from);

  inline TaskRewardReq& operator=(const TaskRewardReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const TaskRewardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TaskRewardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TaskRewardReq* other);

  // implements Message ----------------------------------------------

  TaskRewardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TaskRewardReq& from);
  void MergeFrom(const TaskRewardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::int32 task_id() const;
  inline void set_task_id(::google::protobuf::int32 value);

  // optional int32 other = 2;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 2;
  inline ::google::protobuf::int32 other() const;
  inline void set_other(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TaskRewardReq)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_other();
  inline void clear_has_other();

  ::google::protobuf::int32 task_id_;
  ::google::protobuf::int32 other_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static TaskRewardReq* default_instance_;
};
// -------------------------------------------------------------------

class TaskRewardResp : public ::google::protobuf::MessageLite {
 public:
  TaskRewardResp();
  virtual ~TaskRewardResp();

  TaskRewardResp(const TaskRewardResp& from);

  inline TaskRewardResp& operator=(const TaskRewardResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const TaskRewardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TaskRewardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TaskRewardResp* other);

  // implements Message ----------------------------------------------

  TaskRewardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TaskRewardResp& from);
  void MergeFrom(const TaskRewardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 task_id = 3;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  inline ::google::protobuf::int32 task_id() const;
  inline void set_task_id(::google::protobuf::int32 value);

  // optional int32 other = 4;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 4;
  inline ::google::protobuf::int32 other() const;
  inline void set_other(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TaskRewardResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_other();
  inline void clear_has_other();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 task_id_;
  ::google::protobuf::int32 other_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static TaskRewardResp* default_instance_;
};
// -------------------------------------------------------------------

class GetStrengthResp : public ::google::protobuf::MessageLite {
 public:
  GetStrengthResp();
  virtual ~GetStrengthResp();

  GetStrengthResp(const GetStrengthResp& from);

  inline GetStrengthResp& operator=(const GetStrengthResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetStrengthResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetStrengthResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetStrengthResp* other);

  // implements Message ----------------------------------------------

  GetStrengthResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetStrengthResp& from);
  void MergeFrom(const GetStrengthResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GetStrengthResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static GetStrengthResp* default_instance_;
};
// -------------------------------------------------------------------

class AddStrengthReq : public ::google::protobuf::MessageLite {
 public:
  AddStrengthReq();
  virtual ~AddStrengthReq();

  AddStrengthReq(const AddStrengthReq& from);

  inline AddStrengthReq& operator=(const AddStrengthReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddStrengthReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddStrengthReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddStrengthReq* other);

  // implements Message ----------------------------------------------

  AddStrengthReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddStrengthReq& from);
  void MergeFrom(const AddStrengthReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .Pair item = 2;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::Pair& item() const;
  inline ::Pair* mutable_item();
  inline ::Pair* release_item();
  inline void set_allocated_item(::Pair* item);

  // @@protoc_insertion_point(class_scope:AddStrengthReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_item();
  inline void clear_has_item();

  ::Pair* item_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static AddStrengthReq* default_instance_;
};
// -------------------------------------------------------------------

class AddStrengthResp : public ::google::protobuf::MessageLite {
 public:
  AddStrengthResp();
  virtual ~AddStrengthResp();

  AddStrengthResp(const AddStrengthResp& from);

  inline AddStrengthResp& operator=(const AddStrengthResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const AddStrengthResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AddStrengthResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AddStrengthResp* other);

  // implements Message ----------------------------------------------

  AddStrengthResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AddStrengthResp& from);
  void MergeFrom(const AddStrengthResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AddStrengthResp_AddStrengthRet AddStrengthRet;
  static const AddStrengthRet OK = AddStrengthResp_AddStrengthRet_OK;
  static const AddStrengthRet FAIL = AddStrengthResp_AddStrengthRet_FAIL;
  static const AddStrengthRet REQ_DATA_ERROR = AddStrengthResp_AddStrengthRet_REQ_DATA_ERROR;
  static const AddStrengthRet NO_ITEM = AddStrengthResp_AddStrengthRet_NO_ITEM;
  static const AddStrengthRet ITEM_KEY_ERROR = AddStrengthResp_AddStrengthRet_ITEM_KEY_ERROR;
  static const AddStrengthRet MAX_TIMES = AddStrengthResp_AddStrengthRet_MAX_TIMES;
  static const AddStrengthRet NO_MONEY = AddStrengthResp_AddStrengthRet_NO_MONEY;
  static inline bool AddStrengthRet_IsValid(int value) {
    return AddStrengthResp_AddStrengthRet_IsValid(value);
  }
  static const AddStrengthRet AddStrengthRet_MIN =
    AddStrengthResp_AddStrengthRet_AddStrengthRet_MIN;
  static const AddStrengthRet AddStrengthRet_MAX =
    AddStrengthResp_AddStrengthRet_AddStrengthRet_MAX;
  static const int AddStrengthRet_ARRAYSIZE =
    AddStrengthResp_AddStrengthRet_AddStrengthRet_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .AddStrengthResp.AddStrengthRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::AddStrengthResp_AddStrengthRet result() const;
  inline void set_result(::AddStrengthResp_AddStrengthRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:AddStrengthResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static AddStrengthResp* default_instance_;
};
// -------------------------------------------------------------------

class RankReq : public ::google::protobuf::MessageLite {
 public:
  RankReq();
  virtual ~RankReq();

  RankReq(const RankReq& from);

  inline RankReq& operator=(const RankReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RankReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RankReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RankReq* other);

  // implements Message ----------------------------------------------

  RankReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RankReq& from);
  void MergeFrom(const RankReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RankReq_RankType RankType;
  static const RankType PLAYER_LEVEL = RankReq_RankType_PLAYER_LEVEL;
  static const RankType PLAYER_POWER = RankReq_RankType_PLAYER_POWER;
  static const RankType MAIN_CITY_LEVEL = RankReq_RankType_MAIN_CITY_LEVEL;
  static const RankType GROUP_POWER = RankReq_RankType_GROUP_POWER;
  static const RankType ARENA = RankReq_RankType_ARENA;
  static const RankType TRIAL = RankReq_RankType_TRIAL;
  static inline bool RankType_IsValid(int value) {
    return RankReq_RankType_IsValid(value);
  }
  static const RankType RankType_MIN =
    RankReq_RankType_RankType_MIN;
  static const RankType RankType_MAX =
    RankReq_RankType_RankType_MAX;
  static const int RankType_ARRAYSIZE =
    RankReq_RankType_RankType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .RankReq.RankType rank_type = 1;
  inline bool has_rank_type() const;
  inline void clear_rank_type();
  static const int kRankTypeFieldNumber = 1;
  inline ::RankReq_RankType rank_type() const;
  inline void set_rank_type(::RankReq_RankType value);

  // required int32 start_rank = 2;
  inline bool has_start_rank() const;
  inline void clear_start_rank();
  static const int kStartRankFieldNumber = 2;
  inline ::google::protobuf::int32 start_rank() const;
  inline void set_start_rank(::google::protobuf::int32 value);

  // required bool need_my = 3;
  inline bool has_need_my() const;
  inline void clear_need_my();
  static const int kNeedMyFieldNumber = 3;
  inline bool need_my() const;
  inline void set_need_my(bool value);

  // @@protoc_insertion_point(class_scope:RankReq)
 private:
  inline void set_has_rank_type();
  inline void clear_has_rank_type();
  inline void set_has_start_rank();
  inline void clear_has_start_rank();
  inline void set_has_need_my();
  inline void clear_has_need_my();

  int rank_type_;
  ::google::protobuf::int32 start_rank_;
  bool need_my_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static RankReq* default_instance_;
};
// -------------------------------------------------------------------

class RankResp : public ::google::protobuf::MessageLite {
 public:
  RankResp();
  virtual ~RankResp();

  RankResp(const RankResp& from);

  inline RankResp& operator=(const RankResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RankResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RankResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RankResp* other);

  // implements Message ----------------------------------------------

  RankResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RankResp& from);
  void MergeFrom(const RankResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .OtherUserInfo user_rank = 3;
  inline int user_rank_size() const;
  inline void clear_user_rank();
  static const int kUserRankFieldNumber = 3;
  inline const ::OtherUserInfo& user_rank(int index) const;
  inline ::OtherUserInfo* mutable_user_rank(int index);
  inline ::OtherUserInfo* add_user_rank();
  inline const ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >&
      user_rank() const;
  inline ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >*
      mutable_user_rank();

  // repeated .OtherGroupInfo group_rank = 4;
  inline int group_rank_size() const;
  inline void clear_group_rank();
  static const int kGroupRankFieldNumber = 4;
  inline const ::OtherGroupInfo& group_rank(int index) const;
  inline ::OtherGroupInfo* mutable_group_rank(int index);
  inline ::OtherGroupInfo* add_group_rank();
  inline const ::google::protobuf::RepeatedPtrField< ::OtherGroupInfo >&
      group_rank() const;
  inline ::google::protobuf::RepeatedPtrField< ::OtherGroupInfo >*
      mutable_group_rank();

  // optional .OtherUserInfo my_user_rank = 5;
  inline bool has_my_user_rank() const;
  inline void clear_my_user_rank();
  static const int kMyUserRankFieldNumber = 5;
  inline const ::OtherUserInfo& my_user_rank() const;
  inline ::OtherUserInfo* mutable_my_user_rank();
  inline ::OtherUserInfo* release_my_user_rank();
  inline void set_allocated_my_user_rank(::OtherUserInfo* my_user_rank);

  // optional .OtherGroupInfo my_group_rank = 6;
  inline bool has_my_group_rank() const;
  inline void clear_my_group_rank();
  static const int kMyGroupRankFieldNumber = 6;
  inline const ::OtherGroupInfo& my_group_rank() const;
  inline ::OtherGroupInfo* mutable_my_group_rank();
  inline ::OtherGroupInfo* release_my_group_rank();
  inline void set_allocated_my_group_rank(::OtherGroupInfo* my_group_rank);

  // @@protoc_insertion_point(class_scope:RankResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_my_user_rank();
  inline void clear_has_my_user_rank();
  inline void set_has_my_group_rank();
  inline void clear_has_my_group_rank();

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::OtherUserInfo > user_rank_;
  ::google::protobuf::RepeatedPtrField< ::OtherGroupInfo > group_rank_;
  ::OtherUserInfo* my_user_rank_;
  ::OtherGroupInfo* my_group_rank_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static RankResp* default_instance_;
};
// -------------------------------------------------------------------

class ShopTimeItemListResp_TimeItem : public ::google::protobuf::MessageLite {
 public:
  ShopTimeItemListResp_TimeItem();
  virtual ~ShopTimeItemListResp_TimeItem();

  ShopTimeItemListResp_TimeItem(const ShopTimeItemListResp_TimeItem& from);

  inline ShopTimeItemListResp_TimeItem& operator=(const ShopTimeItemListResp_TimeItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShopTimeItemListResp_TimeItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShopTimeItemListResp_TimeItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShopTimeItemListResp_TimeItem* other);

  // implements Message ----------------------------------------------

  ShopTimeItemListResp_TimeItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShopTimeItemListResp_TimeItem& from);
  void MergeFrom(const ShopTimeItemListResp_TimeItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int64 end_time = 2;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int64 end_time() const;
  inline void set_end_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ShopTimeItemListResp.TimeItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_end_time();
  inline void clear_has_end_time();

  ::google::protobuf::int64 end_time_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ShopTimeItemListResp_TimeItem* default_instance_;
};
// -------------------------------------------------------------------

class ShopTimeItemListResp : public ::google::protobuf::MessageLite {
 public:
  ShopTimeItemListResp();
  virtual ~ShopTimeItemListResp();

  ShopTimeItemListResp(const ShopTimeItemListResp& from);

  inline ShopTimeItemListResp& operator=(const ShopTimeItemListResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShopTimeItemListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShopTimeItemListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShopTimeItemListResp* other);

  // implements Message ----------------------------------------------

  ShopTimeItemListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShopTimeItemListResp& from);
  void MergeFrom(const ShopTimeItemListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ShopTimeItemListResp_TimeItem TimeItem;

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .ShopTimeItemListResp.TimeItem list = 3;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 3;
  inline const ::ShopTimeItemListResp_TimeItem& list(int index) const;
  inline ::ShopTimeItemListResp_TimeItem* mutable_list(int index);
  inline ::ShopTimeItemListResp_TimeItem* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ShopTimeItemListResp_TimeItem >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ShopTimeItemListResp_TimeItem >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:ShopTimeItemListResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::ShopTimeItemListResp_TimeItem > list_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ShopTimeItemListResp* default_instance_;
};
// -------------------------------------------------------------------

class ShopBuyReq : public ::google::protobuf::MessageLite {
 public:
  ShopBuyReq();
  virtual ~ShopBuyReq();

  ShopBuyReq(const ShopBuyReq& from);

  inline ShopBuyReq& operator=(const ShopBuyReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShopBuyReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShopBuyReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShopBuyReq* other);

  // implements Message ----------------------------------------------

  ShopBuyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShopBuyReq& from);
  void MergeFrom(const ShopBuyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShopBuyReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ShopBuyReq* default_instance_;
};
// -------------------------------------------------------------------

class ShopBuyResp : public ::google::protobuf::MessageLite {
 public:
  ShopBuyResp();
  virtual ~ShopBuyResp();

  ShopBuyResp(const ShopBuyResp& from);

  inline ShopBuyResp& operator=(const ShopBuyResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShopBuyResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShopBuyResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShopBuyResp* other);

  // implements Message ----------------------------------------------

  ShopBuyResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShopBuyResp& from);
  void MergeFrom(const ShopBuyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .ShopBuyReq req = 3;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 3;
  inline const ::ShopBuyReq& req() const;
  inline ::ShopBuyReq* mutable_req();
  inline ::ShopBuyReq* release_req();
  inline void set_allocated_req(::ShopBuyReq* req);

  // @@protoc_insertion_point(class_scope:ShopBuyResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_req();
  inline void clear_has_req();

  ::UserSync* user_sync_;
  ::ShopBuyReq* req_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ShopBuyResp* default_instance_;
};
// -------------------------------------------------------------------

class ShipLotteryReq : public ::google::protobuf::MessageLite {
 public:
  ShipLotteryReq();
  virtual ~ShipLotteryReq();

  ShipLotteryReq(const ShipLotteryReq& from);

  inline ShipLotteryReq& operator=(const ShipLotteryReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipLotteryReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipLotteryReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipLotteryReq* other);

  // implements Message ----------------------------------------------

  ShipLotteryReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipLotteryReq& from);
  void MergeFrom(const ShipLotteryReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShipLotteryReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ShipLotteryReq* default_instance_;
};
// -------------------------------------------------------------------

class ShipLotteryResp : public ::google::protobuf::MessageLite {
 public:
  ShipLotteryResp();
  virtual ~ShipLotteryResp();

  ShipLotteryResp(const ShipLotteryResp& from);

  inline ShipLotteryResp& operator=(const ShipLotteryResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipLotteryResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipLotteryResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipLotteryResp* other);

  // implements Message ----------------------------------------------

  ShipLotteryResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipLotteryResp& from);
  void MergeFrom(const ShipLotteryResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .Item item_list = 3;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 3;
  inline const ::Item& item_list(int index) const;
  inline ::Item* mutable_item_list(int index);
  inline ::Item* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Item >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Item >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:ShipLotteryResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::Item > item_list_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static ShipLotteryResp* default_instance_;
};
// -------------------------------------------------------------------

class IsOnlineReq : public ::google::protobuf::MessageLite {
 public:
  IsOnlineReq();
  virtual ~IsOnlineReq();

  IsOnlineReq(const IsOnlineReq& from);

  inline IsOnlineReq& operator=(const IsOnlineReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const IsOnlineReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IsOnlineReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IsOnlineReq* other);

  // implements Message ----------------------------------------------

  IsOnlineReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IsOnlineReq& from);
  void MergeFrom(const IsOnlineReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string user_name_list = 1;
  inline int user_name_list_size() const;
  inline void clear_user_name_list();
  static const int kUserNameListFieldNumber = 1;
  inline const ::std::string& user_name_list(int index) const;
  inline ::std::string* mutable_user_name_list(int index);
  inline void set_user_name_list(int index, const ::std::string& value);
  inline void set_user_name_list(int index, const char* value);
  inline void set_user_name_list(int index, const char* value, size_t size);
  inline ::std::string* add_user_name_list();
  inline void add_user_name_list(const ::std::string& value);
  inline void add_user_name_list(const char* value);
  inline void add_user_name_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_name_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_name_list();

  // @@protoc_insertion_point(class_scope:IsOnlineReq)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> user_name_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static IsOnlineReq* default_instance_;
};
// -------------------------------------------------------------------

class IsOnlineResp : public ::google::protobuf::MessageLite {
 public:
  IsOnlineResp();
  virtual ~IsOnlineResp();

  IsOnlineResp(const IsOnlineResp& from);

  inline IsOnlineResp& operator=(const IsOnlineResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const IsOnlineResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IsOnlineResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IsOnlineResp* other);

  // implements Message ----------------------------------------------

  IsOnlineResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IsOnlineResp& from);
  void MergeFrom(const IsOnlineResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated string user_name_list = 3;
  inline int user_name_list_size() const;
  inline void clear_user_name_list();
  static const int kUserNameListFieldNumber = 3;
  inline const ::std::string& user_name_list(int index) const;
  inline ::std::string* mutable_user_name_list(int index);
  inline void set_user_name_list(int index, const ::std::string& value);
  inline void set_user_name_list(int index, const char* value);
  inline void set_user_name_list(int index, const char* value, size_t size);
  inline ::std::string* add_user_name_list();
  inline void add_user_name_list(const ::std::string& value);
  inline void add_user_name_list(const char* value);
  inline void add_user_name_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& user_name_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_user_name_list();

  // repeated bool is_online_list = 4;
  inline int is_online_list_size() const;
  inline void clear_is_online_list();
  static const int kIsOnlineListFieldNumber = 4;
  inline bool is_online_list(int index) const;
  inline void set_is_online_list(int index, bool value);
  inline void add_is_online_list(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      is_online_list() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_is_online_list();

  // @@protoc_insertion_point(class_scope:IsOnlineResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::std::string> user_name_list_;
  ::google::protobuf::RepeatedField< bool > is_online_list_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static IsOnlineResp* default_instance_;
};
// -------------------------------------------------------------------

class GuideStepReq : public ::google::protobuf::MessageLite {
 public:
  GuideStepReq();
  virtual ~GuideStepReq();

  GuideStepReq(const GuideStepReq& from);

  inline GuideStepReq& operator=(const GuideStepReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GuideStepReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GuideStepReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GuideStepReq* other);

  // implements Message ----------------------------------------------

  GuideStepReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GuideStepReq& from);
  void MergeFrom(const GuideStepReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 step_index = 2;
  inline bool has_step_index() const;
  inline void clear_step_index();
  static const int kStepIndexFieldNumber = 2;
  inline ::google::protobuf::int32 step_index() const;
  inline void set_step_index(::google::protobuf::int32 value);

  // optional int32 step_num = 3;
  inline bool has_step_num() const;
  inline void clear_step_num();
  static const int kStepNumFieldNumber = 3;
  inline ::google::protobuf::int32 step_num() const;
  inline void set_step_num(::google::protobuf::int32 value);

  // optional string talk_key = 4;
  inline bool has_talk_key() const;
  inline void clear_talk_key();
  static const int kTalkKeyFieldNumber = 4;
  inline const ::std::string& talk_key() const;
  inline void set_talk_key(const ::std::string& value);
  inline void set_talk_key(const char* value);
  inline void set_talk_key(const char* value, size_t size);
  inline ::std::string* mutable_talk_key();
  inline ::std::string* release_talk_key();
  inline void set_allocated_talk_key(::std::string* talk_key);

  // @@protoc_insertion_point(class_scope:GuideStepReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_step_index();
  inline void clear_has_step_index();
  inline void set_has_step_num();
  inline void clear_has_step_num();
  inline void set_has_talk_key();
  inline void clear_has_talk_key();

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 step_index_;
  ::std::string* talk_key_;
  ::google::protobuf::int32 step_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static GuideStepReq* default_instance_;
};
// -------------------------------------------------------------------

class GuideStepResp : public ::google::protobuf::MessageLite {
 public:
  GuideStepResp();
  virtual ~GuideStepResp();

  GuideStepResp(const GuideStepResp& from);

  inline GuideStepResp& operator=(const GuideStepResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const GuideStepResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GuideStepResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GuideStepResp* other);

  // implements Message ----------------------------------------------

  GuideStepResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GuideStepResp& from);
  void MergeFrom(const GuideStepResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GuideStepResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static GuideStepResp* default_instance_;
};
// -------------------------------------------------------------------

class AidAwardReq : public ::google::protobuf::MessageLite {
 public:
  AidAwardReq();
  virtual ~AidAwardReq();

  AidAwardReq(const AidAwardReq& from);

  inline AidAwardReq& operator=(const AidAwardReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const AidAwardReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AidAwardReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AidAwardReq* other);

  // implements Message ----------------------------------------------

  AidAwardReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AidAwardReq& from);
  void MergeFrom(const AidAwardReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AidAwardReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static AidAwardReq* default_instance_;
};
// -------------------------------------------------------------------

class AidAwardResp : public ::google::protobuf::MessageLite {
 public:
  AidAwardResp();
  virtual ~AidAwardResp();

  AidAwardResp(const AidAwardResp& from);

  inline AidAwardResp& operator=(const AidAwardResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const AidAwardResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AidAwardResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AidAwardResp* other);

  // implements Message ----------------------------------------------

  AidAwardResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AidAwardResp& from);
  void MergeFrom(const AidAwardResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:AidAwardResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static AidAwardResp* default_instance_;
};
// -------------------------------------------------------------------

class OpenGiftReq : public ::google::protobuf::MessageLite {
 public:
  OpenGiftReq();
  virtual ~OpenGiftReq();

  OpenGiftReq(const OpenGiftReq& from);

  inline OpenGiftReq& operator=(const OpenGiftReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const OpenGiftReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenGiftReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenGiftReq* other);

  // implements Message ----------------------------------------------

  OpenGiftReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenGiftReq& from);
  void MergeFrom(const OpenGiftReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // required int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:OpenGiftReq)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static OpenGiftReq* default_instance_;
};
// -------------------------------------------------------------------

class OpenGiftResp : public ::google::protobuf::MessageLite {
 public:
  OpenGiftResp();
  virtual ~OpenGiftResp();

  OpenGiftResp(const OpenGiftResp& from);

  inline OpenGiftResp& operator=(const OpenGiftResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const OpenGiftResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenGiftResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenGiftResp* other);

  // implements Message ----------------------------------------------

  OpenGiftResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenGiftResp& from);
  void MergeFrom(const OpenGiftResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .Item get_item_list = 3;
  inline int get_item_list_size() const;
  inline void clear_get_item_list();
  static const int kGetItemListFieldNumber = 3;
  inline const ::Item& get_item_list(int index) const;
  inline ::Item* mutable_get_item_list(int index);
  inline ::Item* add_get_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Item >&
      get_item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Item >*
      mutable_get_item_list();

  // @@protoc_insertion_point(class_scope:OpenGiftResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::Item > get_item_list_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdUser_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdUser_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdUser_2eproto();
  friend void protobuf_ShutdownFile_CmdUser_2eproto();

  void InitAsDefaultInstance();
  static OpenGiftResp* default_instance_;
};
// ===================================================================


// ===================================================================

// AddMoneyCallBack

// required string sid = 1;
inline bool AddMoneyCallBack::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddMoneyCallBack::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddMoneyCallBack::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddMoneyCallBack::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& AddMoneyCallBack::sid() const {
  return *sid_;
}
inline void AddMoneyCallBack::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void AddMoneyCallBack::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void AddMoneyCallBack::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddMoneyCallBack::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* AddMoneyCallBack::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddMoneyCallBack::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string orderno = 2;
inline bool AddMoneyCallBack::has_orderno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddMoneyCallBack::set_has_orderno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddMoneyCallBack::clear_has_orderno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddMoneyCallBack::clear_orderno() {
  if (orderno_ != &::google::protobuf::internal::kEmptyString) {
    orderno_->clear();
  }
  clear_has_orderno();
}
inline const ::std::string& AddMoneyCallBack::orderno() const {
  return *orderno_;
}
inline void AddMoneyCallBack::set_orderno(const ::std::string& value) {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::kEmptyString) {
    orderno_ = new ::std::string;
  }
  orderno_->assign(value);
}
inline void AddMoneyCallBack::set_orderno(const char* value) {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::kEmptyString) {
    orderno_ = new ::std::string;
  }
  orderno_->assign(value);
}
inline void AddMoneyCallBack::set_orderno(const char* value, size_t size) {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::kEmptyString) {
    orderno_ = new ::std::string;
  }
  orderno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddMoneyCallBack::mutable_orderno() {
  set_has_orderno();
  if (orderno_ == &::google::protobuf::internal::kEmptyString) {
    orderno_ = new ::std::string;
  }
  return orderno_;
}
inline ::std::string* AddMoneyCallBack::release_orderno() {
  clear_has_orderno();
  if (orderno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderno_;
    orderno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddMoneyCallBack::set_allocated_orderno(::std::string* orderno) {
  if (orderno_ != &::google::protobuf::internal::kEmptyString) {
    delete orderno_;
  }
  if (orderno) {
    set_has_orderno();
    orderno_ = orderno;
  } else {
    clear_has_orderno();
    orderno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 amount = 3;
inline bool AddMoneyCallBack::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddMoneyCallBack::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddMoneyCallBack::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddMoneyCallBack::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline ::google::protobuf::int32 AddMoneyCallBack::amount() const {
  return amount_;
}
inline void AddMoneyCallBack::set_amount(::google::protobuf::int32 value) {
  set_has_amount();
  amount_ = value;
}

// required int32 cur_money = 4;
inline bool AddMoneyCallBack::has_cur_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddMoneyCallBack::set_has_cur_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddMoneyCallBack::clear_has_cur_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddMoneyCallBack::clear_cur_money() {
  cur_money_ = 0;
  clear_has_cur_money();
}
inline ::google::protobuf::int32 AddMoneyCallBack::cur_money() const {
  return cur_money_;
}
inline void AddMoneyCallBack::set_cur_money(::google::protobuf::int32 value) {
  set_has_cur_money();
  cur_money_ = value;
}

// required int32 cur_vip = 5;
inline bool AddMoneyCallBack::has_cur_vip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddMoneyCallBack::set_has_cur_vip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddMoneyCallBack::clear_has_cur_vip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddMoneyCallBack::clear_cur_vip() {
  cur_vip_ = 0;
  clear_has_cur_vip();
}
inline ::google::protobuf::int32 AddMoneyCallBack::cur_vip() const {
  return cur_vip_;
}
inline void AddMoneyCallBack::set_cur_vip(::google::protobuf::int32 value) {
  set_has_cur_vip();
  cur_vip_ = value;
}

// required int32 total_money = 6;
inline bool AddMoneyCallBack::has_total_money() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddMoneyCallBack::set_has_total_money() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddMoneyCallBack::clear_has_total_money() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddMoneyCallBack::clear_total_money() {
  total_money_ = 0;
  clear_has_total_money();
}
inline ::google::protobuf::int32 AddMoneyCallBack::total_money() const {
  return total_money_;
}
inline void AddMoneyCallBack::set_total_money(::google::protobuf::int32 value) {
  set_has_total_money();
  total_money_ = value;
}

// required int32 item_id = 7;
inline bool AddMoneyCallBack::has_item_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddMoneyCallBack::set_has_item_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddMoneyCallBack::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddMoneyCallBack::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 AddMoneyCallBack::item_id() const {
  return item_id_;
}
inline void AddMoneyCallBack::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// required int32 buqian = 8;
inline bool AddMoneyCallBack::has_buqian() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AddMoneyCallBack::set_has_buqian() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AddMoneyCallBack::clear_has_buqian() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AddMoneyCallBack::clear_buqian() {
  buqian_ = 0;
  clear_has_buqian();
}
inline ::google::protobuf::int32 AddMoneyCallBack::buqian() const {
  return buqian_;
}
inline void AddMoneyCallBack::set_buqian(::google::protobuf::int32 value) {
  set_has_buqian();
  buqian_ = value;
}

// optional int32 zsyk = 10;
inline bool AddMoneyCallBack::has_zsyk() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AddMoneyCallBack::set_has_zsyk() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AddMoneyCallBack::clear_has_zsyk() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AddMoneyCallBack::clear_zsyk() {
  zsyk_ = 0;
  clear_has_zsyk();
}
inline ::google::protobuf::int32 AddMoneyCallBack::zsyk() const {
  return zsyk_;
}
inline void AddMoneyCallBack::set_zsyk(::google::protobuf::int32 value) {
  set_has_zsyk();
  zsyk_ = value;
}

// optional int32 new_item_id = 11;
inline bool AddMoneyCallBack::has_new_item_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AddMoneyCallBack::set_has_new_item_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AddMoneyCallBack::clear_has_new_item_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AddMoneyCallBack::clear_new_item_id() {
  new_item_id_ = 0;
  clear_has_new_item_id();
}
inline ::google::protobuf::int32 AddMoneyCallBack::new_item_id() const {
  return new_item_id_;
}
inline void AddMoneyCallBack::set_new_item_id(::google::protobuf::int32 value) {
  set_has_new_item_id();
  new_item_id_ = value;
}

// -------------------------------------------------------------------

// UpdateTimeStampResp

// required int32 result = 1;
inline bool UpdateTimeStampResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTimeStampResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTimeStampResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTimeStampResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UpdateTimeStampResp::result() const {
  return result_;
}
inline void UpdateTimeStampResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool UpdateTimeStampResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTimeStampResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTimeStampResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTimeStampResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& UpdateTimeStampResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* UpdateTimeStampResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* UpdateTimeStampResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void UpdateTimeStampResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// UpdateResReq

// required int32 type = 1;
inline bool UpdateResReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateResReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateResReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateResReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 UpdateResReq::type() const {
  return type_;
}
inline void UpdateResReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// UpdateResResp

// required int32 result = 1;
inline bool UpdateResResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateResResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateResResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateResResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UpdateResResp::result() const {
  return result_;
}
inline void UpdateResResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool UpdateResResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateResResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateResResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateResResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& UpdateResResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* UpdateResResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* UpdateResResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void UpdateResResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int64 credit = 3;
inline bool UpdateResResp::has_credit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateResResp::set_has_credit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateResResp::clear_has_credit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateResResp::clear_credit() {
  credit_ = GOOGLE_LONGLONG(0);
  clear_has_credit();
}
inline ::google::protobuf::int64 UpdateResResp::credit() const {
  return credit_;
}
inline void UpdateResResp::set_credit(::google::protobuf::int64 value) {
  set_has_credit();
  credit_ = value;
}

// -------------------------------------------------------------------

// ChatLog

// required int32 stamp = 1;
inline bool ChatLog::has_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatLog::set_has_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatLog::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatLog::clear_stamp() {
  stamp_ = 0;
  clear_has_stamp();
}
inline ::google::protobuf::int32 ChatLog::stamp() const {
  return stamp_;
}
inline void ChatLog::set_stamp(::google::protobuf::int32 value) {
  set_has_stamp();
  stamp_ = value;
}

// required string chat = 2;
inline bool ChatLog::has_chat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatLog::set_has_chat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatLog::clear_has_chat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatLog::clear_chat() {
  if (chat_ != &::google::protobuf::internal::kEmptyString) {
    chat_->clear();
  }
  clear_has_chat();
}
inline const ::std::string& ChatLog::chat() const {
  return *chat_;
}
inline void ChatLog::set_chat(const ::std::string& value) {
  set_has_chat();
  if (chat_ == &::google::protobuf::internal::kEmptyString) {
    chat_ = new ::std::string;
  }
  chat_->assign(value);
}
inline void ChatLog::set_chat(const char* value) {
  set_has_chat();
  if (chat_ == &::google::protobuf::internal::kEmptyString) {
    chat_ = new ::std::string;
  }
  chat_->assign(value);
}
inline void ChatLog::set_chat(const char* value, size_t size) {
  set_has_chat();
  if (chat_ == &::google::protobuf::internal::kEmptyString) {
    chat_ = new ::std::string;
  }
  chat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatLog::mutable_chat() {
  set_has_chat();
  if (chat_ == &::google::protobuf::internal::kEmptyString) {
    chat_ = new ::std::string;
  }
  return chat_;
}
inline ::std::string* ChatLog::release_chat() {
  clear_has_chat();
  if (chat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chat_;
    chat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatLog::set_allocated_chat(::std::string* chat) {
  if (chat_ != &::google::protobuf::internal::kEmptyString) {
    delete chat_;
  }
  if (chat) {
    set_has_chat();
    chat_ = chat;
  } else {
    clear_has_chat();
    chat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string nickname = 3;
inline bool ChatLog::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatLog::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatLog::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatLog::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& ChatLog::nickname() const {
  return *nickname_;
}
inline void ChatLog::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void ChatLog::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void ChatLog::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatLog::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* ChatLog::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatLog::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string group_name = 4;
inline bool ChatLog::has_group_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatLog::set_has_group_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatLog::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatLog::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& ChatLog::group_name() const {
  return *group_name_;
}
inline void ChatLog::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void ChatLog::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void ChatLog::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatLog::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* ChatLog::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatLog::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user_name = 5;
inline bool ChatLog::has_user_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChatLog::set_has_user_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChatLog::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChatLog::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& ChatLog::user_name() const {
  return *user_name_;
}
inline void ChatLog::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void ChatLog::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void ChatLog::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatLog::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* ChatLog::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatLog::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChatLogList

// repeated .ChatLog log_list = 1;
inline int ChatLogList::log_list_size() const {
  return log_list_.size();
}
inline void ChatLogList::clear_log_list() {
  log_list_.Clear();
}
inline const ::ChatLog& ChatLogList::log_list(int index) const {
  return log_list_.Get(index);
}
inline ::ChatLog* ChatLogList::mutable_log_list(int index) {
  return log_list_.Mutable(index);
}
inline ::ChatLog* ChatLogList::add_log_list() {
  return log_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ChatLog >&
ChatLogList::log_list() const {
  return log_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ChatLog >*
ChatLogList::mutable_log_list() {
  return &log_list_;
}

// -------------------------------------------------------------------

// GetChatLogReq

// required string chat_id = 1;
inline bool GetChatLogReq::has_chat_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetChatLogReq::set_has_chat_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetChatLogReq::clear_has_chat_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetChatLogReq::clear_chat_id() {
  if (chat_id_ != &::google::protobuf::internal::kEmptyString) {
    chat_id_->clear();
  }
  clear_has_chat_id();
}
inline const ::std::string& GetChatLogReq::chat_id() const {
  return *chat_id_;
}
inline void GetChatLogReq::set_chat_id(const ::std::string& value) {
  set_has_chat_id();
  if (chat_id_ == &::google::protobuf::internal::kEmptyString) {
    chat_id_ = new ::std::string;
  }
  chat_id_->assign(value);
}
inline void GetChatLogReq::set_chat_id(const char* value) {
  set_has_chat_id();
  if (chat_id_ == &::google::protobuf::internal::kEmptyString) {
    chat_id_ = new ::std::string;
  }
  chat_id_->assign(value);
}
inline void GetChatLogReq::set_chat_id(const char* value, size_t size) {
  set_has_chat_id();
  if (chat_id_ == &::google::protobuf::internal::kEmptyString) {
    chat_id_ = new ::std::string;
  }
  chat_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetChatLogReq::mutable_chat_id() {
  set_has_chat_id();
  if (chat_id_ == &::google::protobuf::internal::kEmptyString) {
    chat_id_ = new ::std::string;
  }
  return chat_id_;
}
inline ::std::string* GetChatLogReq::release_chat_id() {
  clear_has_chat_id();
  if (chat_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chat_id_;
    chat_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetChatLogReq::set_allocated_chat_id(::std::string* chat_id) {
  if (chat_id_ != &::google::protobuf::internal::kEmptyString) {
    delete chat_id_;
  }
  if (chat_id) {
    set_has_chat_id();
    chat_id_ = chat_id;
  } else {
    clear_has_chat_id();
    chat_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 minor = 2;
inline int GetChatLogReq::minor_size() const {
  return minor_.size();
}
inline void GetChatLogReq::clear_minor() {
  minor_.Clear();
}
inline ::google::protobuf::int32 GetChatLogReq::minor(int index) const {
  return minor_.Get(index);
}
inline void GetChatLogReq::set_minor(int index, ::google::protobuf::int32 value) {
  minor_.Set(index, value);
}
inline void GetChatLogReq::add_minor(::google::protobuf::int32 value) {
  minor_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GetChatLogReq::minor() const {
  return minor_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GetChatLogReq::mutable_minor() {
  return &minor_;
}

// -------------------------------------------------------------------

// GetChatLogResp

// required int32 result = 1;
inline bool GetChatLogResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetChatLogResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetChatLogResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetChatLogResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GetChatLogResp::result() const {
  return result_;
}
inline void GetChatLogResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GetChatLogResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetChatLogResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetChatLogResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetChatLogResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GetChatLogResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* GetChatLogResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GetChatLogResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GetChatLogResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .ChatLog log_list = 3;
inline int GetChatLogResp::log_list_size() const {
  return log_list_.size();
}
inline void GetChatLogResp::clear_log_list() {
  log_list_.Clear();
}
inline const ::ChatLog& GetChatLogResp::log_list(int index) const {
  return log_list_.Get(index);
}
inline ::ChatLog* GetChatLogResp::mutable_log_list(int index) {
  return log_list_.Mutable(index);
}
inline ::ChatLog* GetChatLogResp::add_log_list() {
  return log_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ChatLog >&
GetChatLogResp::log_list() const {
  return log_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ChatLog >*
GetChatLogResp::mutable_log_list() {
  return &log_list_;
}

// -------------------------------------------------------------------

// ChatUserInfo

// optional string uid = 1;
inline bool ChatUserInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatUserInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatUserInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatUserInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& ChatUserInfo::uid() const {
  return *uid_;
}
inline void ChatUserInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void ChatUserInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void ChatUserInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatUserInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* ChatUserInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatUserInfo::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickname = 2;
inline bool ChatUserInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatUserInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatUserInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatUserInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& ChatUserInfo::nickname() const {
  return *nickname_;
}
inline void ChatUserInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void ChatUserInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void ChatUserInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatUserInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* ChatUserInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatUserInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 vip = 3;
inline bool ChatUserInfo::has_vip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatUserInfo::set_has_vip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatUserInfo::clear_has_vip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatUserInfo::clear_vip() {
  vip_ = 0;
  clear_has_vip();
}
inline ::google::protobuf::int32 ChatUserInfo::vip() const {
  return vip_;
}
inline void ChatUserInfo::set_vip(::google::protobuf::int32 value) {
  set_has_vip();
  vip_ = value;
}

// optional int32 sex = 4;
inline bool ChatUserInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatUserInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatUserInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatUserInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 ChatUserInfo::sex() const {
  return sex_;
}
inline void ChatUserInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional int32 level = 5;
inline bool ChatUserInfo::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChatUserInfo::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChatUserInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChatUserInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ChatUserInfo::level() const {
  return level_;
}
inline void ChatUserInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional string group_nickname = 6;
inline bool ChatUserInfo::has_group_nickname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChatUserInfo::set_has_group_nickname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChatUserInfo::clear_has_group_nickname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChatUserInfo::clear_group_nickname() {
  if (group_nickname_ != &::google::protobuf::internal::kEmptyString) {
    group_nickname_->clear();
  }
  clear_has_group_nickname();
}
inline const ::std::string& ChatUserInfo::group_nickname() const {
  return *group_nickname_;
}
inline void ChatUserInfo::set_group_nickname(const ::std::string& value) {
  set_has_group_nickname();
  if (group_nickname_ == &::google::protobuf::internal::kEmptyString) {
    group_nickname_ = new ::std::string;
  }
  group_nickname_->assign(value);
}
inline void ChatUserInfo::set_group_nickname(const char* value) {
  set_has_group_nickname();
  if (group_nickname_ == &::google::protobuf::internal::kEmptyString) {
    group_nickname_ = new ::std::string;
  }
  group_nickname_->assign(value);
}
inline void ChatUserInfo::set_group_nickname(const char* value, size_t size) {
  set_has_group_nickname();
  if (group_nickname_ == &::google::protobuf::internal::kEmptyString) {
    group_nickname_ = new ::std::string;
  }
  group_nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatUserInfo::mutable_group_nickname() {
  set_has_group_nickname();
  if (group_nickname_ == &::google::protobuf::internal::kEmptyString) {
    group_nickname_ = new ::std::string;
  }
  return group_nickname_;
}
inline ::std::string* ChatUserInfo::release_group_nickname() {
  clear_has_group_nickname();
  if (group_nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_nickname_;
    group_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatUserInfo::set_allocated_group_nickname(::std::string* group_nickname) {
  if (group_nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete group_nickname_;
  }
  if (group_nickname) {
    set_has_group_nickname();
    group_nickname_ = group_nickname;
  } else {
    clear_has_group_nickname();
    group_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChatReq

// optional .ChatUserInfo recver = 1;
inline bool ChatReq::has_recver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReq::set_has_recver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReq::clear_has_recver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReq::clear_recver() {
  if (recver_ != NULL) recver_->::ChatUserInfo::Clear();
  clear_has_recver();
}
inline const ::ChatUserInfo& ChatReq::recver() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return recver_ != NULL ? *recver_ : *default_instance().recver_;
#else
  return recver_ != NULL ? *recver_ : *default_instance_->recver_;
#endif
}
inline ::ChatUserInfo* ChatReq::mutable_recver() {
  set_has_recver();
  if (recver_ == NULL) recver_ = new ::ChatUserInfo;
  return recver_;
}
inline ::ChatUserInfo* ChatReq::release_recver() {
  clear_has_recver();
  ::ChatUserInfo* temp = recver_;
  recver_ = NULL;
  return temp;
}
inline void ChatReq::set_allocated_recver(::ChatUserInfo* recver) {
  delete recver_;
  recver_ = recver;
  if (recver) {
    set_has_recver();
  } else {
    clear_has_recver();
  }
}

// optional string msg = 2;
inline bool ChatReq::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatReq::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatReq::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatReq::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ChatReq::msg() const {
  return *msg_;
}
inline void ChatReq::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ChatReq::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ChatReq::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatReq::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ChatReq::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatReq::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 channel = 3;
inline bool ChatReq::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatReq::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatReq::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatReq::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ChatReq::channel() const {
  return channel_;
}
inline void ChatReq::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional .ChatUserInfo sender = 4;
inline bool ChatReq::has_sender() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatReq::set_has_sender() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatReq::clear_has_sender() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatReq::clear_sender() {
  if (sender_ != NULL) sender_->::ChatUserInfo::Clear();
  clear_has_sender();
}
inline const ::ChatUserInfo& ChatReq::sender() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sender_ != NULL ? *sender_ : *default_instance().sender_;
#else
  return sender_ != NULL ? *sender_ : *default_instance_->sender_;
#endif
}
inline ::ChatUserInfo* ChatReq::mutable_sender() {
  set_has_sender();
  if (sender_ == NULL) sender_ = new ::ChatUserInfo;
  return sender_;
}
inline ::ChatUserInfo* ChatReq::release_sender() {
  clear_has_sender();
  ::ChatUserInfo* temp = sender_;
  sender_ = NULL;
  return temp;
}
inline void ChatReq::set_allocated_sender(::ChatUserInfo* sender) {
  delete sender_;
  sender_ = sender;
  if (sender) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
}

// optional int32 type = 5;
inline bool ChatReq::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChatReq::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChatReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChatReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ChatReq::type() const {
  return type_;
}
inline void ChatReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 minor = 6;
inline int ChatReq::minor_size() const {
  return minor_.size();
}
inline void ChatReq::clear_minor() {
  minor_.Clear();
}
inline ::google::protobuf::int32 ChatReq::minor(int index) const {
  return minor_.Get(index);
}
inline void ChatReq::set_minor(int index, ::google::protobuf::int32 value) {
  minor_.Set(index, value);
}
inline void ChatReq::add_minor(::google::protobuf::int32 value) {
  minor_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ChatReq::minor() const {
  return minor_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ChatReq::mutable_minor() {
  return &minor_;
}

// -------------------------------------------------------------------

// ChatResp

// required .ChatResp.ChatRet result = 1;
inline bool ChatResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::ChatResp_ChatRet ChatResp::result() const {
  return static_cast< ::ChatResp_ChatRet >(result_);
}
inline void ChatResp::set_result(::ChatResp_ChatRet value) {
  assert(::ChatResp_ChatRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ChatResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ChatResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ChatResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ChatResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ChatResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ChatMsg_t

// repeated string msg = 1;
inline int ChatMsg_t::msg_size() const {
  return msg_.size();
}
inline void ChatMsg_t::clear_msg() {
  msg_.Clear();
}
inline const ::std::string& ChatMsg_t::msg(int index) const {
  return msg_.Get(index);
}
inline ::std::string* ChatMsg_t::mutable_msg(int index) {
  return msg_.Mutable(index);
}
inline void ChatMsg_t::set_msg(int index, const ::std::string& value) {
  msg_.Mutable(index)->assign(value);
}
inline void ChatMsg_t::set_msg(int index, const char* value) {
  msg_.Mutable(index)->assign(value);
}
inline void ChatMsg_t::set_msg(int index, const char* value, size_t size) {
  msg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatMsg_t::add_msg() {
  return msg_.Add();
}
inline void ChatMsg_t::add_msg(const ::std::string& value) {
  msg_.Add()->assign(value);
}
inline void ChatMsg_t::add_msg(const char* value) {
  msg_.Add()->assign(value);
}
inline void ChatMsg_t::add_msg(const char* value, size_t size) {
  msg_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ChatMsg_t::msg() const {
  return msg_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ChatMsg_t::mutable_msg() {
  return &msg_;
}

// optional int32 channel = 2;
inline bool ChatMsg_t::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMsg_t::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMsg_t::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMsg_t::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ChatMsg_t::channel() const {
  return channel_;
}
inline void ChatMsg_t::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional .ChatUserInfo sender = 3;
inline bool ChatMsg_t::has_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatMsg_t::set_has_sender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatMsg_t::clear_has_sender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatMsg_t::clear_sender() {
  if (sender_ != NULL) sender_->::ChatUserInfo::Clear();
  clear_has_sender();
}
inline const ::ChatUserInfo& ChatMsg_t::sender() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sender_ != NULL ? *sender_ : *default_instance().sender_;
#else
  return sender_ != NULL ? *sender_ : *default_instance_->sender_;
#endif
}
inline ::ChatUserInfo* ChatMsg_t::mutable_sender() {
  set_has_sender();
  if (sender_ == NULL) sender_ = new ::ChatUserInfo;
  return sender_;
}
inline ::ChatUserInfo* ChatMsg_t::release_sender() {
  clear_has_sender();
  ::ChatUserInfo* temp = sender_;
  sender_ = NULL;
  return temp;
}
inline void ChatMsg_t::set_allocated_sender(::ChatUserInfo* sender) {
  delete sender_;
  sender_ = sender;
  if (sender) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
}

// optional .ChatUserInfo recver = 4;
inline bool ChatMsg_t::has_recver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatMsg_t::set_has_recver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatMsg_t::clear_has_recver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatMsg_t::clear_recver() {
  if (recver_ != NULL) recver_->::ChatUserInfo::Clear();
  clear_has_recver();
}
inline const ::ChatUserInfo& ChatMsg_t::recver() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return recver_ != NULL ? *recver_ : *default_instance().recver_;
#else
  return recver_ != NULL ? *recver_ : *default_instance_->recver_;
#endif
}
inline ::ChatUserInfo* ChatMsg_t::mutable_recver() {
  set_has_recver();
  if (recver_ == NULL) recver_ = new ::ChatUserInfo;
  return recver_;
}
inline ::ChatUserInfo* ChatMsg_t::release_recver() {
  clear_has_recver();
  ::ChatUserInfo* temp = recver_;
  recver_ = NULL;
  return temp;
}
inline void ChatMsg_t::set_allocated_recver(::ChatUserInfo* recver) {
  delete recver_;
  recver_ = recver;
  if (recver) {
    set_has_recver();
  } else {
    clear_has_recver();
  }
}

// repeated string recvs = 5;
inline int ChatMsg_t::recvs_size() const {
  return recvs_.size();
}
inline void ChatMsg_t::clear_recvs() {
  recvs_.Clear();
}
inline const ::std::string& ChatMsg_t::recvs(int index) const {
  return recvs_.Get(index);
}
inline ::std::string* ChatMsg_t::mutable_recvs(int index) {
  return recvs_.Mutable(index);
}
inline void ChatMsg_t::set_recvs(int index, const ::std::string& value) {
  recvs_.Mutable(index)->assign(value);
}
inline void ChatMsg_t::set_recvs(int index, const char* value) {
  recvs_.Mutable(index)->assign(value);
}
inline void ChatMsg_t::set_recvs(int index, const char* value, size_t size) {
  recvs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatMsg_t::add_recvs() {
  return recvs_.Add();
}
inline void ChatMsg_t::add_recvs(const ::std::string& value) {
  recvs_.Add()->assign(value);
}
inline void ChatMsg_t::add_recvs(const char* value) {
  recvs_.Add()->assign(value);
}
inline void ChatMsg_t::add_recvs(const char* value, size_t size) {
  recvs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ChatMsg_t::recvs() const {
  return recvs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ChatMsg_t::mutable_recvs() {
  return &recvs_;
}

// optional int32 type = 6;
inline bool ChatMsg_t::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChatMsg_t::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChatMsg_t::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChatMsg_t::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ChatMsg_t::type() const {
  return type_;
}
inline void ChatMsg_t::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 minor = 7;
inline int ChatMsg_t::minor_size() const {
  return minor_.size();
}
inline void ChatMsg_t::clear_minor() {
  minor_.Clear();
}
inline ::google::protobuf::int32 ChatMsg_t::minor(int index) const {
  return minor_.Get(index);
}
inline void ChatMsg_t::set_minor(int index, ::google::protobuf::int32 value) {
  minor_.Set(index, value);
}
inline void ChatMsg_t::add_minor(::google::protobuf::int32 value) {
  minor_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ChatMsg_t::minor() const {
  return minor_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ChatMsg_t::mutable_minor() {
  return &minor_;
}

// -------------------------------------------------------------------

// ChatMsg

// optional string msg = 1;
inline bool ChatMsg::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMsg::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMsg::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMsg::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ChatMsg::msg() const {
  return *msg_;
}
inline void ChatMsg::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ChatMsg::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ChatMsg::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatMsg::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ChatMsg::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatMsg::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 channel = 2;
inline bool ChatMsg::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMsg::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMsg::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMsg::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ChatMsg::channel() const {
  return channel_;
}
inline void ChatMsg::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// optional .ChatUserInfo sender = 3;
inline bool ChatMsg::has_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatMsg::set_has_sender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatMsg::clear_has_sender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatMsg::clear_sender() {
  if (sender_ != NULL) sender_->::ChatUserInfo::Clear();
  clear_has_sender();
}
inline const ::ChatUserInfo& ChatMsg::sender() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sender_ != NULL ? *sender_ : *default_instance().sender_;
#else
  return sender_ != NULL ? *sender_ : *default_instance_->sender_;
#endif
}
inline ::ChatUserInfo* ChatMsg::mutable_sender() {
  set_has_sender();
  if (sender_ == NULL) sender_ = new ::ChatUserInfo;
  return sender_;
}
inline ::ChatUserInfo* ChatMsg::release_sender() {
  clear_has_sender();
  ::ChatUserInfo* temp = sender_;
  sender_ = NULL;
  return temp;
}
inline void ChatMsg::set_allocated_sender(::ChatUserInfo* sender) {
  delete sender_;
  sender_ = sender;
  if (sender) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
}

// optional .ChatUserInfo recver = 4;
inline bool ChatMsg::has_recver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatMsg::set_has_recver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatMsg::clear_has_recver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatMsg::clear_recver() {
  if (recver_ != NULL) recver_->::ChatUserInfo::Clear();
  clear_has_recver();
}
inline const ::ChatUserInfo& ChatMsg::recver() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return recver_ != NULL ? *recver_ : *default_instance().recver_;
#else
  return recver_ != NULL ? *recver_ : *default_instance_->recver_;
#endif
}
inline ::ChatUserInfo* ChatMsg::mutable_recver() {
  set_has_recver();
  if (recver_ == NULL) recver_ = new ::ChatUserInfo;
  return recver_;
}
inline ::ChatUserInfo* ChatMsg::release_recver() {
  clear_has_recver();
  ::ChatUserInfo* temp = recver_;
  recver_ = NULL;
  return temp;
}
inline void ChatMsg::set_allocated_recver(::ChatUserInfo* recver) {
  delete recver_;
  recver_ = recver;
  if (recver) {
    set_has_recver();
  } else {
    clear_has_recver();
  }
}

// repeated string recvs = 5;
inline int ChatMsg::recvs_size() const {
  return recvs_.size();
}
inline void ChatMsg::clear_recvs() {
  recvs_.Clear();
}
inline const ::std::string& ChatMsg::recvs(int index) const {
  return recvs_.Get(index);
}
inline ::std::string* ChatMsg::mutable_recvs(int index) {
  return recvs_.Mutable(index);
}
inline void ChatMsg::set_recvs(int index, const ::std::string& value) {
  recvs_.Mutable(index)->assign(value);
}
inline void ChatMsg::set_recvs(int index, const char* value) {
  recvs_.Mutable(index)->assign(value);
}
inline void ChatMsg::set_recvs(int index, const char* value, size_t size) {
  recvs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatMsg::add_recvs() {
  return recvs_.Add();
}
inline void ChatMsg::add_recvs(const ::std::string& value) {
  recvs_.Add()->assign(value);
}
inline void ChatMsg::add_recvs(const char* value) {
  recvs_.Add()->assign(value);
}
inline void ChatMsg::add_recvs(const char* value, size_t size) {
  recvs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ChatMsg::recvs() const {
  return recvs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ChatMsg::mutable_recvs() {
  return &recvs_;
}

// optional int32 type = 6;
inline bool ChatMsg::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChatMsg::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChatMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChatMsg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ChatMsg::type() const {
  return type_;
}
inline void ChatMsg::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 minor = 7;
inline int ChatMsg::minor_size() const {
  return minor_.size();
}
inline void ChatMsg::clear_minor() {
  minor_.Clear();
}
inline ::google::protobuf::int32 ChatMsg::minor(int index) const {
  return minor_.Get(index);
}
inline void ChatMsg::set_minor(int index, ::google::protobuf::int32 value) {
  minor_.Set(index, value);
}
inline void ChatMsg::add_minor(::google::protobuf::int32 value) {
  minor_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ChatMsg::minor() const {
  return minor_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ChatMsg::mutable_minor() {
  return &minor_;
}

// -------------------------------------------------------------------

// CmdClientGMReq

// required string cmd = 1;
inline bool CmdClientGMReq::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdClientGMReq::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdClientGMReq::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdClientGMReq::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& CmdClientGMReq::cmd() const {
  return *cmd_;
}
inline void CmdClientGMReq::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void CmdClientGMReq::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void CmdClientGMReq::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CmdClientGMReq::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* CmdClientGMReq::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CmdClientGMReq::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CmdClientGMResp

// required int32 result = 1;
inline bool CmdClientGMResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdClientGMResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdClientGMResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdClientGMResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CmdClientGMResp::result() const {
  return result_;
}
inline void CmdClientGMResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool CmdClientGMResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdClientGMResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdClientGMResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdClientGMResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& CmdClientGMResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* CmdClientGMResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* CmdClientGMResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void CmdClientGMResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// CmdGetOtherUserInfoReq

// required string user_name = 1;
inline bool CmdGetOtherUserInfoReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdGetOtherUserInfoReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdGetOtherUserInfoReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdGetOtherUserInfoReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& CmdGetOtherUserInfoReq::user_name() const {
  return *user_name_;
}
inline void CmdGetOtherUserInfoReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void CmdGetOtherUserInfoReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void CmdGetOtherUserInfoReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CmdGetOtherUserInfoReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* CmdGetOtherUserInfoReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CmdGetOtherUserInfoReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 sid = 2;
inline bool CmdGetOtherUserInfoReq::has_sid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdGetOtherUserInfoReq::set_has_sid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdGetOtherUserInfoReq::clear_has_sid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdGetOtherUserInfoReq::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 CmdGetOtherUserInfoReq::sid() const {
  return sid_;
}
inline void CmdGetOtherUserInfoReq::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
}

// repeated int32 lineup = 3;
inline int CmdGetOtherUserInfoReq::lineup_size() const {
  return lineup_.size();
}
inline void CmdGetOtherUserInfoReq::clear_lineup() {
  lineup_.Clear();
}
inline ::google::protobuf::int32 CmdGetOtherUserInfoReq::lineup(int index) const {
  return lineup_.Get(index);
}
inline void CmdGetOtherUserInfoReq::set_lineup(int index, ::google::protobuf::int32 value) {
  lineup_.Set(index, value);
}
inline void CmdGetOtherUserInfoReq::add_lineup(::google::protobuf::int32 value) {
  lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CmdGetOtherUserInfoReq::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CmdGetOtherUserInfoReq::mutable_lineup() {
  return &lineup_;
}

// -------------------------------------------------------------------

// CmdGetOtherUserInfoResp

// required int32 result = 1;
inline bool CmdGetOtherUserInfoResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdGetOtherUserInfoResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdGetOtherUserInfoResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdGetOtherUserInfoResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CmdGetOtherUserInfoResp::result() const {
  return result_;
}
inline void CmdGetOtherUserInfoResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 type = 2;
inline bool CmdGetOtherUserInfoResp::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdGetOtherUserInfoResp::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdGetOtherUserInfoResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdGetOtherUserInfoResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CmdGetOtherUserInfoResp::type() const {
  return type_;
}
inline void CmdGetOtherUserInfoResp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional .OtherUserInfo info = 3;
inline bool CmdGetOtherUserInfoResp::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CmdGetOtherUserInfoResp::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CmdGetOtherUserInfoResp::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CmdGetOtherUserInfoResp::clear_info() {
  if (info_ != NULL) info_->::OtherUserInfo::Clear();
  clear_has_info();
}
inline const ::OtherUserInfo& CmdGetOtherUserInfoResp::info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return info_ != NULL ? *info_ : *default_instance().info_;
#else
  return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
}
inline ::OtherUserInfo* CmdGetOtherUserInfoResp::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::OtherUserInfo;
  return info_;
}
inline ::OtherUserInfo* CmdGetOtherUserInfoResp::release_info() {
  clear_has_info();
  ::OtherUserInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void CmdGetOtherUserInfoResp::set_allocated_info(::OtherUserInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// CmdGetOtherUserInfoListReq

// repeated string user_name_list = 1;
inline int CmdGetOtherUserInfoListReq::user_name_list_size() const {
  return user_name_list_.size();
}
inline void CmdGetOtherUserInfoListReq::clear_user_name_list() {
  user_name_list_.Clear();
}
inline const ::std::string& CmdGetOtherUserInfoListReq::user_name_list(int index) const {
  return user_name_list_.Get(index);
}
inline ::std::string* CmdGetOtherUserInfoListReq::mutable_user_name_list(int index) {
  return user_name_list_.Mutable(index);
}
inline void CmdGetOtherUserInfoListReq::set_user_name_list(int index, const ::std::string& value) {
  user_name_list_.Mutable(index)->assign(value);
}
inline void CmdGetOtherUserInfoListReq::set_user_name_list(int index, const char* value) {
  user_name_list_.Mutable(index)->assign(value);
}
inline void CmdGetOtherUserInfoListReq::set_user_name_list(int index, const char* value, size_t size) {
  user_name_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CmdGetOtherUserInfoListReq::add_user_name_list() {
  return user_name_list_.Add();
}
inline void CmdGetOtherUserInfoListReq::add_user_name_list(const ::std::string& value) {
  user_name_list_.Add()->assign(value);
}
inline void CmdGetOtherUserInfoListReq::add_user_name_list(const char* value) {
  user_name_list_.Add()->assign(value);
}
inline void CmdGetOtherUserInfoListReq::add_user_name_list(const char* value, size_t size) {
  user_name_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CmdGetOtherUserInfoListReq::user_name_list() const {
  return user_name_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CmdGetOtherUserInfoListReq::mutable_user_name_list() {
  return &user_name_list_;
}

// required int32 sid = 2;
inline bool CmdGetOtherUserInfoListReq::has_sid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdGetOtherUserInfoListReq::set_has_sid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdGetOtherUserInfoListReq::clear_has_sid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdGetOtherUserInfoListReq::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 CmdGetOtherUserInfoListReq::sid() const {
  return sid_;
}
inline void CmdGetOtherUserInfoListReq::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
}

// -------------------------------------------------------------------

// CmdGetOtherUserInfoListResp

// required int32 result = 1;
inline bool CmdGetOtherUserInfoListResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdGetOtherUserInfoListResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdGetOtherUserInfoListResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdGetOtherUserInfoListResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CmdGetOtherUserInfoListResp::result() const {
  return result_;
}
inline void CmdGetOtherUserInfoListResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 type = 2;
inline bool CmdGetOtherUserInfoListResp::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdGetOtherUserInfoListResp::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdGetOtherUserInfoListResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdGetOtherUserInfoListResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CmdGetOtherUserInfoListResp::type() const {
  return type_;
}
inline void CmdGetOtherUserInfoListResp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated .OtherUserInfo info_list = 3;
inline int CmdGetOtherUserInfoListResp::info_list_size() const {
  return info_list_.size();
}
inline void CmdGetOtherUserInfoListResp::clear_info_list() {
  info_list_.Clear();
}
inline const ::OtherUserInfo& CmdGetOtherUserInfoListResp::info_list(int index) const {
  return info_list_.Get(index);
}
inline ::OtherUserInfo* CmdGetOtherUserInfoListResp::mutable_info_list(int index) {
  return info_list_.Mutable(index);
}
inline ::OtherUserInfo* CmdGetOtherUserInfoListResp::add_info_list() {
  return info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >&
CmdGetOtherUserInfoListResp::info_list() const {
  return info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >*
CmdGetOtherUserInfoListResp::mutable_info_list() {
  return &info_list_;
}

// -------------------------------------------------------------------

// NewFriendUpdate

// required string sender = 1;
inline bool NewFriendUpdate::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewFriendUpdate::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewFriendUpdate::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewFriendUpdate::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& NewFriendUpdate::sender() const {
  return *sender_;
}
inline void NewFriendUpdate::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void NewFriendUpdate::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void NewFriendUpdate::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewFriendUpdate::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* NewFriendUpdate::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewFriendUpdate::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BeFriendUpdate

// required int32 result = 1;
inline bool BeFriendUpdate::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BeFriendUpdate::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BeFriendUpdate::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BeFriendUpdate::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BeFriendUpdate::result() const {
  return result_;
}
inline void BeFriendUpdate::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// GetFriendsInfoReq

// required int32 type = 1;
inline bool GetFriendsInfoReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFriendsInfoReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFriendsInfoReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFriendsInfoReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GetFriendsInfoReq::type() const {
  return type_;
}
inline void GetFriendsInfoReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 index = 2;
inline bool GetFriendsInfoReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFriendsInfoReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFriendsInfoReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFriendsInfoReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 GetFriendsInfoReq::index() const {
  return index_;
}
inline void GetFriendsInfoReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional int32 num = 3;
inline bool GetFriendsInfoReq::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetFriendsInfoReq::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetFriendsInfoReq::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetFriendsInfoReq::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 GetFriendsInfoReq::num() const {
  return num_;
}
inline void GetFriendsInfoReq::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional string nickname = 4;
inline bool GetFriendsInfoReq::has_nickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetFriendsInfoReq::set_has_nickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetFriendsInfoReq::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetFriendsInfoReq::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& GetFriendsInfoReq::nickname() const {
  return *nickname_;
}
inline void GetFriendsInfoReq::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void GetFriendsInfoReq::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void GetFriendsInfoReq::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetFriendsInfoReq::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* GetFriendsInfoReq::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetFriendsInfoReq::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetFriendsInfoResp

// required int32 result = 1;
inline bool GetFriendsInfoResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFriendsInfoResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFriendsInfoResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFriendsInfoResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GetFriendsInfoResp::result() const {
  return result_;
}
inline void GetFriendsInfoResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required int32 type = 2;
inline bool GetFriendsInfoResp::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetFriendsInfoResp::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetFriendsInfoResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetFriendsInfoResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GetFriendsInfoResp::type() const {
  return type_;
}
inline void GetFriendsInfoResp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated .OtherUserInfo list = 3;
inline int GetFriendsInfoResp::list_size() const {
  return list_.size();
}
inline void GetFriendsInfoResp::clear_list() {
  list_.Clear();
}
inline const ::OtherUserInfo& GetFriendsInfoResp::list(int index) const {
  return list_.Get(index);
}
inline ::OtherUserInfo* GetFriendsInfoResp::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::OtherUserInfo* GetFriendsInfoResp::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >&
GetFriendsInfoResp::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >*
GetFriendsInfoResp::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// ApplyFriendReq

// required string recver = 1;
inline bool ApplyFriendReq::has_recver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyFriendReq::set_has_recver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyFriendReq::clear_has_recver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyFriendReq::clear_recver() {
  if (recver_ != &::google::protobuf::internal::kEmptyString) {
    recver_->clear();
  }
  clear_has_recver();
}
inline const ::std::string& ApplyFriendReq::recver() const {
  return *recver_;
}
inline void ApplyFriendReq::set_recver(const ::std::string& value) {
  set_has_recver();
  if (recver_ == &::google::protobuf::internal::kEmptyString) {
    recver_ = new ::std::string;
  }
  recver_->assign(value);
}
inline void ApplyFriendReq::set_recver(const char* value) {
  set_has_recver();
  if (recver_ == &::google::protobuf::internal::kEmptyString) {
    recver_ = new ::std::string;
  }
  recver_->assign(value);
}
inline void ApplyFriendReq::set_recver(const char* value, size_t size) {
  set_has_recver();
  if (recver_ == &::google::protobuf::internal::kEmptyString) {
    recver_ = new ::std::string;
  }
  recver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplyFriendReq::mutable_recver() {
  set_has_recver();
  if (recver_ == &::google::protobuf::internal::kEmptyString) {
    recver_ = new ::std::string;
  }
  return recver_;
}
inline ::std::string* ApplyFriendReq::release_recver() {
  clear_has_recver();
  if (recver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recver_;
    recver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApplyFriendReq::set_allocated_recver(::std::string* recver) {
  if (recver_ != &::google::protobuf::internal::kEmptyString) {
    delete recver_;
  }
  if (recver) {
    set_has_recver();
    recver_ = recver;
  } else {
    clear_has_recver();
    recver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ApplyFriendResp

// required .ApplyFriendResp.ApplyFriendRet result = 1;
inline bool ApplyFriendResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyFriendResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyFriendResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyFriendResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::ApplyFriendResp_ApplyFriendRet ApplyFriendResp::result() const {
  return static_cast< ::ApplyFriendResp_ApplyFriendRet >(result_);
}
inline void ApplyFriendResp::set_result(::ApplyFriendResp_ApplyFriendRet value) {
  assert(::ApplyFriendResp_ApplyFriendRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// AcceptFriendReq

// required string sender = 1;
inline bool AcceptFriendReq::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptFriendReq::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptFriendReq::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptFriendReq::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& AcceptFriendReq::sender() const {
  return *sender_;
}
inline void AcceptFriendReq::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void AcceptFriendReq::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void AcceptFriendReq::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptFriendReq::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* AcceptFriendReq::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcceptFriendReq::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 mail_guid = 2;
inline bool AcceptFriendReq::has_mail_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcceptFriendReq::set_has_mail_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcceptFriendReq::clear_has_mail_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcceptFriendReq::clear_mail_guid() {
  mail_guid_ = 0;
  clear_has_mail_guid();
}
inline ::google::protobuf::int32 AcceptFriendReq::mail_guid() const {
  return mail_guid_;
}
inline void AcceptFriendReq::set_mail_guid(::google::protobuf::int32 value) {
  set_has_mail_guid();
  mail_guid_ = value;
}

// -------------------------------------------------------------------

// AcceptFriendResp

// required .AcceptFriendResp.AcceptFriendRet result = 1;
inline bool AcceptFriendResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptFriendResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptFriendResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptFriendResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::AcceptFriendResp_AcceptFriendRet AcceptFriendResp::result() const {
  return static_cast< ::AcceptFriendResp_AcceptFriendRet >(result_);
}
inline void AcceptFriendResp::set_result(::AcceptFriendResp_AcceptFriendRet value) {
  assert(::AcceptFriendResp_AcceptFriendRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RemoveFriendReq

// required string user_name = 1;
inline bool RemoveFriendReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveFriendReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveFriendReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveFriendReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& RemoveFriendReq::user_name() const {
  return *user_name_;
}
inline void RemoveFriendReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void RemoveFriendReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void RemoveFriendReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFriendReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* RemoveFriendReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoveFriendReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RemoveFriendResp

// required int32 result = 1;
inline bool RemoveFriendResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveFriendResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveFriendResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveFriendResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RemoveFriendResp::result() const {
  return result_;
}
inline void RemoveFriendResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// FriendAddTiliReq

// required string user_name = 1;
inline bool FriendAddTiliReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendAddTiliReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendAddTiliReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendAddTiliReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& FriendAddTiliReq::user_name() const {
  return *user_name_;
}
inline void FriendAddTiliReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void FriendAddTiliReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void FriendAddTiliReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendAddTiliReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* FriendAddTiliReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendAddTiliReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FriendAddTiliResp

// required int32 result = 1;
inline bool FriendAddTiliResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendAddTiliResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendAddTiliResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendAddTiliResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 FriendAddTiliResp::result() const {
  return result_;
}
inline void FriendAddTiliResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool FriendAddTiliResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendAddTiliResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendAddTiliResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendAddTiliResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& FriendAddTiliResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* FriendAddTiliResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* FriendAddTiliResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void FriendAddTiliResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// FriendAddTiliUpdate

// required int32 result = 1;
inline bool FriendAddTiliUpdate::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendAddTiliUpdate::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendAddTiliUpdate::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendAddTiliUpdate::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 FriendAddTiliUpdate::result() const {
  return result_;
}
inline void FriendAddTiliUpdate::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required .OtherUserInfo info = 2;
inline bool FriendAddTiliUpdate::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendAddTiliUpdate::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendAddTiliUpdate::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendAddTiliUpdate::clear_info() {
  if (info_ != NULL) info_->::OtherUserInfo::Clear();
  clear_has_info();
}
inline const ::OtherUserInfo& FriendAddTiliUpdate::info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return info_ != NULL ? *info_ : *default_instance().info_;
#else
  return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
}
inline ::OtherUserInfo* FriendAddTiliUpdate::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::OtherUserInfo;
  return info_;
}
inline ::OtherUserInfo* FriendAddTiliUpdate::release_info() {
  clear_has_info();
  ::OtherUserInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void FriendAddTiliUpdate::set_allocated_info(::OtherUserInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// FriendReadTiliReq

// repeated string user_name = 1;
inline int FriendReadTiliReq::user_name_size() const {
  return user_name_.size();
}
inline void FriendReadTiliReq::clear_user_name() {
  user_name_.Clear();
}
inline const ::std::string& FriendReadTiliReq::user_name(int index) const {
  return user_name_.Get(index);
}
inline ::std::string* FriendReadTiliReq::mutable_user_name(int index) {
  return user_name_.Mutable(index);
}
inline void FriendReadTiliReq::set_user_name(int index, const ::std::string& value) {
  user_name_.Mutable(index)->assign(value);
}
inline void FriendReadTiliReq::set_user_name(int index, const char* value) {
  user_name_.Mutable(index)->assign(value);
}
inline void FriendReadTiliReq::set_user_name(int index, const char* value, size_t size) {
  user_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendReadTiliReq::add_user_name() {
  return user_name_.Add();
}
inline void FriendReadTiliReq::add_user_name(const ::std::string& value) {
  user_name_.Add()->assign(value);
}
inline void FriendReadTiliReq::add_user_name(const char* value) {
  user_name_.Add()->assign(value);
}
inline void FriendReadTiliReq::add_user_name(const char* value, size_t size) {
  user_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FriendReadTiliReq::user_name() const {
  return user_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FriendReadTiliReq::mutable_user_name() {
  return &user_name_;
}

// -------------------------------------------------------------------

// FriendReadTiliResp

// required int32 result = 1;
inline bool FriendReadTiliResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendReadTiliResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendReadTiliResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendReadTiliResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 FriendReadTiliResp::result() const {
  return result_;
}
inline void FriendReadTiliResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool FriendReadTiliResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendReadTiliResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendReadTiliResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendReadTiliResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& FriendReadTiliResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* FriendReadTiliResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* FriendReadTiliResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void FriendReadTiliResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 all_tili = 3;
inline bool FriendReadTiliResp::has_all_tili() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendReadTiliResp::set_has_all_tili() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendReadTiliResp::clear_has_all_tili() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendReadTiliResp::clear_all_tili() {
  all_tili_ = 0;
  clear_has_all_tili();
}
inline ::google::protobuf::int32 FriendReadTiliResp::all_tili() const {
  return all_tili_;
}
inline void FriendReadTiliResp::set_all_tili(::google::protobuf::int32 value) {
  set_has_all_tili();
  all_tili_ = value;
}

// -------------------------------------------------------------------

// BlackListReq

// required int32 type = 1;
inline bool BlackListReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlackListReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlackListReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlackListReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BlackListReq::type() const {
  return type_;
}
inline void BlackListReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string user_name = 2;
inline bool BlackListReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlackListReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlackListReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlackListReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& BlackListReq::user_name() const {
  return *user_name_;
}
inline void BlackListReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void BlackListReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void BlackListReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlackListReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* BlackListReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlackListReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BlackListResp

// required int32 result = 1;
inline bool BlackListResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlackListResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlackListResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlackListResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BlackListResp::result() const {
  return result_;
}
inline void BlackListResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// TalkListReq

// required int32 type = 1;
inline bool TalkListReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TalkListReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TalkListReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TalkListReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 TalkListReq::type() const {
  return type_;
}
inline void TalkListReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string user_name = 2;
inline bool TalkListReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TalkListReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TalkListReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TalkListReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& TalkListReq::user_name() const {
  return *user_name_;
}
inline void TalkListReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TalkListReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void TalkListReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TalkListReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* TalkListReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TalkListReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TalkListResp

// required int32 result = 1;
inline bool TalkListResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TalkListResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TalkListResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TalkListResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 TalkListResp::result() const {
  return result_;
}
inline void TalkListResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// TaskListResp

// required int32 result = 1;
inline bool TaskListResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskListResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskListResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskListResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 TaskListResp::result() const {
  return result_;
}
inline void TaskListResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool TaskListResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskListResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskListResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskListResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& TaskListResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* TaskListResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* TaskListResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void TaskListResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .TaskInfo task_list = 3;
inline int TaskListResp::task_list_size() const {
  return task_list_.size();
}
inline void TaskListResp::clear_task_list() {
  task_list_.Clear();
}
inline const ::TaskInfo& TaskListResp::task_list(int index) const {
  return task_list_.Get(index);
}
inline ::TaskInfo* TaskListResp::mutable_task_list(int index) {
  return task_list_.Mutable(index);
}
inline ::TaskInfo* TaskListResp::add_task_list() {
  return task_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TaskInfo >&
TaskListResp::task_list() const {
  return task_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::TaskInfo >*
TaskListResp::mutable_task_list() {
  return &task_list_;
}

// -------------------------------------------------------------------

// TaskRewardReq

// required int32 task_id = 1;
inline bool TaskRewardReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskRewardReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskRewardReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskRewardReq::clear_task_id() {
  task_id_ = 0;
  clear_has_task_id();
}
inline ::google::protobuf::int32 TaskRewardReq::task_id() const {
  return task_id_;
}
inline void TaskRewardReq::set_task_id(::google::protobuf::int32 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional int32 other = 2;
inline bool TaskRewardReq::has_other() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskRewardReq::set_has_other() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskRewardReq::clear_has_other() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskRewardReq::clear_other() {
  other_ = 0;
  clear_has_other();
}
inline ::google::protobuf::int32 TaskRewardReq::other() const {
  return other_;
}
inline void TaskRewardReq::set_other(::google::protobuf::int32 value) {
  set_has_other();
  other_ = value;
}

// -------------------------------------------------------------------

// TaskRewardResp

// required int32 result = 1;
inline bool TaskRewardResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskRewardResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskRewardResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskRewardResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 TaskRewardResp::result() const {
  return result_;
}
inline void TaskRewardResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool TaskRewardResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskRewardResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskRewardResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskRewardResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& TaskRewardResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* TaskRewardResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* TaskRewardResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void TaskRewardResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 task_id = 3;
inline bool TaskRewardResp::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskRewardResp::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskRewardResp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskRewardResp::clear_task_id() {
  task_id_ = 0;
  clear_has_task_id();
}
inline ::google::protobuf::int32 TaskRewardResp::task_id() const {
  return task_id_;
}
inline void TaskRewardResp::set_task_id(::google::protobuf::int32 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional int32 other = 4;
inline bool TaskRewardResp::has_other() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskRewardResp::set_has_other() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskRewardResp::clear_has_other() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskRewardResp::clear_other() {
  other_ = 0;
  clear_has_other();
}
inline ::google::protobuf::int32 TaskRewardResp::other() const {
  return other_;
}
inline void TaskRewardResp::set_other(::google::protobuf::int32 value) {
  set_has_other();
  other_ = value;
}

// -------------------------------------------------------------------

// GetStrengthResp

// required int32 result = 1;
inline bool GetStrengthResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStrengthResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStrengthResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStrengthResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GetStrengthResp::result() const {
  return result_;
}
inline void GetStrengthResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GetStrengthResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetStrengthResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetStrengthResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetStrengthResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GetStrengthResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* GetStrengthResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GetStrengthResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GetStrengthResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// AddStrengthReq

// required int32 type = 1;
inline bool AddStrengthReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddStrengthReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddStrengthReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddStrengthReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AddStrengthReq::type() const {
  return type_;
}
inline void AddStrengthReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional .Pair item = 2;
inline bool AddStrengthReq::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddStrengthReq::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddStrengthReq::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddStrengthReq::clear_item() {
  if (item_ != NULL) item_->::Pair::Clear();
  clear_has_item();
}
inline const ::Pair& AddStrengthReq::item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::Pair* AddStrengthReq::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::Pair;
  return item_;
}
inline ::Pair* AddStrengthReq::release_item() {
  clear_has_item();
  ::Pair* temp = item_;
  item_ = NULL;
  return temp;
}
inline void AddStrengthReq::set_allocated_item(::Pair* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// AddStrengthResp

// required .AddStrengthResp.AddStrengthRet result = 1;
inline bool AddStrengthResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddStrengthResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddStrengthResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddStrengthResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::AddStrengthResp_AddStrengthRet AddStrengthResp::result() const {
  return static_cast< ::AddStrengthResp_AddStrengthRet >(result_);
}
inline void AddStrengthResp::set_result(::AddStrengthResp_AddStrengthRet value) {
  assert(::AddStrengthResp_AddStrengthRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool AddStrengthResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddStrengthResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddStrengthResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddStrengthResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& AddStrengthResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* AddStrengthResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* AddStrengthResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void AddStrengthResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// RankReq

// required .RankReq.RankType rank_type = 1;
inline bool RankReq::has_rank_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RankReq::set_has_rank_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RankReq::clear_has_rank_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RankReq::clear_rank_type() {
  rank_type_ = 1;
  clear_has_rank_type();
}
inline ::RankReq_RankType RankReq::rank_type() const {
  return static_cast< ::RankReq_RankType >(rank_type_);
}
inline void RankReq::set_rank_type(::RankReq_RankType value) {
  assert(::RankReq_RankType_IsValid(value));
  set_has_rank_type();
  rank_type_ = value;
}

// required int32 start_rank = 2;
inline bool RankReq::has_start_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RankReq::set_has_start_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RankReq::clear_has_start_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RankReq::clear_start_rank() {
  start_rank_ = 0;
  clear_has_start_rank();
}
inline ::google::protobuf::int32 RankReq::start_rank() const {
  return start_rank_;
}
inline void RankReq::set_start_rank(::google::protobuf::int32 value) {
  set_has_start_rank();
  start_rank_ = value;
}

// required bool need_my = 3;
inline bool RankReq::has_need_my() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RankReq::set_has_need_my() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RankReq::clear_has_need_my() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RankReq::clear_need_my() {
  need_my_ = false;
  clear_has_need_my();
}
inline bool RankReq::need_my() const {
  return need_my_;
}
inline void RankReq::set_need_my(bool value) {
  set_has_need_my();
  need_my_ = value;
}

// -------------------------------------------------------------------

// RankResp

// required int32 result = 1;
inline bool RankResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RankResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RankResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RankResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RankResp::result() const {
  return result_;
}
inline void RankResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool RankResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RankResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RankResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RankResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& RankResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* RankResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* RankResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void RankResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .OtherUserInfo user_rank = 3;
inline int RankResp::user_rank_size() const {
  return user_rank_.size();
}
inline void RankResp::clear_user_rank() {
  user_rank_.Clear();
}
inline const ::OtherUserInfo& RankResp::user_rank(int index) const {
  return user_rank_.Get(index);
}
inline ::OtherUserInfo* RankResp::mutable_user_rank(int index) {
  return user_rank_.Mutable(index);
}
inline ::OtherUserInfo* RankResp::add_user_rank() {
  return user_rank_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >&
RankResp::user_rank() const {
  return user_rank_;
}
inline ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >*
RankResp::mutable_user_rank() {
  return &user_rank_;
}

// repeated .OtherGroupInfo group_rank = 4;
inline int RankResp::group_rank_size() const {
  return group_rank_.size();
}
inline void RankResp::clear_group_rank() {
  group_rank_.Clear();
}
inline const ::OtherGroupInfo& RankResp::group_rank(int index) const {
  return group_rank_.Get(index);
}
inline ::OtherGroupInfo* RankResp::mutable_group_rank(int index) {
  return group_rank_.Mutable(index);
}
inline ::OtherGroupInfo* RankResp::add_group_rank() {
  return group_rank_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OtherGroupInfo >&
RankResp::group_rank() const {
  return group_rank_;
}
inline ::google::protobuf::RepeatedPtrField< ::OtherGroupInfo >*
RankResp::mutable_group_rank() {
  return &group_rank_;
}

// optional .OtherUserInfo my_user_rank = 5;
inline bool RankResp::has_my_user_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RankResp::set_has_my_user_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RankResp::clear_has_my_user_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RankResp::clear_my_user_rank() {
  if (my_user_rank_ != NULL) my_user_rank_->::OtherUserInfo::Clear();
  clear_has_my_user_rank();
}
inline const ::OtherUserInfo& RankResp::my_user_rank() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return my_user_rank_ != NULL ? *my_user_rank_ : *default_instance().my_user_rank_;
#else
  return my_user_rank_ != NULL ? *my_user_rank_ : *default_instance_->my_user_rank_;
#endif
}
inline ::OtherUserInfo* RankResp::mutable_my_user_rank() {
  set_has_my_user_rank();
  if (my_user_rank_ == NULL) my_user_rank_ = new ::OtherUserInfo;
  return my_user_rank_;
}
inline ::OtherUserInfo* RankResp::release_my_user_rank() {
  clear_has_my_user_rank();
  ::OtherUserInfo* temp = my_user_rank_;
  my_user_rank_ = NULL;
  return temp;
}
inline void RankResp::set_allocated_my_user_rank(::OtherUserInfo* my_user_rank) {
  delete my_user_rank_;
  my_user_rank_ = my_user_rank;
  if (my_user_rank) {
    set_has_my_user_rank();
  } else {
    clear_has_my_user_rank();
  }
}

// optional .OtherGroupInfo my_group_rank = 6;
inline bool RankResp::has_my_group_rank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RankResp::set_has_my_group_rank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RankResp::clear_has_my_group_rank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RankResp::clear_my_group_rank() {
  if (my_group_rank_ != NULL) my_group_rank_->::OtherGroupInfo::Clear();
  clear_has_my_group_rank();
}
inline const ::OtherGroupInfo& RankResp::my_group_rank() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return my_group_rank_ != NULL ? *my_group_rank_ : *default_instance().my_group_rank_;
#else
  return my_group_rank_ != NULL ? *my_group_rank_ : *default_instance_->my_group_rank_;
#endif
}
inline ::OtherGroupInfo* RankResp::mutable_my_group_rank() {
  set_has_my_group_rank();
  if (my_group_rank_ == NULL) my_group_rank_ = new ::OtherGroupInfo;
  return my_group_rank_;
}
inline ::OtherGroupInfo* RankResp::release_my_group_rank() {
  clear_has_my_group_rank();
  ::OtherGroupInfo* temp = my_group_rank_;
  my_group_rank_ = NULL;
  return temp;
}
inline void RankResp::set_allocated_my_group_rank(::OtherGroupInfo* my_group_rank) {
  delete my_group_rank_;
  my_group_rank_ = my_group_rank;
  if (my_group_rank) {
    set_has_my_group_rank();
  } else {
    clear_has_my_group_rank();
  }
}

// -------------------------------------------------------------------

// ShopTimeItemListResp_TimeItem

// required int32 id = 1;
inline bool ShopTimeItemListResp_TimeItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShopTimeItemListResp_TimeItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShopTimeItemListResp_TimeItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShopTimeItemListResp_TimeItem::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ShopTimeItemListResp_TimeItem::id() const {
  return id_;
}
inline void ShopTimeItemListResp_TimeItem::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int64 end_time = 2;
inline bool ShopTimeItemListResp_TimeItem::has_end_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShopTimeItemListResp_TimeItem::set_has_end_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShopTimeItemListResp_TimeItem::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShopTimeItemListResp_TimeItem::clear_end_time() {
  end_time_ = GOOGLE_LONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::int64 ShopTimeItemListResp_TimeItem::end_time() const {
  return end_time_;
}
inline void ShopTimeItemListResp_TimeItem::set_end_time(::google::protobuf::int64 value) {
  set_has_end_time();
  end_time_ = value;
}

// -------------------------------------------------------------------

// ShopTimeItemListResp

// required int32 result = 1;
inline bool ShopTimeItemListResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShopTimeItemListResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShopTimeItemListResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShopTimeItemListResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ShopTimeItemListResp::result() const {
  return result_;
}
inline void ShopTimeItemListResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ShopTimeItemListResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShopTimeItemListResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShopTimeItemListResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShopTimeItemListResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ShopTimeItemListResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ShopTimeItemListResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ShopTimeItemListResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ShopTimeItemListResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .ShopTimeItemListResp.TimeItem list = 3;
inline int ShopTimeItemListResp::list_size() const {
  return list_.size();
}
inline void ShopTimeItemListResp::clear_list() {
  list_.Clear();
}
inline const ::ShopTimeItemListResp_TimeItem& ShopTimeItemListResp::list(int index) const {
  return list_.Get(index);
}
inline ::ShopTimeItemListResp_TimeItem* ShopTimeItemListResp::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::ShopTimeItemListResp_TimeItem* ShopTimeItemListResp::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShopTimeItemListResp_TimeItem >&
ShopTimeItemListResp::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ShopTimeItemListResp_TimeItem >*
ShopTimeItemListResp::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// ShopBuyReq

// required int32 id = 1;
inline bool ShopBuyReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShopBuyReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShopBuyReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShopBuyReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ShopBuyReq::id() const {
  return id_;
}
inline void ShopBuyReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 num = 2;
inline bool ShopBuyReq::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShopBuyReq::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShopBuyReq::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShopBuyReq::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ShopBuyReq::num() const {
  return num_;
}
inline void ShopBuyReq::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// ShopBuyResp

// required int32 result = 1;
inline bool ShopBuyResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShopBuyResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShopBuyResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShopBuyResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ShopBuyResp::result() const {
  return result_;
}
inline void ShopBuyResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ShopBuyResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShopBuyResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShopBuyResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShopBuyResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ShopBuyResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ShopBuyResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ShopBuyResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ShopBuyResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .ShopBuyReq req = 3;
inline bool ShopBuyResp::has_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShopBuyResp::set_has_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShopBuyResp::clear_has_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShopBuyResp::clear_req() {
  if (req_ != NULL) req_->::ShopBuyReq::Clear();
  clear_has_req();
}
inline const ::ShopBuyReq& ShopBuyResp::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::ShopBuyReq* ShopBuyResp::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::ShopBuyReq;
  return req_;
}
inline ::ShopBuyReq* ShopBuyResp::release_req() {
  clear_has_req();
  ::ShopBuyReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void ShopBuyResp::set_allocated_req(::ShopBuyReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// -------------------------------------------------------------------

// ShipLotteryReq

// required int32 id = 1;
inline bool ShipLotteryReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipLotteryReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipLotteryReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipLotteryReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ShipLotteryReq::id() const {
  return id_;
}
inline void ShipLotteryReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 type = 2;
inline bool ShipLotteryReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipLotteryReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipLotteryReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipLotteryReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ShipLotteryReq::type() const {
  return type_;
}
inline void ShipLotteryReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ShipLotteryResp

// required int32 result = 1;
inline bool ShipLotteryResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipLotteryResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipLotteryResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipLotteryResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ShipLotteryResp::result() const {
  return result_;
}
inline void ShipLotteryResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ShipLotteryResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipLotteryResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipLotteryResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipLotteryResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ShipLotteryResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ShipLotteryResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ShipLotteryResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ShipLotteryResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .Item item_list = 3;
inline int ShipLotteryResp::item_list_size() const {
  return item_list_.size();
}
inline void ShipLotteryResp::clear_item_list() {
  item_list_.Clear();
}
inline const ::Item& ShipLotteryResp::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::Item* ShipLotteryResp::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::Item* ShipLotteryResp::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Item >&
ShipLotteryResp::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Item >*
ShipLotteryResp::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// IsOnlineReq

// repeated string user_name_list = 1;
inline int IsOnlineReq::user_name_list_size() const {
  return user_name_list_.size();
}
inline void IsOnlineReq::clear_user_name_list() {
  user_name_list_.Clear();
}
inline const ::std::string& IsOnlineReq::user_name_list(int index) const {
  return user_name_list_.Get(index);
}
inline ::std::string* IsOnlineReq::mutable_user_name_list(int index) {
  return user_name_list_.Mutable(index);
}
inline void IsOnlineReq::set_user_name_list(int index, const ::std::string& value) {
  user_name_list_.Mutable(index)->assign(value);
}
inline void IsOnlineReq::set_user_name_list(int index, const char* value) {
  user_name_list_.Mutable(index)->assign(value);
}
inline void IsOnlineReq::set_user_name_list(int index, const char* value, size_t size) {
  user_name_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsOnlineReq::add_user_name_list() {
  return user_name_list_.Add();
}
inline void IsOnlineReq::add_user_name_list(const ::std::string& value) {
  user_name_list_.Add()->assign(value);
}
inline void IsOnlineReq::add_user_name_list(const char* value) {
  user_name_list_.Add()->assign(value);
}
inline void IsOnlineReq::add_user_name_list(const char* value, size_t size) {
  user_name_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IsOnlineReq::user_name_list() const {
  return user_name_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IsOnlineReq::mutable_user_name_list() {
  return &user_name_list_;
}

// -------------------------------------------------------------------

// IsOnlineResp

// required int32 result = 1;
inline bool IsOnlineResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsOnlineResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsOnlineResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsOnlineResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 IsOnlineResp::result() const {
  return result_;
}
inline void IsOnlineResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool IsOnlineResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IsOnlineResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IsOnlineResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IsOnlineResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& IsOnlineResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* IsOnlineResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* IsOnlineResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void IsOnlineResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated string user_name_list = 3;
inline int IsOnlineResp::user_name_list_size() const {
  return user_name_list_.size();
}
inline void IsOnlineResp::clear_user_name_list() {
  user_name_list_.Clear();
}
inline const ::std::string& IsOnlineResp::user_name_list(int index) const {
  return user_name_list_.Get(index);
}
inline ::std::string* IsOnlineResp::mutable_user_name_list(int index) {
  return user_name_list_.Mutable(index);
}
inline void IsOnlineResp::set_user_name_list(int index, const ::std::string& value) {
  user_name_list_.Mutable(index)->assign(value);
}
inline void IsOnlineResp::set_user_name_list(int index, const char* value) {
  user_name_list_.Mutable(index)->assign(value);
}
inline void IsOnlineResp::set_user_name_list(int index, const char* value, size_t size) {
  user_name_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsOnlineResp::add_user_name_list() {
  return user_name_list_.Add();
}
inline void IsOnlineResp::add_user_name_list(const ::std::string& value) {
  user_name_list_.Add()->assign(value);
}
inline void IsOnlineResp::add_user_name_list(const char* value) {
  user_name_list_.Add()->assign(value);
}
inline void IsOnlineResp::add_user_name_list(const char* value, size_t size) {
  user_name_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IsOnlineResp::user_name_list() const {
  return user_name_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IsOnlineResp::mutable_user_name_list() {
  return &user_name_list_;
}

// repeated bool is_online_list = 4;
inline int IsOnlineResp::is_online_list_size() const {
  return is_online_list_.size();
}
inline void IsOnlineResp::clear_is_online_list() {
  is_online_list_.Clear();
}
inline bool IsOnlineResp::is_online_list(int index) const {
  return is_online_list_.Get(index);
}
inline void IsOnlineResp::set_is_online_list(int index, bool value) {
  is_online_list_.Set(index, value);
}
inline void IsOnlineResp::add_is_online_list(bool value) {
  is_online_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
IsOnlineResp::is_online_list() const {
  return is_online_list_;
}
inline ::google::protobuf::RepeatedField< bool >*
IsOnlineResp::mutable_is_online_list() {
  return &is_online_list_;
}

// -------------------------------------------------------------------

// GuideStepReq

// required int32 type = 1;
inline bool GuideStepReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuideStepReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuideStepReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuideStepReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GuideStepReq::type() const {
  return type_;
}
inline void GuideStepReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 step_index = 2;
inline bool GuideStepReq::has_step_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuideStepReq::set_has_step_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuideStepReq::clear_has_step_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuideStepReq::clear_step_index() {
  step_index_ = 0;
  clear_has_step_index();
}
inline ::google::protobuf::int32 GuideStepReq::step_index() const {
  return step_index_;
}
inline void GuideStepReq::set_step_index(::google::protobuf::int32 value) {
  set_has_step_index();
  step_index_ = value;
}

// optional int32 step_num = 3;
inline bool GuideStepReq::has_step_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuideStepReq::set_has_step_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuideStepReq::clear_has_step_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuideStepReq::clear_step_num() {
  step_num_ = 0;
  clear_has_step_num();
}
inline ::google::protobuf::int32 GuideStepReq::step_num() const {
  return step_num_;
}
inline void GuideStepReq::set_step_num(::google::protobuf::int32 value) {
  set_has_step_num();
  step_num_ = value;
}

// optional string talk_key = 4;
inline bool GuideStepReq::has_talk_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuideStepReq::set_has_talk_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuideStepReq::clear_has_talk_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuideStepReq::clear_talk_key() {
  if (talk_key_ != &::google::protobuf::internal::kEmptyString) {
    talk_key_->clear();
  }
  clear_has_talk_key();
}
inline const ::std::string& GuideStepReq::talk_key() const {
  return *talk_key_;
}
inline void GuideStepReq::set_talk_key(const ::std::string& value) {
  set_has_talk_key();
  if (talk_key_ == &::google::protobuf::internal::kEmptyString) {
    talk_key_ = new ::std::string;
  }
  talk_key_->assign(value);
}
inline void GuideStepReq::set_talk_key(const char* value) {
  set_has_talk_key();
  if (talk_key_ == &::google::protobuf::internal::kEmptyString) {
    talk_key_ = new ::std::string;
  }
  talk_key_->assign(value);
}
inline void GuideStepReq::set_talk_key(const char* value, size_t size) {
  set_has_talk_key();
  if (talk_key_ == &::google::protobuf::internal::kEmptyString) {
    talk_key_ = new ::std::string;
  }
  talk_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GuideStepReq::mutable_talk_key() {
  set_has_talk_key();
  if (talk_key_ == &::google::protobuf::internal::kEmptyString) {
    talk_key_ = new ::std::string;
  }
  return talk_key_;
}
inline ::std::string* GuideStepReq::release_talk_key() {
  clear_has_talk_key();
  if (talk_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = talk_key_;
    talk_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GuideStepReq::set_allocated_talk_key(::std::string* talk_key) {
  if (talk_key_ != &::google::protobuf::internal::kEmptyString) {
    delete talk_key_;
  }
  if (talk_key) {
    set_has_talk_key();
    talk_key_ = talk_key;
  } else {
    clear_has_talk_key();
    talk_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GuideStepResp

// required int32 result = 1;
inline bool GuideStepResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuideStepResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuideStepResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuideStepResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GuideStepResp::result() const {
  return result_;
}
inline void GuideStepResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GuideStepResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuideStepResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuideStepResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuideStepResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GuideStepResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* GuideStepResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GuideStepResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GuideStepResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// AidAwardReq

// required int32 type = 1;
inline bool AidAwardReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AidAwardReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AidAwardReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AidAwardReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AidAwardReq::type() const {
  return type_;
}
inline void AidAwardReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AidAwardResp

// required int32 result = 1;
inline bool AidAwardResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AidAwardResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AidAwardResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AidAwardResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AidAwardResp::result() const {
  return result_;
}
inline void AidAwardResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool AidAwardResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AidAwardResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AidAwardResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AidAwardResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& AidAwardResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* AidAwardResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* AidAwardResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void AidAwardResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// OpenGiftReq

// required int32 item_id = 1;
inline bool OpenGiftReq::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenGiftReq::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenGiftReq::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenGiftReq::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 OpenGiftReq::item_id() const {
  return item_id_;
}
inline void OpenGiftReq::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// required int32 num = 2;
inline bool OpenGiftReq::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenGiftReq::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenGiftReq::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenGiftReq::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 OpenGiftReq::num() const {
  return num_;
}
inline void OpenGiftReq::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// OpenGiftResp

// required int32 result = 1;
inline bool OpenGiftResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenGiftResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenGiftResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenGiftResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 OpenGiftResp::result() const {
  return result_;
}
inline void OpenGiftResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool OpenGiftResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenGiftResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenGiftResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenGiftResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& OpenGiftResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* OpenGiftResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* OpenGiftResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void OpenGiftResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .Item get_item_list = 3;
inline int OpenGiftResp::get_item_list_size() const {
  return get_item_list_.size();
}
inline void OpenGiftResp::clear_get_item_list() {
  get_item_list_.Clear();
}
inline const ::Item& OpenGiftResp::get_item_list(int index) const {
  return get_item_list_.Get(index);
}
inline ::Item* OpenGiftResp::mutable_get_item_list(int index) {
  return get_item_list_.Mutable(index);
}
inline ::Item* OpenGiftResp::add_get_item_list() {
  return get_item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Item >&
OpenGiftResp::get_item_list() const {
  return get_item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Item >*
OpenGiftResp::mutable_get_item_list() {
  return &get_item_list_;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdUser_2eproto__INCLUDED
