// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: worldboss.proto

#ifndef PROTOBUF_worldboss_2eproto__INCLUDED
#define PROTOBUF_worldboss_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Item.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_worldboss_2eproto();
void protobuf_AssignDesc_worldboss_2eproto();
void protobuf_ShutdownFile_worldboss_2eproto();

class WBossHeadInfo;
class WBossAttrInfo;
class WorldBossInfo;
class UserDamageInfo;
class WBossAttackInfo;
class UserWBossInfo;
class WBossTerminateInfo;
class WBossRankRewardItem;
class WBossRankRewardList;

enum UserWBossInfo_Const {
  UserWBossInfo_Const_BaseFreeAttackTimes = 3
};
bool UserWBossInfo_Const_IsValid(int value);
const UserWBossInfo_Const UserWBossInfo_Const_Const_MIN = UserWBossInfo_Const_BaseFreeAttackTimes;
const UserWBossInfo_Const UserWBossInfo_Const_Const_MAX = UserWBossInfo_Const_BaseFreeAttackTimes;
const int UserWBossInfo_Const_Const_ARRAYSIZE = UserWBossInfo_Const_Const_MAX + 1;

// ===================================================================

class WBossHeadInfo : public ::google::protobuf::MessageLite {
 public:
  WBossHeadInfo();
  virtual ~WBossHeadInfo();

  WBossHeadInfo(const WBossHeadInfo& from);

  inline WBossHeadInfo& operator=(const WBossHeadInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const WBossHeadInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WBossHeadInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WBossHeadInfo* other);

  // implements Message ----------------------------------------------

  WBossHeadInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WBossHeadInfo& from);
  void MergeFrom(const WBossHeadInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 boss_index = 11;
  inline bool has_boss_index() const;
  inline void clear_boss_index();
  static const int kBossIndexFieldNumber = 11;
  inline ::google::protobuf::int32 boss_index() const;
  inline void set_boss_index(::google::protobuf::int32 value);

  // optional int32 boss_season = 1;
  inline bool has_boss_season() const;
  inline void clear_boss_season();
  static const int kBossSeasonFieldNumber = 1;
  inline ::google::protobuf::int32 boss_season() const;
  inline void set_boss_season(::google::protobuf::int32 value);

  // optional int32 boss_id = 2;
  inline bool has_boss_id() const;
  inline void clear_boss_id();
  static const int kBossIdFieldNumber = 2;
  inline ::google::protobuf::int32 boss_id() const;
  inline void set_boss_id(::google::protobuf::int32 value);

  // optional int32 boss_generations = 3;
  inline bool has_boss_generations() const;
  inline void clear_boss_generations();
  static const int kBossGenerationsFieldNumber = 3;
  inline ::google::protobuf::int32 boss_generations() const;
  inline void set_boss_generations(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WBossHeadInfo)
 private:
  inline void set_has_boss_index();
  inline void clear_has_boss_index();
  inline void set_has_boss_season();
  inline void clear_has_boss_season();
  inline void set_has_boss_id();
  inline void clear_has_boss_id();
  inline void set_has_boss_generations();
  inline void clear_has_boss_generations();

  ::google::protobuf::int32 boss_index_;
  ::google::protobuf::int32 boss_season_;
  ::google::protobuf::int32 boss_id_;
  ::google::protobuf::int32 boss_generations_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_worldboss_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_worldboss_2eproto();
  #endif
  friend void protobuf_AssignDesc_worldboss_2eproto();
  friend void protobuf_ShutdownFile_worldboss_2eproto();

  void InitAsDefaultInstance();
  static WBossHeadInfo* default_instance_;
};
// -------------------------------------------------------------------

class WBossAttrInfo : public ::google::protobuf::MessageLite {
 public:
  WBossAttrInfo();
  virtual ~WBossAttrInfo();

  WBossAttrInfo(const WBossAttrInfo& from);

  inline WBossAttrInfo& operator=(const WBossAttrInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const WBossAttrInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WBossAttrInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WBossAttrInfo* other);

  // implements Message ----------------------------------------------

  WBossAttrInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WBossAttrInfo& from);
  void MergeFrom(const WBossAttrInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 cur_hp = 11;
  inline bool has_cur_hp() const;
  inline void clear_cur_hp();
  static const int kCurHpFieldNumber = 11;
  inline ::google::protobuf::int64 cur_hp() const;
  inline void set_cur_hp(::google::protobuf::int64 value);

  // optional int64 max_hp = 12;
  inline bool has_max_hp() const;
  inline void clear_max_hp();
  static const int kMaxHpFieldNumber = 12;
  inline ::google::protobuf::int64 max_hp() const;
  inline void set_max_hp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:WBossAttrInfo)
 private:
  inline void set_has_cur_hp();
  inline void clear_has_cur_hp();
  inline void set_has_max_hp();
  inline void clear_has_max_hp();

  ::google::protobuf::int64 cur_hp_;
  ::google::protobuf::int64 max_hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_worldboss_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_worldboss_2eproto();
  #endif
  friend void protobuf_AssignDesc_worldboss_2eproto();
  friend void protobuf_ShutdownFile_worldboss_2eproto();

  void InitAsDefaultInstance();
  static WBossAttrInfo* default_instance_;
};
// -------------------------------------------------------------------

class WorldBossInfo : public ::google::protobuf::MessageLite {
 public:
  WorldBossInfo();
  virtual ~WorldBossInfo();

  WorldBossInfo(const WorldBossInfo& from);

  inline WorldBossInfo& operator=(const WorldBossInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const WorldBossInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WorldBossInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WorldBossInfo* other);

  // implements Message ----------------------------------------------

  WorldBossInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WorldBossInfo& from);
  void MergeFrom(const WorldBossInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .WBossHeadInfo head_info = 1;
  inline bool has_head_info() const;
  inline void clear_head_info();
  static const int kHeadInfoFieldNumber = 1;
  inline const ::WBossHeadInfo& head_info() const;
  inline ::WBossHeadInfo* mutable_head_info();
  inline ::WBossHeadInfo* release_head_info();
  inline void set_allocated_head_info(::WBossHeadInfo* head_info);

  // optional .WBossAttrInfo attr_info = 2;
  inline bool has_attr_info() const;
  inline void clear_attr_info();
  static const int kAttrInfoFieldNumber = 2;
  inline const ::WBossAttrInfo& attr_info() const;
  inline ::WBossAttrInfo* mutable_attr_info();
  inline ::WBossAttrInfo* release_attr_info();
  inline void set_allocated_attr_info(::WBossAttrInfo* attr_info);

  // optional int32 is_alive = 10;
  inline bool has_is_alive() const;
  inline void clear_is_alive();
  static const int kIsAliveFieldNumber = 10;
  inline ::google::protobuf::int32 is_alive() const;
  inline void set_is_alive(::google::protobuf::int32 value);

  // optional int64 reward_calc_time = 11;
  inline bool has_reward_calc_time() const;
  inline void clear_reward_calc_time();
  static const int kRewardCalcTimeFieldNumber = 11;
  inline ::google::protobuf::int64 reward_calc_time() const;
  inline void set_reward_calc_time(::google::protobuf::int64 value);

  // optional int64 attack_start_time = 12;
  inline bool has_attack_start_time() const;
  inline void clear_attack_start_time();
  static const int kAttackStartTimeFieldNumber = 12;
  inline ::google::protobuf::int64 attack_start_time() const;
  inline void set_attack_start_time(::google::protobuf::int64 value);

  // optional int64 attack_end_time = 13;
  inline bool has_attack_end_time() const;
  inline void clear_attack_end_time();
  static const int kAttackEndTimeFieldNumber = 13;
  inline ::google::protobuf::int64 attack_end_time() const;
  inline void set_attack_end_time(::google::protobuf::int64 value);

  // optional int64 next_boss_time = 21;
  inline bool has_next_boss_time() const;
  inline void clear_next_boss_time();
  static const int kNextBossTimeFieldNumber = 21;
  inline ::google::protobuf::int64 next_boss_time() const;
  inline void set_next_boss_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:WorldBossInfo)
 private:
  inline void set_has_head_info();
  inline void clear_has_head_info();
  inline void set_has_attr_info();
  inline void clear_has_attr_info();
  inline void set_has_is_alive();
  inline void clear_has_is_alive();
  inline void set_has_reward_calc_time();
  inline void clear_has_reward_calc_time();
  inline void set_has_attack_start_time();
  inline void clear_has_attack_start_time();
  inline void set_has_attack_end_time();
  inline void clear_has_attack_end_time();
  inline void set_has_next_boss_time();
  inline void clear_has_next_boss_time();

  ::WBossHeadInfo* head_info_;
  ::WBossAttrInfo* attr_info_;
  ::google::protobuf::int64 reward_calc_time_;
  ::google::protobuf::int64 attack_start_time_;
  ::google::protobuf::int64 attack_end_time_;
  ::google::protobuf::int64 next_boss_time_;
  ::google::protobuf::int32 is_alive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_worldboss_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_worldboss_2eproto();
  #endif
  friend void protobuf_AssignDesc_worldboss_2eproto();
  friend void protobuf_ShutdownFile_worldboss_2eproto();

  void InitAsDefaultInstance();
  static WorldBossInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserDamageInfo : public ::google::protobuf::MessageLite {
 public:
  UserDamageInfo();
  virtual ~UserDamageInfo();

  UserDamageInfo(const UserDamageInfo& from);

  inline UserDamageInfo& operator=(const UserDamageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserDamageInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserDamageInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserDamageInfo* other);

  // implements Message ----------------------------------------------

  UserDamageInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserDamageInfo& from);
  void MergeFrom(const UserDamageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .WBossHeadInfo boss_head = 1;
  inline bool has_boss_head() const;
  inline void clear_boss_head();
  static const int kBossHeadFieldNumber = 1;
  inline const ::WBossHeadInfo& boss_head() const;
  inline ::WBossHeadInfo* mutable_boss_head();
  inline ::WBossHeadInfo* release_boss_head();
  inline void set_allocated_boss_head(::WBossHeadInfo* boss_head);

  // optional int64 reward_calc_time = 2;
  inline bool has_reward_calc_time() const;
  inline void clear_reward_calc_time();
  static const int kRewardCalcTimeFieldNumber = 2;
  inline ::google::protobuf::int64 reward_calc_time() const;
  inline void set_reward_calc_time(::google::protobuf::int64 value);

  // optional int32 cur_season_rank = 10;
  inline bool has_cur_season_rank() const;
  inline void clear_cur_season_rank();
  static const int kCurSeasonRankFieldNumber = 10;
  inline ::google::protobuf::int32 cur_season_rank() const;
  inline void set_cur_season_rank(::google::protobuf::int32 value);

  // optional int32 cur_season_damage = 11;
  inline bool has_cur_season_damage() const;
  inline void clear_cur_season_damage();
  static const int kCurSeasonDamageFieldNumber = 11;
  inline ::google::protobuf::int32 cur_season_damage() const;
  inline void set_cur_season_damage(::google::protobuf::int32 value);

  // optional int32 last_attack_damage = 12;
  inline bool has_last_attack_damage() const;
  inline void clear_last_attack_damage();
  static const int kLastAttackDamageFieldNumber = 12;
  inline ::google::protobuf::int32 last_attack_damage() const;
  inline void set_last_attack_damage(::google::protobuf::int32 value);

  // optional int32 max_season_damage = 21;
  inline bool has_max_season_damage() const;
  inline void clear_max_season_damage();
  static const int kMaxSeasonDamageFieldNumber = 21;
  inline ::google::protobuf::int32 max_season_damage() const;
  inline void set_max_season_damage(::google::protobuf::int32 value);

  // optional int32 max_attack_damage = 22;
  inline bool has_max_attack_damage() const;
  inline void clear_max_attack_damage();
  static const int kMaxAttackDamageFieldNumber = 22;
  inline ::google::protobuf::int32 max_attack_damage() const;
  inline void set_max_attack_damage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UserDamageInfo)
 private:
  inline void set_has_boss_head();
  inline void clear_has_boss_head();
  inline void set_has_reward_calc_time();
  inline void clear_has_reward_calc_time();
  inline void set_has_cur_season_rank();
  inline void clear_has_cur_season_rank();
  inline void set_has_cur_season_damage();
  inline void clear_has_cur_season_damage();
  inline void set_has_last_attack_damage();
  inline void clear_has_last_attack_damage();
  inline void set_has_max_season_damage();
  inline void clear_has_max_season_damage();
  inline void set_has_max_attack_damage();
  inline void clear_has_max_attack_damage();

  ::WBossHeadInfo* boss_head_;
  ::google::protobuf::int64 reward_calc_time_;
  ::google::protobuf::int32 cur_season_rank_;
  ::google::protobuf::int32 cur_season_damage_;
  ::google::protobuf::int32 last_attack_damage_;
  ::google::protobuf::int32 max_season_damage_;
  ::google::protobuf::int32 max_attack_damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_worldboss_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_worldboss_2eproto();
  #endif
  friend void protobuf_AssignDesc_worldboss_2eproto();
  friend void protobuf_ShutdownFile_worldboss_2eproto();

  void InitAsDefaultInstance();
  static UserDamageInfo* default_instance_;
};
// -------------------------------------------------------------------

class WBossAttackInfo : public ::google::protobuf::MessageLite {
 public:
  WBossAttackInfo();
  virtual ~WBossAttackInfo();

  WBossAttackInfo(const WBossAttackInfo& from);

  inline WBossAttackInfo& operator=(const WBossAttackInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const WBossAttackInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WBossAttackInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WBossAttackInfo* other);

  // implements Message ----------------------------------------------

  WBossAttackInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WBossAttackInfo& from);
  void MergeFrom(const WBossAttackInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string nick_name = 2;
  inline bool has_nick_name() const;
  inline void clear_nick_name();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nick_name() const;
  inline void set_nick_name(const ::std::string& value);
  inline void set_nick_name(const char* value);
  inline void set_nick_name(const char* value, size_t size);
  inline ::std::string* mutable_nick_name();
  inline ::std::string* release_nick_name();
  inline void set_allocated_nick_name(::std::string* nick_name);

  // optional int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 viplv = 4;
  inline bool has_viplv() const;
  inline void clear_viplv();
  static const int kViplvFieldNumber = 4;
  inline ::google::protobuf::int32 viplv() const;
  inline void set_viplv(::google::protobuf::int32 value);

  // optional int32 power = 5;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 5;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // optional int32 damage = 21;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 21;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // optional int32 total_damage = 22;
  inline bool has_total_damage() const;
  inline void clear_total_damage();
  static const int kTotalDamageFieldNumber = 22;
  inline ::google::protobuf::int32 total_damage() const;
  inline void set_total_damage(::google::protobuf::int32 value);

  // optional int64 time = 100;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 100;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:WBossAttackInfo)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_nick_name();
  inline void clear_has_nick_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_viplv();
  inline void clear_has_viplv();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_total_damage();
  inline void clear_has_total_damage();
  inline void set_has_time();
  inline void clear_has_time();

  ::std::string* user_name_;
  ::std::string* nick_name_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 viplv_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 damage_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 total_damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_worldboss_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_worldboss_2eproto();
  #endif
  friend void protobuf_AssignDesc_worldboss_2eproto();
  friend void protobuf_ShutdownFile_worldboss_2eproto();

  void InitAsDefaultInstance();
  static WBossAttackInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserWBossInfo : public ::google::protobuf::MessageLite {
 public:
  UserWBossInfo();
  virtual ~UserWBossInfo();

  UserWBossInfo(const UserWBossInfo& from);

  inline UserWBossInfo& operator=(const UserWBossInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserWBossInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserWBossInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserWBossInfo* other);

  // implements Message ----------------------------------------------

  UserWBossInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserWBossInfo& from);
  void MergeFrom(const UserWBossInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UserWBossInfo_Const Const;
  static const Const BaseFreeAttackTimes = UserWBossInfo_Const_BaseFreeAttackTimes;
  static inline bool Const_IsValid(int value) {
    return UserWBossInfo_Const_IsValid(value);
  }
  static const Const Const_MIN =
    UserWBossInfo_Const_Const_MIN;
  static const Const Const_MAX =
    UserWBossInfo_Const_Const_MAX;
  static const int Const_ARRAYSIZE =
    UserWBossInfo_Const_Const_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 cur_attack_times = 1;
  inline bool has_cur_attack_times() const;
  inline void clear_cur_attack_times();
  static const int kCurAttackTimesFieldNumber = 1;
  inline ::google::protobuf::int32 cur_attack_times() const;
  inline void set_cur_attack_times(::google::protobuf::int32 value);

  // optional int32 max_attack_times = 2;
  inline bool has_max_attack_times() const;
  inline void clear_max_attack_times();
  static const int kMaxAttackTimesFieldNumber = 2;
  inline ::google::protobuf::int32 max_attack_times() const;
  inline void set_max_attack_times(::google::protobuf::int32 value);

  // optional .UserDamageInfo dmg_info = 11;
  inline bool has_dmg_info() const;
  inline void clear_dmg_info();
  static const int kDmgInfoFieldNumber = 11;
  inline const ::UserDamageInfo& dmg_info() const;
  inline ::UserDamageInfo* mutable_dmg_info();
  inline ::UserDamageInfo* release_dmg_info();
  inline void set_allocated_dmg_info(::UserDamageInfo* dmg_info);

  // optional int32 terminate_boss_times = 21;
  inline bool has_terminate_boss_times() const;
  inline void clear_terminate_boss_times();
  static const int kTerminateBossTimesFieldNumber = 21;
  inline ::google::protobuf::int32 terminate_boss_times() const;
  inline void set_terminate_boss_times(::google::protobuf::int32 value);

  // optional int32 need_update = 50;
  inline bool has_need_update() const;
  inline void clear_need_update();
  static const int kNeedUpdateFieldNumber = 50;
  inline ::google::protobuf::int32 need_update() const;
  inline void set_need_update(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UserWBossInfo)
 private:
  inline void set_has_cur_attack_times();
  inline void clear_has_cur_attack_times();
  inline void set_has_max_attack_times();
  inline void clear_has_max_attack_times();
  inline void set_has_dmg_info();
  inline void clear_has_dmg_info();
  inline void set_has_terminate_boss_times();
  inline void clear_has_terminate_boss_times();
  inline void set_has_need_update();
  inline void clear_has_need_update();

  ::google::protobuf::int32 cur_attack_times_;
  ::google::protobuf::int32 max_attack_times_;
  ::UserDamageInfo* dmg_info_;
  ::google::protobuf::int32 terminate_boss_times_;
  ::google::protobuf::int32 need_update_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_worldboss_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_worldboss_2eproto();
  #endif
  friend void protobuf_AssignDesc_worldboss_2eproto();
  friend void protobuf_ShutdownFile_worldboss_2eproto();

  void InitAsDefaultInstance();
  static UserWBossInfo* default_instance_;
};
// -------------------------------------------------------------------

class WBossTerminateInfo : public ::google::protobuf::MessageLite {
 public:
  WBossTerminateInfo();
  virtual ~WBossTerminateInfo();

  WBossTerminateInfo(const WBossTerminateInfo& from);

  inline WBossTerminateInfo& operator=(const WBossTerminateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const WBossTerminateInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WBossTerminateInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WBossTerminateInfo* other);

  // implements Message ----------------------------------------------

  WBossTerminateInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WBossTerminateInfo& from);
  void MergeFrom(const WBossTerminateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string nick_name = 2;
  inline bool has_nick_name() const;
  inline void clear_nick_name();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nick_name() const;
  inline void set_nick_name(const ::std::string& value);
  inline void set_nick_name(const char* value);
  inline void set_nick_name(const char* value, size_t size);
  inline ::std::string* mutable_nick_name();
  inline ::std::string* release_nick_name();
  inline void set_allocated_nick_name(::std::string* nick_name);

  // optional int32 attack_damage = 11;
  inline bool has_attack_damage() const;
  inline void clear_attack_damage();
  static const int kAttackDamageFieldNumber = 11;
  inline ::google::protobuf::int32 attack_damage() const;
  inline void set_attack_damage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WBossTerminateInfo)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_nick_name();
  inline void clear_has_nick_name();
  inline void set_has_attack_damage();
  inline void clear_has_attack_damage();

  ::std::string* user_name_;
  ::std::string* nick_name_;
  ::google::protobuf::int32 attack_damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_worldboss_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_worldboss_2eproto();
  #endif
  friend void protobuf_AssignDesc_worldboss_2eproto();
  friend void protobuf_ShutdownFile_worldboss_2eproto();

  void InitAsDefaultInstance();
  static WBossTerminateInfo* default_instance_;
};
// -------------------------------------------------------------------

class WBossRankRewardItem : public ::google::protobuf::MessageLite {
 public:
  WBossRankRewardItem();
  virtual ~WBossRankRewardItem();

  WBossRankRewardItem(const WBossRankRewardItem& from);

  inline WBossRankRewardItem& operator=(const WBossRankRewardItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const WBossRankRewardItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WBossRankRewardItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WBossRankRewardItem* other);

  // implements Message ----------------------------------------------

  WBossRankRewardItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WBossRankRewardItem& from);
  void MergeFrom(const WBossRankRewardItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 idx = 1;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 1;
  inline ::google::protobuf::int32 idx() const;
  inline void set_idx(::google::protobuf::int32 value);

  // optional int32 from = 2;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 2;
  inline ::google::protobuf::int32 from() const;
  inline void set_from(::google::protobuf::int32 value);

  // optional int32 to = 3;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 3;
  inline ::google::protobuf::int32 to() const;
  inline void set_to(::google::protobuf::int32 value);

  // repeated .Item item_list = 21;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 21;
  inline const ::Item& item_list(int index) const;
  inline ::Item* mutable_item_list(int index);
  inline ::Item* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Item >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Item >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:WBossRankRewardItem)
 private:
  inline void set_has_idx();
  inline void clear_has_idx();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();

  ::google::protobuf::int32 idx_;
  ::google::protobuf::int32 from_;
  ::google::protobuf::RepeatedPtrField< ::Item > item_list_;
  ::google::protobuf::int32 to_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_worldboss_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_worldboss_2eproto();
  #endif
  friend void protobuf_AssignDesc_worldboss_2eproto();
  friend void protobuf_ShutdownFile_worldboss_2eproto();

  void InitAsDefaultInstance();
  static WBossRankRewardItem* default_instance_;
};
// -------------------------------------------------------------------

class WBossRankRewardList : public ::google::protobuf::MessageLite {
 public:
  WBossRankRewardList();
  virtual ~WBossRankRewardList();

  WBossRankRewardList(const WBossRankRewardList& from);

  inline WBossRankRewardList& operator=(const WBossRankRewardList& from) {
    CopyFrom(from);
    return *this;
  }

  static const WBossRankRewardList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WBossRankRewardList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WBossRankRewardList* other);

  // implements Message ----------------------------------------------

  WBossRankRewardList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WBossRankRewardList& from);
  void MergeFrom(const WBossRankRewardList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .WBossRankRewardItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::WBossRankRewardItem& items(int index) const;
  inline ::WBossRankRewardItem* mutable_items(int index);
  inline ::WBossRankRewardItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::WBossRankRewardItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::WBossRankRewardItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:WBossRankRewardList)
 private:

  ::google::protobuf::RepeatedPtrField< ::WBossRankRewardItem > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_worldboss_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_worldboss_2eproto();
  #endif
  friend void protobuf_AssignDesc_worldboss_2eproto();
  friend void protobuf_ShutdownFile_worldboss_2eproto();

  void InitAsDefaultInstance();
  static WBossRankRewardList* default_instance_;
};
// ===================================================================


// ===================================================================

// WBossHeadInfo

// optional int32 boss_index = 11;
inline bool WBossHeadInfo::has_boss_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WBossHeadInfo::set_has_boss_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WBossHeadInfo::clear_has_boss_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WBossHeadInfo::clear_boss_index() {
  boss_index_ = 0;
  clear_has_boss_index();
}
inline ::google::protobuf::int32 WBossHeadInfo::boss_index() const {
  return boss_index_;
}
inline void WBossHeadInfo::set_boss_index(::google::protobuf::int32 value) {
  set_has_boss_index();
  boss_index_ = value;
}

// optional int32 boss_season = 1;
inline bool WBossHeadInfo::has_boss_season() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WBossHeadInfo::set_has_boss_season() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WBossHeadInfo::clear_has_boss_season() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WBossHeadInfo::clear_boss_season() {
  boss_season_ = 0;
  clear_has_boss_season();
}
inline ::google::protobuf::int32 WBossHeadInfo::boss_season() const {
  return boss_season_;
}
inline void WBossHeadInfo::set_boss_season(::google::protobuf::int32 value) {
  set_has_boss_season();
  boss_season_ = value;
}

// optional int32 boss_id = 2;
inline bool WBossHeadInfo::has_boss_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WBossHeadInfo::set_has_boss_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WBossHeadInfo::clear_has_boss_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WBossHeadInfo::clear_boss_id() {
  boss_id_ = 0;
  clear_has_boss_id();
}
inline ::google::protobuf::int32 WBossHeadInfo::boss_id() const {
  return boss_id_;
}
inline void WBossHeadInfo::set_boss_id(::google::protobuf::int32 value) {
  set_has_boss_id();
  boss_id_ = value;
}

// optional int32 boss_generations = 3;
inline bool WBossHeadInfo::has_boss_generations() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WBossHeadInfo::set_has_boss_generations() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WBossHeadInfo::clear_has_boss_generations() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WBossHeadInfo::clear_boss_generations() {
  boss_generations_ = 0;
  clear_has_boss_generations();
}
inline ::google::protobuf::int32 WBossHeadInfo::boss_generations() const {
  return boss_generations_;
}
inline void WBossHeadInfo::set_boss_generations(::google::protobuf::int32 value) {
  set_has_boss_generations();
  boss_generations_ = value;
}

// -------------------------------------------------------------------

// WBossAttrInfo

// optional int64 cur_hp = 11;
inline bool WBossAttrInfo::has_cur_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WBossAttrInfo::set_has_cur_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WBossAttrInfo::clear_has_cur_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WBossAttrInfo::clear_cur_hp() {
  cur_hp_ = GOOGLE_LONGLONG(0);
  clear_has_cur_hp();
}
inline ::google::protobuf::int64 WBossAttrInfo::cur_hp() const {
  return cur_hp_;
}
inline void WBossAttrInfo::set_cur_hp(::google::protobuf::int64 value) {
  set_has_cur_hp();
  cur_hp_ = value;
}

// optional int64 max_hp = 12;
inline bool WBossAttrInfo::has_max_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WBossAttrInfo::set_has_max_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WBossAttrInfo::clear_has_max_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WBossAttrInfo::clear_max_hp() {
  max_hp_ = GOOGLE_LONGLONG(0);
  clear_has_max_hp();
}
inline ::google::protobuf::int64 WBossAttrInfo::max_hp() const {
  return max_hp_;
}
inline void WBossAttrInfo::set_max_hp(::google::protobuf::int64 value) {
  set_has_max_hp();
  max_hp_ = value;
}

// -------------------------------------------------------------------

// WorldBossInfo

// optional .WBossHeadInfo head_info = 1;
inline bool WorldBossInfo::has_head_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorldBossInfo::set_has_head_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorldBossInfo::clear_has_head_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorldBossInfo::clear_head_info() {
  if (head_info_ != NULL) head_info_->::WBossHeadInfo::Clear();
  clear_has_head_info();
}
inline const ::WBossHeadInfo& WorldBossInfo::head_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_info_ != NULL ? *head_info_ : *default_instance().head_info_;
#else
  return head_info_ != NULL ? *head_info_ : *default_instance_->head_info_;
#endif
}
inline ::WBossHeadInfo* WorldBossInfo::mutable_head_info() {
  set_has_head_info();
  if (head_info_ == NULL) head_info_ = new ::WBossHeadInfo;
  return head_info_;
}
inline ::WBossHeadInfo* WorldBossInfo::release_head_info() {
  clear_has_head_info();
  ::WBossHeadInfo* temp = head_info_;
  head_info_ = NULL;
  return temp;
}
inline void WorldBossInfo::set_allocated_head_info(::WBossHeadInfo* head_info) {
  delete head_info_;
  head_info_ = head_info;
  if (head_info) {
    set_has_head_info();
  } else {
    clear_has_head_info();
  }
}

// optional .WBossAttrInfo attr_info = 2;
inline bool WorldBossInfo::has_attr_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorldBossInfo::set_has_attr_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorldBossInfo::clear_has_attr_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorldBossInfo::clear_attr_info() {
  if (attr_info_ != NULL) attr_info_->::WBossAttrInfo::Clear();
  clear_has_attr_info();
}
inline const ::WBossAttrInfo& WorldBossInfo::attr_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attr_info_ != NULL ? *attr_info_ : *default_instance().attr_info_;
#else
  return attr_info_ != NULL ? *attr_info_ : *default_instance_->attr_info_;
#endif
}
inline ::WBossAttrInfo* WorldBossInfo::mutable_attr_info() {
  set_has_attr_info();
  if (attr_info_ == NULL) attr_info_ = new ::WBossAttrInfo;
  return attr_info_;
}
inline ::WBossAttrInfo* WorldBossInfo::release_attr_info() {
  clear_has_attr_info();
  ::WBossAttrInfo* temp = attr_info_;
  attr_info_ = NULL;
  return temp;
}
inline void WorldBossInfo::set_allocated_attr_info(::WBossAttrInfo* attr_info) {
  delete attr_info_;
  attr_info_ = attr_info;
  if (attr_info) {
    set_has_attr_info();
  } else {
    clear_has_attr_info();
  }
}

// optional int32 is_alive = 10;
inline bool WorldBossInfo::has_is_alive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WorldBossInfo::set_has_is_alive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WorldBossInfo::clear_has_is_alive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WorldBossInfo::clear_is_alive() {
  is_alive_ = 0;
  clear_has_is_alive();
}
inline ::google::protobuf::int32 WorldBossInfo::is_alive() const {
  return is_alive_;
}
inline void WorldBossInfo::set_is_alive(::google::protobuf::int32 value) {
  set_has_is_alive();
  is_alive_ = value;
}

// optional int64 reward_calc_time = 11;
inline bool WorldBossInfo::has_reward_calc_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WorldBossInfo::set_has_reward_calc_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WorldBossInfo::clear_has_reward_calc_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WorldBossInfo::clear_reward_calc_time() {
  reward_calc_time_ = GOOGLE_LONGLONG(0);
  clear_has_reward_calc_time();
}
inline ::google::protobuf::int64 WorldBossInfo::reward_calc_time() const {
  return reward_calc_time_;
}
inline void WorldBossInfo::set_reward_calc_time(::google::protobuf::int64 value) {
  set_has_reward_calc_time();
  reward_calc_time_ = value;
}

// optional int64 attack_start_time = 12;
inline bool WorldBossInfo::has_attack_start_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WorldBossInfo::set_has_attack_start_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WorldBossInfo::clear_has_attack_start_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WorldBossInfo::clear_attack_start_time() {
  attack_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_attack_start_time();
}
inline ::google::protobuf::int64 WorldBossInfo::attack_start_time() const {
  return attack_start_time_;
}
inline void WorldBossInfo::set_attack_start_time(::google::protobuf::int64 value) {
  set_has_attack_start_time();
  attack_start_time_ = value;
}

// optional int64 attack_end_time = 13;
inline bool WorldBossInfo::has_attack_end_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WorldBossInfo::set_has_attack_end_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WorldBossInfo::clear_has_attack_end_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WorldBossInfo::clear_attack_end_time() {
  attack_end_time_ = GOOGLE_LONGLONG(0);
  clear_has_attack_end_time();
}
inline ::google::protobuf::int64 WorldBossInfo::attack_end_time() const {
  return attack_end_time_;
}
inline void WorldBossInfo::set_attack_end_time(::google::protobuf::int64 value) {
  set_has_attack_end_time();
  attack_end_time_ = value;
}

// optional int64 next_boss_time = 21;
inline bool WorldBossInfo::has_next_boss_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WorldBossInfo::set_has_next_boss_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WorldBossInfo::clear_has_next_boss_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WorldBossInfo::clear_next_boss_time() {
  next_boss_time_ = GOOGLE_LONGLONG(0);
  clear_has_next_boss_time();
}
inline ::google::protobuf::int64 WorldBossInfo::next_boss_time() const {
  return next_boss_time_;
}
inline void WorldBossInfo::set_next_boss_time(::google::protobuf::int64 value) {
  set_has_next_boss_time();
  next_boss_time_ = value;
}

// -------------------------------------------------------------------

// UserDamageInfo

// optional .WBossHeadInfo boss_head = 1;
inline bool UserDamageInfo::has_boss_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDamageInfo::set_has_boss_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDamageInfo::clear_has_boss_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDamageInfo::clear_boss_head() {
  if (boss_head_ != NULL) boss_head_->::WBossHeadInfo::Clear();
  clear_has_boss_head();
}
inline const ::WBossHeadInfo& UserDamageInfo::boss_head() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return boss_head_ != NULL ? *boss_head_ : *default_instance().boss_head_;
#else
  return boss_head_ != NULL ? *boss_head_ : *default_instance_->boss_head_;
#endif
}
inline ::WBossHeadInfo* UserDamageInfo::mutable_boss_head() {
  set_has_boss_head();
  if (boss_head_ == NULL) boss_head_ = new ::WBossHeadInfo;
  return boss_head_;
}
inline ::WBossHeadInfo* UserDamageInfo::release_boss_head() {
  clear_has_boss_head();
  ::WBossHeadInfo* temp = boss_head_;
  boss_head_ = NULL;
  return temp;
}
inline void UserDamageInfo::set_allocated_boss_head(::WBossHeadInfo* boss_head) {
  delete boss_head_;
  boss_head_ = boss_head;
  if (boss_head) {
    set_has_boss_head();
  } else {
    clear_has_boss_head();
  }
}

// optional int64 reward_calc_time = 2;
inline bool UserDamageInfo::has_reward_calc_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDamageInfo::set_has_reward_calc_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDamageInfo::clear_has_reward_calc_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDamageInfo::clear_reward_calc_time() {
  reward_calc_time_ = GOOGLE_LONGLONG(0);
  clear_has_reward_calc_time();
}
inline ::google::protobuf::int64 UserDamageInfo::reward_calc_time() const {
  return reward_calc_time_;
}
inline void UserDamageInfo::set_reward_calc_time(::google::protobuf::int64 value) {
  set_has_reward_calc_time();
  reward_calc_time_ = value;
}

// optional int32 cur_season_rank = 10;
inline bool UserDamageInfo::has_cur_season_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserDamageInfo::set_has_cur_season_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserDamageInfo::clear_has_cur_season_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserDamageInfo::clear_cur_season_rank() {
  cur_season_rank_ = 0;
  clear_has_cur_season_rank();
}
inline ::google::protobuf::int32 UserDamageInfo::cur_season_rank() const {
  return cur_season_rank_;
}
inline void UserDamageInfo::set_cur_season_rank(::google::protobuf::int32 value) {
  set_has_cur_season_rank();
  cur_season_rank_ = value;
}

// optional int32 cur_season_damage = 11;
inline bool UserDamageInfo::has_cur_season_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserDamageInfo::set_has_cur_season_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserDamageInfo::clear_has_cur_season_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserDamageInfo::clear_cur_season_damage() {
  cur_season_damage_ = 0;
  clear_has_cur_season_damage();
}
inline ::google::protobuf::int32 UserDamageInfo::cur_season_damage() const {
  return cur_season_damage_;
}
inline void UserDamageInfo::set_cur_season_damage(::google::protobuf::int32 value) {
  set_has_cur_season_damage();
  cur_season_damage_ = value;
}

// optional int32 last_attack_damage = 12;
inline bool UserDamageInfo::has_last_attack_damage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserDamageInfo::set_has_last_attack_damage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserDamageInfo::clear_has_last_attack_damage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserDamageInfo::clear_last_attack_damage() {
  last_attack_damage_ = 0;
  clear_has_last_attack_damage();
}
inline ::google::protobuf::int32 UserDamageInfo::last_attack_damage() const {
  return last_attack_damage_;
}
inline void UserDamageInfo::set_last_attack_damage(::google::protobuf::int32 value) {
  set_has_last_attack_damage();
  last_attack_damage_ = value;
}

// optional int32 max_season_damage = 21;
inline bool UserDamageInfo::has_max_season_damage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserDamageInfo::set_has_max_season_damage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserDamageInfo::clear_has_max_season_damage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserDamageInfo::clear_max_season_damage() {
  max_season_damage_ = 0;
  clear_has_max_season_damage();
}
inline ::google::protobuf::int32 UserDamageInfo::max_season_damage() const {
  return max_season_damage_;
}
inline void UserDamageInfo::set_max_season_damage(::google::protobuf::int32 value) {
  set_has_max_season_damage();
  max_season_damage_ = value;
}

// optional int32 max_attack_damage = 22;
inline bool UserDamageInfo::has_max_attack_damage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserDamageInfo::set_has_max_attack_damage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserDamageInfo::clear_has_max_attack_damage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserDamageInfo::clear_max_attack_damage() {
  max_attack_damage_ = 0;
  clear_has_max_attack_damage();
}
inline ::google::protobuf::int32 UserDamageInfo::max_attack_damage() const {
  return max_attack_damage_;
}
inline void UserDamageInfo::set_max_attack_damage(::google::protobuf::int32 value) {
  set_has_max_attack_damage();
  max_attack_damage_ = value;
}

// -------------------------------------------------------------------

// WBossAttackInfo

// optional string user_name = 1;
inline bool WBossAttackInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WBossAttackInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WBossAttackInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WBossAttackInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& WBossAttackInfo::user_name() const {
  return *user_name_;
}
inline void WBossAttackInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void WBossAttackInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void WBossAttackInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WBossAttackInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* WBossAttackInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WBossAttackInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nick_name = 2;
inline bool WBossAttackInfo::has_nick_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WBossAttackInfo::set_has_nick_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WBossAttackInfo::clear_has_nick_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WBossAttackInfo::clear_nick_name() {
  if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
    nick_name_->clear();
  }
  clear_has_nick_name();
}
inline const ::std::string& WBossAttackInfo::nick_name() const {
  return *nick_name_;
}
inline void WBossAttackInfo::set_nick_name(const ::std::string& value) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(value);
}
inline void WBossAttackInfo::set_nick_name(const char* value) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(value);
}
inline void WBossAttackInfo::set_nick_name(const char* value, size_t size) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WBossAttackInfo::mutable_nick_name() {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  return nick_name_;
}
inline ::std::string* WBossAttackInfo::release_nick_name() {
  clear_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_name_;
    nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WBossAttackInfo::set_allocated_nick_name(::std::string* nick_name) {
  if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_name_;
  }
  if (nick_name) {
    set_has_nick_name();
    nick_name_ = nick_name;
  } else {
    clear_has_nick_name();
    nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 3;
inline bool WBossAttackInfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WBossAttackInfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WBossAttackInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WBossAttackInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 WBossAttackInfo::level() const {
  return level_;
}
inline void WBossAttackInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 viplv = 4;
inline bool WBossAttackInfo::has_viplv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WBossAttackInfo::set_has_viplv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WBossAttackInfo::clear_has_viplv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WBossAttackInfo::clear_viplv() {
  viplv_ = 0;
  clear_has_viplv();
}
inline ::google::protobuf::int32 WBossAttackInfo::viplv() const {
  return viplv_;
}
inline void WBossAttackInfo::set_viplv(::google::protobuf::int32 value) {
  set_has_viplv();
  viplv_ = value;
}

// optional int32 power = 5;
inline bool WBossAttackInfo::has_power() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WBossAttackInfo::set_has_power() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WBossAttackInfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WBossAttackInfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 WBossAttackInfo::power() const {
  return power_;
}
inline void WBossAttackInfo::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional int32 damage = 21;
inline bool WBossAttackInfo::has_damage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WBossAttackInfo::set_has_damage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WBossAttackInfo::clear_has_damage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WBossAttackInfo::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 WBossAttackInfo::damage() const {
  return damage_;
}
inline void WBossAttackInfo::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// optional int32 total_damage = 22;
inline bool WBossAttackInfo::has_total_damage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WBossAttackInfo::set_has_total_damage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WBossAttackInfo::clear_has_total_damage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WBossAttackInfo::clear_total_damage() {
  total_damage_ = 0;
  clear_has_total_damage();
}
inline ::google::protobuf::int32 WBossAttackInfo::total_damage() const {
  return total_damage_;
}
inline void WBossAttackInfo::set_total_damage(::google::protobuf::int32 value) {
  set_has_total_damage();
  total_damage_ = value;
}

// optional int64 time = 100;
inline bool WBossAttackInfo::has_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WBossAttackInfo::set_has_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WBossAttackInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WBossAttackInfo::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 WBossAttackInfo::time() const {
  return time_;
}
inline void WBossAttackInfo::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// UserWBossInfo

// optional int32 cur_attack_times = 1;
inline bool UserWBossInfo::has_cur_attack_times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserWBossInfo::set_has_cur_attack_times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserWBossInfo::clear_has_cur_attack_times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserWBossInfo::clear_cur_attack_times() {
  cur_attack_times_ = 0;
  clear_has_cur_attack_times();
}
inline ::google::protobuf::int32 UserWBossInfo::cur_attack_times() const {
  return cur_attack_times_;
}
inline void UserWBossInfo::set_cur_attack_times(::google::protobuf::int32 value) {
  set_has_cur_attack_times();
  cur_attack_times_ = value;
}

// optional int32 max_attack_times = 2;
inline bool UserWBossInfo::has_max_attack_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserWBossInfo::set_has_max_attack_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserWBossInfo::clear_has_max_attack_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserWBossInfo::clear_max_attack_times() {
  max_attack_times_ = 0;
  clear_has_max_attack_times();
}
inline ::google::protobuf::int32 UserWBossInfo::max_attack_times() const {
  return max_attack_times_;
}
inline void UserWBossInfo::set_max_attack_times(::google::protobuf::int32 value) {
  set_has_max_attack_times();
  max_attack_times_ = value;
}

// optional .UserDamageInfo dmg_info = 11;
inline bool UserWBossInfo::has_dmg_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserWBossInfo::set_has_dmg_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserWBossInfo::clear_has_dmg_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserWBossInfo::clear_dmg_info() {
  if (dmg_info_ != NULL) dmg_info_->::UserDamageInfo::Clear();
  clear_has_dmg_info();
}
inline const ::UserDamageInfo& UserWBossInfo::dmg_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dmg_info_ != NULL ? *dmg_info_ : *default_instance().dmg_info_;
#else
  return dmg_info_ != NULL ? *dmg_info_ : *default_instance_->dmg_info_;
#endif
}
inline ::UserDamageInfo* UserWBossInfo::mutable_dmg_info() {
  set_has_dmg_info();
  if (dmg_info_ == NULL) dmg_info_ = new ::UserDamageInfo;
  return dmg_info_;
}
inline ::UserDamageInfo* UserWBossInfo::release_dmg_info() {
  clear_has_dmg_info();
  ::UserDamageInfo* temp = dmg_info_;
  dmg_info_ = NULL;
  return temp;
}
inline void UserWBossInfo::set_allocated_dmg_info(::UserDamageInfo* dmg_info) {
  delete dmg_info_;
  dmg_info_ = dmg_info;
  if (dmg_info) {
    set_has_dmg_info();
  } else {
    clear_has_dmg_info();
  }
}

// optional int32 terminate_boss_times = 21;
inline bool UserWBossInfo::has_terminate_boss_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserWBossInfo::set_has_terminate_boss_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserWBossInfo::clear_has_terminate_boss_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserWBossInfo::clear_terminate_boss_times() {
  terminate_boss_times_ = 0;
  clear_has_terminate_boss_times();
}
inline ::google::protobuf::int32 UserWBossInfo::terminate_boss_times() const {
  return terminate_boss_times_;
}
inline void UserWBossInfo::set_terminate_boss_times(::google::protobuf::int32 value) {
  set_has_terminate_boss_times();
  terminate_boss_times_ = value;
}

// optional int32 need_update = 50;
inline bool UserWBossInfo::has_need_update() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserWBossInfo::set_has_need_update() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserWBossInfo::clear_has_need_update() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserWBossInfo::clear_need_update() {
  need_update_ = 0;
  clear_has_need_update();
}
inline ::google::protobuf::int32 UserWBossInfo::need_update() const {
  return need_update_;
}
inline void UserWBossInfo::set_need_update(::google::protobuf::int32 value) {
  set_has_need_update();
  need_update_ = value;
}

// -------------------------------------------------------------------

// WBossTerminateInfo

// optional string user_name = 1;
inline bool WBossTerminateInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WBossTerminateInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WBossTerminateInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WBossTerminateInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& WBossTerminateInfo::user_name() const {
  return *user_name_;
}
inline void WBossTerminateInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void WBossTerminateInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void WBossTerminateInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WBossTerminateInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* WBossTerminateInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WBossTerminateInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nick_name = 2;
inline bool WBossTerminateInfo::has_nick_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WBossTerminateInfo::set_has_nick_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WBossTerminateInfo::clear_has_nick_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WBossTerminateInfo::clear_nick_name() {
  if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
    nick_name_->clear();
  }
  clear_has_nick_name();
}
inline const ::std::string& WBossTerminateInfo::nick_name() const {
  return *nick_name_;
}
inline void WBossTerminateInfo::set_nick_name(const ::std::string& value) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(value);
}
inline void WBossTerminateInfo::set_nick_name(const char* value) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(value);
}
inline void WBossTerminateInfo::set_nick_name(const char* value, size_t size) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WBossTerminateInfo::mutable_nick_name() {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  return nick_name_;
}
inline ::std::string* WBossTerminateInfo::release_nick_name() {
  clear_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_name_;
    nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WBossTerminateInfo::set_allocated_nick_name(::std::string* nick_name) {
  if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_name_;
  }
  if (nick_name) {
    set_has_nick_name();
    nick_name_ = nick_name;
  } else {
    clear_has_nick_name();
    nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 attack_damage = 11;
inline bool WBossTerminateInfo::has_attack_damage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WBossTerminateInfo::set_has_attack_damage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WBossTerminateInfo::clear_has_attack_damage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WBossTerminateInfo::clear_attack_damage() {
  attack_damage_ = 0;
  clear_has_attack_damage();
}
inline ::google::protobuf::int32 WBossTerminateInfo::attack_damage() const {
  return attack_damage_;
}
inline void WBossTerminateInfo::set_attack_damage(::google::protobuf::int32 value) {
  set_has_attack_damage();
  attack_damage_ = value;
}

// -------------------------------------------------------------------

// WBossRankRewardItem

// optional int32 idx = 1;
inline bool WBossRankRewardItem::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WBossRankRewardItem::set_has_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WBossRankRewardItem::clear_has_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WBossRankRewardItem::clear_idx() {
  idx_ = 0;
  clear_has_idx();
}
inline ::google::protobuf::int32 WBossRankRewardItem::idx() const {
  return idx_;
}
inline void WBossRankRewardItem::set_idx(::google::protobuf::int32 value) {
  set_has_idx();
  idx_ = value;
}

// optional int32 from = 2;
inline bool WBossRankRewardItem::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WBossRankRewardItem::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WBossRankRewardItem::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WBossRankRewardItem::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::google::protobuf::int32 WBossRankRewardItem::from() const {
  return from_;
}
inline void WBossRankRewardItem::set_from(::google::protobuf::int32 value) {
  set_has_from();
  from_ = value;
}

// optional int32 to = 3;
inline bool WBossRankRewardItem::has_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WBossRankRewardItem::set_has_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WBossRankRewardItem::clear_has_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WBossRankRewardItem::clear_to() {
  to_ = 0;
  clear_has_to();
}
inline ::google::protobuf::int32 WBossRankRewardItem::to() const {
  return to_;
}
inline void WBossRankRewardItem::set_to(::google::protobuf::int32 value) {
  set_has_to();
  to_ = value;
}

// repeated .Item item_list = 21;
inline int WBossRankRewardItem::item_list_size() const {
  return item_list_.size();
}
inline void WBossRankRewardItem::clear_item_list() {
  item_list_.Clear();
}
inline const ::Item& WBossRankRewardItem::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::Item* WBossRankRewardItem::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::Item* WBossRankRewardItem::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Item >&
WBossRankRewardItem::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Item >*
WBossRankRewardItem::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// WBossRankRewardList

// repeated .WBossRankRewardItem items = 1;
inline int WBossRankRewardList::items_size() const {
  return items_.size();
}
inline void WBossRankRewardList::clear_items() {
  items_.Clear();
}
inline const ::WBossRankRewardItem& WBossRankRewardList::items(int index) const {
  return items_.Get(index);
}
inline ::WBossRankRewardItem* WBossRankRewardList::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::WBossRankRewardItem* WBossRankRewardList::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::WBossRankRewardItem >&
WBossRankRewardList::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::WBossRankRewardItem >*
WBossRankRewardList::mutable_items() {
  return &items_;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_worldboss_2eproto__INCLUDED
