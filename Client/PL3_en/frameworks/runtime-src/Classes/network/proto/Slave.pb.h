// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Slave.proto

#ifndef PROTOBUF_Slave_2eproto__INCLUDED
#define PROTOBUF_Slave_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Slave_2eproto();
void protobuf_AssignDesc_Slave_2eproto();
void protobuf_ShutdownFile_Slave_2eproto();

class SlaveNoteInfo;
class SlaveData;
class SlaveBriefInfo;

enum SlaveNoteInfo_SlaveNoteType {
  SlaveNoteInfo_SlaveNoteType_WORK_ADD = 1,
  SlaveNoteInfo_SlaveNoteType_WORK_SUB = 2,
  SlaveNoteInfo_SlaveNoteType_FAWN_ON_ADD = 3,
  SlaveNoteInfo_SlaveNoteType_FAWN_ON_SUB = 4,
  SlaveNoteInfo_SlaveNoteType_ROB_SUCCESS = 5,
  SlaveNoteInfo_SlaveNoteType_SAVE_SUCCESS = 6,
  SlaveNoteInfo_SlaveNoteType_SHOW = 7,
  SlaveNoteInfo_SlaveNoteType_BE_SHOW = 8,
  SlaveNoteInfo_SlaveNoteType_WATCH = 9,
  SlaveNoteInfo_SlaveNoteType_BE_ROB_SUCCESS = 10,
  SlaveNoteInfo_SlaveNoteType_BE_SAVE_SUCCESS = 11,
  SlaveNoteInfo_SlaveNoteType_SLAVE_BE_SAVE_SUCCESS = 12,
  SlaveNoteInfo_SlaveNoteType_SAVE_SELF_SUCCESS = 13,
  SlaveNoteInfo_SlaveNoteType_FREE = 14,
  SlaveNoteInfo_SlaveNoteType_BE_FREE = 15,
  SlaveNoteInfo_SlaveNoteType_BE_CATCH = 16
};
bool SlaveNoteInfo_SlaveNoteType_IsValid(int value);
const SlaveNoteInfo_SlaveNoteType SlaveNoteInfo_SlaveNoteType_SlaveNoteType_MIN = SlaveNoteInfo_SlaveNoteType_WORK_ADD;
const SlaveNoteInfo_SlaveNoteType SlaveNoteInfo_SlaveNoteType_SlaveNoteType_MAX = SlaveNoteInfo_SlaveNoteType_BE_CATCH;
const int SlaveNoteInfo_SlaveNoteType_SlaveNoteType_ARRAYSIZE = SlaveNoteInfo_SlaveNoteType_SlaveNoteType_MAX + 1;

// ===================================================================

class SlaveNoteInfo : public ::google::protobuf::MessageLite {
 public:
  SlaveNoteInfo();
  virtual ~SlaveNoteInfo();

  SlaveNoteInfo(const SlaveNoteInfo& from);

  inline SlaveNoteInfo& operator=(const SlaveNoteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SlaveNoteInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SlaveNoteInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SlaveNoteInfo* other);

  // implements Message ----------------------------------------------

  SlaveNoteInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SlaveNoteInfo& from);
  void MergeFrom(const SlaveNoteInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SlaveNoteInfo_SlaveNoteType SlaveNoteType;
  static const SlaveNoteType WORK_ADD = SlaveNoteInfo_SlaveNoteType_WORK_ADD;
  static const SlaveNoteType WORK_SUB = SlaveNoteInfo_SlaveNoteType_WORK_SUB;
  static const SlaveNoteType FAWN_ON_ADD = SlaveNoteInfo_SlaveNoteType_FAWN_ON_ADD;
  static const SlaveNoteType FAWN_ON_SUB = SlaveNoteInfo_SlaveNoteType_FAWN_ON_SUB;
  static const SlaveNoteType ROB_SUCCESS = SlaveNoteInfo_SlaveNoteType_ROB_SUCCESS;
  static const SlaveNoteType SAVE_SUCCESS = SlaveNoteInfo_SlaveNoteType_SAVE_SUCCESS;
  static const SlaveNoteType SHOW = SlaveNoteInfo_SlaveNoteType_SHOW;
  static const SlaveNoteType BE_SHOW = SlaveNoteInfo_SlaveNoteType_BE_SHOW;
  static const SlaveNoteType WATCH = SlaveNoteInfo_SlaveNoteType_WATCH;
  static const SlaveNoteType BE_ROB_SUCCESS = SlaveNoteInfo_SlaveNoteType_BE_ROB_SUCCESS;
  static const SlaveNoteType BE_SAVE_SUCCESS = SlaveNoteInfo_SlaveNoteType_BE_SAVE_SUCCESS;
  static const SlaveNoteType SLAVE_BE_SAVE_SUCCESS = SlaveNoteInfo_SlaveNoteType_SLAVE_BE_SAVE_SUCCESS;
  static const SlaveNoteType SAVE_SELF_SUCCESS = SlaveNoteInfo_SlaveNoteType_SAVE_SELF_SUCCESS;
  static const SlaveNoteType FREE = SlaveNoteInfo_SlaveNoteType_FREE;
  static const SlaveNoteType BE_FREE = SlaveNoteInfo_SlaveNoteType_BE_FREE;
  static const SlaveNoteType BE_CATCH = SlaveNoteInfo_SlaveNoteType_BE_CATCH;
  static inline bool SlaveNoteType_IsValid(int value) {
    return SlaveNoteInfo_SlaveNoteType_IsValid(value);
  }
  static const SlaveNoteType SlaveNoteType_MIN =
    SlaveNoteInfo_SlaveNoteType_SlaveNoteType_MIN;
  static const SlaveNoteType SlaveNoteType_MAX =
    SlaveNoteInfo_SlaveNoteType_SlaveNoteType_MAX;
  static const int SlaveNoteType_ARRAYSIZE =
    SlaveNoteInfo_SlaveNoteType_SlaveNoteType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .SlaveNoteInfo.SlaveNoteType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::SlaveNoteInfo_SlaveNoteType type() const;
  inline void set_type(::SlaveNoteInfo_SlaveNoteType value);

  // required int32 text_index = 2;
  inline bool has_text_index() const;
  inline void clear_text_index();
  static const int kTextIndexFieldNumber = 2;
  inline ::google::protobuf::int32 text_index() const;
  inline void set_text_index(::google::protobuf::int32 value);

  // repeated string param_list = 3;
  inline int param_list_size() const;
  inline void clear_param_list();
  static const int kParamListFieldNumber = 3;
  inline const ::std::string& param_list(int index) const;
  inline ::std::string* mutable_param_list(int index);
  inline void set_param_list(int index, const ::std::string& value);
  inline void set_param_list(int index, const char* value);
  inline void set_param_list(int index, const char* value, size_t size);
  inline ::std::string* add_param_list();
  inline void add_param_list(const ::std::string& value);
  inline void add_param_list(const char* value);
  inline void add_param_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& param_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_param_list();

  // @@protoc_insertion_point(class_scope:SlaveNoteInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_text_index();
  inline void clear_has_text_index();

  int type_;
  ::google::protobuf::int32 text_index_;
  ::google::protobuf::RepeatedPtrField< ::std::string> param_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Slave_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Slave_2eproto();
  #endif
  friend void protobuf_AssignDesc_Slave_2eproto();
  friend void protobuf_ShutdownFile_Slave_2eproto();

  void InitAsDefaultInstance();
  static SlaveNoteInfo* default_instance_;
};
// -------------------------------------------------------------------

class SlaveData : public ::google::protobuf::MessageLite {
 public:
  SlaveData();
  virtual ~SlaveData();

  SlaveData(const SlaveData& from);

  inline SlaveData& operator=(const SlaveData& from) {
    CopyFrom(from);
    return *this;
  }

  static const SlaveData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SlaveData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SlaveData* other);

  // implements Message ----------------------------------------------

  SlaveData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SlaveData& from);
  void MergeFrom(const SlaveData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required int32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // required int64 work_cd_start_time = 3;
  inline bool has_work_cd_start_time() const;
  inline void clear_work_cd_start_time();
  static const int kWorkCdStartTimeFieldNumber = 3;
  inline ::google::protobuf::int64 work_cd_start_time() const;
  inline void set_work_cd_start_time(::google::protobuf::int64 value);

  // required int64 fawn_on_cd_start_time = 4;
  inline bool has_fawn_on_cd_start_time() const;
  inline void clear_fawn_on_cd_start_time();
  static const int kFawnOnCdStartTimeFieldNumber = 4;
  inline ::google::protobuf::int64 fawn_on_cd_start_time() const;
  inline void set_fawn_on_cd_start_time(::google::protobuf::int64 value);

  // required int64 help_cd_start_time = 5;
  inline bool has_help_cd_start_time() const;
  inline void clear_help_cd_start_time();
  static const int kHelpCdStartTimeFieldNumber = 5;
  inline ::google::protobuf::int64 help_cd_start_time() const;
  inline void set_help_cd_start_time(::google::protobuf::int64 value);

  // required int64 revolt_cd_start_time = 6;
  inline bool has_revolt_cd_start_time() const;
  inline void clear_revolt_cd_start_time();
  static const int kRevoltCdStartTimeFieldNumber = 6;
  inline ::google::protobuf::int64 revolt_cd_start_time() const;
  inline void set_revolt_cd_start_time(::google::protobuf::int64 value);

  // required int64 slaved_start_time = 7;
  inline bool has_slaved_start_time() const;
  inline void clear_slaved_start_time();
  static const int kSlavedStartTimeFieldNumber = 7;
  inline ::google::protobuf::int64 slaved_start_time() const;
  inline void set_slaved_start_time(::google::protobuf::int64 value);

  // required int64 show_start_time = 8;
  inline bool has_show_start_time() const;
  inline void clear_show_start_time();
  static const int kShowStartTimeFieldNumber = 8;
  inline ::google::protobuf::int64 show_start_time() const;
  inline void set_show_start_time(::google::protobuf::int64 value);

  // required int64 get_res_start_time = 9;
  inline bool has_get_res_start_time() const;
  inline void clear_get_res_start_time();
  static const int kGetResStartTimeFieldNumber = 9;
  inline ::google::protobuf::int64 get_res_start_time() const;
  inline void set_get_res_start_time(::google::protobuf::int64 value);

  // required int32 show_watch_num = 10;
  inline bool has_show_watch_num() const;
  inline void clear_show_watch_num();
  static const int kShowWatchNumFieldNumber = 10;
  inline ::google::protobuf::int32 show_watch_num() const;
  inline void set_show_watch_num(::google::protobuf::int32 value);

  // required int32 get_slaves_times = 11;
  inline bool has_get_slaves_times() const;
  inline void clear_get_slaves_times();
  static const int kGetSlavesTimesFieldNumber = 11;
  inline ::google::protobuf::int32 get_slaves_times() const;
  inline void set_get_slaves_times(::google::protobuf::int32 value);

  // required int32 buy_get_slaves_times = 12;
  inline bool has_buy_get_slaves_times() const;
  inline void clear_buy_get_slaves_times();
  static const int kBuyGetSlavesTimesFieldNumber = 12;
  inline ::google::protobuf::int32 buy_get_slaves_times() const;
  inline void set_buy_get_slaves_times(::google::protobuf::int32 value);

  // required int32 get_save_times = 13;
  inline bool has_get_save_times() const;
  inline void clear_get_save_times();
  static const int kGetSaveTimesFieldNumber = 13;
  inline ::google::protobuf::int32 get_save_times() const;
  inline void set_get_save_times(::google::protobuf::int32 value);

  // required int32 buy_get_save_times = 14;
  inline bool has_buy_get_save_times() const;
  inline void clear_buy_get_save_times();
  static const int kBuyGetSaveTimesFieldNumber = 14;
  inline ::google::protobuf::int32 buy_get_save_times() const;
  inline void set_buy_get_save_times(::google::protobuf::int32 value);

  // optional string master = 15;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 15;
  inline const ::std::string& master() const;
  inline void set_master(const ::std::string& value);
  inline void set_master(const char* value);
  inline void set_master(const char* value, size_t size);
  inline ::std::string* mutable_master();
  inline ::std::string* release_master();
  inline void set_allocated_master(::std::string* master);

  // repeated string slave_list = 16;
  inline int slave_list_size() const;
  inline void clear_slave_list();
  static const int kSlaveListFieldNumber = 16;
  inline const ::std::string& slave_list(int index) const;
  inline ::std::string* mutable_slave_list(int index);
  inline void set_slave_list(int index, const ::std::string& value);
  inline void set_slave_list(int index, const char* value);
  inline void set_slave_list(int index, const char* value, size_t size);
  inline ::std::string* add_slave_list();
  inline void add_slave_list(const ::std::string& value);
  inline void add_slave_list(const char* value);
  inline void add_slave_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& slave_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_slave_list();

  // repeated string enemy_list = 17;
  inline int enemy_list_size() const;
  inline void clear_enemy_list();
  static const int kEnemyListFieldNumber = 17;
  inline const ::std::string& enemy_list(int index) const;
  inline ::std::string* mutable_enemy_list(int index);
  inline void set_enemy_list(int index, const ::std::string& value);
  inline void set_enemy_list(int index, const char* value);
  inline void set_enemy_list(int index, const char* value, size_t size);
  inline ::std::string* add_enemy_list();
  inline void add_enemy_list(const ::std::string& value);
  inline void add_enemy_list(const char* value);
  inline void add_enemy_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& enemy_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_enemy_list();

  // repeated string help_list = 18;
  inline int help_list_size() const;
  inline void clear_help_list();
  static const int kHelpListFieldNumber = 18;
  inline const ::std::string& help_list(int index) const;
  inline ::std::string* mutable_help_list(int index);
  inline void set_help_list(int index, const ::std::string& value);
  inline void set_help_list(int index, const char* value);
  inline void set_help_list(int index, const char* value, size_t size);
  inline ::std::string* add_help_list();
  inline void add_help_list(const ::std::string& value);
  inline void add_help_list(const char* value);
  inline void add_help_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& help_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_help_list();

  // repeated string watch_list = 19;
  inline int watch_list_size() const;
  inline void clear_watch_list();
  static const int kWatchListFieldNumber = 19;
  inline const ::std::string& watch_list(int index) const;
  inline ::std::string* mutable_watch_list(int index);
  inline void set_watch_list(int index, const ::std::string& value);
  inline void set_watch_list(int index, const char* value);
  inline void set_watch_list(int index, const char* value, size_t size);
  inline ::std::string* add_watch_list();
  inline void add_watch_list(const ::std::string& value);
  inline void add_watch_list(const char* value);
  inline void add_watch_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& watch_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_watch_list();

  // repeated .SlaveNoteInfo note = 20;
  inline int note_size() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 20;
  inline const ::SlaveNoteInfo& note(int index) const;
  inline ::SlaveNoteInfo* mutable_note(int index);
  inline ::SlaveNoteInfo* add_note();
  inline const ::google::protobuf::RepeatedPtrField< ::SlaveNoteInfo >&
      note() const;
  inline ::google::protobuf::RepeatedPtrField< ::SlaveNoteInfo >*
      mutable_note();

  // repeated int64 res_pool = 21;
  inline int res_pool_size() const;
  inline void clear_res_pool();
  static const int kResPoolFieldNumber = 21;
  inline ::google::protobuf::int64 res_pool(int index) const;
  inline void set_res_pool(int index, ::google::protobuf::int64 value);
  inline void add_res_pool(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      res_pool() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_res_pool();

  // required int64 exp_pool = 22;
  inline bool has_exp_pool() const;
  inline void clear_exp_pool();
  static const int kExpPoolFieldNumber = 22;
  inline ::google::protobuf::int64 exp_pool() const;
  inline void set_exp_pool(::google::protobuf::int64 value);

  // repeated int64 res_sub_cache = 23;
  inline int res_sub_cache_size() const;
  inline void clear_res_sub_cache();
  static const int kResSubCacheFieldNumber = 23;
  inline ::google::protobuf::int64 res_sub_cache(int index) const;
  inline void set_res_sub_cache(int index, ::google::protobuf::int64 value);
  inline void add_res_sub_cache(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      res_sub_cache() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_res_sub_cache();

  // @@protoc_insertion_point(class_scope:SlaveData)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_work_cd_start_time();
  inline void clear_has_work_cd_start_time();
  inline void set_has_fawn_on_cd_start_time();
  inline void clear_has_fawn_on_cd_start_time();
  inline void set_has_help_cd_start_time();
  inline void clear_has_help_cd_start_time();
  inline void set_has_revolt_cd_start_time();
  inline void clear_has_revolt_cd_start_time();
  inline void set_has_slaved_start_time();
  inline void clear_has_slaved_start_time();
  inline void set_has_show_start_time();
  inline void clear_has_show_start_time();
  inline void set_has_get_res_start_time();
  inline void clear_has_get_res_start_time();
  inline void set_has_show_watch_num();
  inline void clear_has_show_watch_num();
  inline void set_has_get_slaves_times();
  inline void clear_has_get_slaves_times();
  inline void set_has_buy_get_slaves_times();
  inline void clear_has_buy_get_slaves_times();
  inline void set_has_get_save_times();
  inline void clear_has_get_save_times();
  inline void set_has_buy_get_save_times();
  inline void clear_has_buy_get_save_times();
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_exp_pool();
  inline void clear_has_exp_pool();

  ::std::string* user_name_;
  ::google::protobuf::int64 work_cd_start_time_;
  ::google::protobuf::int64 fawn_on_cd_start_time_;
  ::google::protobuf::int64 help_cd_start_time_;
  ::google::protobuf::int64 revolt_cd_start_time_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 show_watch_num_;
  ::google::protobuf::int64 slaved_start_time_;
  ::google::protobuf::int64 show_start_time_;
  ::google::protobuf::int64 get_res_start_time_;
  ::google::protobuf::int32 get_slaves_times_;
  ::google::protobuf::int32 buy_get_slaves_times_;
  ::google::protobuf::int32 get_save_times_;
  ::google::protobuf::int32 buy_get_save_times_;
  ::std::string* master_;
  ::google::protobuf::RepeatedPtrField< ::std::string> slave_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> enemy_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> help_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> watch_list_;
  ::google::protobuf::RepeatedPtrField< ::SlaveNoteInfo > note_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > res_pool_;
  ::google::protobuf::int64 exp_pool_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > res_sub_cache_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Slave_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Slave_2eproto();
  #endif
  friend void protobuf_AssignDesc_Slave_2eproto();
  friend void protobuf_ShutdownFile_Slave_2eproto();

  void InitAsDefaultInstance();
  static SlaveData* default_instance_;
};
// -------------------------------------------------------------------

class SlaveBriefInfo : public ::google::protobuf::MessageLite {
 public:
  SlaveBriefInfo();
  virtual ~SlaveBriefInfo();

  SlaveBriefInfo(const SlaveBriefInfo& from);

  inline SlaveBriefInfo& operator=(const SlaveBriefInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SlaveBriefInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SlaveBriefInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SlaveBriefInfo* other);

  // implements Message ----------------------------------------------

  SlaveBriefInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SlaveBriefInfo& from);
  void MergeFrom(const SlaveBriefInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required int32 icon_id = 3;
  inline bool has_icon_id() const;
  inline void clear_icon_id();
  static const int kIconIdFieldNumber = 3;
  inline ::google::protobuf::int32 icon_id() const;
  inline void set_icon_id(::google::protobuf::int32 value);

  // required int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 power = 5;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 5;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // required int32 slave_count = 6;
  inline bool has_slave_count() const;
  inline void clear_slave_count();
  static const int kSlaveCountFieldNumber = 6;
  inline ::google::protobuf::int32 slave_count() const;
  inline void set_slave_count(::google::protobuf::int32 value);

  // required int32 state = 7;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string group_nickname = 8;
  inline bool has_group_nickname() const;
  inline void clear_group_nickname();
  static const int kGroupNicknameFieldNumber = 8;
  inline const ::std::string& group_nickname() const;
  inline void set_group_nickname(const ::std::string& value);
  inline void set_group_nickname(const char* value);
  inline void set_group_nickname(const char* value, size_t size);
  inline ::std::string* mutable_group_nickname();
  inline ::std::string* release_group_nickname();
  inline void set_allocated_group_nickname(::std::string* group_nickname);

  // optional string master = 9;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 9;
  inline const ::std::string& master() const;
  inline void set_master(const ::std::string& value);
  inline void set_master(const char* value);
  inline void set_master(const char* value, size_t size);
  inline ::std::string* mutable_master();
  inline ::std::string* release_master();
  inline void set_allocated_master(::std::string* master);

  // optional string master_nickname = 10;
  inline bool has_master_nickname() const;
  inline void clear_master_nickname();
  static const int kMasterNicknameFieldNumber = 10;
  inline const ::std::string& master_nickname() const;
  inline void set_master_nickname(const ::std::string& value);
  inline void set_master_nickname(const char* value);
  inline void set_master_nickname(const char* value, size_t size);
  inline ::std::string* mutable_master_nickname();
  inline ::std::string* release_master_nickname();
  inline void set_allocated_master_nickname(::std::string* master_nickname);

  // @@protoc_insertion_point(class_scope:SlaveBriefInfo)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_icon_id();
  inline void clear_has_icon_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_slave_count();
  inline void clear_has_slave_count();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_group_nickname();
  inline void clear_has_group_nickname();
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_master_nickname();
  inline void clear_has_master_nickname();

  ::std::string* user_name_;
  ::std::string* nickname_;
  ::google::protobuf::int32 icon_id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 slave_count_;
  ::std::string* group_nickname_;
  ::std::string* master_;
  ::std::string* master_nickname_;
  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Slave_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Slave_2eproto();
  #endif
  friend void protobuf_AssignDesc_Slave_2eproto();
  friend void protobuf_ShutdownFile_Slave_2eproto();

  void InitAsDefaultInstance();
  static SlaveBriefInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// SlaveNoteInfo

// required .SlaveNoteInfo.SlaveNoteType type = 1;
inline bool SlaveNoteInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveNoteInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveNoteInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveNoteInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SlaveNoteInfo_SlaveNoteType SlaveNoteInfo::type() const {
  return static_cast< ::SlaveNoteInfo_SlaveNoteType >(type_);
}
inline void SlaveNoteInfo::set_type(::SlaveNoteInfo_SlaveNoteType value) {
  assert(::SlaveNoteInfo_SlaveNoteType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 text_index = 2;
inline bool SlaveNoteInfo::has_text_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveNoteInfo::set_has_text_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveNoteInfo::clear_has_text_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveNoteInfo::clear_text_index() {
  text_index_ = 0;
  clear_has_text_index();
}
inline ::google::protobuf::int32 SlaveNoteInfo::text_index() const {
  return text_index_;
}
inline void SlaveNoteInfo::set_text_index(::google::protobuf::int32 value) {
  set_has_text_index();
  text_index_ = value;
}

// repeated string param_list = 3;
inline int SlaveNoteInfo::param_list_size() const {
  return param_list_.size();
}
inline void SlaveNoteInfo::clear_param_list() {
  param_list_.Clear();
}
inline const ::std::string& SlaveNoteInfo::param_list(int index) const {
  return param_list_.Get(index);
}
inline ::std::string* SlaveNoteInfo::mutable_param_list(int index) {
  return param_list_.Mutable(index);
}
inline void SlaveNoteInfo::set_param_list(int index, const ::std::string& value) {
  param_list_.Mutable(index)->assign(value);
}
inline void SlaveNoteInfo::set_param_list(int index, const char* value) {
  param_list_.Mutable(index)->assign(value);
}
inline void SlaveNoteInfo::set_param_list(int index, const char* value, size_t size) {
  param_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveNoteInfo::add_param_list() {
  return param_list_.Add();
}
inline void SlaveNoteInfo::add_param_list(const ::std::string& value) {
  param_list_.Add()->assign(value);
}
inline void SlaveNoteInfo::add_param_list(const char* value) {
  param_list_.Add()->assign(value);
}
inline void SlaveNoteInfo::add_param_list(const char* value, size_t size) {
  param_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SlaveNoteInfo::param_list() const {
  return param_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SlaveNoteInfo::mutable_param_list() {
  return &param_list_;
}

// -------------------------------------------------------------------

// SlaveData

// required string user_name = 1;
inline bool SlaveData::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveData::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveData::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveData::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& SlaveData::user_name() const {
  return *user_name_;
}
inline void SlaveData::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void SlaveData::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void SlaveData::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveData::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* SlaveData::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveData::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 state = 2;
inline bool SlaveData::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveData::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveData::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveData::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 SlaveData::state() const {
  return state_;
}
inline void SlaveData::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// required int64 work_cd_start_time = 3;
inline bool SlaveData::has_work_cd_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveData::set_has_work_cd_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveData::clear_has_work_cd_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveData::clear_work_cd_start_time() {
  work_cd_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_work_cd_start_time();
}
inline ::google::protobuf::int64 SlaveData::work_cd_start_time() const {
  return work_cd_start_time_;
}
inline void SlaveData::set_work_cd_start_time(::google::protobuf::int64 value) {
  set_has_work_cd_start_time();
  work_cd_start_time_ = value;
}

// required int64 fawn_on_cd_start_time = 4;
inline bool SlaveData::has_fawn_on_cd_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveData::set_has_fawn_on_cd_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveData::clear_has_fawn_on_cd_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveData::clear_fawn_on_cd_start_time() {
  fawn_on_cd_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_fawn_on_cd_start_time();
}
inline ::google::protobuf::int64 SlaveData::fawn_on_cd_start_time() const {
  return fawn_on_cd_start_time_;
}
inline void SlaveData::set_fawn_on_cd_start_time(::google::protobuf::int64 value) {
  set_has_fawn_on_cd_start_time();
  fawn_on_cd_start_time_ = value;
}

// required int64 help_cd_start_time = 5;
inline bool SlaveData::has_help_cd_start_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveData::set_has_help_cd_start_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveData::clear_has_help_cd_start_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveData::clear_help_cd_start_time() {
  help_cd_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_help_cd_start_time();
}
inline ::google::protobuf::int64 SlaveData::help_cd_start_time() const {
  return help_cd_start_time_;
}
inline void SlaveData::set_help_cd_start_time(::google::protobuf::int64 value) {
  set_has_help_cd_start_time();
  help_cd_start_time_ = value;
}

// required int64 revolt_cd_start_time = 6;
inline bool SlaveData::has_revolt_cd_start_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveData::set_has_revolt_cd_start_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveData::clear_has_revolt_cd_start_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveData::clear_revolt_cd_start_time() {
  revolt_cd_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_revolt_cd_start_time();
}
inline ::google::protobuf::int64 SlaveData::revolt_cd_start_time() const {
  return revolt_cd_start_time_;
}
inline void SlaveData::set_revolt_cd_start_time(::google::protobuf::int64 value) {
  set_has_revolt_cd_start_time();
  revolt_cd_start_time_ = value;
}

// required int64 slaved_start_time = 7;
inline bool SlaveData::has_slaved_start_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlaveData::set_has_slaved_start_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlaveData::clear_has_slaved_start_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlaveData::clear_slaved_start_time() {
  slaved_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_slaved_start_time();
}
inline ::google::protobuf::int64 SlaveData::slaved_start_time() const {
  return slaved_start_time_;
}
inline void SlaveData::set_slaved_start_time(::google::protobuf::int64 value) {
  set_has_slaved_start_time();
  slaved_start_time_ = value;
}

// required int64 show_start_time = 8;
inline bool SlaveData::has_show_start_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SlaveData::set_has_show_start_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SlaveData::clear_has_show_start_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SlaveData::clear_show_start_time() {
  show_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_show_start_time();
}
inline ::google::protobuf::int64 SlaveData::show_start_time() const {
  return show_start_time_;
}
inline void SlaveData::set_show_start_time(::google::protobuf::int64 value) {
  set_has_show_start_time();
  show_start_time_ = value;
}

// required int64 get_res_start_time = 9;
inline bool SlaveData::has_get_res_start_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SlaveData::set_has_get_res_start_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SlaveData::clear_has_get_res_start_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SlaveData::clear_get_res_start_time() {
  get_res_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_get_res_start_time();
}
inline ::google::protobuf::int64 SlaveData::get_res_start_time() const {
  return get_res_start_time_;
}
inline void SlaveData::set_get_res_start_time(::google::protobuf::int64 value) {
  set_has_get_res_start_time();
  get_res_start_time_ = value;
}

// required int32 show_watch_num = 10;
inline bool SlaveData::has_show_watch_num() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SlaveData::set_has_show_watch_num() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SlaveData::clear_has_show_watch_num() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SlaveData::clear_show_watch_num() {
  show_watch_num_ = 0;
  clear_has_show_watch_num();
}
inline ::google::protobuf::int32 SlaveData::show_watch_num() const {
  return show_watch_num_;
}
inline void SlaveData::set_show_watch_num(::google::protobuf::int32 value) {
  set_has_show_watch_num();
  show_watch_num_ = value;
}

// required int32 get_slaves_times = 11;
inline bool SlaveData::has_get_slaves_times() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SlaveData::set_has_get_slaves_times() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SlaveData::clear_has_get_slaves_times() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SlaveData::clear_get_slaves_times() {
  get_slaves_times_ = 0;
  clear_has_get_slaves_times();
}
inline ::google::protobuf::int32 SlaveData::get_slaves_times() const {
  return get_slaves_times_;
}
inline void SlaveData::set_get_slaves_times(::google::protobuf::int32 value) {
  set_has_get_slaves_times();
  get_slaves_times_ = value;
}

// required int32 buy_get_slaves_times = 12;
inline bool SlaveData::has_buy_get_slaves_times() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SlaveData::set_has_buy_get_slaves_times() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SlaveData::clear_has_buy_get_slaves_times() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SlaveData::clear_buy_get_slaves_times() {
  buy_get_slaves_times_ = 0;
  clear_has_buy_get_slaves_times();
}
inline ::google::protobuf::int32 SlaveData::buy_get_slaves_times() const {
  return buy_get_slaves_times_;
}
inline void SlaveData::set_buy_get_slaves_times(::google::protobuf::int32 value) {
  set_has_buy_get_slaves_times();
  buy_get_slaves_times_ = value;
}

// required int32 get_save_times = 13;
inline bool SlaveData::has_get_save_times() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SlaveData::set_has_get_save_times() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SlaveData::clear_has_get_save_times() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SlaveData::clear_get_save_times() {
  get_save_times_ = 0;
  clear_has_get_save_times();
}
inline ::google::protobuf::int32 SlaveData::get_save_times() const {
  return get_save_times_;
}
inline void SlaveData::set_get_save_times(::google::protobuf::int32 value) {
  set_has_get_save_times();
  get_save_times_ = value;
}

// required int32 buy_get_save_times = 14;
inline bool SlaveData::has_buy_get_save_times() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SlaveData::set_has_buy_get_save_times() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SlaveData::clear_has_buy_get_save_times() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SlaveData::clear_buy_get_save_times() {
  buy_get_save_times_ = 0;
  clear_has_buy_get_save_times();
}
inline ::google::protobuf::int32 SlaveData::buy_get_save_times() const {
  return buy_get_save_times_;
}
inline void SlaveData::set_buy_get_save_times(::google::protobuf::int32 value) {
  set_has_buy_get_save_times();
  buy_get_save_times_ = value;
}

// optional string master = 15;
inline bool SlaveData::has_master() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SlaveData::set_has_master() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SlaveData::clear_has_master() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SlaveData::clear_master() {
  if (master_ != &::google::protobuf::internal::kEmptyString) {
    master_->clear();
  }
  clear_has_master();
}
inline const ::std::string& SlaveData::master() const {
  return *master_;
}
inline void SlaveData::set_master(const ::std::string& value) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(value);
}
inline void SlaveData::set_master(const char* value) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(value);
}
inline void SlaveData::set_master(const char* value, size_t size) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveData::mutable_master() {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  return master_;
}
inline ::std::string* SlaveData::release_master() {
  clear_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = master_;
    master_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveData::set_allocated_master(::std::string* master) {
  if (master_ != &::google::protobuf::internal::kEmptyString) {
    delete master_;
  }
  if (master) {
    set_has_master();
    master_ = master;
  } else {
    clear_has_master();
    master_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string slave_list = 16;
inline int SlaveData::slave_list_size() const {
  return slave_list_.size();
}
inline void SlaveData::clear_slave_list() {
  slave_list_.Clear();
}
inline const ::std::string& SlaveData::slave_list(int index) const {
  return slave_list_.Get(index);
}
inline ::std::string* SlaveData::mutable_slave_list(int index) {
  return slave_list_.Mutable(index);
}
inline void SlaveData::set_slave_list(int index, const ::std::string& value) {
  slave_list_.Mutable(index)->assign(value);
}
inline void SlaveData::set_slave_list(int index, const char* value) {
  slave_list_.Mutable(index)->assign(value);
}
inline void SlaveData::set_slave_list(int index, const char* value, size_t size) {
  slave_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveData::add_slave_list() {
  return slave_list_.Add();
}
inline void SlaveData::add_slave_list(const ::std::string& value) {
  slave_list_.Add()->assign(value);
}
inline void SlaveData::add_slave_list(const char* value) {
  slave_list_.Add()->assign(value);
}
inline void SlaveData::add_slave_list(const char* value, size_t size) {
  slave_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SlaveData::slave_list() const {
  return slave_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SlaveData::mutable_slave_list() {
  return &slave_list_;
}

// repeated string enemy_list = 17;
inline int SlaveData::enemy_list_size() const {
  return enemy_list_.size();
}
inline void SlaveData::clear_enemy_list() {
  enemy_list_.Clear();
}
inline const ::std::string& SlaveData::enemy_list(int index) const {
  return enemy_list_.Get(index);
}
inline ::std::string* SlaveData::mutable_enemy_list(int index) {
  return enemy_list_.Mutable(index);
}
inline void SlaveData::set_enemy_list(int index, const ::std::string& value) {
  enemy_list_.Mutable(index)->assign(value);
}
inline void SlaveData::set_enemy_list(int index, const char* value) {
  enemy_list_.Mutable(index)->assign(value);
}
inline void SlaveData::set_enemy_list(int index, const char* value, size_t size) {
  enemy_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveData::add_enemy_list() {
  return enemy_list_.Add();
}
inline void SlaveData::add_enemy_list(const ::std::string& value) {
  enemy_list_.Add()->assign(value);
}
inline void SlaveData::add_enemy_list(const char* value) {
  enemy_list_.Add()->assign(value);
}
inline void SlaveData::add_enemy_list(const char* value, size_t size) {
  enemy_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SlaveData::enemy_list() const {
  return enemy_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SlaveData::mutable_enemy_list() {
  return &enemy_list_;
}

// repeated string help_list = 18;
inline int SlaveData::help_list_size() const {
  return help_list_.size();
}
inline void SlaveData::clear_help_list() {
  help_list_.Clear();
}
inline const ::std::string& SlaveData::help_list(int index) const {
  return help_list_.Get(index);
}
inline ::std::string* SlaveData::mutable_help_list(int index) {
  return help_list_.Mutable(index);
}
inline void SlaveData::set_help_list(int index, const ::std::string& value) {
  help_list_.Mutable(index)->assign(value);
}
inline void SlaveData::set_help_list(int index, const char* value) {
  help_list_.Mutable(index)->assign(value);
}
inline void SlaveData::set_help_list(int index, const char* value, size_t size) {
  help_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveData::add_help_list() {
  return help_list_.Add();
}
inline void SlaveData::add_help_list(const ::std::string& value) {
  help_list_.Add()->assign(value);
}
inline void SlaveData::add_help_list(const char* value) {
  help_list_.Add()->assign(value);
}
inline void SlaveData::add_help_list(const char* value, size_t size) {
  help_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SlaveData::help_list() const {
  return help_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SlaveData::mutable_help_list() {
  return &help_list_;
}

// repeated string watch_list = 19;
inline int SlaveData::watch_list_size() const {
  return watch_list_.size();
}
inline void SlaveData::clear_watch_list() {
  watch_list_.Clear();
}
inline const ::std::string& SlaveData::watch_list(int index) const {
  return watch_list_.Get(index);
}
inline ::std::string* SlaveData::mutable_watch_list(int index) {
  return watch_list_.Mutable(index);
}
inline void SlaveData::set_watch_list(int index, const ::std::string& value) {
  watch_list_.Mutable(index)->assign(value);
}
inline void SlaveData::set_watch_list(int index, const char* value) {
  watch_list_.Mutable(index)->assign(value);
}
inline void SlaveData::set_watch_list(int index, const char* value, size_t size) {
  watch_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveData::add_watch_list() {
  return watch_list_.Add();
}
inline void SlaveData::add_watch_list(const ::std::string& value) {
  watch_list_.Add()->assign(value);
}
inline void SlaveData::add_watch_list(const char* value) {
  watch_list_.Add()->assign(value);
}
inline void SlaveData::add_watch_list(const char* value, size_t size) {
  watch_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SlaveData::watch_list() const {
  return watch_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SlaveData::mutable_watch_list() {
  return &watch_list_;
}

// repeated .SlaveNoteInfo note = 20;
inline int SlaveData::note_size() const {
  return note_.size();
}
inline void SlaveData::clear_note() {
  note_.Clear();
}
inline const ::SlaveNoteInfo& SlaveData::note(int index) const {
  return note_.Get(index);
}
inline ::SlaveNoteInfo* SlaveData::mutable_note(int index) {
  return note_.Mutable(index);
}
inline ::SlaveNoteInfo* SlaveData::add_note() {
  return note_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SlaveNoteInfo >&
SlaveData::note() const {
  return note_;
}
inline ::google::protobuf::RepeatedPtrField< ::SlaveNoteInfo >*
SlaveData::mutable_note() {
  return &note_;
}

// repeated int64 res_pool = 21;
inline int SlaveData::res_pool_size() const {
  return res_pool_.size();
}
inline void SlaveData::clear_res_pool() {
  res_pool_.Clear();
}
inline ::google::protobuf::int64 SlaveData::res_pool(int index) const {
  return res_pool_.Get(index);
}
inline void SlaveData::set_res_pool(int index, ::google::protobuf::int64 value) {
  res_pool_.Set(index, value);
}
inline void SlaveData::add_res_pool(::google::protobuf::int64 value) {
  res_pool_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SlaveData::res_pool() const {
  return res_pool_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SlaveData::mutable_res_pool() {
  return &res_pool_;
}

// required int64 exp_pool = 22;
inline bool SlaveData::has_exp_pool() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SlaveData::set_has_exp_pool() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SlaveData::clear_has_exp_pool() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SlaveData::clear_exp_pool() {
  exp_pool_ = GOOGLE_LONGLONG(0);
  clear_has_exp_pool();
}
inline ::google::protobuf::int64 SlaveData::exp_pool() const {
  return exp_pool_;
}
inline void SlaveData::set_exp_pool(::google::protobuf::int64 value) {
  set_has_exp_pool();
  exp_pool_ = value;
}

// repeated int64 res_sub_cache = 23;
inline int SlaveData::res_sub_cache_size() const {
  return res_sub_cache_.size();
}
inline void SlaveData::clear_res_sub_cache() {
  res_sub_cache_.Clear();
}
inline ::google::protobuf::int64 SlaveData::res_sub_cache(int index) const {
  return res_sub_cache_.Get(index);
}
inline void SlaveData::set_res_sub_cache(int index, ::google::protobuf::int64 value) {
  res_sub_cache_.Set(index, value);
}
inline void SlaveData::add_res_sub_cache(::google::protobuf::int64 value) {
  res_sub_cache_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SlaveData::res_sub_cache() const {
  return res_sub_cache_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SlaveData::mutable_res_sub_cache() {
  return &res_sub_cache_;
}

// -------------------------------------------------------------------

// SlaveBriefInfo

// required string user_name = 1;
inline bool SlaveBriefInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveBriefInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveBriefInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveBriefInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& SlaveBriefInfo::user_name() const {
  return *user_name_;
}
inline void SlaveBriefInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void SlaveBriefInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void SlaveBriefInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveBriefInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* SlaveBriefInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveBriefInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string nickname = 2;
inline bool SlaveBriefInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveBriefInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveBriefInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveBriefInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& SlaveBriefInfo::nickname() const {
  return *nickname_;
}
inline void SlaveBriefInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void SlaveBriefInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void SlaveBriefInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveBriefInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* SlaveBriefInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveBriefInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 icon_id = 3;
inline bool SlaveBriefInfo::has_icon_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveBriefInfo::set_has_icon_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveBriefInfo::clear_has_icon_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveBriefInfo::clear_icon_id() {
  icon_id_ = 0;
  clear_has_icon_id();
}
inline ::google::protobuf::int32 SlaveBriefInfo::icon_id() const {
  return icon_id_;
}
inline void SlaveBriefInfo::set_icon_id(::google::protobuf::int32 value) {
  set_has_icon_id();
  icon_id_ = value;
}

// required int32 level = 4;
inline bool SlaveBriefInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveBriefInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveBriefInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveBriefInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 SlaveBriefInfo::level() const {
  return level_;
}
inline void SlaveBriefInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 power = 5;
inline bool SlaveBriefInfo::has_power() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveBriefInfo::set_has_power() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveBriefInfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveBriefInfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 SlaveBriefInfo::power() const {
  return power_;
}
inline void SlaveBriefInfo::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// required int32 slave_count = 6;
inline bool SlaveBriefInfo::has_slave_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveBriefInfo::set_has_slave_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveBriefInfo::clear_has_slave_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveBriefInfo::clear_slave_count() {
  slave_count_ = 0;
  clear_has_slave_count();
}
inline ::google::protobuf::int32 SlaveBriefInfo::slave_count() const {
  return slave_count_;
}
inline void SlaveBriefInfo::set_slave_count(::google::protobuf::int32 value) {
  set_has_slave_count();
  slave_count_ = value;
}

// required int32 state = 7;
inline bool SlaveBriefInfo::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlaveBriefInfo::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlaveBriefInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlaveBriefInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 SlaveBriefInfo::state() const {
  return state_;
}
inline void SlaveBriefInfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional string group_nickname = 8;
inline bool SlaveBriefInfo::has_group_nickname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SlaveBriefInfo::set_has_group_nickname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SlaveBriefInfo::clear_has_group_nickname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SlaveBriefInfo::clear_group_nickname() {
  if (group_nickname_ != &::google::protobuf::internal::kEmptyString) {
    group_nickname_->clear();
  }
  clear_has_group_nickname();
}
inline const ::std::string& SlaveBriefInfo::group_nickname() const {
  return *group_nickname_;
}
inline void SlaveBriefInfo::set_group_nickname(const ::std::string& value) {
  set_has_group_nickname();
  if (group_nickname_ == &::google::protobuf::internal::kEmptyString) {
    group_nickname_ = new ::std::string;
  }
  group_nickname_->assign(value);
}
inline void SlaveBriefInfo::set_group_nickname(const char* value) {
  set_has_group_nickname();
  if (group_nickname_ == &::google::protobuf::internal::kEmptyString) {
    group_nickname_ = new ::std::string;
  }
  group_nickname_->assign(value);
}
inline void SlaveBriefInfo::set_group_nickname(const char* value, size_t size) {
  set_has_group_nickname();
  if (group_nickname_ == &::google::protobuf::internal::kEmptyString) {
    group_nickname_ = new ::std::string;
  }
  group_nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveBriefInfo::mutable_group_nickname() {
  set_has_group_nickname();
  if (group_nickname_ == &::google::protobuf::internal::kEmptyString) {
    group_nickname_ = new ::std::string;
  }
  return group_nickname_;
}
inline ::std::string* SlaveBriefInfo::release_group_nickname() {
  clear_has_group_nickname();
  if (group_nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_nickname_;
    group_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveBriefInfo::set_allocated_group_nickname(::std::string* group_nickname) {
  if (group_nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete group_nickname_;
  }
  if (group_nickname) {
    set_has_group_nickname();
    group_nickname_ = group_nickname;
  } else {
    clear_has_group_nickname();
    group_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string master = 9;
inline bool SlaveBriefInfo::has_master() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SlaveBriefInfo::set_has_master() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SlaveBriefInfo::clear_has_master() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SlaveBriefInfo::clear_master() {
  if (master_ != &::google::protobuf::internal::kEmptyString) {
    master_->clear();
  }
  clear_has_master();
}
inline const ::std::string& SlaveBriefInfo::master() const {
  return *master_;
}
inline void SlaveBriefInfo::set_master(const ::std::string& value) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(value);
}
inline void SlaveBriefInfo::set_master(const char* value) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(value);
}
inline void SlaveBriefInfo::set_master(const char* value, size_t size) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveBriefInfo::mutable_master() {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  return master_;
}
inline ::std::string* SlaveBriefInfo::release_master() {
  clear_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = master_;
    master_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveBriefInfo::set_allocated_master(::std::string* master) {
  if (master_ != &::google::protobuf::internal::kEmptyString) {
    delete master_;
  }
  if (master) {
    set_has_master();
    master_ = master;
  } else {
    clear_has_master();
    master_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string master_nickname = 10;
inline bool SlaveBriefInfo::has_master_nickname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SlaveBriefInfo::set_has_master_nickname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SlaveBriefInfo::clear_has_master_nickname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SlaveBriefInfo::clear_master_nickname() {
  if (master_nickname_ != &::google::protobuf::internal::kEmptyString) {
    master_nickname_->clear();
  }
  clear_has_master_nickname();
}
inline const ::std::string& SlaveBriefInfo::master_nickname() const {
  return *master_nickname_;
}
inline void SlaveBriefInfo::set_master_nickname(const ::std::string& value) {
  set_has_master_nickname();
  if (master_nickname_ == &::google::protobuf::internal::kEmptyString) {
    master_nickname_ = new ::std::string;
  }
  master_nickname_->assign(value);
}
inline void SlaveBriefInfo::set_master_nickname(const char* value) {
  set_has_master_nickname();
  if (master_nickname_ == &::google::protobuf::internal::kEmptyString) {
    master_nickname_ = new ::std::string;
  }
  master_nickname_->assign(value);
}
inline void SlaveBriefInfo::set_master_nickname(const char* value, size_t size) {
  set_has_master_nickname();
  if (master_nickname_ == &::google::protobuf::internal::kEmptyString) {
    master_nickname_ = new ::std::string;
  }
  master_nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveBriefInfo::mutable_master_nickname() {
  set_has_master_nickname();
  if (master_nickname_ == &::google::protobuf::internal::kEmptyString) {
    master_nickname_ = new ::std::string;
  }
  return master_nickname_;
}
inline ::std::string* SlaveBriefInfo::release_master_nickname() {
  clear_has_master_nickname();
  if (master_nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = master_nickname_;
    master_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveBriefInfo::set_allocated_master_nickname(::std::string* master_nickname) {
  if (master_nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete master_nickname_;
  }
  if (master_nickname) {
    set_has_master_nickname();
    master_nickname_ = master_nickname;
  } else {
    clear_has_master_nickname();
    master_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Slave_2eproto__INCLUDED
