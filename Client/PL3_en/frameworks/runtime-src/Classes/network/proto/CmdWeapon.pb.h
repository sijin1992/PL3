// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdWeapon.proto

#ifndef PROTOBUF_CmdWeapon_2eproto__INCLUDED
#define PROTOBUF_CmdWeapon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "AirShip.pb.h"
#include "UserSync.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdWeapon_2eproto();
void protobuf_AssignDesc_CmdWeapon_2eproto();
void protobuf_ShutdownFile_CmdWeapon_2eproto();

class GetShipListReq;
class GetShipListResp;
class ChangeLineupReq;
class ChangeLineupResp;
class ChangeWeaponReq;
class ChangeWeaponResp;
class ShipDevelopeReq;
class ShipDevelopeResp;
class BlueprintDevelopeReq;
class BlueprintDevelopeResp;
class ShipRemoveReq;
class ShipRemoveResp;
class WeaponUpgradeReq;
class WeaponUpgradeResp;
class ShipBreakReq;
class ShipBreakResp;
class ShipAddExpReq;
class ShipAddExpResp;
class ShipFixReq;
class ShipFixResp;
class ShipAddEnergyExpReq;
class ShipAddEnergyExpResp;
class ShipLockEnergyTimeReq;
class ShipLockEnergyTimeResp;

// ===================================================================

class GetShipListReq : public ::google::protobuf::MessageLite {
 public:
  GetShipListReq();
  virtual ~GetShipListReq();

  GetShipListReq(const GetShipListReq& from);

  inline GetShipListReq& operator=(const GetShipListReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetShipListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetShipListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetShipListReq* other);

  // implements Message ----------------------------------------------

  GetShipListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetShipListReq& from);
  void MergeFrom(const GetShipListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ship_id = 1;
  inline bool has_ship_id() const;
  inline void clear_ship_id();
  static const int kShipIdFieldNumber = 1;
  inline ::google::protobuf::int32 ship_id() const;
  inline void set_ship_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GetShipListReq)
 private:
  inline void set_has_ship_id();
  inline void clear_has_ship_id();

  ::google::protobuf::int32 ship_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static GetShipListReq* default_instance_;
};
// -------------------------------------------------------------------

class GetShipListResp : public ::google::protobuf::MessageLite {
 public:
  GetShipListResp();
  virtual ~GetShipListResp();

  GetShipListResp(const GetShipListResp& from);

  inline GetShipListResp& operator=(const GetShipListResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetShipListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetShipListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetShipListResp* other);

  // implements Message ----------------------------------------------

  GetShipListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetShipListResp& from);
  void MergeFrom(const GetShipListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .AirShip ship_info = 2;
  inline bool has_ship_info() const;
  inline void clear_ship_info();
  static const int kShipInfoFieldNumber = 2;
  inline const ::AirShip& ship_info() const;
  inline ::AirShip* mutable_ship_info();
  inline ::AirShip* release_ship_info();
  inline void set_allocated_ship_info(::AirShip* ship_info);

  // repeated .AirShip ship_list = 3;
  inline int ship_list_size() const;
  inline void clear_ship_list();
  static const int kShipListFieldNumber = 3;
  inline const ::AirShip& ship_list(int index) const;
  inline ::AirShip* mutable_ship_list(int index);
  inline ::AirShip* add_ship_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
      ship_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
      mutable_ship_list();

  // @@protoc_insertion_point(class_scope:GetShipListResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_ship_info();
  inline void clear_has_ship_info();

  ::AirShip* ship_info_;
  ::google::protobuf::RepeatedPtrField< ::AirShip > ship_list_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static GetShipListResp* default_instance_;
};
// -------------------------------------------------------------------

class ChangeLineupReq : public ::google::protobuf::MessageLite {
 public:
  ChangeLineupReq();
  virtual ~ChangeLineupReq();

  ChangeLineupReq(const ChangeLineupReq& from);

  inline ChangeLineupReq& operator=(const ChangeLineupReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChangeLineupReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeLineupReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeLineupReq* other);

  // implements Message ----------------------------------------------

  ChangeLineupReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeLineupReq& from);
  void MergeFrom(const ChangeLineupReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int32 lineup = 2;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 2;
  inline ::google::protobuf::int32 lineup(int index) const;
  inline void set_lineup(int index, ::google::protobuf::int32 value);
  inline void add_lineup(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lineup();

  // optional int32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional string line_name = 4;
  inline bool has_line_name() const;
  inline void clear_line_name();
  static const int kLineNameFieldNumber = 4;
  inline const ::std::string& line_name() const;
  inline void set_line_name(const ::std::string& value);
  inline void set_line_name(const char* value);
  inline void set_line_name(const char* value, size_t size);
  inline ::std::string* mutable_line_name();
  inline ::std::string* release_line_name();
  inline void set_allocated_line_name(::std::string* line_name);

  // @@protoc_insertion_point(class_scope:ChangeLineupReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_line_name();
  inline void clear_has_line_name();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lineup_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 index_;
  ::std::string* line_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ChangeLineupReq* default_instance_;
};
// -------------------------------------------------------------------

class ChangeLineupResp : public ::google::protobuf::MessageLite {
 public:
  ChangeLineupResp();
  virtual ~ChangeLineupResp();

  ChangeLineupResp(const ChangeLineupResp& from);

  inline ChangeLineupResp& operator=(const ChangeLineupResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChangeLineupResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeLineupResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeLineupResp* other);

  // implements Message ----------------------------------------------

  ChangeLineupResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeLineupResp& from);
  void MergeFrom(const ChangeLineupResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated int32 lineup = 3;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 3;
  inline ::google::protobuf::int32 lineup(int index) const;
  inline void set_lineup(int index, ::google::protobuf::int32 value);
  inline void add_lineup(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lineup();

  // required int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ChangeLineupResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_type();
  inline void clear_has_type();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lineup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ChangeLineupResp* default_instance_;
};
// -------------------------------------------------------------------

class ChangeWeaponReq : public ::google::protobuf::MessageLite {
 public:
  ChangeWeaponReq();
  virtual ~ChangeWeaponReq();

  ChangeWeaponReq(const ChangeWeaponReq& from);

  inline ChangeWeaponReq& operator=(const ChangeWeaponReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChangeWeaponReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeWeaponReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeWeaponReq* other);

  // implements Message ----------------------------------------------

  ChangeWeaponReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeWeaponReq& from);
  void MergeFrom(const ChangeWeaponReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 ship_id = 2;
  inline bool has_ship_id() const;
  inline void clear_ship_id();
  static const int kShipIdFieldNumber = 2;
  inline ::google::protobuf::int32 ship_id() const;
  inline void set_ship_id(::google::protobuf::int32 value);

  // optional int32 gift = 3;
  inline bool has_gift() const;
  inline void clear_gift();
  static const int kGiftFieldNumber = 3;
  inline ::google::protobuf::int32 gift() const;
  inline void set_gift(::google::protobuf::int32 value);

  // optional int32 skill = 4;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 4;
  inline ::google::protobuf::int32 skill() const;
  inline void set_skill(::google::protobuf::int32 value);

  // repeated int32 weapon_list = 5;
  inline int weapon_list_size() const;
  inline void clear_weapon_list();
  static const int kWeaponListFieldNumber = 5;
  inline ::google::protobuf::int32 weapon_list(int index) const;
  inline void set_weapon_list(int index, ::google::protobuf::int32 value);
  inline void add_weapon_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      weapon_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_weapon_list();

  // @@protoc_insertion_point(class_scope:ChangeWeaponReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ship_id();
  inline void clear_has_ship_id();
  inline void set_has_gift();
  inline void clear_has_gift();
  inline void set_has_skill();
  inline void clear_has_skill();

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 ship_id_;
  ::google::protobuf::int32 gift_;
  ::google::protobuf::int32 skill_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > weapon_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ChangeWeaponReq* default_instance_;
};
// -------------------------------------------------------------------

class ChangeWeaponResp : public ::google::protobuf::MessageLite {
 public:
  ChangeWeaponResp();
  virtual ~ChangeWeaponResp();

  ChangeWeaponResp(const ChangeWeaponResp& from);

  inline ChangeWeaponResp& operator=(const ChangeWeaponResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChangeWeaponResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeWeaponResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeWeaponResp* other);

  // implements Message ----------------------------------------------

  ChangeWeaponResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeWeaponResp& from);
  void MergeFrom(const ChangeWeaponResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 ship_id = 3;
  inline bool has_ship_id() const;
  inline void clear_ship_id();
  static const int kShipIdFieldNumber = 3;
  inline ::google::protobuf::int32 ship_id() const;
  inline void set_ship_id(::google::protobuf::int32 value);

  // optional int32 gift = 4;
  inline bool has_gift() const;
  inline void clear_gift();
  static const int kGiftFieldNumber = 4;
  inline ::google::protobuf::int32 gift() const;
  inline void set_gift(::google::protobuf::int32 value);

  // optional int32 skill = 5;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 5;
  inline ::google::protobuf::int32 skill() const;
  inline void set_skill(::google::protobuf::int32 value);

  // repeated int32 weapon_list = 6;
  inline int weapon_list_size() const;
  inline void clear_weapon_list();
  static const int kWeaponListFieldNumber = 6;
  inline ::google::protobuf::int32 weapon_list(int index) const;
  inline void set_weapon_list(int index, ::google::protobuf::int32 value);
  inline void add_weapon_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      weapon_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_weapon_list();

  // @@protoc_insertion_point(class_scope:ChangeWeaponResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_ship_id();
  inline void clear_has_ship_id();
  inline void set_has_gift();
  inline void clear_has_gift();
  inline void set_has_skill();
  inline void clear_has_skill();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 ship_id_;
  ::google::protobuf::int32 gift_;
  ::google::protobuf::int32 skill_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > weapon_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ChangeWeaponResp* default_instance_;
};
// -------------------------------------------------------------------

class ShipDevelopeReq : public ::google::protobuf::MessageLite {
 public:
  ShipDevelopeReq();
  virtual ~ShipDevelopeReq();

  ShipDevelopeReq(const ShipDevelopeReq& from);

  inline ShipDevelopeReq& operator=(const ShipDevelopeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipDevelopeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipDevelopeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipDevelopeReq* other);

  // implements Message ----------------------------------------------

  ShipDevelopeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipDevelopeReq& from);
  void MergeFrom(const ShipDevelopeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 ship_id = 2;
  inline bool has_ship_id() const;
  inline void clear_ship_id();
  static const int kShipIdFieldNumber = 2;
  inline ::google::protobuf::int32 ship_id() const;
  inline void set_ship_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShipDevelopeReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ship_id();
  inline void clear_has_ship_id();

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 ship_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipDevelopeReq* default_instance_;
};
// -------------------------------------------------------------------

class ShipDevelopeResp : public ::google::protobuf::MessageLite {
 public:
  ShipDevelopeResp();
  virtual ~ShipDevelopeResp();

  ShipDevelopeResp(const ShipDevelopeResp& from);

  inline ShipDevelopeResp& operator=(const ShipDevelopeResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipDevelopeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipDevelopeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipDevelopeResp* other);

  // implements Message ----------------------------------------------

  ShipDevelopeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipDevelopeResp& from);
  void MergeFrom(const ShipDevelopeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 ship_id = 3;
  inline bool has_ship_id() const;
  inline void clear_ship_id();
  static const int kShipIdFieldNumber = 3;
  inline ::google::protobuf::int32 ship_id() const;
  inline void set_ship_id(::google::protobuf::int32 value);

  // optional int32 ship_guid = 4;
  inline bool has_ship_guid() const;
  inline void clear_ship_guid();
  static const int kShipGuidFieldNumber = 4;
  inline ::google::protobuf::int32 ship_guid() const;
  inline void set_ship_guid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShipDevelopeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_ship_id();
  inline void clear_has_ship_id();
  inline void set_has_ship_guid();
  inline void clear_has_ship_guid();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 ship_id_;
  ::google::protobuf::int32 ship_guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipDevelopeResp* default_instance_;
};
// -------------------------------------------------------------------

class BlueprintDevelopeReq : public ::google::protobuf::MessageLite {
 public:
  BlueprintDevelopeReq();
  virtual ~BlueprintDevelopeReq();

  BlueprintDevelopeReq(const BlueprintDevelopeReq& from);

  inline BlueprintDevelopeReq& operator=(const BlueprintDevelopeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const BlueprintDevelopeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BlueprintDevelopeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BlueprintDevelopeReq* other);

  // implements Message ----------------------------------------------

  BlueprintDevelopeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BlueprintDevelopeReq& from);
  void MergeFrom(const BlueprintDevelopeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 blueprint_id = 2;
  inline bool has_blueprint_id() const;
  inline void clear_blueprint_id();
  static const int kBlueprintIdFieldNumber = 2;
  inline ::google::protobuf::int32 blueprint_id() const;
  inline void set_blueprint_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BlueprintDevelopeReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_blueprint_id();
  inline void clear_has_blueprint_id();

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 blueprint_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static BlueprintDevelopeReq* default_instance_;
};
// -------------------------------------------------------------------

class BlueprintDevelopeResp : public ::google::protobuf::MessageLite {
 public:
  BlueprintDevelopeResp();
  virtual ~BlueprintDevelopeResp();

  BlueprintDevelopeResp(const BlueprintDevelopeResp& from);

  inline BlueprintDevelopeResp& operator=(const BlueprintDevelopeResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const BlueprintDevelopeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BlueprintDevelopeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BlueprintDevelopeResp* other);

  // implements Message ----------------------------------------------

  BlueprintDevelopeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BlueprintDevelopeResp& from);
  void MergeFrom(const BlueprintDevelopeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 blueprint_id = 3;
  inline bool has_blueprint_id() const;
  inline void clear_blueprint_id();
  static const int kBlueprintIdFieldNumber = 3;
  inline ::google::protobuf::int32 blueprint_id() const;
  inline void set_blueprint_id(::google::protobuf::int32 value);

  // optional int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional bool crit = 5;
  inline bool has_crit() const;
  inline void clear_crit();
  static const int kCritFieldNumber = 5;
  inline bool crit() const;
  inline void set_crit(bool value);

  // optional int32 num = 6;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 6;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BlueprintDevelopeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_blueprint_id();
  inline void clear_has_blueprint_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_crit();
  inline void clear_has_crit();
  inline void set_has_num();
  inline void clear_has_num();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 blueprint_id_;
  ::google::protobuf::int32 type_;
  bool crit_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static BlueprintDevelopeResp* default_instance_;
};
// -------------------------------------------------------------------

class ShipRemoveReq : public ::google::protobuf::MessageLite {
 public:
  ShipRemoveReq();
  virtual ~ShipRemoveReq();

  ShipRemoveReq(const ShipRemoveReq& from);

  inline ShipRemoveReq& operator=(const ShipRemoveReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipRemoveReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipRemoveReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipRemoveReq* other);

  // implements Message ----------------------------------------------

  ShipRemoveReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipRemoveReq& from);
  void MergeFrom(const ShipRemoveReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 ship_guid = 2;
  inline bool has_ship_guid() const;
  inline void clear_ship_guid();
  static const int kShipGuidFieldNumber = 2;
  inline ::google::protobuf::int32 ship_guid() const;
  inline void set_ship_guid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShipRemoveReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ship_guid();
  inline void clear_has_ship_guid();

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 ship_guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipRemoveReq* default_instance_;
};
// -------------------------------------------------------------------

class ShipRemoveResp : public ::google::protobuf::MessageLite {
 public:
  ShipRemoveResp();
  virtual ~ShipRemoveResp();

  ShipRemoveResp(const ShipRemoveResp& from);

  inline ShipRemoveResp& operator=(const ShipRemoveResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipRemoveResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipRemoveResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipRemoveResp* other);

  // implements Message ----------------------------------------------

  ShipRemoveResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipRemoveResp& from);
  void MergeFrom(const ShipRemoveResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ShipRemoveResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipRemoveResp* default_instance_;
};
// -------------------------------------------------------------------

class WeaponUpgradeReq : public ::google::protobuf::MessageLite {
 public:
  WeaponUpgradeReq();
  virtual ~WeaponUpgradeReq();

  WeaponUpgradeReq(const WeaponUpgradeReq& from);

  inline WeaponUpgradeReq& operator=(const WeaponUpgradeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const WeaponUpgradeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WeaponUpgradeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WeaponUpgradeReq* other);

  // implements Message ----------------------------------------------

  WeaponUpgradeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WeaponUpgradeReq& from);
  void MergeFrom(const WeaponUpgradeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 guid = 2;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 2;
  inline ::google::protobuf::int32 guid() const;
  inline void set_guid(::google::protobuf::int32 value);

  // optional int32 weapon_id = 3;
  inline bool has_weapon_id() const;
  inline void clear_weapon_id();
  static const int kWeaponIdFieldNumber = 3;
  inline ::google::protobuf::int32 weapon_id() const;
  inline void set_weapon_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WeaponUpgradeReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_weapon_id();
  inline void clear_has_weapon_id();

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 guid_;
  ::google::protobuf::int32 weapon_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static WeaponUpgradeReq* default_instance_;
};
// -------------------------------------------------------------------

class WeaponUpgradeResp : public ::google::protobuf::MessageLite {
 public:
  WeaponUpgradeResp();
  virtual ~WeaponUpgradeResp();

  WeaponUpgradeResp(const WeaponUpgradeResp& from);

  inline WeaponUpgradeResp& operator=(const WeaponUpgradeResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const WeaponUpgradeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WeaponUpgradeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WeaponUpgradeResp* other);

  // implements Message ----------------------------------------------

  WeaponUpgradeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WeaponUpgradeResp& from);
  void MergeFrom(const WeaponUpgradeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 guid = 4;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 4;
  inline ::google::protobuf::int32 guid() const;
  inline void set_guid(::google::protobuf::int32 value);

  // optional int32 weapon_id = 5;
  inline bool has_weapon_id() const;
  inline void clear_weapon_id();
  static const int kWeaponIdFieldNumber = 5;
  inline ::google::protobuf::int32 weapon_id() const;
  inline void set_weapon_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WeaponUpgradeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_weapon_id();
  inline void clear_has_weapon_id();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 guid_;
  ::google::protobuf::int32 weapon_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static WeaponUpgradeResp* default_instance_;
};
// -------------------------------------------------------------------

class ShipBreakReq : public ::google::protobuf::MessageLite {
 public:
  ShipBreakReq();
  virtual ~ShipBreakReq();

  ShipBreakReq(const ShipBreakReq& from);

  inline ShipBreakReq& operator=(const ShipBreakReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipBreakReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipBreakReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipBreakReq* other);

  // implements Message ----------------------------------------------

  ShipBreakReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipBreakReq& from);
  void MergeFrom(const ShipBreakReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ship_guid = 1;
  inline bool has_ship_guid() const;
  inline void clear_ship_guid();
  static const int kShipGuidFieldNumber = 1;
  inline ::google::protobuf::int32 ship_guid() const;
  inline void set_ship_guid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShipBreakReq)
 private:
  inline void set_has_ship_guid();
  inline void clear_has_ship_guid();

  ::google::protobuf::int32 ship_guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipBreakReq* default_instance_;
};
// -------------------------------------------------------------------

class ShipBreakResp : public ::google::protobuf::MessageLite {
 public:
  ShipBreakResp();
  virtual ~ShipBreakResp();

  ShipBreakResp(const ShipBreakResp& from);

  inline ShipBreakResp& operator=(const ShipBreakResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipBreakResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipBreakResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipBreakResp* other);

  // implements Message ----------------------------------------------

  ShipBreakResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipBreakResp& from);
  void MergeFrom(const ShipBreakResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 ship_guid = 3;
  inline bool has_ship_guid() const;
  inline void clear_ship_guid();
  static const int kShipGuidFieldNumber = 3;
  inline ::google::protobuf::int32 ship_guid() const;
  inline void set_ship_guid(::google::protobuf::int32 value);

  // optional int32 ship_break = 4;
  inline bool has_ship_break() const;
  inline void clear_ship_break();
  static const int kShipBreakFieldNumber = 4;
  inline ::google::protobuf::int32 ship_break() const;
  inline void set_ship_break(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShipBreakResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_ship_guid();
  inline void clear_has_ship_guid();
  inline void set_has_ship_break();
  inline void clear_has_ship_break();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 ship_guid_;
  ::google::protobuf::int32 ship_break_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipBreakResp* default_instance_;
};
// -------------------------------------------------------------------

class ShipAddExpReq : public ::google::protobuf::MessageLite {
 public:
  ShipAddExpReq();
  virtual ~ShipAddExpReq();

  ShipAddExpReq(const ShipAddExpReq& from);

  inline ShipAddExpReq& operator=(const ShipAddExpReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipAddExpReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipAddExpReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipAddExpReq* other);

  // implements Message ----------------------------------------------

  ShipAddExpReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipAddExpReq& from);
  void MergeFrom(const ShipAddExpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ship_guid = 1;
  inline bool has_ship_guid() const;
  inline void clear_ship_guid();
  static const int kShipGuidFieldNumber = 1;
  inline ::google::protobuf::int32 ship_guid() const;
  inline void set_ship_guid(::google::protobuf::int32 value);

  // repeated int32 item_id_list = 2;
  inline int item_id_list_size() const;
  inline void clear_item_id_list();
  static const int kItemIdListFieldNumber = 2;
  inline ::google::protobuf::int32 item_id_list(int index) const;
  inline void set_item_id_list(int index, ::google::protobuf::int32 value);
  inline void add_item_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      item_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_item_id_list();

  // repeated int32 item_num_list = 3;
  inline int item_num_list_size() const;
  inline void clear_item_num_list();
  static const int kItemNumListFieldNumber = 3;
  inline ::google::protobuf::int32 item_num_list(int index) const;
  inline void set_item_num_list(int index, ::google::protobuf::int32 value);
  inline void add_item_num_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      item_num_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_item_num_list();

  // @@protoc_insertion_point(class_scope:ShipAddExpReq)
 private:
  inline void set_has_ship_guid();
  inline void clear_has_ship_guid();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > item_id_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > item_num_list_;
  ::google::protobuf::int32 ship_guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipAddExpReq* default_instance_;
};
// -------------------------------------------------------------------

class ShipAddExpResp : public ::google::protobuf::MessageLite {
 public:
  ShipAddExpResp();
  virtual ~ShipAddExpResp();

  ShipAddExpResp(const ShipAddExpResp& from);

  inline ShipAddExpResp& operator=(const ShipAddExpResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipAddExpResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipAddExpResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipAddExpResp* other);

  // implements Message ----------------------------------------------

  ShipAddExpResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipAddExpResp& from);
  void MergeFrom(const ShipAddExpResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ShipAddExpResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipAddExpResp* default_instance_;
};
// -------------------------------------------------------------------

class ShipFixReq : public ::google::protobuf::MessageLite {
 public:
  ShipFixReq();
  virtual ~ShipFixReq();

  ShipFixReq(const ShipFixReq& from);

  inline ShipFixReq& operator=(const ShipFixReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipFixReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipFixReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipFixReq* other);

  // implements Message ----------------------------------------------

  ShipFixReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipFixReq& from);
  void MergeFrom(const ShipFixReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int32 guids = 2;
  inline int guids_size() const;
  inline void clear_guids();
  static const int kGuidsFieldNumber = 2;
  inline ::google::protobuf::int32 guids(int index) const;
  inline void set_guids(int index, ::google::protobuf::int32 value);
  inline void add_guids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      guids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_guids();

  // @@protoc_insertion_point(class_scope:ShipFixReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > guids_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipFixReq* default_instance_;
};
// -------------------------------------------------------------------

class ShipFixResp : public ::google::protobuf::MessageLite {
 public:
  ShipFixResp();
  virtual ~ShipFixResp();

  ShipFixResp(const ShipFixResp& from);

  inline ShipFixResp& operator=(const ShipFixResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipFixResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipFixResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipFixResp* other);

  // implements Message ----------------------------------------------

  ShipFixResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipFixResp& from);
  void MergeFrom(const ShipFixResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ShipFixResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipFixResp* default_instance_;
};
// -------------------------------------------------------------------

class ShipAddEnergyExpReq : public ::google::protobuf::MessageLite {
 public:
  ShipAddEnergyExpReq();
  virtual ~ShipAddEnergyExpReq();

  ShipAddEnergyExpReq(const ShipAddEnergyExpReq& from);

  inline ShipAddEnergyExpReq& operator=(const ShipAddEnergyExpReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipAddEnergyExpReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipAddEnergyExpReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipAddEnergyExpReq* other);

  // implements Message ----------------------------------------------

  ShipAddEnergyExpReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipAddEnergyExpReq& from);
  void MergeFrom(const ShipAddEnergyExpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ship_guid = 1;
  inline bool has_ship_guid() const;
  inline void clear_ship_guid();
  static const int kShipGuidFieldNumber = 1;
  inline ::google::protobuf::int32 ship_guid() const;
  inline void set_ship_guid(::google::protobuf::int32 value);

  // repeated int32 res_list = 2;
  inline int res_list_size() const;
  inline void clear_res_list();
  static const int kResListFieldNumber = 2;
  inline ::google::protobuf::int32 res_list(int index) const;
  inline void set_res_list(int index, ::google::protobuf::int32 value);
  inline void add_res_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      res_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_res_list();

  // @@protoc_insertion_point(class_scope:ShipAddEnergyExpReq)
 private:
  inline void set_has_ship_guid();
  inline void clear_has_ship_guid();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > res_list_;
  ::google::protobuf::int32 ship_guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipAddEnergyExpReq* default_instance_;
};
// -------------------------------------------------------------------

class ShipAddEnergyExpResp : public ::google::protobuf::MessageLite {
 public:
  ShipAddEnergyExpResp();
  virtual ~ShipAddEnergyExpResp();

  ShipAddEnergyExpResp(const ShipAddEnergyExpResp& from);

  inline ShipAddEnergyExpResp& operator=(const ShipAddEnergyExpResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipAddEnergyExpResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipAddEnergyExpResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipAddEnergyExpResp* other);

  // implements Message ----------------------------------------------

  ShipAddEnergyExpResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipAddEnergyExpResp& from);
  void MergeFrom(const ShipAddEnergyExpResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ShipAddEnergyExpResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipAddEnergyExpResp* default_instance_;
};
// -------------------------------------------------------------------

class ShipLockEnergyTimeReq : public ::google::protobuf::MessageLite {
 public:
  ShipLockEnergyTimeReq();
  virtual ~ShipLockEnergyTimeReq();

  ShipLockEnergyTimeReq(const ShipLockEnergyTimeReq& from);

  inline ShipLockEnergyTimeReq& operator=(const ShipLockEnergyTimeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipLockEnergyTimeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipLockEnergyTimeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipLockEnergyTimeReq* other);

  // implements Message ----------------------------------------------

  ShipLockEnergyTimeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipLockEnergyTimeReq& from);
  void MergeFrom(const ShipLockEnergyTimeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ShipLockEnergyTimeReq)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipLockEnergyTimeReq* default_instance_;
};
// -------------------------------------------------------------------

class ShipLockEnergyTimeResp : public ::google::protobuf::MessageLite {
 public:
  ShipLockEnergyTimeResp();
  virtual ~ShipLockEnergyTimeResp();

  ShipLockEnergyTimeResp(const ShipLockEnergyTimeResp& from);

  inline ShipLockEnergyTimeResp& operator=(const ShipLockEnergyTimeResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShipLockEnergyTimeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShipLockEnergyTimeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShipLockEnergyTimeResp* other);

  // implements Message ----------------------------------------------

  ShipLockEnergyTimeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShipLockEnergyTimeResp& from);
  void MergeFrom(const ShipLockEnergyTimeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ShipLockEnergyTimeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdWeapon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdWeapon_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdWeapon_2eproto();
  friend void protobuf_ShutdownFile_CmdWeapon_2eproto();

  void InitAsDefaultInstance();
  static ShipLockEnergyTimeResp* default_instance_;
};
// ===================================================================


// ===================================================================

// GetShipListReq

// required int32 ship_id = 1;
inline bool GetShipListReq::has_ship_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetShipListReq::set_has_ship_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetShipListReq::clear_has_ship_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetShipListReq::clear_ship_id() {
  ship_id_ = 0;
  clear_has_ship_id();
}
inline ::google::protobuf::int32 GetShipListReq::ship_id() const {
  return ship_id_;
}
inline void GetShipListReq::set_ship_id(::google::protobuf::int32 value) {
  set_has_ship_id();
  ship_id_ = value;
}

// -------------------------------------------------------------------

// GetShipListResp

// required int32 result = 1;
inline bool GetShipListResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetShipListResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetShipListResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetShipListResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GetShipListResp::result() const {
  return result_;
}
inline void GetShipListResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .AirShip ship_info = 2;
inline bool GetShipListResp::has_ship_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetShipListResp::set_has_ship_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetShipListResp::clear_has_ship_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetShipListResp::clear_ship_info() {
  if (ship_info_ != NULL) ship_info_->::AirShip::Clear();
  clear_has_ship_info();
}
inline const ::AirShip& GetShipListResp::ship_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ship_info_ != NULL ? *ship_info_ : *default_instance().ship_info_;
#else
  return ship_info_ != NULL ? *ship_info_ : *default_instance_->ship_info_;
#endif
}
inline ::AirShip* GetShipListResp::mutable_ship_info() {
  set_has_ship_info();
  if (ship_info_ == NULL) ship_info_ = new ::AirShip;
  return ship_info_;
}
inline ::AirShip* GetShipListResp::release_ship_info() {
  clear_has_ship_info();
  ::AirShip* temp = ship_info_;
  ship_info_ = NULL;
  return temp;
}
inline void GetShipListResp::set_allocated_ship_info(::AirShip* ship_info) {
  delete ship_info_;
  ship_info_ = ship_info;
  if (ship_info) {
    set_has_ship_info();
  } else {
    clear_has_ship_info();
  }
}

// repeated .AirShip ship_list = 3;
inline int GetShipListResp::ship_list_size() const {
  return ship_list_.size();
}
inline void GetShipListResp::clear_ship_list() {
  ship_list_.Clear();
}
inline const ::AirShip& GetShipListResp::ship_list(int index) const {
  return ship_list_.Get(index);
}
inline ::AirShip* GetShipListResp::mutable_ship_list(int index) {
  return ship_list_.Mutable(index);
}
inline ::AirShip* GetShipListResp::add_ship_list() {
  return ship_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AirShip >&
GetShipListResp::ship_list() const {
  return ship_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AirShip >*
GetShipListResp::mutable_ship_list() {
  return &ship_list_;
}

// -------------------------------------------------------------------

// ChangeLineupReq

// required int32 type = 1;
inline bool ChangeLineupReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeLineupReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeLineupReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeLineupReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ChangeLineupReq::type() const {
  return type_;
}
inline void ChangeLineupReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 lineup = 2;
inline int ChangeLineupReq::lineup_size() const {
  return lineup_.size();
}
inline void ChangeLineupReq::clear_lineup() {
  lineup_.Clear();
}
inline ::google::protobuf::int32 ChangeLineupReq::lineup(int index) const {
  return lineup_.Get(index);
}
inline void ChangeLineupReq::set_lineup(int index, ::google::protobuf::int32 value) {
  lineup_.Set(index, value);
}
inline void ChangeLineupReq::add_lineup(::google::protobuf::int32 value) {
  lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ChangeLineupReq::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ChangeLineupReq::mutable_lineup() {
  return &lineup_;
}

// optional int32 index = 3;
inline bool ChangeLineupReq::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeLineupReq::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeLineupReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeLineupReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 ChangeLineupReq::index() const {
  return index_;
}
inline void ChangeLineupReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional string line_name = 4;
inline bool ChangeLineupReq::has_line_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeLineupReq::set_has_line_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeLineupReq::clear_has_line_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeLineupReq::clear_line_name() {
  if (line_name_ != &::google::protobuf::internal::kEmptyString) {
    line_name_->clear();
  }
  clear_has_line_name();
}
inline const ::std::string& ChangeLineupReq::line_name() const {
  return *line_name_;
}
inline void ChangeLineupReq::set_line_name(const ::std::string& value) {
  set_has_line_name();
  if (line_name_ == &::google::protobuf::internal::kEmptyString) {
    line_name_ = new ::std::string;
  }
  line_name_->assign(value);
}
inline void ChangeLineupReq::set_line_name(const char* value) {
  set_has_line_name();
  if (line_name_ == &::google::protobuf::internal::kEmptyString) {
    line_name_ = new ::std::string;
  }
  line_name_->assign(value);
}
inline void ChangeLineupReq::set_line_name(const char* value, size_t size) {
  set_has_line_name();
  if (line_name_ == &::google::protobuf::internal::kEmptyString) {
    line_name_ = new ::std::string;
  }
  line_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeLineupReq::mutable_line_name() {
  set_has_line_name();
  if (line_name_ == &::google::protobuf::internal::kEmptyString) {
    line_name_ = new ::std::string;
  }
  return line_name_;
}
inline ::std::string* ChangeLineupReq::release_line_name() {
  clear_has_line_name();
  if (line_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = line_name_;
    line_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeLineupReq::set_allocated_line_name(::std::string* line_name) {
  if (line_name_ != &::google::protobuf::internal::kEmptyString) {
    delete line_name_;
  }
  if (line_name) {
    set_has_line_name();
    line_name_ = line_name;
  } else {
    clear_has_line_name();
    line_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangeLineupResp

// required int32 result = 1;
inline bool ChangeLineupResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeLineupResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeLineupResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeLineupResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ChangeLineupResp::result() const {
  return result_;
}
inline void ChangeLineupResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ChangeLineupResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeLineupResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeLineupResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeLineupResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ChangeLineupResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ChangeLineupResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ChangeLineupResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ChangeLineupResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated int32 lineup = 3;
inline int ChangeLineupResp::lineup_size() const {
  return lineup_.size();
}
inline void ChangeLineupResp::clear_lineup() {
  lineup_.Clear();
}
inline ::google::protobuf::int32 ChangeLineupResp::lineup(int index) const {
  return lineup_.Get(index);
}
inline void ChangeLineupResp::set_lineup(int index, ::google::protobuf::int32 value) {
  lineup_.Set(index, value);
}
inline void ChangeLineupResp::add_lineup(::google::protobuf::int32 value) {
  lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ChangeLineupResp::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ChangeLineupResp::mutable_lineup() {
  return &lineup_;
}

// required int32 type = 4;
inline bool ChangeLineupResp::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeLineupResp::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeLineupResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeLineupResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ChangeLineupResp::type() const {
  return type_;
}
inline void ChangeLineupResp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ChangeWeaponReq

// required int32 type = 1;
inline bool ChangeWeaponReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeWeaponReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeWeaponReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeWeaponReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ChangeWeaponReq::type() const {
  return type_;
}
inline void ChangeWeaponReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 ship_id = 2;
inline bool ChangeWeaponReq::has_ship_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeWeaponReq::set_has_ship_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeWeaponReq::clear_has_ship_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeWeaponReq::clear_ship_id() {
  ship_id_ = 0;
  clear_has_ship_id();
}
inline ::google::protobuf::int32 ChangeWeaponReq::ship_id() const {
  return ship_id_;
}
inline void ChangeWeaponReq::set_ship_id(::google::protobuf::int32 value) {
  set_has_ship_id();
  ship_id_ = value;
}

// optional int32 gift = 3;
inline bool ChangeWeaponReq::has_gift() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeWeaponReq::set_has_gift() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeWeaponReq::clear_has_gift() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeWeaponReq::clear_gift() {
  gift_ = 0;
  clear_has_gift();
}
inline ::google::protobuf::int32 ChangeWeaponReq::gift() const {
  return gift_;
}
inline void ChangeWeaponReq::set_gift(::google::protobuf::int32 value) {
  set_has_gift();
  gift_ = value;
}

// optional int32 skill = 4;
inline bool ChangeWeaponReq::has_skill() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeWeaponReq::set_has_skill() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeWeaponReq::clear_has_skill() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeWeaponReq::clear_skill() {
  skill_ = 0;
  clear_has_skill();
}
inline ::google::protobuf::int32 ChangeWeaponReq::skill() const {
  return skill_;
}
inline void ChangeWeaponReq::set_skill(::google::protobuf::int32 value) {
  set_has_skill();
  skill_ = value;
}

// repeated int32 weapon_list = 5;
inline int ChangeWeaponReq::weapon_list_size() const {
  return weapon_list_.size();
}
inline void ChangeWeaponReq::clear_weapon_list() {
  weapon_list_.Clear();
}
inline ::google::protobuf::int32 ChangeWeaponReq::weapon_list(int index) const {
  return weapon_list_.Get(index);
}
inline void ChangeWeaponReq::set_weapon_list(int index, ::google::protobuf::int32 value) {
  weapon_list_.Set(index, value);
}
inline void ChangeWeaponReq::add_weapon_list(::google::protobuf::int32 value) {
  weapon_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ChangeWeaponReq::weapon_list() const {
  return weapon_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ChangeWeaponReq::mutable_weapon_list() {
  return &weapon_list_;
}

// -------------------------------------------------------------------

// ChangeWeaponResp

// required int32 result = 1;
inline bool ChangeWeaponResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeWeaponResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeWeaponResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeWeaponResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ChangeWeaponResp::result() const {
  return result_;
}
inline void ChangeWeaponResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ChangeWeaponResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeWeaponResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeWeaponResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeWeaponResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ChangeWeaponResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ChangeWeaponResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ChangeWeaponResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ChangeWeaponResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 ship_id = 3;
inline bool ChangeWeaponResp::has_ship_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeWeaponResp::set_has_ship_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeWeaponResp::clear_has_ship_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeWeaponResp::clear_ship_id() {
  ship_id_ = 0;
  clear_has_ship_id();
}
inline ::google::protobuf::int32 ChangeWeaponResp::ship_id() const {
  return ship_id_;
}
inline void ChangeWeaponResp::set_ship_id(::google::protobuf::int32 value) {
  set_has_ship_id();
  ship_id_ = value;
}

// optional int32 gift = 4;
inline bool ChangeWeaponResp::has_gift() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeWeaponResp::set_has_gift() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeWeaponResp::clear_has_gift() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeWeaponResp::clear_gift() {
  gift_ = 0;
  clear_has_gift();
}
inline ::google::protobuf::int32 ChangeWeaponResp::gift() const {
  return gift_;
}
inline void ChangeWeaponResp::set_gift(::google::protobuf::int32 value) {
  set_has_gift();
  gift_ = value;
}

// optional int32 skill = 5;
inline bool ChangeWeaponResp::has_skill() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeWeaponResp::set_has_skill() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeWeaponResp::clear_has_skill() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeWeaponResp::clear_skill() {
  skill_ = 0;
  clear_has_skill();
}
inline ::google::protobuf::int32 ChangeWeaponResp::skill() const {
  return skill_;
}
inline void ChangeWeaponResp::set_skill(::google::protobuf::int32 value) {
  set_has_skill();
  skill_ = value;
}

// repeated int32 weapon_list = 6;
inline int ChangeWeaponResp::weapon_list_size() const {
  return weapon_list_.size();
}
inline void ChangeWeaponResp::clear_weapon_list() {
  weapon_list_.Clear();
}
inline ::google::protobuf::int32 ChangeWeaponResp::weapon_list(int index) const {
  return weapon_list_.Get(index);
}
inline void ChangeWeaponResp::set_weapon_list(int index, ::google::protobuf::int32 value) {
  weapon_list_.Set(index, value);
}
inline void ChangeWeaponResp::add_weapon_list(::google::protobuf::int32 value) {
  weapon_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ChangeWeaponResp::weapon_list() const {
  return weapon_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ChangeWeaponResp::mutable_weapon_list() {
  return &weapon_list_;
}

// -------------------------------------------------------------------

// ShipDevelopeReq

// required int32 type = 1;
inline bool ShipDevelopeReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipDevelopeReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipDevelopeReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipDevelopeReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ShipDevelopeReq::type() const {
  return type_;
}
inline void ShipDevelopeReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 ship_id = 2;
inline bool ShipDevelopeReq::has_ship_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipDevelopeReq::set_has_ship_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipDevelopeReq::clear_has_ship_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipDevelopeReq::clear_ship_id() {
  ship_id_ = 0;
  clear_has_ship_id();
}
inline ::google::protobuf::int32 ShipDevelopeReq::ship_id() const {
  return ship_id_;
}
inline void ShipDevelopeReq::set_ship_id(::google::protobuf::int32 value) {
  set_has_ship_id();
  ship_id_ = value;
}

// -------------------------------------------------------------------

// ShipDevelopeResp

// required int32 result = 1;
inline bool ShipDevelopeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipDevelopeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipDevelopeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipDevelopeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ShipDevelopeResp::result() const {
  return result_;
}
inline void ShipDevelopeResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ShipDevelopeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipDevelopeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipDevelopeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipDevelopeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ShipDevelopeResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ShipDevelopeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ShipDevelopeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ShipDevelopeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 ship_id = 3;
inline bool ShipDevelopeResp::has_ship_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShipDevelopeResp::set_has_ship_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShipDevelopeResp::clear_has_ship_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShipDevelopeResp::clear_ship_id() {
  ship_id_ = 0;
  clear_has_ship_id();
}
inline ::google::protobuf::int32 ShipDevelopeResp::ship_id() const {
  return ship_id_;
}
inline void ShipDevelopeResp::set_ship_id(::google::protobuf::int32 value) {
  set_has_ship_id();
  ship_id_ = value;
}

// optional int32 ship_guid = 4;
inline bool ShipDevelopeResp::has_ship_guid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShipDevelopeResp::set_has_ship_guid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShipDevelopeResp::clear_has_ship_guid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShipDevelopeResp::clear_ship_guid() {
  ship_guid_ = 0;
  clear_has_ship_guid();
}
inline ::google::protobuf::int32 ShipDevelopeResp::ship_guid() const {
  return ship_guid_;
}
inline void ShipDevelopeResp::set_ship_guid(::google::protobuf::int32 value) {
  set_has_ship_guid();
  ship_guid_ = value;
}

// -------------------------------------------------------------------

// BlueprintDevelopeReq

// required int32 type = 1;
inline bool BlueprintDevelopeReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlueprintDevelopeReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlueprintDevelopeReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlueprintDevelopeReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BlueprintDevelopeReq::type() const {
  return type_;
}
inline void BlueprintDevelopeReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 blueprint_id = 2;
inline bool BlueprintDevelopeReq::has_blueprint_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlueprintDevelopeReq::set_has_blueprint_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlueprintDevelopeReq::clear_has_blueprint_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlueprintDevelopeReq::clear_blueprint_id() {
  blueprint_id_ = 0;
  clear_has_blueprint_id();
}
inline ::google::protobuf::int32 BlueprintDevelopeReq::blueprint_id() const {
  return blueprint_id_;
}
inline void BlueprintDevelopeReq::set_blueprint_id(::google::protobuf::int32 value) {
  set_has_blueprint_id();
  blueprint_id_ = value;
}

// -------------------------------------------------------------------

// BlueprintDevelopeResp

// required int32 result = 1;
inline bool BlueprintDevelopeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlueprintDevelopeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlueprintDevelopeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlueprintDevelopeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BlueprintDevelopeResp::result() const {
  return result_;
}
inline void BlueprintDevelopeResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool BlueprintDevelopeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlueprintDevelopeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlueprintDevelopeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlueprintDevelopeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& BlueprintDevelopeResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* BlueprintDevelopeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* BlueprintDevelopeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void BlueprintDevelopeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 blueprint_id = 3;
inline bool BlueprintDevelopeResp::has_blueprint_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlueprintDevelopeResp::set_has_blueprint_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlueprintDevelopeResp::clear_has_blueprint_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlueprintDevelopeResp::clear_blueprint_id() {
  blueprint_id_ = 0;
  clear_has_blueprint_id();
}
inline ::google::protobuf::int32 BlueprintDevelopeResp::blueprint_id() const {
  return blueprint_id_;
}
inline void BlueprintDevelopeResp::set_blueprint_id(::google::protobuf::int32 value) {
  set_has_blueprint_id();
  blueprint_id_ = value;
}

// optional int32 type = 4;
inline bool BlueprintDevelopeResp::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlueprintDevelopeResp::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlueprintDevelopeResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlueprintDevelopeResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BlueprintDevelopeResp::type() const {
  return type_;
}
inline void BlueprintDevelopeResp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bool crit = 5;
inline bool BlueprintDevelopeResp::has_crit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlueprintDevelopeResp::set_has_crit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlueprintDevelopeResp::clear_has_crit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlueprintDevelopeResp::clear_crit() {
  crit_ = false;
  clear_has_crit();
}
inline bool BlueprintDevelopeResp::crit() const {
  return crit_;
}
inline void BlueprintDevelopeResp::set_crit(bool value) {
  set_has_crit();
  crit_ = value;
}

// optional int32 num = 6;
inline bool BlueprintDevelopeResp::has_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlueprintDevelopeResp::set_has_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlueprintDevelopeResp::clear_has_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlueprintDevelopeResp::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 BlueprintDevelopeResp::num() const {
  return num_;
}
inline void BlueprintDevelopeResp::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// ShipRemoveReq

// required int32 type = 1;
inline bool ShipRemoveReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipRemoveReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipRemoveReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipRemoveReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ShipRemoveReq::type() const {
  return type_;
}
inline void ShipRemoveReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 ship_guid = 2;
inline bool ShipRemoveReq::has_ship_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipRemoveReq::set_has_ship_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipRemoveReq::clear_has_ship_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipRemoveReq::clear_ship_guid() {
  ship_guid_ = 0;
  clear_has_ship_guid();
}
inline ::google::protobuf::int32 ShipRemoveReq::ship_guid() const {
  return ship_guid_;
}
inline void ShipRemoveReq::set_ship_guid(::google::protobuf::int32 value) {
  set_has_ship_guid();
  ship_guid_ = value;
}

// -------------------------------------------------------------------

// ShipRemoveResp

// required int32 result = 1;
inline bool ShipRemoveResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipRemoveResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipRemoveResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipRemoveResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ShipRemoveResp::result() const {
  return result_;
}
inline void ShipRemoveResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ShipRemoveResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipRemoveResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipRemoveResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipRemoveResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ShipRemoveResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ShipRemoveResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ShipRemoveResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ShipRemoveResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// WeaponUpgradeReq

// required int32 type = 1;
inline bool WeaponUpgradeReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponUpgradeReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponUpgradeReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponUpgradeReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 WeaponUpgradeReq::type() const {
  return type_;
}
inline void WeaponUpgradeReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 guid = 2;
inline bool WeaponUpgradeReq::has_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponUpgradeReq::set_has_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponUpgradeReq::clear_has_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponUpgradeReq::clear_guid() {
  guid_ = 0;
  clear_has_guid();
}
inline ::google::protobuf::int32 WeaponUpgradeReq::guid() const {
  return guid_;
}
inline void WeaponUpgradeReq::set_guid(::google::protobuf::int32 value) {
  set_has_guid();
  guid_ = value;
}

// optional int32 weapon_id = 3;
inline bool WeaponUpgradeReq::has_weapon_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponUpgradeReq::set_has_weapon_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponUpgradeReq::clear_has_weapon_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponUpgradeReq::clear_weapon_id() {
  weapon_id_ = 0;
  clear_has_weapon_id();
}
inline ::google::protobuf::int32 WeaponUpgradeReq::weapon_id() const {
  return weapon_id_;
}
inline void WeaponUpgradeReq::set_weapon_id(::google::protobuf::int32 value) {
  set_has_weapon_id();
  weapon_id_ = value;
}

// -------------------------------------------------------------------

// WeaponUpgradeResp

// required int32 result = 1;
inline bool WeaponUpgradeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponUpgradeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponUpgradeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponUpgradeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 WeaponUpgradeResp::result() const {
  return result_;
}
inline void WeaponUpgradeResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool WeaponUpgradeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponUpgradeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponUpgradeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponUpgradeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& WeaponUpgradeResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* WeaponUpgradeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* WeaponUpgradeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void WeaponUpgradeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 type = 3;
inline bool WeaponUpgradeResp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponUpgradeResp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponUpgradeResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponUpgradeResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 WeaponUpgradeResp::type() const {
  return type_;
}
inline void WeaponUpgradeResp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 guid = 4;
inline bool WeaponUpgradeResp::has_guid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeaponUpgradeResp::set_has_guid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeaponUpgradeResp::clear_has_guid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeaponUpgradeResp::clear_guid() {
  guid_ = 0;
  clear_has_guid();
}
inline ::google::protobuf::int32 WeaponUpgradeResp::guid() const {
  return guid_;
}
inline void WeaponUpgradeResp::set_guid(::google::protobuf::int32 value) {
  set_has_guid();
  guid_ = value;
}

// optional int32 weapon_id = 5;
inline bool WeaponUpgradeResp::has_weapon_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WeaponUpgradeResp::set_has_weapon_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WeaponUpgradeResp::clear_has_weapon_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WeaponUpgradeResp::clear_weapon_id() {
  weapon_id_ = 0;
  clear_has_weapon_id();
}
inline ::google::protobuf::int32 WeaponUpgradeResp::weapon_id() const {
  return weapon_id_;
}
inline void WeaponUpgradeResp::set_weapon_id(::google::protobuf::int32 value) {
  set_has_weapon_id();
  weapon_id_ = value;
}

// -------------------------------------------------------------------

// ShipBreakReq

// required int32 ship_guid = 1;
inline bool ShipBreakReq::has_ship_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipBreakReq::set_has_ship_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipBreakReq::clear_has_ship_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipBreakReq::clear_ship_guid() {
  ship_guid_ = 0;
  clear_has_ship_guid();
}
inline ::google::protobuf::int32 ShipBreakReq::ship_guid() const {
  return ship_guid_;
}
inline void ShipBreakReq::set_ship_guid(::google::protobuf::int32 value) {
  set_has_ship_guid();
  ship_guid_ = value;
}

// -------------------------------------------------------------------

// ShipBreakResp

// required int32 result = 1;
inline bool ShipBreakResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipBreakResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipBreakResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipBreakResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ShipBreakResp::result() const {
  return result_;
}
inline void ShipBreakResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ShipBreakResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipBreakResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipBreakResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipBreakResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ShipBreakResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ShipBreakResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ShipBreakResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ShipBreakResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 ship_guid = 3;
inline bool ShipBreakResp::has_ship_guid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShipBreakResp::set_has_ship_guid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShipBreakResp::clear_has_ship_guid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShipBreakResp::clear_ship_guid() {
  ship_guid_ = 0;
  clear_has_ship_guid();
}
inline ::google::protobuf::int32 ShipBreakResp::ship_guid() const {
  return ship_guid_;
}
inline void ShipBreakResp::set_ship_guid(::google::protobuf::int32 value) {
  set_has_ship_guid();
  ship_guid_ = value;
}

// optional int32 ship_break = 4;
inline bool ShipBreakResp::has_ship_break() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShipBreakResp::set_has_ship_break() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShipBreakResp::clear_has_ship_break() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShipBreakResp::clear_ship_break() {
  ship_break_ = 0;
  clear_has_ship_break();
}
inline ::google::protobuf::int32 ShipBreakResp::ship_break() const {
  return ship_break_;
}
inline void ShipBreakResp::set_ship_break(::google::protobuf::int32 value) {
  set_has_ship_break();
  ship_break_ = value;
}

// -------------------------------------------------------------------

// ShipAddExpReq

// required int32 ship_guid = 1;
inline bool ShipAddExpReq::has_ship_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipAddExpReq::set_has_ship_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipAddExpReq::clear_has_ship_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipAddExpReq::clear_ship_guid() {
  ship_guid_ = 0;
  clear_has_ship_guid();
}
inline ::google::protobuf::int32 ShipAddExpReq::ship_guid() const {
  return ship_guid_;
}
inline void ShipAddExpReq::set_ship_guid(::google::protobuf::int32 value) {
  set_has_ship_guid();
  ship_guid_ = value;
}

// repeated int32 item_id_list = 2;
inline int ShipAddExpReq::item_id_list_size() const {
  return item_id_list_.size();
}
inline void ShipAddExpReq::clear_item_id_list() {
  item_id_list_.Clear();
}
inline ::google::protobuf::int32 ShipAddExpReq::item_id_list(int index) const {
  return item_id_list_.Get(index);
}
inline void ShipAddExpReq::set_item_id_list(int index, ::google::protobuf::int32 value) {
  item_id_list_.Set(index, value);
}
inline void ShipAddExpReq::add_item_id_list(::google::protobuf::int32 value) {
  item_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ShipAddExpReq::item_id_list() const {
  return item_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ShipAddExpReq::mutable_item_id_list() {
  return &item_id_list_;
}

// repeated int32 item_num_list = 3;
inline int ShipAddExpReq::item_num_list_size() const {
  return item_num_list_.size();
}
inline void ShipAddExpReq::clear_item_num_list() {
  item_num_list_.Clear();
}
inline ::google::protobuf::int32 ShipAddExpReq::item_num_list(int index) const {
  return item_num_list_.Get(index);
}
inline void ShipAddExpReq::set_item_num_list(int index, ::google::protobuf::int32 value) {
  item_num_list_.Set(index, value);
}
inline void ShipAddExpReq::add_item_num_list(::google::protobuf::int32 value) {
  item_num_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ShipAddExpReq::item_num_list() const {
  return item_num_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ShipAddExpReq::mutable_item_num_list() {
  return &item_num_list_;
}

// -------------------------------------------------------------------

// ShipAddExpResp

// required int32 result = 1;
inline bool ShipAddExpResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipAddExpResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipAddExpResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipAddExpResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ShipAddExpResp::result() const {
  return result_;
}
inline void ShipAddExpResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ShipAddExpResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipAddExpResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipAddExpResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipAddExpResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ShipAddExpResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ShipAddExpResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ShipAddExpResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ShipAddExpResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ShipFixReq

// required int32 type = 1;
inline bool ShipFixReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipFixReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipFixReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipFixReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ShipFixReq::type() const {
  return type_;
}
inline void ShipFixReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 guids = 2;
inline int ShipFixReq::guids_size() const {
  return guids_.size();
}
inline void ShipFixReq::clear_guids() {
  guids_.Clear();
}
inline ::google::protobuf::int32 ShipFixReq::guids(int index) const {
  return guids_.Get(index);
}
inline void ShipFixReq::set_guids(int index, ::google::protobuf::int32 value) {
  guids_.Set(index, value);
}
inline void ShipFixReq::add_guids(::google::protobuf::int32 value) {
  guids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ShipFixReq::guids() const {
  return guids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ShipFixReq::mutable_guids() {
  return &guids_;
}

// -------------------------------------------------------------------

// ShipFixResp

// required int32 result = 1;
inline bool ShipFixResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipFixResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipFixResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipFixResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ShipFixResp::result() const {
  return result_;
}
inline void ShipFixResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ShipFixResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipFixResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipFixResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipFixResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ShipFixResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ShipFixResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ShipFixResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ShipFixResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ShipAddEnergyExpReq

// required int32 ship_guid = 1;
inline bool ShipAddEnergyExpReq::has_ship_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipAddEnergyExpReq::set_has_ship_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipAddEnergyExpReq::clear_has_ship_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipAddEnergyExpReq::clear_ship_guid() {
  ship_guid_ = 0;
  clear_has_ship_guid();
}
inline ::google::protobuf::int32 ShipAddEnergyExpReq::ship_guid() const {
  return ship_guid_;
}
inline void ShipAddEnergyExpReq::set_ship_guid(::google::protobuf::int32 value) {
  set_has_ship_guid();
  ship_guid_ = value;
}

// repeated int32 res_list = 2;
inline int ShipAddEnergyExpReq::res_list_size() const {
  return res_list_.size();
}
inline void ShipAddEnergyExpReq::clear_res_list() {
  res_list_.Clear();
}
inline ::google::protobuf::int32 ShipAddEnergyExpReq::res_list(int index) const {
  return res_list_.Get(index);
}
inline void ShipAddEnergyExpReq::set_res_list(int index, ::google::protobuf::int32 value) {
  res_list_.Set(index, value);
}
inline void ShipAddEnergyExpReq::add_res_list(::google::protobuf::int32 value) {
  res_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ShipAddEnergyExpReq::res_list() const {
  return res_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ShipAddEnergyExpReq::mutable_res_list() {
  return &res_list_;
}

// -------------------------------------------------------------------

// ShipAddEnergyExpResp

// required int32 result = 1;
inline bool ShipAddEnergyExpResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipAddEnergyExpResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipAddEnergyExpResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipAddEnergyExpResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ShipAddEnergyExpResp::result() const {
  return result_;
}
inline void ShipAddEnergyExpResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ShipAddEnergyExpResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipAddEnergyExpResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipAddEnergyExpResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipAddEnergyExpResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ShipAddEnergyExpResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ShipAddEnergyExpResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ShipAddEnergyExpResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ShipAddEnergyExpResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ShipLockEnergyTimeReq

// -------------------------------------------------------------------

// ShipLockEnergyTimeResp

// required int32 result = 1;
inline bool ShipLockEnergyTimeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipLockEnergyTimeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipLockEnergyTimeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipLockEnergyTimeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ShipLockEnergyTimeResp::result() const {
  return result_;
}
inline void ShipLockEnergyTimeResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ShipLockEnergyTimeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipLockEnergyTimeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipLockEnergyTimeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipLockEnergyTimeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ShipLockEnergyTimeResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ShipLockEnergyTimeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ShipLockEnergyTimeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ShipLockEnergyTimeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdWeapon_2eproto__INCLUDED
