// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdHome.proto

#ifndef PROTOBUF_CmdHome_2eproto__INCLUDED
#define PROTOBUF_CmdHome_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Item.pb.h"
#include "Home.pb.h"
#include "UserSync.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdHome_2eproto();
void protobuf_AssignDesc_CmdHome_2eproto();
void protobuf_ShutdownFile_CmdHome_2eproto();

class GetHomeSatusReq;
class GetHomeSatusResp;
class GetResourceReq;
class GetResourceResp;
class UpgradeResLandReq;
class UpgradeResLandResp;
class RemoveResLandReq;
class RemoveResLandResp;
class CancelResBuildingReq;
class CancelResBuildingResp;
class SpeedUpBuildReq;
class SpeedUpBuildResp;
class TradeGetMoneyResp;

// ===================================================================

class GetHomeSatusReq : public ::google::protobuf::MessageLite {
 public:
  GetHomeSatusReq();
  virtual ~GetHomeSatusReq();

  GetHomeSatusReq(const GetHomeSatusReq& from);

  inline GetHomeSatusReq& operator=(const GetHomeSatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetHomeSatusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetHomeSatusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetHomeSatusReq* other);

  // implements Message ----------------------------------------------

  GetHomeSatusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetHomeSatusReq& from);
  void MergeFrom(const GetHomeSatusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 home_type = 1;
  inline bool has_home_type() const;
  inline void clear_home_type();
  static const int kHomeTypeFieldNumber = 1;
  inline ::google::protobuf::int32 home_type() const;
  inline void set_home_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GetHomeSatusReq)
 private:
  inline void set_has_home_type();
  inline void clear_has_home_type();

  ::google::protobuf::int32 home_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static GetHomeSatusReq* default_instance_;
};
// -------------------------------------------------------------------

class GetHomeSatusResp : public ::google::protobuf::MessageLite {
 public:
  GetHomeSatusResp();
  virtual ~GetHomeSatusResp();

  GetHomeSatusResp(const GetHomeSatusResp& from);

  inline GetHomeSatusResp& operator=(const GetHomeSatusResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetHomeSatusResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetHomeSatusResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetHomeSatusResp* other);

  // implements Message ----------------------------------------------

  GetHomeSatusResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetHomeSatusResp& from);
  void MergeFrom(const GetHomeSatusResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:GetHomeSatusResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static GetHomeSatusResp* default_instance_;
};
// -------------------------------------------------------------------

class GetResourceReq : public ::google::protobuf::MessageLite {
 public:
  GetResourceReq();
  virtual ~GetResourceReq();

  GetResourceReq(const GetResourceReq& from);

  inline GetResourceReq& operator=(const GetResourceReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetResourceReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetResourceReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetResourceReq* other);

  // implements Message ----------------------------------------------

  GetResourceReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetResourceReq& from);
  void MergeFrom(const GetResourceReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 land_index = 1;
  inline bool has_land_index() const;
  inline void clear_land_index();
  static const int kLandIndexFieldNumber = 1;
  inline ::google::protobuf::int32 land_index() const;
  inline void set_land_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GetResourceReq)
 private:
  inline void set_has_land_index();
  inline void clear_has_land_index();

  ::google::protobuf::int32 land_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static GetResourceReq* default_instance_;
};
// -------------------------------------------------------------------

class GetResourceResp : public ::google::protobuf::MessageLite {
 public:
  GetResourceResp();
  virtual ~GetResourceResp();

  GetResourceResp(const GetResourceResp& from);

  inline GetResourceResp& operator=(const GetResourceResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetResourceResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetResourceResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetResourceResp* other);

  // implements Message ----------------------------------------------

  GetResourceResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetResourceResp& from);
  void MergeFrom(const GetResourceResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 land_index = 3;
  inline bool has_land_index() const;
  inline void clear_land_index();
  static const int kLandIndexFieldNumber = 3;
  inline ::google::protobuf::int32 land_index() const;
  inline void set_land_index(::google::protobuf::int32 value);

  // optional int32 resource_type = 4;
  inline bool has_resource_type() const;
  inline void clear_resource_type();
  static const int kResourceTypeFieldNumber = 4;
  inline ::google::protobuf::int32 resource_type() const;
  inline void set_resource_type(::google::protobuf::int32 value);

  // optional int32 resource_num = 5;
  inline bool has_resource_num() const;
  inline void clear_resource_num();
  static const int kResourceNumFieldNumber = 5;
  inline ::google::protobuf::int32 resource_num() const;
  inline void set_resource_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GetResourceResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_land_index();
  inline void clear_has_land_index();
  inline void set_has_resource_type();
  inline void clear_has_resource_type();
  inline void set_has_resource_num();
  inline void clear_has_resource_num();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 land_index_;
  ::google::protobuf::int32 resource_type_;
  ::google::protobuf::int32 resource_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static GetResourceResp* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeResLandReq : public ::google::protobuf::MessageLite {
 public:
  UpgradeResLandReq();
  virtual ~UpgradeResLandReq();

  UpgradeResLandReq(const UpgradeResLandReq& from);

  inline UpgradeResLandReq& operator=(const UpgradeResLandReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpgradeResLandReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpgradeResLandReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpgradeResLandReq* other);

  // implements Message ----------------------------------------------

  UpgradeResLandReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpgradeResLandReq& from);
  void MergeFrom(const UpgradeResLandReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 land_index = 1;
  inline bool has_land_index() const;
  inline void clear_land_index();
  static const int kLandIndexFieldNumber = 1;
  inline ::google::protobuf::int32 land_index() const;
  inline void set_land_index(::google::protobuf::int32 value);

  // optional int32 resource_type = 2;
  inline bool has_resource_type() const;
  inline void clear_resource_type();
  static const int kResourceTypeFieldNumber = 2;
  inline ::google::protobuf::int32 resource_type() const;
  inline void set_resource_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UpgradeResLandReq)
 private:
  inline void set_has_land_index();
  inline void clear_has_land_index();
  inline void set_has_resource_type();
  inline void clear_has_resource_type();

  ::google::protobuf::int32 land_index_;
  ::google::protobuf::int32 resource_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static UpgradeResLandReq* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeResLandResp : public ::google::protobuf::MessageLite {
 public:
  UpgradeResLandResp();
  virtual ~UpgradeResLandResp();

  UpgradeResLandResp(const UpgradeResLandResp& from);

  inline UpgradeResLandResp& operator=(const UpgradeResLandResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpgradeResLandResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpgradeResLandResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpgradeResLandResp* other);

  // implements Message ----------------------------------------------

  UpgradeResLandResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpgradeResLandResp& from);
  void MergeFrom(const UpgradeResLandResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 land_index = 3;
  inline bool has_land_index() const;
  inline void clear_land_index();
  static const int kLandIndexFieldNumber = 3;
  inline ::google::protobuf::int32 land_index() const;
  inline void set_land_index(::google::protobuf::int32 value);

  // optional int32 resource_type = 4;
  inline bool has_resource_type() const;
  inline void clear_resource_type();
  static const int kResourceTypeFieldNumber = 4;
  inline ::google::protobuf::int32 resource_type() const;
  inline void set_resource_type(::google::protobuf::int32 value);

  // optional int32 building_time = 5;
  inline bool has_building_time() const;
  inline void clear_building_time();
  static const int kBuildingTimeFieldNumber = 5;
  inline ::google::protobuf::int32 building_time() const;
  inline void set_building_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UpgradeResLandResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_land_index();
  inline void clear_has_land_index();
  inline void set_has_resource_type();
  inline void clear_has_resource_type();
  inline void set_has_building_time();
  inline void clear_has_building_time();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 land_index_;
  ::google::protobuf::int32 resource_type_;
  ::google::protobuf::int32 building_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static UpgradeResLandResp* default_instance_;
};
// -------------------------------------------------------------------

class RemoveResLandReq : public ::google::protobuf::MessageLite {
 public:
  RemoveResLandReq();
  virtual ~RemoveResLandReq();

  RemoveResLandReq(const RemoveResLandReq& from);

  inline RemoveResLandReq& operator=(const RemoveResLandReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RemoveResLandReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveResLandReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveResLandReq* other);

  // implements Message ----------------------------------------------

  RemoveResLandReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveResLandReq& from);
  void MergeFrom(const RemoveResLandReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 land_index = 1;
  inline bool has_land_index() const;
  inline void clear_land_index();
  static const int kLandIndexFieldNumber = 1;
  inline ::google::protobuf::int32 land_index() const;
  inline void set_land_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RemoveResLandReq)
 private:
  inline void set_has_land_index();
  inline void clear_has_land_index();

  ::google::protobuf::int32 land_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static RemoveResLandReq* default_instance_;
};
// -------------------------------------------------------------------

class RemoveResLandResp : public ::google::protobuf::MessageLite {
 public:
  RemoveResLandResp();
  virtual ~RemoveResLandResp();

  RemoveResLandResp(const RemoveResLandResp& from);

  inline RemoveResLandResp& operator=(const RemoveResLandResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RemoveResLandResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveResLandResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveResLandResp* other);

  // implements Message ----------------------------------------------

  RemoveResLandResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveResLandResp& from);
  void MergeFrom(const RemoveResLandResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 building_time = 2;
  inline bool has_building_time() const;
  inline void clear_building_time();
  static const int kBuildingTimeFieldNumber = 2;
  inline ::google::protobuf::int32 building_time() const;
  inline void set_building_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RemoveResLandResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_building_time();
  inline void clear_has_building_time();

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 building_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static RemoveResLandResp* default_instance_;
};
// -------------------------------------------------------------------

class CancelResBuildingReq : public ::google::protobuf::MessageLite {
 public:
  CancelResBuildingReq();
  virtual ~CancelResBuildingReq();

  CancelResBuildingReq(const CancelResBuildingReq& from);

  inline CancelResBuildingReq& operator=(const CancelResBuildingReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const CancelResBuildingReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CancelResBuildingReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CancelResBuildingReq* other);

  // implements Message ----------------------------------------------

  CancelResBuildingReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CancelResBuildingReq& from);
  void MergeFrom(const CancelResBuildingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 land_index = 1;
  inline bool has_land_index() const;
  inline void clear_land_index();
  static const int kLandIndexFieldNumber = 1;
  inline ::google::protobuf::int32 land_index() const;
  inline void set_land_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CancelResBuildingReq)
 private:
  inline void set_has_land_index();
  inline void clear_has_land_index();

  ::google::protobuf::int32 land_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static CancelResBuildingReq* default_instance_;
};
// -------------------------------------------------------------------

class CancelResBuildingResp : public ::google::protobuf::MessageLite {
 public:
  CancelResBuildingResp();
  virtual ~CancelResBuildingResp();

  CancelResBuildingResp(const CancelResBuildingResp& from);

  inline CancelResBuildingResp& operator=(const CancelResBuildingResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CancelResBuildingResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CancelResBuildingResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CancelResBuildingResp* other);

  // implements Message ----------------------------------------------

  CancelResBuildingResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CancelResBuildingResp& from);
  void MergeFrom(const CancelResBuildingResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:CancelResBuildingResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static CancelResBuildingResp* default_instance_;
};
// -------------------------------------------------------------------

class SpeedUpBuildReq : public ::google::protobuf::MessageLite {
 public:
  SpeedUpBuildReq();
  virtual ~SpeedUpBuildReq();

  SpeedUpBuildReq(const SpeedUpBuildReq& from);

  inline SpeedUpBuildReq& operator=(const SpeedUpBuildReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const SpeedUpBuildReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SpeedUpBuildReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SpeedUpBuildReq* other);

  // implements Message ----------------------------------------------

  SpeedUpBuildReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SpeedUpBuildReq& from);
  void MergeFrom(const SpeedUpBuildReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 land_index = 1;
  inline bool has_land_index() const;
  inline void clear_land_index();
  static const int kLandIndexFieldNumber = 1;
  inline ::google::protobuf::int32 land_index() const;
  inline void set_land_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SpeedUpBuildReq)
 private:
  inline void set_has_land_index();
  inline void clear_has_land_index();

  ::google::protobuf::int32 land_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static SpeedUpBuildReq* default_instance_;
};
// -------------------------------------------------------------------

class SpeedUpBuildResp : public ::google::protobuf::MessageLite {
 public:
  SpeedUpBuildResp();
  virtual ~SpeedUpBuildResp();

  SpeedUpBuildResp(const SpeedUpBuildResp& from);

  inline SpeedUpBuildResp& operator=(const SpeedUpBuildResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const SpeedUpBuildResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SpeedUpBuildResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SpeedUpBuildResp* other);

  // implements Message ----------------------------------------------

  SpeedUpBuildResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SpeedUpBuildResp& from);
  void MergeFrom(const SpeedUpBuildResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 land_index = 3;
  inline bool has_land_index() const;
  inline void clear_land_index();
  static const int kLandIndexFieldNumber = 3;
  inline ::google::protobuf::int32 land_index() const;
  inline void set_land_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SpeedUpBuildResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_land_index();
  inline void clear_has_land_index();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 land_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static SpeedUpBuildResp* default_instance_;
};
// -------------------------------------------------------------------

class TradeGetMoneyResp : public ::google::protobuf::MessageLite {
 public:
  TradeGetMoneyResp();
  virtual ~TradeGetMoneyResp();

  TradeGetMoneyResp(const TradeGetMoneyResp& from);

  inline TradeGetMoneyResp& operator=(const TradeGetMoneyResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const TradeGetMoneyResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TradeGetMoneyResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TradeGetMoneyResp* other);

  // implements Message ----------------------------------------------

  TradeGetMoneyResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TradeGetMoneyResp& from);
  void MergeFrom(const TradeGetMoneyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:TradeGetMoneyResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdHome_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdHome_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdHome_2eproto();
  friend void protobuf_ShutdownFile_CmdHome_2eproto();

  void InitAsDefaultInstance();
  static TradeGetMoneyResp* default_instance_;
};
// ===================================================================


// ===================================================================

// GetHomeSatusReq

// required int32 home_type = 1;
inline bool GetHomeSatusReq::has_home_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetHomeSatusReq::set_has_home_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetHomeSatusReq::clear_has_home_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetHomeSatusReq::clear_home_type() {
  home_type_ = 0;
  clear_has_home_type();
}
inline ::google::protobuf::int32 GetHomeSatusReq::home_type() const {
  return home_type_;
}
inline void GetHomeSatusReq::set_home_type(::google::protobuf::int32 value) {
  set_has_home_type();
  home_type_ = value;
}

// -------------------------------------------------------------------

// GetHomeSatusResp

// required int32 result = 1;
inline bool GetHomeSatusResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetHomeSatusResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetHomeSatusResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetHomeSatusResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GetHomeSatusResp::result() const {
  return result_;
}
inline void GetHomeSatusResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GetHomeSatusResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetHomeSatusResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetHomeSatusResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetHomeSatusResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GetHomeSatusResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* GetHomeSatusResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GetHomeSatusResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GetHomeSatusResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// GetResourceReq

// required int32 land_index = 1;
inline bool GetResourceReq::has_land_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetResourceReq::set_has_land_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetResourceReq::clear_has_land_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetResourceReq::clear_land_index() {
  land_index_ = 0;
  clear_has_land_index();
}
inline ::google::protobuf::int32 GetResourceReq::land_index() const {
  return land_index_;
}
inline void GetResourceReq::set_land_index(::google::protobuf::int32 value) {
  set_has_land_index();
  land_index_ = value;
}

// -------------------------------------------------------------------

// GetResourceResp

// required int32 result = 1;
inline bool GetResourceResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetResourceResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetResourceResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetResourceResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GetResourceResp::result() const {
  return result_;
}
inline void GetResourceResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GetResourceResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetResourceResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetResourceResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetResourceResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GetResourceResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* GetResourceResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GetResourceResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GetResourceResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 land_index = 3;
inline bool GetResourceResp::has_land_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetResourceResp::set_has_land_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetResourceResp::clear_has_land_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetResourceResp::clear_land_index() {
  land_index_ = 0;
  clear_has_land_index();
}
inline ::google::protobuf::int32 GetResourceResp::land_index() const {
  return land_index_;
}
inline void GetResourceResp::set_land_index(::google::protobuf::int32 value) {
  set_has_land_index();
  land_index_ = value;
}

// optional int32 resource_type = 4;
inline bool GetResourceResp::has_resource_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetResourceResp::set_has_resource_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetResourceResp::clear_has_resource_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetResourceResp::clear_resource_type() {
  resource_type_ = 0;
  clear_has_resource_type();
}
inline ::google::protobuf::int32 GetResourceResp::resource_type() const {
  return resource_type_;
}
inline void GetResourceResp::set_resource_type(::google::protobuf::int32 value) {
  set_has_resource_type();
  resource_type_ = value;
}

// optional int32 resource_num = 5;
inline bool GetResourceResp::has_resource_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetResourceResp::set_has_resource_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetResourceResp::clear_has_resource_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetResourceResp::clear_resource_num() {
  resource_num_ = 0;
  clear_has_resource_num();
}
inline ::google::protobuf::int32 GetResourceResp::resource_num() const {
  return resource_num_;
}
inline void GetResourceResp::set_resource_num(::google::protobuf::int32 value) {
  set_has_resource_num();
  resource_num_ = value;
}

// -------------------------------------------------------------------

// UpgradeResLandReq

// required int32 land_index = 1;
inline bool UpgradeResLandReq::has_land_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeResLandReq::set_has_land_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeResLandReq::clear_has_land_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeResLandReq::clear_land_index() {
  land_index_ = 0;
  clear_has_land_index();
}
inline ::google::protobuf::int32 UpgradeResLandReq::land_index() const {
  return land_index_;
}
inline void UpgradeResLandReq::set_land_index(::google::protobuf::int32 value) {
  set_has_land_index();
  land_index_ = value;
}

// optional int32 resource_type = 2;
inline bool UpgradeResLandReq::has_resource_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeResLandReq::set_has_resource_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeResLandReq::clear_has_resource_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeResLandReq::clear_resource_type() {
  resource_type_ = 0;
  clear_has_resource_type();
}
inline ::google::protobuf::int32 UpgradeResLandReq::resource_type() const {
  return resource_type_;
}
inline void UpgradeResLandReq::set_resource_type(::google::protobuf::int32 value) {
  set_has_resource_type();
  resource_type_ = value;
}

// -------------------------------------------------------------------

// UpgradeResLandResp

// required int32 result = 1;
inline bool UpgradeResLandResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeResLandResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeResLandResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeResLandResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UpgradeResLandResp::result() const {
  return result_;
}
inline void UpgradeResLandResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool UpgradeResLandResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeResLandResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeResLandResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeResLandResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& UpgradeResLandResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* UpgradeResLandResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* UpgradeResLandResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void UpgradeResLandResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 land_index = 3;
inline bool UpgradeResLandResp::has_land_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpgradeResLandResp::set_has_land_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpgradeResLandResp::clear_has_land_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpgradeResLandResp::clear_land_index() {
  land_index_ = 0;
  clear_has_land_index();
}
inline ::google::protobuf::int32 UpgradeResLandResp::land_index() const {
  return land_index_;
}
inline void UpgradeResLandResp::set_land_index(::google::protobuf::int32 value) {
  set_has_land_index();
  land_index_ = value;
}

// optional int32 resource_type = 4;
inline bool UpgradeResLandResp::has_resource_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpgradeResLandResp::set_has_resource_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpgradeResLandResp::clear_has_resource_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpgradeResLandResp::clear_resource_type() {
  resource_type_ = 0;
  clear_has_resource_type();
}
inline ::google::protobuf::int32 UpgradeResLandResp::resource_type() const {
  return resource_type_;
}
inline void UpgradeResLandResp::set_resource_type(::google::protobuf::int32 value) {
  set_has_resource_type();
  resource_type_ = value;
}

// optional int32 building_time = 5;
inline bool UpgradeResLandResp::has_building_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpgradeResLandResp::set_has_building_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpgradeResLandResp::clear_has_building_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpgradeResLandResp::clear_building_time() {
  building_time_ = 0;
  clear_has_building_time();
}
inline ::google::protobuf::int32 UpgradeResLandResp::building_time() const {
  return building_time_;
}
inline void UpgradeResLandResp::set_building_time(::google::protobuf::int32 value) {
  set_has_building_time();
  building_time_ = value;
}

// -------------------------------------------------------------------

// RemoveResLandReq

// required int32 land_index = 1;
inline bool RemoveResLandReq::has_land_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveResLandReq::set_has_land_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveResLandReq::clear_has_land_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveResLandReq::clear_land_index() {
  land_index_ = 0;
  clear_has_land_index();
}
inline ::google::protobuf::int32 RemoveResLandReq::land_index() const {
  return land_index_;
}
inline void RemoveResLandReq::set_land_index(::google::protobuf::int32 value) {
  set_has_land_index();
  land_index_ = value;
}

// -------------------------------------------------------------------

// RemoveResLandResp

// required int32 result = 1;
inline bool RemoveResLandResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveResLandResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveResLandResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveResLandResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RemoveResLandResp::result() const {
  return result_;
}
inline void RemoveResLandResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 building_time = 2;
inline bool RemoveResLandResp::has_building_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveResLandResp::set_has_building_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveResLandResp::clear_has_building_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveResLandResp::clear_building_time() {
  building_time_ = 0;
  clear_has_building_time();
}
inline ::google::protobuf::int32 RemoveResLandResp::building_time() const {
  return building_time_;
}
inline void RemoveResLandResp::set_building_time(::google::protobuf::int32 value) {
  set_has_building_time();
  building_time_ = value;
}

// -------------------------------------------------------------------

// CancelResBuildingReq

// required int32 land_index = 1;
inline bool CancelResBuildingReq::has_land_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelResBuildingReq::set_has_land_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelResBuildingReq::clear_has_land_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelResBuildingReq::clear_land_index() {
  land_index_ = 0;
  clear_has_land_index();
}
inline ::google::protobuf::int32 CancelResBuildingReq::land_index() const {
  return land_index_;
}
inline void CancelResBuildingReq::set_land_index(::google::protobuf::int32 value) {
  set_has_land_index();
  land_index_ = value;
}

// -------------------------------------------------------------------

// CancelResBuildingResp

// required int32 result = 1;
inline bool CancelResBuildingResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelResBuildingResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelResBuildingResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelResBuildingResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CancelResBuildingResp::result() const {
  return result_;
}
inline void CancelResBuildingResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool CancelResBuildingResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelResBuildingResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelResBuildingResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelResBuildingResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& CancelResBuildingResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* CancelResBuildingResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* CancelResBuildingResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void CancelResBuildingResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// SpeedUpBuildReq

// required int32 land_index = 1;
inline bool SpeedUpBuildReq::has_land_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedUpBuildReq::set_has_land_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedUpBuildReq::clear_has_land_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedUpBuildReq::clear_land_index() {
  land_index_ = 0;
  clear_has_land_index();
}
inline ::google::protobuf::int32 SpeedUpBuildReq::land_index() const {
  return land_index_;
}
inline void SpeedUpBuildReq::set_land_index(::google::protobuf::int32 value) {
  set_has_land_index();
  land_index_ = value;
}

// -------------------------------------------------------------------

// SpeedUpBuildResp

// required int32 result = 1;
inline bool SpeedUpBuildResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedUpBuildResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedUpBuildResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedUpBuildResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 SpeedUpBuildResp::result() const {
  return result_;
}
inline void SpeedUpBuildResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool SpeedUpBuildResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeedUpBuildResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeedUpBuildResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeedUpBuildResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& SpeedUpBuildResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* SpeedUpBuildResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* SpeedUpBuildResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void SpeedUpBuildResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 land_index = 3;
inline bool SpeedUpBuildResp::has_land_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeedUpBuildResp::set_has_land_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeedUpBuildResp::clear_has_land_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpeedUpBuildResp::clear_land_index() {
  land_index_ = 0;
  clear_has_land_index();
}
inline ::google::protobuf::int32 SpeedUpBuildResp::land_index() const {
  return land_index_;
}
inline void SpeedUpBuildResp::set_land_index(::google::protobuf::int32 value) {
  set_has_land_index();
  land_index_ = value;
}

// -------------------------------------------------------------------

// TradeGetMoneyResp

// required int32 result = 1;
inline bool TradeGetMoneyResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeGetMoneyResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeGetMoneyResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeGetMoneyResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 TradeGetMoneyResp::result() const {
  return result_;
}
inline void TradeGetMoneyResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool TradeGetMoneyResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeGetMoneyResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeGetMoneyResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeGetMoneyResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& TradeGetMoneyResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* TradeGetMoneyResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* TradeGetMoneyResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void TradeGetMoneyResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdHome_2eproto__INCLUDED
