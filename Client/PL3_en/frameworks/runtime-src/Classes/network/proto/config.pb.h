// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#ifndef PROTOBUF_config_2eproto__INCLUDED
#define PROTOBUF_config_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_config_2eproto();
void protobuf_AssignDesc_config_2eproto();
void protobuf_ShutdownFile_config_2eproto();

class ConfValue;
class ConfigRow;
class ConfigTable;
class nick_name_ctrl;

// ===================================================================

class ConfValue : public ::google::protobuf::MessageLite {
 public:
  ConfValue();
  virtual ~ConfValue();

  ConfValue(const ConfValue& from);

  inline ConfValue& operator=(const ConfValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConfValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfValue* other);

  // implements Message ----------------------------------------------

  ConfValue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfValue& from);
  void MergeFrom(const ConfValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 val_int = 1;
  inline bool has_val_int() const;
  inline void clear_val_int();
  static const int kValIntFieldNumber = 1;
  inline ::google::protobuf::int32 val_int() const;
  inline void set_val_int(::google::protobuf::int32 value);

  // optional int64 val_long = 2;
  inline bool has_val_long() const;
  inline void clear_val_long();
  static const int kValLongFieldNumber = 2;
  inline ::google::protobuf::int64 val_long() const;
  inline void set_val_long(::google::protobuf::int64 value);

  // optional string val_string = 3;
  inline bool has_val_string() const;
  inline void clear_val_string();
  static const int kValStringFieldNumber = 3;
  inline const ::std::string& val_string() const;
  inline void set_val_string(const ::std::string& value);
  inline void set_val_string(const char* value);
  inline void set_val_string(const char* value, size_t size);
  inline ::std::string* mutable_val_string();
  inline ::std::string* release_val_string();
  inline void set_allocated_val_string(::std::string* val_string);

  // @@protoc_insertion_point(class_scope:ConfValue)
 private:
  inline void set_has_val_int();
  inline void clear_has_val_int();
  inline void set_has_val_long();
  inline void clear_has_val_long();
  inline void set_has_val_string();
  inline void clear_has_val_string();

  ::google::protobuf::int64 val_long_;
  ::std::string* val_string_;
  ::google::protobuf::int32 val_int_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_config_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_config_2eproto();
  #endif
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static ConfValue* default_instance_;
};
// -------------------------------------------------------------------

class ConfigRow : public ::google::protobuf::MessageLite {
 public:
  ConfigRow();
  virtual ~ConfigRow();

  ConfigRow(const ConfigRow& from);

  inline ConfigRow& operator=(const ConfigRow& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConfigRow& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigRow* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigRow* other);

  // implements Message ----------------------------------------------

  ConfigRow* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigRow& from);
  void MergeFrom(const ConfigRow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ConfValue values = 1;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline const ::ConfValue& values(int index) const;
  inline ::ConfValue* mutable_values(int index);
  inline ::ConfValue* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::ConfValue >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::ConfValue >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ConfigRow)
 private:

  ::google::protobuf::RepeatedPtrField< ::ConfValue > values_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_config_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_config_2eproto();
  #endif
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static ConfigRow* default_instance_;
};
// -------------------------------------------------------------------

class ConfigTable : public ::google::protobuf::MessageLite {
 public:
  ConfigTable();
  virtual ~ConfigTable();

  ConfigTable(const ConfigTable& from);

  inline ConfigTable& operator=(const ConfigTable& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConfigTable& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigTable* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigTable* other);

  // implements Message ----------------------------------------------

  ConfigTable* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigTable& from);
  void MergeFrom(const ConfigTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string fields = 1;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 1;
  inline const ::std::string& fields(int index) const;
  inline ::std::string* mutable_fields(int index);
  inline void set_fields(int index, const ::std::string& value);
  inline void set_fields(int index, const char* value);
  inline void set_fields(int index, const char* value, size_t size);
  inline ::std::string* add_fields();
  inline void add_fields(const ::std::string& value);
  inline void add_fields(const char* value);
  inline void add_fields(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // repeated .ConfigRow rows = 2;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 2;
  inline const ::ConfigRow& rows(int index) const;
  inline ::ConfigRow* mutable_rows(int index);
  inline ::ConfigRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::ConfigRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::ConfigRow >*
      mutable_rows();

  // @@protoc_insertion_point(class_scope:ConfigTable)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::RepeatedPtrField< ::ConfigRow > rows_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_config_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_config_2eproto();
  #endif
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static ConfigTable* default_instance_;
};
// -------------------------------------------------------------------

class nick_name_ctrl : public ::google::protobuf::MessageLite {
 public:
  nick_name_ctrl();
  virtual ~nick_name_ctrl();

  nick_name_ctrl(const nick_name_ctrl& from);

  inline nick_name_ctrl& operator=(const nick_name_ctrl& from) {
    CopyFrom(from);
    return *this;
  }

  static const nick_name_ctrl& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const nick_name_ctrl* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(nick_name_ctrl* other);

  // implements Message ----------------------------------------------

  nick_name_ctrl* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const nick_name_ctrl& from);
  void MergeFrom(const nick_name_ctrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required int32 flag = 2;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nick_name_ctrl)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_flag();
  inline void clear_has_flag();

  ::std::string* user_name_;
  ::google::protobuf::int32 flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_config_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_config_2eproto();
  #endif
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static nick_name_ctrl* default_instance_;
};
// ===================================================================


// ===================================================================

// ConfValue

// optional int32 val_int = 1;
inline bool ConfValue::has_val_int() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfValue::set_has_val_int() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfValue::clear_has_val_int() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfValue::clear_val_int() {
  val_int_ = 0;
  clear_has_val_int();
}
inline ::google::protobuf::int32 ConfValue::val_int() const {
  return val_int_;
}
inline void ConfValue::set_val_int(::google::protobuf::int32 value) {
  set_has_val_int();
  val_int_ = value;
}

// optional int64 val_long = 2;
inline bool ConfValue::has_val_long() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfValue::set_has_val_long() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfValue::clear_has_val_long() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfValue::clear_val_long() {
  val_long_ = GOOGLE_LONGLONG(0);
  clear_has_val_long();
}
inline ::google::protobuf::int64 ConfValue::val_long() const {
  return val_long_;
}
inline void ConfValue::set_val_long(::google::protobuf::int64 value) {
  set_has_val_long();
  val_long_ = value;
}

// optional string val_string = 3;
inline bool ConfValue::has_val_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfValue::set_has_val_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfValue::clear_has_val_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfValue::clear_val_string() {
  if (val_string_ != &::google::protobuf::internal::kEmptyString) {
    val_string_->clear();
  }
  clear_has_val_string();
}
inline const ::std::string& ConfValue::val_string() const {
  return *val_string_;
}
inline void ConfValue::set_val_string(const ::std::string& value) {
  set_has_val_string();
  if (val_string_ == &::google::protobuf::internal::kEmptyString) {
    val_string_ = new ::std::string;
  }
  val_string_->assign(value);
}
inline void ConfValue::set_val_string(const char* value) {
  set_has_val_string();
  if (val_string_ == &::google::protobuf::internal::kEmptyString) {
    val_string_ = new ::std::string;
  }
  val_string_->assign(value);
}
inline void ConfValue::set_val_string(const char* value, size_t size) {
  set_has_val_string();
  if (val_string_ == &::google::protobuf::internal::kEmptyString) {
    val_string_ = new ::std::string;
  }
  val_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfValue::mutable_val_string() {
  set_has_val_string();
  if (val_string_ == &::google::protobuf::internal::kEmptyString) {
    val_string_ = new ::std::string;
  }
  return val_string_;
}
inline ::std::string* ConfValue::release_val_string() {
  clear_has_val_string();
  if (val_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = val_string_;
    val_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfValue::set_allocated_val_string(::std::string* val_string) {
  if (val_string_ != &::google::protobuf::internal::kEmptyString) {
    delete val_string_;
  }
  if (val_string) {
    set_has_val_string();
    val_string_ = val_string;
  } else {
    clear_has_val_string();
    val_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConfigRow

// repeated .ConfValue values = 1;
inline int ConfigRow::values_size() const {
  return values_.size();
}
inline void ConfigRow::clear_values() {
  values_.Clear();
}
inline const ::ConfValue& ConfigRow::values(int index) const {
  return values_.Get(index);
}
inline ::ConfValue* ConfigRow::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::ConfValue* ConfigRow::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ConfValue >&
ConfigRow::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::ConfValue >*
ConfigRow::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// ConfigTable

// repeated string fields = 1;
inline int ConfigTable::fields_size() const {
  return fields_.size();
}
inline void ConfigTable::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& ConfigTable::fields(int index) const {
  return fields_.Get(index);
}
inline ::std::string* ConfigTable::mutable_fields(int index) {
  return fields_.Mutable(index);
}
inline void ConfigTable::set_fields(int index, const ::std::string& value) {
  fields_.Mutable(index)->assign(value);
}
inline void ConfigTable::set_fields(int index, const char* value) {
  fields_.Mutable(index)->assign(value);
}
inline void ConfigTable::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigTable::add_fields() {
  return fields_.Add();
}
inline void ConfigTable::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
}
inline void ConfigTable::add_fields(const char* value) {
  fields_.Add()->assign(value);
}
inline void ConfigTable::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ConfigTable::fields() const {
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ConfigTable::mutable_fields() {
  return &fields_;
}

// repeated .ConfigRow rows = 2;
inline int ConfigTable::rows_size() const {
  return rows_.size();
}
inline void ConfigTable::clear_rows() {
  rows_.Clear();
}
inline const ::ConfigRow& ConfigTable::rows(int index) const {
  return rows_.Get(index);
}
inline ::ConfigRow* ConfigTable::mutable_rows(int index) {
  return rows_.Mutable(index);
}
inline ::ConfigRow* ConfigTable::add_rows() {
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ConfigRow >&
ConfigTable::rows() const {
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::ConfigRow >*
ConfigTable::mutable_rows() {
  return &rows_;
}

// -------------------------------------------------------------------

// nick_name_ctrl

// required string user_name = 1;
inline bool nick_name_ctrl::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void nick_name_ctrl::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void nick_name_ctrl::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void nick_name_ctrl::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& nick_name_ctrl::user_name() const {
  return *user_name_;
}
inline void nick_name_ctrl::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void nick_name_ctrl::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void nick_name_ctrl::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* nick_name_ctrl::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* nick_name_ctrl::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void nick_name_ctrl::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 flag = 2;
inline bool nick_name_ctrl::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void nick_name_ctrl::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void nick_name_ctrl::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void nick_name_ctrl::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 nick_name_ctrl::flag() const {
  return flag_;
}
inline void nick_name_ctrl::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_config_2eproto__INCLUDED
