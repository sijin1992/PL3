// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdPlanet.proto

#ifndef PROTOBUF_CmdPlanet_2eproto__INCLUDED
#define PROTOBUF_CmdPlanet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Planet.pb.h"
#include "OtherInfo.pb.h"
#include "UserInfo.pb.h"
#include "UserSync.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdPlanet_2eproto();
void protobuf_AssignDesc_CmdPlanet_2eproto();
void protobuf_ShutdownFile_CmdPlanet_2eproto();

class PlanetGetReq;
class PlanetGetResp;
class PlanetCollectReq;
class PlanetCollectResp;
class PlanetRideBackReq;
class PlanetRideBackResp;
class PlanetRuinsReq;
class PlanetRuinsResp;
class PlanetRaidReq;
class PlanetRaidResp;
class PlanetSpeedUpReq;
class PlanetSpeedUpResp;
class PlanetShieldReq;
class PlanetShieldResp;
class PlanetMoveBaseReq;
class PlanetMoveBaseResp;
class PlanetMarkReq;
class PlanetMarkResp;
class PlanetTowerReq;
class PlanetTowerResp;
class PlanetWangZuoTitleReq;
class PLanetWangZuoTitleResp;

enum PlanetCollectResp_PlanetCollectRet {
  PlanetCollectResp_PlanetCollectRet_OK = 0,
  PlanetCollectResp_PlanetCollectRet_FAIL = -1,
  PlanetCollectResp_PlanetCollectRet_ERROR_TYPE = 1,
  PlanetCollectResp_PlanetCollectRet_REQ_ERROR = 2,
  PlanetCollectResp_PlanetCollectRet_LINEUP_ERROR = 3,
  PlanetCollectResp_PlanetCollectRet_NO_DURABLE = 4,
  PlanetCollectResp_PlanetCollectRet_FIXING = 5,
  PlanetCollectResp_PlanetCollectRet_OUTING = 6,
  PlanetCollectResp_PlanetCollectRet_ARMY_NUM_MAX = 7,
  PlanetCollectResp_PlanetCollectRet_MY_RES = 8,
  PlanetCollectResp_PlanetCollectRet_RES_MAX_LOAD = 9,
  PlanetCollectResp_PlanetCollectRet_ERROR_GROUP = 10,
  PlanetCollectResp_PlanetCollectRet_NO_STORAGE = 11,
  PlanetCollectResp_PlanetCollectRet_ALREADY_COLLECT = 12
};
bool PlanetCollectResp_PlanetCollectRet_IsValid(int value);
const PlanetCollectResp_PlanetCollectRet PlanetCollectResp_PlanetCollectRet_PlanetCollectRet_MIN = PlanetCollectResp_PlanetCollectRet_FAIL;
const PlanetCollectResp_PlanetCollectRet PlanetCollectResp_PlanetCollectRet_PlanetCollectRet_MAX = PlanetCollectResp_PlanetCollectRet_ALREADY_COLLECT;
const int PlanetCollectResp_PlanetCollectRet_PlanetCollectRet_ARRAYSIZE = PlanetCollectResp_PlanetCollectRet_PlanetCollectRet_MAX + 1;

enum PlanetRuinsResp_PlanetRuinsRet {
  PlanetRuinsResp_PlanetRuinsRet_OK = 0,
  PlanetRuinsResp_PlanetRuinsRet_FAIL = -1,
  PlanetRuinsResp_PlanetRuinsRet_ERROR_TYPE = 1,
  PlanetRuinsResp_PlanetRuinsRet_REQ_ERROR = 2,
  PlanetRuinsResp_PlanetRuinsRet_LINEUP_ERROR = 3,
  PlanetRuinsResp_PlanetRuinsRet_NO_DURABLE = 4,
  PlanetRuinsResp_PlanetRuinsRet_FIXING = 5,
  PlanetRuinsResp_PlanetRuinsRet_OUTING = 6,
  PlanetRuinsResp_PlanetRuinsRet_ARMY_NUM_MAX = 7,
  PlanetRuinsResp_PlanetRuinsRet_NO_TYPE = 8,
  PlanetRuinsResp_PlanetRuinsRet_NO_STRENGTH = 9
};
bool PlanetRuinsResp_PlanetRuinsRet_IsValid(int value);
const PlanetRuinsResp_PlanetRuinsRet PlanetRuinsResp_PlanetRuinsRet_PlanetRuinsRet_MIN = PlanetRuinsResp_PlanetRuinsRet_FAIL;
const PlanetRuinsResp_PlanetRuinsRet PlanetRuinsResp_PlanetRuinsRet_PlanetRuinsRet_MAX = PlanetRuinsResp_PlanetRuinsRet_NO_STRENGTH;
const int PlanetRuinsResp_PlanetRuinsRet_PlanetRuinsRet_ARRAYSIZE = PlanetRuinsResp_PlanetRuinsRet_PlanetRuinsRet_MAX + 1;

enum PlanetRaidResp_PlanetRaidRet {
  PlanetRaidResp_PlanetRaidRet_OK = 0,
  PlanetRaidResp_PlanetRaidRet_FAIL = -1,
  PlanetRaidResp_PlanetRaidRet_ERROR_TYPE = 1,
  PlanetRaidResp_PlanetRaidRet_REQ_ERROR = 2,
  PlanetRaidResp_PlanetRaidRet_LINEUP_ERROR = 3,
  PlanetRaidResp_PlanetRaidRet_NO_DURABLE = 4,
  PlanetRaidResp_PlanetRaidRet_FIXING = 5,
  PlanetRaidResp_PlanetRaidRet_OUTING = 6,
  PlanetRaidResp_PlanetRaidRet_ARMY_NUM_MAX = 7,
  PlanetRaidResp_PlanetRaidRet_NOT_OPEN = 8,
  PlanetRaidResp_PlanetRaidRet_ERROR_GROUP = 9,
  PlanetRaidResp_PlanetRaidRet_ERROR_STATUS = 10,
  PlanetRaidResp_PlanetRaidRet_NO_STRENGTH = 11,
  PlanetRaidResp_PlanetRaidRet_NO_GROUP = 12,
  PlanetRaidResp_PlanetRaidRet_ALREADY_GUARDE = 13,
  PlanetRaidResp_PlanetRaidRet_ALREADY_ACCOMPANY = 14,
  PlanetRaidResp_PlanetRaidRet_ALREADY_REQ_ACCOMPANY = 15,
  PlanetRaidResp_PlanetRaidRet_NO_GROUP_POWER = 16,
  PlanetRaidResp_PlanetRaidRet_NO_BASE_POWER = 17,
  PlanetRaidResp_PlanetRaidRet_SHIELD = 18,
  PlanetRaidResp_PlanetRaidRet_NO_LAST_CITY_1 = 19,
  PlanetRaidResp_PlanetRaidRet_NO_LAST_CITY_2 = 20,
  PlanetRaidResp_PlanetRaidRet_NO_LAST_CITY_3 = 21
};
bool PlanetRaidResp_PlanetRaidRet_IsValid(int value);
const PlanetRaidResp_PlanetRaidRet PlanetRaidResp_PlanetRaidRet_PlanetRaidRet_MIN = PlanetRaidResp_PlanetRaidRet_FAIL;
const PlanetRaidResp_PlanetRaidRet PlanetRaidResp_PlanetRaidRet_PlanetRaidRet_MAX = PlanetRaidResp_PlanetRaidRet_NO_LAST_CITY_3;
const int PlanetRaidResp_PlanetRaidRet_PlanetRaidRet_ARRAYSIZE = PlanetRaidResp_PlanetRaidRet_PlanetRaidRet_MAX + 1;

enum PlanetMoveBaseResp_PlanetMoveBaseRet {
  PlanetMoveBaseResp_PlanetMoveBaseRet_OK = 0,
  PlanetMoveBaseResp_PlanetMoveBaseRet_FAIL = -1,
  PlanetMoveBaseResp_PlanetMoveBaseRet_NO_ITEM = 1,
  PlanetMoveBaseResp_PlanetMoveBaseRet_HAS_ELEMENT = 2,
  PlanetMoveBaseResp_PlanetMoveBaseRet_ERROR_NATION = 3,
  PlanetMoveBaseResp_PlanetMoveBaseRet_ERROR_CITY = 4,
  PlanetMoveBaseResp_PlanetMoveBaseRet_ERROR_POS = 5
};
bool PlanetMoveBaseResp_PlanetMoveBaseRet_IsValid(int value);
const PlanetMoveBaseResp_PlanetMoveBaseRet PlanetMoveBaseResp_PlanetMoveBaseRet_PlanetMoveBaseRet_MIN = PlanetMoveBaseResp_PlanetMoveBaseRet_FAIL;
const PlanetMoveBaseResp_PlanetMoveBaseRet PlanetMoveBaseResp_PlanetMoveBaseRet_PlanetMoveBaseRet_MAX = PlanetMoveBaseResp_PlanetMoveBaseRet_ERROR_POS;
const int PlanetMoveBaseResp_PlanetMoveBaseRet_PlanetMoveBaseRet_ARRAYSIZE = PlanetMoveBaseResp_PlanetMoveBaseRet_PlanetMoveBaseRet_MAX + 1;

// ===================================================================

class PlanetGetReq : public ::google::protobuf::MessageLite {
 public:
  PlanetGetReq();
  virtual ~PlanetGetReq();

  PlanetGetReq(const PlanetGetReq& from);

  inline PlanetGetReq& operator=(const PlanetGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetGetReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetGetReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetGetReq* other);

  // implements Message ----------------------------------------------

  PlanetGetReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetGetReq& from);
  void MergeFrom(const PlanetGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int32 node_id_list = 2;
  inline int node_id_list_size() const;
  inline void clear_node_id_list();
  static const int kNodeIdListFieldNumber = 2;
  inline ::google::protobuf::int32 node_id_list(int index) const;
  inline void set_node_id_list(int index, ::google::protobuf::int32 value);
  inline void add_node_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      node_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_node_id_list();

  // repeated string element_global_key_list = 3;
  inline int element_global_key_list_size() const;
  inline void clear_element_global_key_list();
  static const int kElementGlobalKeyListFieldNumber = 3;
  inline const ::std::string& element_global_key_list(int index) const;
  inline ::std::string* mutable_element_global_key_list(int index);
  inline void set_element_global_key_list(int index, const ::std::string& value);
  inline void set_element_global_key_list(int index, const char* value);
  inline void set_element_global_key_list(int index, const char* value, size_t size);
  inline ::std::string* add_element_global_key_list();
  inline void add_element_global_key_list(const ::std::string& value);
  inline void add_element_global_key_list(const char* value);
  inline void add_element_global_key_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& element_global_key_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_element_global_key_list();

  // repeated string army_line_key_list = 4;
  inline int army_line_key_list_size() const;
  inline void clear_army_line_key_list();
  static const int kArmyLineKeyListFieldNumber = 4;
  inline const ::std::string& army_line_key_list(int index) const;
  inline ::std::string* mutable_army_line_key_list(int index);
  inline void set_army_line_key_list(int index, const ::std::string& value);
  inline void set_army_line_key_list(int index, const char* value);
  inline void set_army_line_key_list(int index, const char* value, size_t size);
  inline ::std::string* add_army_line_key_list();
  inline void add_army_line_key_list(const ::std::string& value);
  inline void add_army_line_key_list(const char* value);
  inline void add_army_line_key_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& army_line_key_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_army_line_key_list();

  // repeated string army_key_list = 5;
  inline int army_key_list_size() const;
  inline void clear_army_key_list();
  static const int kArmyKeyListFieldNumber = 5;
  inline const ::std::string& army_key_list(int index) const;
  inline ::std::string* mutable_army_key_list(int index);
  inline void set_army_key_list(int index, const ::std::string& value);
  inline void set_army_key_list(int index, const char* value);
  inline void set_army_key_list(int index, const char* value, size_t size);
  inline ::std::string* add_army_key_list();
  inline void add_army_key_list(const ::std::string& value);
  inline void add_army_key_list(const char* value);
  inline void add_army_key_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& army_key_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_army_key_list();

  // @@protoc_insertion_point(class_scope:PlanetGetReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > node_id_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> element_global_key_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> army_line_key_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> army_key_list_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetGetReq* default_instance_;
};
// -------------------------------------------------------------------

class PlanetGetResp : public ::google::protobuf::MessageLite {
 public:
  PlanetGetResp();
  virtual ~PlanetGetResp();

  PlanetGetResp(const PlanetGetResp& from);

  inline PlanetGetResp& operator=(const PlanetGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetGetResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetGetResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetGetResp* other);

  // implements Message ----------------------------------------------

  PlanetGetResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetGetResp& from);
  void MergeFrom(const PlanetGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .PlanetUser planet_user = 4;
  inline bool has_planet_user() const;
  inline void clear_planet_user();
  static const int kPlanetUserFieldNumber = 4;
  inline const ::PlanetUser& planet_user() const;
  inline ::PlanetUser* mutable_planet_user();
  inline ::PlanetUser* release_planet_user();
  inline void set_allocated_planet_user(::PlanetUser* planet_user);

  // repeated .PlanetNode node_list = 5;
  inline int node_list_size() const;
  inline void clear_node_list();
  static const int kNodeListFieldNumber = 5;
  inline const ::PlanetNode& node_list(int index) const;
  inline ::PlanetNode* mutable_node_list(int index);
  inline ::PlanetNode* add_node_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlanetNode >&
      node_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlanetNode >*
      mutable_node_list();

  // repeated .PlanetElement element_list = 6;
  inline int element_list_size() const;
  inline void clear_element_list();
  static const int kElementListFieldNumber = 6;
  inline const ::PlanetElement& element_list(int index) const;
  inline ::PlanetElement* mutable_element_list(int index);
  inline ::PlanetElement* add_element_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlanetElement >&
      element_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlanetElement >*
      mutable_element_list();

  // repeated .PlanetArmyLine planet_army_line_list = 7;
  inline int planet_army_line_list_size() const;
  inline void clear_planet_army_line_list();
  static const int kPlanetArmyLineListFieldNumber = 7;
  inline const ::PlanetArmyLine& planet_army_line_list(int index) const;
  inline ::PlanetArmyLine* mutable_planet_army_line_list(int index);
  inline ::PlanetArmyLine* add_planet_army_line_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlanetArmyLine >&
      planet_army_line_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlanetArmyLine >*
      mutable_planet_army_line_list();

  // repeated .PlanetMailUser mail_user_list = 8;
  inline int mail_user_list_size() const;
  inline void clear_mail_user_list();
  static const int kMailUserListFieldNumber = 8;
  inline const ::PlanetMailUser& mail_user_list(int index) const;
  inline ::PlanetMailUser* mutable_mail_user_list(int index);
  inline ::PlanetMailUser* add_mail_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlanetMailUser >&
      mail_user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlanetMailUser >*
      mutable_mail_user_list();

  // repeated .PlanetArmyInfo army_info_list = 9;
  inline int army_info_list_size() const;
  inline void clear_army_info_list();
  static const int kArmyInfoListFieldNumber = 9;
  inline const ::PlanetArmyInfo& army_info_list(int index) const;
  inline ::PlanetArmyInfo* mutable_army_info_list(int index);
  inline ::PlanetArmyInfo* add_army_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlanetArmyInfo >&
      army_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlanetArmyInfo >*
      mutable_army_info_list();

  // repeated .PlanetArmy army_list = 10;
  inline int army_list_size() const;
  inline void clear_army_list();
  static const int kArmyListFieldNumber = 10;
  inline const ::PlanetArmy& army_list(int index) const;
  inline ::PlanetArmy* mutable_army_list(int index);
  inline ::PlanetArmy* add_army_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlanetArmy >&
      army_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlanetArmy >*
      mutable_army_list();

  // @@protoc_insertion_point(class_scope:PlanetGetResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_planet_user();
  inline void clear_has_planet_user();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 type_;
  ::PlanetUser* planet_user_;
  ::google::protobuf::RepeatedPtrField< ::PlanetNode > node_list_;
  ::google::protobuf::RepeatedPtrField< ::PlanetElement > element_list_;
  ::google::protobuf::RepeatedPtrField< ::PlanetArmyLine > planet_army_line_list_;
  ::google::protobuf::RepeatedPtrField< ::PlanetMailUser > mail_user_list_;
  ::google::protobuf::RepeatedPtrField< ::PlanetArmyInfo > army_info_list_;
  ::google::protobuf::RepeatedPtrField< ::PlanetArmy > army_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetGetResp* default_instance_;
};
// -------------------------------------------------------------------

class PlanetCollectReq : public ::google::protobuf::MessageLite {
 public:
  PlanetCollectReq();
  virtual ~PlanetCollectReq();

  PlanetCollectReq(const PlanetCollectReq& from);

  inline PlanetCollectReq& operator=(const PlanetCollectReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetCollectReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetCollectReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetCollectReq* other);

  // implements Message ----------------------------------------------

  PlanetCollectReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetCollectReq& from);
  void MergeFrom(const PlanetCollectReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string res_global_key = 1;
  inline bool has_res_global_key() const;
  inline void clear_res_global_key();
  static const int kResGlobalKeyFieldNumber = 1;
  inline const ::std::string& res_global_key() const;
  inline void set_res_global_key(const ::std::string& value);
  inline void set_res_global_key(const char* value);
  inline void set_res_global_key(const char* value, size_t size);
  inline ::std::string* mutable_res_global_key();
  inline ::std::string* release_res_global_key();
  inline void set_allocated_res_global_key(::std::string* res_global_key);

  // repeated int32 lineup = 2;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 2;
  inline ::google::protobuf::int32 lineup(int index) const;
  inline void set_lineup(int index, ::google::protobuf::int32 value);
  inline void add_lineup(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lineup();

  // @@protoc_insertion_point(class_scope:PlanetCollectReq)
 private:
  inline void set_has_res_global_key();
  inline void clear_has_res_global_key();

  ::std::string* res_global_key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lineup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetCollectReq* default_instance_;
};
// -------------------------------------------------------------------

class PlanetCollectResp : public ::google::protobuf::MessageLite {
 public:
  PlanetCollectResp();
  virtual ~PlanetCollectResp();

  PlanetCollectResp(const PlanetCollectResp& from);

  inline PlanetCollectResp& operator=(const PlanetCollectResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetCollectResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetCollectResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetCollectResp* other);

  // implements Message ----------------------------------------------

  PlanetCollectResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetCollectResp& from);
  void MergeFrom(const PlanetCollectResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PlanetCollectResp_PlanetCollectRet PlanetCollectRet;
  static const PlanetCollectRet OK = PlanetCollectResp_PlanetCollectRet_OK;
  static const PlanetCollectRet FAIL = PlanetCollectResp_PlanetCollectRet_FAIL;
  static const PlanetCollectRet ERROR_TYPE = PlanetCollectResp_PlanetCollectRet_ERROR_TYPE;
  static const PlanetCollectRet REQ_ERROR = PlanetCollectResp_PlanetCollectRet_REQ_ERROR;
  static const PlanetCollectRet LINEUP_ERROR = PlanetCollectResp_PlanetCollectRet_LINEUP_ERROR;
  static const PlanetCollectRet NO_DURABLE = PlanetCollectResp_PlanetCollectRet_NO_DURABLE;
  static const PlanetCollectRet FIXING = PlanetCollectResp_PlanetCollectRet_FIXING;
  static const PlanetCollectRet OUTING = PlanetCollectResp_PlanetCollectRet_OUTING;
  static const PlanetCollectRet ARMY_NUM_MAX = PlanetCollectResp_PlanetCollectRet_ARMY_NUM_MAX;
  static const PlanetCollectRet MY_RES = PlanetCollectResp_PlanetCollectRet_MY_RES;
  static const PlanetCollectRet RES_MAX_LOAD = PlanetCollectResp_PlanetCollectRet_RES_MAX_LOAD;
  static const PlanetCollectRet ERROR_GROUP = PlanetCollectResp_PlanetCollectRet_ERROR_GROUP;
  static const PlanetCollectRet NO_STORAGE = PlanetCollectResp_PlanetCollectRet_NO_STORAGE;
  static const PlanetCollectRet ALREADY_COLLECT = PlanetCollectResp_PlanetCollectRet_ALREADY_COLLECT;
  static inline bool PlanetCollectRet_IsValid(int value) {
    return PlanetCollectResp_PlanetCollectRet_IsValid(value);
  }
  static const PlanetCollectRet PlanetCollectRet_MIN =
    PlanetCollectResp_PlanetCollectRet_PlanetCollectRet_MIN;
  static const PlanetCollectRet PlanetCollectRet_MAX =
    PlanetCollectResp_PlanetCollectRet_PlanetCollectRet_MAX;
  static const int PlanetCollectRet_ARRAYSIZE =
    PlanetCollectResp_PlanetCollectRet_PlanetCollectRet_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .PlanetCollectResp.PlanetCollectRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::PlanetCollectResp_PlanetCollectRet result() const;
  inline void set_result(::PlanetCollectResp_PlanetCollectRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .PlanetUser planet_user = 3;
  inline bool has_planet_user() const;
  inline void clear_planet_user();
  static const int kPlanetUserFieldNumber = 3;
  inline const ::PlanetUser& planet_user() const;
  inline ::PlanetUser* mutable_planet_user();
  inline ::PlanetUser* release_planet_user();
  inline void set_allocated_planet_user(::PlanetUser* planet_user);

  // @@protoc_insertion_point(class_scope:PlanetCollectResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_planet_user();
  inline void clear_has_planet_user();

  ::UserSync* user_sync_;
  ::PlanetUser* planet_user_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetCollectResp* default_instance_;
};
// -------------------------------------------------------------------

class PlanetRideBackReq : public ::google::protobuf::MessageLite {
 public:
  PlanetRideBackReq();
  virtual ~PlanetRideBackReq();

  PlanetRideBackReq(const PlanetRideBackReq& from);

  inline PlanetRideBackReq& operator=(const PlanetRideBackReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetRideBackReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetRideBackReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetRideBackReq* other);

  // implements Message ----------------------------------------------

  PlanetRideBackReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetRideBackReq& from);
  void MergeFrom(const PlanetRideBackReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated int32 army_guid = 2;
  inline int army_guid_size() const;
  inline void clear_army_guid();
  static const int kArmyGuidFieldNumber = 2;
  inline ::google::protobuf::int32 army_guid(int index) const;
  inline void set_army_guid(int index, ::google::protobuf::int32 value);
  inline void add_army_guid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      army_guid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_army_guid();

  // @@protoc_insertion_point(class_scope:PlanetRideBackReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > army_guid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetRideBackReq* default_instance_;
};
// -------------------------------------------------------------------

class PlanetRideBackResp : public ::google::protobuf::MessageLite {
 public:
  PlanetRideBackResp();
  virtual ~PlanetRideBackResp();

  PlanetRideBackResp(const PlanetRideBackResp& from);

  inline PlanetRideBackResp& operator=(const PlanetRideBackResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetRideBackResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetRideBackResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetRideBackResp* other);

  // implements Message ----------------------------------------------

  PlanetRideBackResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetRideBackResp& from);
  void MergeFrom(const PlanetRideBackResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .PlanetUser planet_user = 3;
  inline bool has_planet_user() const;
  inline void clear_planet_user();
  static const int kPlanetUserFieldNumber = 3;
  inline const ::PlanetUser& planet_user() const;
  inline ::PlanetUser* mutable_planet_user();
  inline ::PlanetUser* release_planet_user();
  inline void set_allocated_planet_user(::PlanetUser* planet_user);

  // @@protoc_insertion_point(class_scope:PlanetRideBackResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_planet_user();
  inline void clear_has_planet_user();

  ::UserSync* user_sync_;
  ::PlanetUser* planet_user_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetRideBackResp* default_instance_;
};
// -------------------------------------------------------------------

class PlanetRuinsReq : public ::google::protobuf::MessageLite {
 public:
  PlanetRuinsReq();
  virtual ~PlanetRuinsReq();

  PlanetRuinsReq(const PlanetRuinsReq& from);

  inline PlanetRuinsReq& operator=(const PlanetRuinsReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetRuinsReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetRuinsReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetRuinsReq* other);

  // implements Message ----------------------------------------------

  PlanetRuinsReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetRuinsReq& from);
  void MergeFrom(const PlanetRuinsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string element_global_key = 1;
  inline bool has_element_global_key() const;
  inline void clear_element_global_key();
  static const int kElementGlobalKeyFieldNumber = 1;
  inline const ::std::string& element_global_key() const;
  inline void set_element_global_key(const ::std::string& value);
  inline void set_element_global_key(const char* value);
  inline void set_element_global_key(const char* value, size_t size);
  inline ::std::string* mutable_element_global_key();
  inline ::std::string* release_element_global_key();
  inline void set_allocated_element_global_key(::std::string* element_global_key);

  // repeated int32 lineup = 2;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 2;
  inline ::google::protobuf::int32 lineup(int index) const;
  inline void set_lineup(int index, ::google::protobuf::int32 value);
  inline void add_lineup(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lineup();

  // @@protoc_insertion_point(class_scope:PlanetRuinsReq)
 private:
  inline void set_has_element_global_key();
  inline void clear_has_element_global_key();

  ::std::string* element_global_key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lineup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetRuinsReq* default_instance_;
};
// -------------------------------------------------------------------

class PlanetRuinsResp : public ::google::protobuf::MessageLite {
 public:
  PlanetRuinsResp();
  virtual ~PlanetRuinsResp();

  PlanetRuinsResp(const PlanetRuinsResp& from);

  inline PlanetRuinsResp& operator=(const PlanetRuinsResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetRuinsResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetRuinsResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetRuinsResp* other);

  // implements Message ----------------------------------------------

  PlanetRuinsResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetRuinsResp& from);
  void MergeFrom(const PlanetRuinsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PlanetRuinsResp_PlanetRuinsRet PlanetRuinsRet;
  static const PlanetRuinsRet OK = PlanetRuinsResp_PlanetRuinsRet_OK;
  static const PlanetRuinsRet FAIL = PlanetRuinsResp_PlanetRuinsRet_FAIL;
  static const PlanetRuinsRet ERROR_TYPE = PlanetRuinsResp_PlanetRuinsRet_ERROR_TYPE;
  static const PlanetRuinsRet REQ_ERROR = PlanetRuinsResp_PlanetRuinsRet_REQ_ERROR;
  static const PlanetRuinsRet LINEUP_ERROR = PlanetRuinsResp_PlanetRuinsRet_LINEUP_ERROR;
  static const PlanetRuinsRet NO_DURABLE = PlanetRuinsResp_PlanetRuinsRet_NO_DURABLE;
  static const PlanetRuinsRet FIXING = PlanetRuinsResp_PlanetRuinsRet_FIXING;
  static const PlanetRuinsRet OUTING = PlanetRuinsResp_PlanetRuinsRet_OUTING;
  static const PlanetRuinsRet ARMY_NUM_MAX = PlanetRuinsResp_PlanetRuinsRet_ARMY_NUM_MAX;
  static const PlanetRuinsRet NO_TYPE = PlanetRuinsResp_PlanetRuinsRet_NO_TYPE;
  static const PlanetRuinsRet NO_STRENGTH = PlanetRuinsResp_PlanetRuinsRet_NO_STRENGTH;
  static inline bool PlanetRuinsRet_IsValid(int value) {
    return PlanetRuinsResp_PlanetRuinsRet_IsValid(value);
  }
  static const PlanetRuinsRet PlanetRuinsRet_MIN =
    PlanetRuinsResp_PlanetRuinsRet_PlanetRuinsRet_MIN;
  static const PlanetRuinsRet PlanetRuinsRet_MAX =
    PlanetRuinsResp_PlanetRuinsRet_PlanetRuinsRet_MAX;
  static const int PlanetRuinsRet_ARRAYSIZE =
    PlanetRuinsResp_PlanetRuinsRet_PlanetRuinsRet_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .PlanetRuinsResp.PlanetRuinsRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::PlanetRuinsResp_PlanetRuinsRet result() const;
  inline void set_result(::PlanetRuinsResp_PlanetRuinsRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .PlanetUser planet_user = 3;
  inline bool has_planet_user() const;
  inline void clear_planet_user();
  static const int kPlanetUserFieldNumber = 3;
  inline const ::PlanetUser& planet_user() const;
  inline ::PlanetUser* mutable_planet_user();
  inline ::PlanetUser* release_planet_user();
  inline void set_allocated_planet_user(::PlanetUser* planet_user);

  // @@protoc_insertion_point(class_scope:PlanetRuinsResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_planet_user();
  inline void clear_has_planet_user();

  ::UserSync* user_sync_;
  ::PlanetUser* planet_user_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetRuinsResp* default_instance_;
};
// -------------------------------------------------------------------

class PlanetRaidReq : public ::google::protobuf::MessageLite {
 public:
  PlanetRaidReq();
  virtual ~PlanetRaidReq();

  PlanetRaidReq(const PlanetRaidReq& from);

  inline PlanetRaidReq& operator=(const PlanetRaidReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetRaidReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetRaidReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetRaidReq* other);

  // implements Message ----------------------------------------------

  PlanetRaidReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetRaidReq& from);
  void MergeFrom(const PlanetRaidReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 type_list = 1;
  inline int type_list_size() const;
  inline void clear_type_list();
  static const int kTypeListFieldNumber = 1;
  inline ::google::protobuf::int32 type_list(int index) const;
  inline void set_type_list(int index, ::google::protobuf::int32 value);
  inline void add_type_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      type_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_type_list();

  // required string element_global_key = 2;
  inline bool has_element_global_key() const;
  inline void clear_element_global_key();
  static const int kElementGlobalKeyFieldNumber = 2;
  inline const ::std::string& element_global_key() const;
  inline void set_element_global_key(const ::std::string& value);
  inline void set_element_global_key(const char* value);
  inline void set_element_global_key(const char* value, size_t size);
  inline ::std::string* mutable_element_global_key();
  inline ::std::string* release_element_global_key();
  inline void set_allocated_element_global_key(::std::string* element_global_key);

  // repeated int32 lineup = 3;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 3;
  inline ::google::protobuf::int32 lineup(int index) const;
  inline void set_lineup(int index, ::google::protobuf::int32 value);
  inline void add_lineup(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      lineup() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_lineup();

  // optional string army_key = 4;
  inline bool has_army_key() const;
  inline void clear_army_key();
  static const int kArmyKeyFieldNumber = 4;
  inline const ::std::string& army_key() const;
  inline void set_army_key(const ::std::string& value);
  inline void set_army_key(const char* value);
  inline void set_army_key(const char* value, size_t size);
  inline ::std::string* mutable_army_key();
  inline ::std::string* release_army_key();
  inline void set_allocated_army_key(::std::string* army_key);

  // optional int32 mass_level = 5;
  inline bool has_mass_level() const;
  inline void clear_mass_level();
  static const int kMassLevelFieldNumber = 5;
  inline ::google::protobuf::int32 mass_level() const;
  inline void set_mass_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlanetRaidReq)
 private:
  inline void set_has_element_global_key();
  inline void clear_has_element_global_key();
  inline void set_has_army_key();
  inline void clear_has_army_key();
  inline void set_has_mass_level();
  inline void clear_has_mass_level();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > type_list_;
  ::std::string* element_global_key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > lineup_;
  ::std::string* army_key_;
  ::google::protobuf::int32 mass_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetRaidReq* default_instance_;
};
// -------------------------------------------------------------------

class PlanetRaidResp : public ::google::protobuf::MessageLite {
 public:
  PlanetRaidResp();
  virtual ~PlanetRaidResp();

  PlanetRaidResp(const PlanetRaidResp& from);

  inline PlanetRaidResp& operator=(const PlanetRaidResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetRaidResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetRaidResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetRaidResp* other);

  // implements Message ----------------------------------------------

  PlanetRaidResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetRaidResp& from);
  void MergeFrom(const PlanetRaidResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PlanetRaidResp_PlanetRaidRet PlanetRaidRet;
  static const PlanetRaidRet OK = PlanetRaidResp_PlanetRaidRet_OK;
  static const PlanetRaidRet FAIL = PlanetRaidResp_PlanetRaidRet_FAIL;
  static const PlanetRaidRet ERROR_TYPE = PlanetRaidResp_PlanetRaidRet_ERROR_TYPE;
  static const PlanetRaidRet REQ_ERROR = PlanetRaidResp_PlanetRaidRet_REQ_ERROR;
  static const PlanetRaidRet LINEUP_ERROR = PlanetRaidResp_PlanetRaidRet_LINEUP_ERROR;
  static const PlanetRaidRet NO_DURABLE = PlanetRaidResp_PlanetRaidRet_NO_DURABLE;
  static const PlanetRaidRet FIXING = PlanetRaidResp_PlanetRaidRet_FIXING;
  static const PlanetRaidRet OUTING = PlanetRaidResp_PlanetRaidRet_OUTING;
  static const PlanetRaidRet ARMY_NUM_MAX = PlanetRaidResp_PlanetRaidRet_ARMY_NUM_MAX;
  static const PlanetRaidRet NOT_OPEN = PlanetRaidResp_PlanetRaidRet_NOT_OPEN;
  static const PlanetRaidRet ERROR_GROUP = PlanetRaidResp_PlanetRaidRet_ERROR_GROUP;
  static const PlanetRaidRet ERROR_STATUS = PlanetRaidResp_PlanetRaidRet_ERROR_STATUS;
  static const PlanetRaidRet NO_STRENGTH = PlanetRaidResp_PlanetRaidRet_NO_STRENGTH;
  static const PlanetRaidRet NO_GROUP = PlanetRaidResp_PlanetRaidRet_NO_GROUP;
  static const PlanetRaidRet ALREADY_GUARDE = PlanetRaidResp_PlanetRaidRet_ALREADY_GUARDE;
  static const PlanetRaidRet ALREADY_ACCOMPANY = PlanetRaidResp_PlanetRaidRet_ALREADY_ACCOMPANY;
  static const PlanetRaidRet ALREADY_REQ_ACCOMPANY = PlanetRaidResp_PlanetRaidRet_ALREADY_REQ_ACCOMPANY;
  static const PlanetRaidRet NO_GROUP_POWER = PlanetRaidResp_PlanetRaidRet_NO_GROUP_POWER;
  static const PlanetRaidRet NO_BASE_POWER = PlanetRaidResp_PlanetRaidRet_NO_BASE_POWER;
  static const PlanetRaidRet SHIELD = PlanetRaidResp_PlanetRaidRet_SHIELD;
  static const PlanetRaidRet NO_LAST_CITY_1 = PlanetRaidResp_PlanetRaidRet_NO_LAST_CITY_1;
  static const PlanetRaidRet NO_LAST_CITY_2 = PlanetRaidResp_PlanetRaidRet_NO_LAST_CITY_2;
  static const PlanetRaidRet NO_LAST_CITY_3 = PlanetRaidResp_PlanetRaidRet_NO_LAST_CITY_3;
  static inline bool PlanetRaidRet_IsValid(int value) {
    return PlanetRaidResp_PlanetRaidRet_IsValid(value);
  }
  static const PlanetRaidRet PlanetRaidRet_MIN =
    PlanetRaidResp_PlanetRaidRet_PlanetRaidRet_MIN;
  static const PlanetRaidRet PlanetRaidRet_MAX =
    PlanetRaidResp_PlanetRaidRet_PlanetRaidRet_MAX;
  static const int PlanetRaidRet_ARRAYSIZE =
    PlanetRaidResp_PlanetRaidRet_PlanetRaidRet_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .PlanetRaidResp.PlanetRaidRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::PlanetRaidResp_PlanetRaidRet result() const;
  inline void set_result(::PlanetRaidResp_PlanetRaidRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .PlanetUser planet_user = 3;
  inline bool has_planet_user() const;
  inline void clear_planet_user();
  static const int kPlanetUserFieldNumber = 3;
  inline const ::PlanetUser& planet_user() const;
  inline ::PlanetUser* mutable_planet_user();
  inline ::PlanetUser* release_planet_user();
  inline void set_allocated_planet_user(::PlanetUser* planet_user);

  // @@protoc_insertion_point(class_scope:PlanetRaidResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_planet_user();
  inline void clear_has_planet_user();

  ::UserSync* user_sync_;
  ::PlanetUser* planet_user_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetRaidResp* default_instance_;
};
// -------------------------------------------------------------------

class PlanetSpeedUpReq : public ::google::protobuf::MessageLite {
 public:
  PlanetSpeedUpReq();
  virtual ~PlanetSpeedUpReq();

  PlanetSpeedUpReq(const PlanetSpeedUpReq& from);

  inline PlanetSpeedUpReq& operator=(const PlanetSpeedUpReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetSpeedUpReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetSpeedUpReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetSpeedUpReq* other);

  // implements Message ----------------------------------------------

  PlanetSpeedUpReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetSpeedUpReq& from);
  void MergeFrom(const PlanetSpeedUpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string army_key = 1;
  inline bool has_army_key() const;
  inline void clear_army_key();
  static const int kArmyKeyFieldNumber = 1;
  inline const ::std::string& army_key() const;
  inline void set_army_key(const ::std::string& value);
  inline void set_army_key(const char* value);
  inline void set_army_key(const char* value, size_t size);
  inline ::std::string* mutable_army_key();
  inline ::std::string* release_army_key();
  inline void set_allocated_army_key(::std::string* army_key);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlanetSpeedUpReq)
 private:
  inline void set_has_army_key();
  inline void clear_has_army_key();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string* army_key_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetSpeedUpReq* default_instance_;
};
// -------------------------------------------------------------------

class PlanetSpeedUpResp : public ::google::protobuf::MessageLite {
 public:
  PlanetSpeedUpResp();
  virtual ~PlanetSpeedUpResp();

  PlanetSpeedUpResp(const PlanetSpeedUpResp& from);

  inline PlanetSpeedUpResp& operator=(const PlanetSpeedUpResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetSpeedUpResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetSpeedUpResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetSpeedUpResp* other);

  // implements Message ----------------------------------------------

  PlanetSpeedUpResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetSpeedUpResp& from);
  void MergeFrom(const PlanetSpeedUpResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 3;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 3;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .PlanetArmy army = 4;
  inline bool has_army() const;
  inline void clear_army();
  static const int kArmyFieldNumber = 4;
  inline const ::PlanetArmy& army() const;
  inline ::PlanetArmy* mutable_army();
  inline ::PlanetArmy* release_army();
  inline void set_allocated_army(::PlanetArmy* army);

  // @@protoc_insertion_point(class_scope:PlanetSpeedUpResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_army();
  inline void clear_has_army();

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 type_;
  ::UserSync* user_sync_;
  ::PlanetArmy* army_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetSpeedUpResp* default_instance_;
};
// -------------------------------------------------------------------

class PlanetShieldReq : public ::google::protobuf::MessageLite {
 public:
  PlanetShieldReq();
  virtual ~PlanetShieldReq();

  PlanetShieldReq(const PlanetShieldReq& from);

  inline PlanetShieldReq& operator=(const PlanetShieldReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetShieldReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetShieldReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetShieldReq* other);

  // implements Message ----------------------------------------------

  PlanetShieldReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetShieldReq& from);
  void MergeFrom(const PlanetShieldReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlanetShieldReq)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();

  ::google::protobuf::int32 item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetShieldReq* default_instance_;
};
// -------------------------------------------------------------------

class PlanetShieldResp : public ::google::protobuf::MessageLite {
 public:
  PlanetShieldResp();
  virtual ~PlanetShieldResp();

  PlanetShieldResp(const PlanetShieldResp& from);

  inline PlanetShieldResp& operator=(const PlanetShieldResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetShieldResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetShieldResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetShieldResp* other);

  // implements Message ----------------------------------------------

  PlanetShieldResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetShieldResp& from);
  void MergeFrom(const PlanetShieldResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:PlanetShieldResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetShieldResp* default_instance_;
};
// -------------------------------------------------------------------

class PlanetMoveBaseReq : public ::google::protobuf::MessageLite {
 public:
  PlanetMoveBaseReq();
  virtual ~PlanetMoveBaseReq();

  PlanetMoveBaseReq(const PlanetMoveBaseReq& from);

  inline PlanetMoveBaseReq& operator=(const PlanetMoveBaseReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetMoveBaseReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetMoveBaseReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetMoveBaseReq* other);

  // implements Message ----------------------------------------------

  PlanetMoveBaseReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetMoveBaseReq& from);
  void MergeFrom(const PlanetMoveBaseReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .PlanetPoint pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline const ::PlanetPoint& pos() const;
  inline ::PlanetPoint* mutable_pos();
  inline ::PlanetPoint* release_pos();
  inline void set_allocated_pos(::PlanetPoint* pos);

  // @@protoc_insertion_point(class_scope:PlanetMoveBaseReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::PlanetPoint* pos_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetMoveBaseReq* default_instance_;
};
// -------------------------------------------------------------------

class PlanetMoveBaseResp : public ::google::protobuf::MessageLite {
 public:
  PlanetMoveBaseResp();
  virtual ~PlanetMoveBaseResp();

  PlanetMoveBaseResp(const PlanetMoveBaseResp& from);

  inline PlanetMoveBaseResp& operator=(const PlanetMoveBaseResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetMoveBaseResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetMoveBaseResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetMoveBaseResp* other);

  // implements Message ----------------------------------------------

  PlanetMoveBaseResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetMoveBaseResp& from);
  void MergeFrom(const PlanetMoveBaseResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PlanetMoveBaseResp_PlanetMoveBaseRet PlanetMoveBaseRet;
  static const PlanetMoveBaseRet OK = PlanetMoveBaseResp_PlanetMoveBaseRet_OK;
  static const PlanetMoveBaseRet FAIL = PlanetMoveBaseResp_PlanetMoveBaseRet_FAIL;
  static const PlanetMoveBaseRet NO_ITEM = PlanetMoveBaseResp_PlanetMoveBaseRet_NO_ITEM;
  static const PlanetMoveBaseRet HAS_ELEMENT = PlanetMoveBaseResp_PlanetMoveBaseRet_HAS_ELEMENT;
  static const PlanetMoveBaseRet ERROR_NATION = PlanetMoveBaseResp_PlanetMoveBaseRet_ERROR_NATION;
  static const PlanetMoveBaseRet ERROR_CITY = PlanetMoveBaseResp_PlanetMoveBaseRet_ERROR_CITY;
  static const PlanetMoveBaseRet ERROR_POS = PlanetMoveBaseResp_PlanetMoveBaseRet_ERROR_POS;
  static inline bool PlanetMoveBaseRet_IsValid(int value) {
    return PlanetMoveBaseResp_PlanetMoveBaseRet_IsValid(value);
  }
  static const PlanetMoveBaseRet PlanetMoveBaseRet_MIN =
    PlanetMoveBaseResp_PlanetMoveBaseRet_PlanetMoveBaseRet_MIN;
  static const PlanetMoveBaseRet PlanetMoveBaseRet_MAX =
    PlanetMoveBaseResp_PlanetMoveBaseRet_PlanetMoveBaseRet_MAX;
  static const int PlanetMoveBaseRet_ARRAYSIZE =
    PlanetMoveBaseResp_PlanetMoveBaseRet_PlanetMoveBaseRet_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .PlanetMoveBaseResp.PlanetMoveBaseRet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::PlanetMoveBaseResp_PlanetMoveBaseRet result() const;
  inline void set_result(::PlanetMoveBaseResp_PlanetMoveBaseRet value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional .PlanetUser planet_user = 3;
  inline bool has_planet_user() const;
  inline void clear_planet_user();
  static const int kPlanetUserFieldNumber = 3;
  inline const ::PlanetUser& planet_user() const;
  inline ::PlanetUser* mutable_planet_user();
  inline ::PlanetUser* release_planet_user();
  inline void set_allocated_planet_user(::PlanetUser* planet_user);

  // @@protoc_insertion_point(class_scope:PlanetMoveBaseResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_planet_user();
  inline void clear_has_planet_user();

  ::UserSync* user_sync_;
  ::PlanetUser* planet_user_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetMoveBaseResp* default_instance_;
};
// -------------------------------------------------------------------

class PlanetMarkReq : public ::google::protobuf::MessageLite {
 public:
  PlanetMarkReq();
  virtual ~PlanetMarkReq();

  PlanetMarkReq(const PlanetMarkReq& from);

  inline PlanetMarkReq& operator=(const PlanetMarkReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetMarkReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetMarkReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetMarkReq* other);

  // implements Message ----------------------------------------------

  PlanetMarkReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetMarkReq& from);
  void MergeFrom(const PlanetMarkReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .PlanetPoint pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline const ::PlanetPoint& pos() const;
  inline ::PlanetPoint* mutable_pos();
  inline ::PlanetPoint* release_pos();
  inline void set_allocated_pos(::PlanetPoint* pos);

  // @@protoc_insertion_point(class_scope:PlanetMarkReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::std::string* name_;
  ::PlanetPoint* pos_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetMarkReq* default_instance_;
};
// -------------------------------------------------------------------

class PlanetMarkResp : public ::google::protobuf::MessageLite {
 public:
  PlanetMarkResp();
  virtual ~PlanetMarkResp();

  PlanetMarkResp(const PlanetMarkResp& from);

  inline PlanetMarkResp& operator=(const PlanetMarkResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetMarkResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetMarkResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetMarkResp* other);

  // implements Message ----------------------------------------------

  PlanetMarkResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetMarkResp& from);
  void MergeFrom(const PlanetMarkResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated .PlanetMark mark_list = 3;
  inline int mark_list_size() const;
  inline void clear_mark_list();
  static const int kMarkListFieldNumber = 3;
  inline const ::PlanetMark& mark_list(int index) const;
  inline ::PlanetMark* mutable_mark_list(int index);
  inline ::PlanetMark* add_mark_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlanetMark >&
      mark_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlanetMark >*
      mutable_mark_list();

  // @@protoc_insertion_point(class_scope:PlanetMarkResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedPtrField< ::PlanetMark > mark_list_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetMarkResp* default_instance_;
};
// -------------------------------------------------------------------

class PlanetTowerReq : public ::google::protobuf::MessageLite {
 public:
  PlanetTowerReq();
  virtual ~PlanetTowerReq();

  PlanetTowerReq(const PlanetTowerReq& from);

  inline PlanetTowerReq& operator=(const PlanetTowerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetTowerReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetTowerReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetTowerReq* other);

  // implements Message ----------------------------------------------

  PlanetTowerReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetTowerReq& from);
  void MergeFrom(const PlanetTowerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string element_global_key = 2;
  inline bool has_element_global_key() const;
  inline void clear_element_global_key();
  static const int kElementGlobalKeyFieldNumber = 2;
  inline const ::std::string& element_global_key() const;
  inline void set_element_global_key(const ::std::string& value);
  inline void set_element_global_key(const char* value);
  inline void set_element_global_key(const char* value, size_t size);
  inline ::std::string* mutable_element_global_key();
  inline ::std::string* release_element_global_key();
  inline void set_allocated_element_global_key(::std::string* element_global_key);

  // @@protoc_insertion_point(class_scope:PlanetTowerReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_element_global_key();
  inline void clear_has_element_global_key();

  ::std::string* element_global_key_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetTowerReq* default_instance_;
};
// -------------------------------------------------------------------

class PlanetTowerResp : public ::google::protobuf::MessageLite {
 public:
  PlanetTowerResp();
  virtual ~PlanetTowerResp();

  PlanetTowerResp(const PlanetTowerResp& from);

  inline PlanetTowerResp& operator=(const PlanetTowerResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetTowerResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetTowerResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetTowerResp* other);

  // implements Message ----------------------------------------------

  PlanetTowerResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetTowerResp& from);
  void MergeFrom(const PlanetTowerResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .PlanetElement element = 2;
  inline bool has_element() const;
  inline void clear_element();
  static const int kElementFieldNumber = 2;
  inline const ::PlanetElement& element() const;
  inline ::PlanetElement* mutable_element();
  inline ::PlanetElement* release_element();
  inline void set_allocated_element(::PlanetElement* element);

  // @@protoc_insertion_point(class_scope:PlanetTowerResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_element();
  inline void clear_has_element();

  ::PlanetElement* element_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetTowerResp* default_instance_;
};
// -------------------------------------------------------------------

class PlanetWangZuoTitleReq : public ::google::protobuf::MessageLite {
 public:
  PlanetWangZuoTitleReq();
  virtual ~PlanetWangZuoTitleReq();

  PlanetWangZuoTitleReq(const PlanetWangZuoTitleReq& from);

  inline PlanetWangZuoTitleReq& operator=(const PlanetWangZuoTitleReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlanetWangZuoTitleReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlanetWangZuoTitleReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlanetWangZuoTitleReq* other);

  // implements Message ----------------------------------------------

  PlanetWangZuoTitleReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlanetWangZuoTitleReq& from);
  void MergeFrom(const PlanetWangZuoTitleReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional int32 title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline ::google::protobuf::int32 title() const;
  inline void set_title(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlanetWangZuoTitleReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_title();
  inline void clear_has_title();

  ::std::string* user_name_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 title_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PlanetWangZuoTitleReq* default_instance_;
};
// -------------------------------------------------------------------

class PLanetWangZuoTitleResp : public ::google::protobuf::MessageLite {
 public:
  PLanetWangZuoTitleResp();
  virtual ~PLanetWangZuoTitleResp();

  PLanetWangZuoTitleResp(const PLanetWangZuoTitleResp& from);

  inline PLanetWangZuoTitleResp& operator=(const PLanetWangZuoTitleResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const PLanetWangZuoTitleResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PLanetWangZuoTitleResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PLanetWangZuoTitleResp* other);

  // implements Message ----------------------------------------------

  PLanetWangZuoTitleResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PLanetWangZuoTitleResp& from);
  void MergeFrom(const PLanetWangZuoTitleResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .PlanetWangZuoTitleList title_list = 3;
  inline bool has_title_list() const;
  inline void clear_title_list();
  static const int kTitleListFieldNumber = 3;
  inline const ::PlanetWangZuoTitleList& title_list() const;
  inline ::PlanetWangZuoTitleList* mutable_title_list();
  inline ::PlanetWangZuoTitleList* release_title_list();
  inline void set_allocated_title_list(::PlanetWangZuoTitleList* title_list);

  // optional .PlanetWangZuoOccupyList occupy_list = 4;
  inline bool has_occupy_list() const;
  inline void clear_occupy_list();
  static const int kOccupyListFieldNumber = 4;
  inline const ::PlanetWangZuoOccupyList& occupy_list() const;
  inline ::PlanetWangZuoOccupyList* mutable_occupy_list();
  inline ::PlanetWangZuoOccupyList* release_occupy_list();
  inline void set_allocated_occupy_list(::PlanetWangZuoOccupyList* occupy_list);

  // repeated .OtherUserInfo user_list = 5;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 5;
  inline const ::OtherUserInfo& user_list(int index) const;
  inline ::OtherUserInfo* mutable_user_list(int index);
  inline ::OtherUserInfo* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >*
      mutable_user_list();

  // @@protoc_insertion_point(class_scope:PLanetWangZuoTitleResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_title_list();
  inline void clear_has_title_list();
  inline void set_has_occupy_list();
  inline void clear_has_occupy_list();

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 type_;
  ::PlanetWangZuoTitleList* title_list_;
  ::PlanetWangZuoOccupyList* occupy_list_;
  ::google::protobuf::RepeatedPtrField< ::OtherUserInfo > user_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdPlanet_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdPlanet_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdPlanet_2eproto();
  friend void protobuf_ShutdownFile_CmdPlanet_2eproto();

  void InitAsDefaultInstance();
  static PLanetWangZuoTitleResp* default_instance_;
};
// ===================================================================


// ===================================================================

// PlanetGetReq

// required int32 type = 1;
inline bool PlanetGetReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetGetReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetGetReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetGetReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlanetGetReq::type() const {
  return type_;
}
inline void PlanetGetReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 node_id_list = 2;
inline int PlanetGetReq::node_id_list_size() const {
  return node_id_list_.size();
}
inline void PlanetGetReq::clear_node_id_list() {
  node_id_list_.Clear();
}
inline ::google::protobuf::int32 PlanetGetReq::node_id_list(int index) const {
  return node_id_list_.Get(index);
}
inline void PlanetGetReq::set_node_id_list(int index, ::google::protobuf::int32 value) {
  node_id_list_.Set(index, value);
}
inline void PlanetGetReq::add_node_id_list(::google::protobuf::int32 value) {
  node_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PlanetGetReq::node_id_list() const {
  return node_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PlanetGetReq::mutable_node_id_list() {
  return &node_id_list_;
}

// repeated string element_global_key_list = 3;
inline int PlanetGetReq::element_global_key_list_size() const {
  return element_global_key_list_.size();
}
inline void PlanetGetReq::clear_element_global_key_list() {
  element_global_key_list_.Clear();
}
inline const ::std::string& PlanetGetReq::element_global_key_list(int index) const {
  return element_global_key_list_.Get(index);
}
inline ::std::string* PlanetGetReq::mutable_element_global_key_list(int index) {
  return element_global_key_list_.Mutable(index);
}
inline void PlanetGetReq::set_element_global_key_list(int index, const ::std::string& value) {
  element_global_key_list_.Mutable(index)->assign(value);
}
inline void PlanetGetReq::set_element_global_key_list(int index, const char* value) {
  element_global_key_list_.Mutable(index)->assign(value);
}
inline void PlanetGetReq::set_element_global_key_list(int index, const char* value, size_t size) {
  element_global_key_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetGetReq::add_element_global_key_list() {
  return element_global_key_list_.Add();
}
inline void PlanetGetReq::add_element_global_key_list(const ::std::string& value) {
  element_global_key_list_.Add()->assign(value);
}
inline void PlanetGetReq::add_element_global_key_list(const char* value) {
  element_global_key_list_.Add()->assign(value);
}
inline void PlanetGetReq::add_element_global_key_list(const char* value, size_t size) {
  element_global_key_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PlanetGetReq::element_global_key_list() const {
  return element_global_key_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PlanetGetReq::mutable_element_global_key_list() {
  return &element_global_key_list_;
}

// repeated string army_line_key_list = 4;
inline int PlanetGetReq::army_line_key_list_size() const {
  return army_line_key_list_.size();
}
inline void PlanetGetReq::clear_army_line_key_list() {
  army_line_key_list_.Clear();
}
inline const ::std::string& PlanetGetReq::army_line_key_list(int index) const {
  return army_line_key_list_.Get(index);
}
inline ::std::string* PlanetGetReq::mutable_army_line_key_list(int index) {
  return army_line_key_list_.Mutable(index);
}
inline void PlanetGetReq::set_army_line_key_list(int index, const ::std::string& value) {
  army_line_key_list_.Mutable(index)->assign(value);
}
inline void PlanetGetReq::set_army_line_key_list(int index, const char* value) {
  army_line_key_list_.Mutable(index)->assign(value);
}
inline void PlanetGetReq::set_army_line_key_list(int index, const char* value, size_t size) {
  army_line_key_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetGetReq::add_army_line_key_list() {
  return army_line_key_list_.Add();
}
inline void PlanetGetReq::add_army_line_key_list(const ::std::string& value) {
  army_line_key_list_.Add()->assign(value);
}
inline void PlanetGetReq::add_army_line_key_list(const char* value) {
  army_line_key_list_.Add()->assign(value);
}
inline void PlanetGetReq::add_army_line_key_list(const char* value, size_t size) {
  army_line_key_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PlanetGetReq::army_line_key_list() const {
  return army_line_key_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PlanetGetReq::mutable_army_line_key_list() {
  return &army_line_key_list_;
}

// repeated string army_key_list = 5;
inline int PlanetGetReq::army_key_list_size() const {
  return army_key_list_.size();
}
inline void PlanetGetReq::clear_army_key_list() {
  army_key_list_.Clear();
}
inline const ::std::string& PlanetGetReq::army_key_list(int index) const {
  return army_key_list_.Get(index);
}
inline ::std::string* PlanetGetReq::mutable_army_key_list(int index) {
  return army_key_list_.Mutable(index);
}
inline void PlanetGetReq::set_army_key_list(int index, const ::std::string& value) {
  army_key_list_.Mutable(index)->assign(value);
}
inline void PlanetGetReq::set_army_key_list(int index, const char* value) {
  army_key_list_.Mutable(index)->assign(value);
}
inline void PlanetGetReq::set_army_key_list(int index, const char* value, size_t size) {
  army_key_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetGetReq::add_army_key_list() {
  return army_key_list_.Add();
}
inline void PlanetGetReq::add_army_key_list(const ::std::string& value) {
  army_key_list_.Add()->assign(value);
}
inline void PlanetGetReq::add_army_key_list(const char* value) {
  army_key_list_.Add()->assign(value);
}
inline void PlanetGetReq::add_army_key_list(const char* value, size_t size) {
  army_key_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PlanetGetReq::army_key_list() const {
  return army_key_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PlanetGetReq::mutable_army_key_list() {
  return &army_key_list_;
}

// -------------------------------------------------------------------

// PlanetGetResp

// required int32 result = 1;
inline bool PlanetGetResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetGetResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetGetResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetGetResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PlanetGetResp::result() const {
  return result_;
}
inline void PlanetGetResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PlanetGetResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetGetResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetGetResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetGetResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PlanetGetResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* PlanetGetResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PlanetGetResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PlanetGetResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// required int32 type = 3;
inline bool PlanetGetResp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanetGetResp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanetGetResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanetGetResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlanetGetResp::type() const {
  return type_;
}
inline void PlanetGetResp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional .PlanetUser planet_user = 4;
inline bool PlanetGetResp::has_planet_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlanetGetResp::set_has_planet_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlanetGetResp::clear_has_planet_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlanetGetResp::clear_planet_user() {
  if (planet_user_ != NULL) planet_user_->::PlanetUser::Clear();
  clear_has_planet_user();
}
inline const ::PlanetUser& PlanetGetResp::planet_user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return planet_user_ != NULL ? *planet_user_ : *default_instance().planet_user_;
#else
  return planet_user_ != NULL ? *planet_user_ : *default_instance_->planet_user_;
#endif
}
inline ::PlanetUser* PlanetGetResp::mutable_planet_user() {
  set_has_planet_user();
  if (planet_user_ == NULL) planet_user_ = new ::PlanetUser;
  return planet_user_;
}
inline ::PlanetUser* PlanetGetResp::release_planet_user() {
  clear_has_planet_user();
  ::PlanetUser* temp = planet_user_;
  planet_user_ = NULL;
  return temp;
}
inline void PlanetGetResp::set_allocated_planet_user(::PlanetUser* planet_user) {
  delete planet_user_;
  planet_user_ = planet_user;
  if (planet_user) {
    set_has_planet_user();
  } else {
    clear_has_planet_user();
  }
}

// repeated .PlanetNode node_list = 5;
inline int PlanetGetResp::node_list_size() const {
  return node_list_.size();
}
inline void PlanetGetResp::clear_node_list() {
  node_list_.Clear();
}
inline const ::PlanetNode& PlanetGetResp::node_list(int index) const {
  return node_list_.Get(index);
}
inline ::PlanetNode* PlanetGetResp::mutable_node_list(int index) {
  return node_list_.Mutable(index);
}
inline ::PlanetNode* PlanetGetResp::add_node_list() {
  return node_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlanetNode >&
PlanetGetResp::node_list() const {
  return node_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlanetNode >*
PlanetGetResp::mutable_node_list() {
  return &node_list_;
}

// repeated .PlanetElement element_list = 6;
inline int PlanetGetResp::element_list_size() const {
  return element_list_.size();
}
inline void PlanetGetResp::clear_element_list() {
  element_list_.Clear();
}
inline const ::PlanetElement& PlanetGetResp::element_list(int index) const {
  return element_list_.Get(index);
}
inline ::PlanetElement* PlanetGetResp::mutable_element_list(int index) {
  return element_list_.Mutable(index);
}
inline ::PlanetElement* PlanetGetResp::add_element_list() {
  return element_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlanetElement >&
PlanetGetResp::element_list() const {
  return element_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlanetElement >*
PlanetGetResp::mutable_element_list() {
  return &element_list_;
}

// repeated .PlanetArmyLine planet_army_line_list = 7;
inline int PlanetGetResp::planet_army_line_list_size() const {
  return planet_army_line_list_.size();
}
inline void PlanetGetResp::clear_planet_army_line_list() {
  planet_army_line_list_.Clear();
}
inline const ::PlanetArmyLine& PlanetGetResp::planet_army_line_list(int index) const {
  return planet_army_line_list_.Get(index);
}
inline ::PlanetArmyLine* PlanetGetResp::mutable_planet_army_line_list(int index) {
  return planet_army_line_list_.Mutable(index);
}
inline ::PlanetArmyLine* PlanetGetResp::add_planet_army_line_list() {
  return planet_army_line_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlanetArmyLine >&
PlanetGetResp::planet_army_line_list() const {
  return planet_army_line_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlanetArmyLine >*
PlanetGetResp::mutable_planet_army_line_list() {
  return &planet_army_line_list_;
}

// repeated .PlanetMailUser mail_user_list = 8;
inline int PlanetGetResp::mail_user_list_size() const {
  return mail_user_list_.size();
}
inline void PlanetGetResp::clear_mail_user_list() {
  mail_user_list_.Clear();
}
inline const ::PlanetMailUser& PlanetGetResp::mail_user_list(int index) const {
  return mail_user_list_.Get(index);
}
inline ::PlanetMailUser* PlanetGetResp::mutable_mail_user_list(int index) {
  return mail_user_list_.Mutable(index);
}
inline ::PlanetMailUser* PlanetGetResp::add_mail_user_list() {
  return mail_user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlanetMailUser >&
PlanetGetResp::mail_user_list() const {
  return mail_user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlanetMailUser >*
PlanetGetResp::mutable_mail_user_list() {
  return &mail_user_list_;
}

// repeated .PlanetArmyInfo army_info_list = 9;
inline int PlanetGetResp::army_info_list_size() const {
  return army_info_list_.size();
}
inline void PlanetGetResp::clear_army_info_list() {
  army_info_list_.Clear();
}
inline const ::PlanetArmyInfo& PlanetGetResp::army_info_list(int index) const {
  return army_info_list_.Get(index);
}
inline ::PlanetArmyInfo* PlanetGetResp::mutable_army_info_list(int index) {
  return army_info_list_.Mutable(index);
}
inline ::PlanetArmyInfo* PlanetGetResp::add_army_info_list() {
  return army_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlanetArmyInfo >&
PlanetGetResp::army_info_list() const {
  return army_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlanetArmyInfo >*
PlanetGetResp::mutable_army_info_list() {
  return &army_info_list_;
}

// repeated .PlanetArmy army_list = 10;
inline int PlanetGetResp::army_list_size() const {
  return army_list_.size();
}
inline void PlanetGetResp::clear_army_list() {
  army_list_.Clear();
}
inline const ::PlanetArmy& PlanetGetResp::army_list(int index) const {
  return army_list_.Get(index);
}
inline ::PlanetArmy* PlanetGetResp::mutable_army_list(int index) {
  return army_list_.Mutable(index);
}
inline ::PlanetArmy* PlanetGetResp::add_army_list() {
  return army_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlanetArmy >&
PlanetGetResp::army_list() const {
  return army_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlanetArmy >*
PlanetGetResp::mutable_army_list() {
  return &army_list_;
}

// -------------------------------------------------------------------

// PlanetCollectReq

// required string res_global_key = 1;
inline bool PlanetCollectReq::has_res_global_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetCollectReq::set_has_res_global_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetCollectReq::clear_has_res_global_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetCollectReq::clear_res_global_key() {
  if (res_global_key_ != &::google::protobuf::internal::kEmptyString) {
    res_global_key_->clear();
  }
  clear_has_res_global_key();
}
inline const ::std::string& PlanetCollectReq::res_global_key() const {
  return *res_global_key_;
}
inline void PlanetCollectReq::set_res_global_key(const ::std::string& value) {
  set_has_res_global_key();
  if (res_global_key_ == &::google::protobuf::internal::kEmptyString) {
    res_global_key_ = new ::std::string;
  }
  res_global_key_->assign(value);
}
inline void PlanetCollectReq::set_res_global_key(const char* value) {
  set_has_res_global_key();
  if (res_global_key_ == &::google::protobuf::internal::kEmptyString) {
    res_global_key_ = new ::std::string;
  }
  res_global_key_->assign(value);
}
inline void PlanetCollectReq::set_res_global_key(const char* value, size_t size) {
  set_has_res_global_key();
  if (res_global_key_ == &::google::protobuf::internal::kEmptyString) {
    res_global_key_ = new ::std::string;
  }
  res_global_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetCollectReq::mutable_res_global_key() {
  set_has_res_global_key();
  if (res_global_key_ == &::google::protobuf::internal::kEmptyString) {
    res_global_key_ = new ::std::string;
  }
  return res_global_key_;
}
inline ::std::string* PlanetCollectReq::release_res_global_key() {
  clear_has_res_global_key();
  if (res_global_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = res_global_key_;
    res_global_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlanetCollectReq::set_allocated_res_global_key(::std::string* res_global_key) {
  if (res_global_key_ != &::google::protobuf::internal::kEmptyString) {
    delete res_global_key_;
  }
  if (res_global_key) {
    set_has_res_global_key();
    res_global_key_ = res_global_key;
  } else {
    clear_has_res_global_key();
    res_global_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 lineup = 2;
inline int PlanetCollectReq::lineup_size() const {
  return lineup_.size();
}
inline void PlanetCollectReq::clear_lineup() {
  lineup_.Clear();
}
inline ::google::protobuf::int32 PlanetCollectReq::lineup(int index) const {
  return lineup_.Get(index);
}
inline void PlanetCollectReq::set_lineup(int index, ::google::protobuf::int32 value) {
  lineup_.Set(index, value);
}
inline void PlanetCollectReq::add_lineup(::google::protobuf::int32 value) {
  lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PlanetCollectReq::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PlanetCollectReq::mutable_lineup() {
  return &lineup_;
}

// -------------------------------------------------------------------

// PlanetCollectResp

// required .PlanetCollectResp.PlanetCollectRet result = 1;
inline bool PlanetCollectResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetCollectResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetCollectResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetCollectResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::PlanetCollectResp_PlanetCollectRet PlanetCollectResp::result() const {
  return static_cast< ::PlanetCollectResp_PlanetCollectRet >(result_);
}
inline void PlanetCollectResp::set_result(::PlanetCollectResp_PlanetCollectRet value) {
  assert(::PlanetCollectResp_PlanetCollectRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PlanetCollectResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetCollectResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetCollectResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetCollectResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PlanetCollectResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* PlanetCollectResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PlanetCollectResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PlanetCollectResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .PlanetUser planet_user = 3;
inline bool PlanetCollectResp::has_planet_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanetCollectResp::set_has_planet_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanetCollectResp::clear_has_planet_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanetCollectResp::clear_planet_user() {
  if (planet_user_ != NULL) planet_user_->::PlanetUser::Clear();
  clear_has_planet_user();
}
inline const ::PlanetUser& PlanetCollectResp::planet_user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return planet_user_ != NULL ? *planet_user_ : *default_instance().planet_user_;
#else
  return planet_user_ != NULL ? *planet_user_ : *default_instance_->planet_user_;
#endif
}
inline ::PlanetUser* PlanetCollectResp::mutable_planet_user() {
  set_has_planet_user();
  if (planet_user_ == NULL) planet_user_ = new ::PlanetUser;
  return planet_user_;
}
inline ::PlanetUser* PlanetCollectResp::release_planet_user() {
  clear_has_planet_user();
  ::PlanetUser* temp = planet_user_;
  planet_user_ = NULL;
  return temp;
}
inline void PlanetCollectResp::set_allocated_planet_user(::PlanetUser* planet_user) {
  delete planet_user_;
  planet_user_ = planet_user;
  if (planet_user) {
    set_has_planet_user();
  } else {
    clear_has_planet_user();
  }
}

// -------------------------------------------------------------------

// PlanetRideBackReq

// required int32 type = 1;
inline bool PlanetRideBackReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetRideBackReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetRideBackReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetRideBackReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlanetRideBackReq::type() const {
  return type_;
}
inline void PlanetRideBackReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 army_guid = 2;
inline int PlanetRideBackReq::army_guid_size() const {
  return army_guid_.size();
}
inline void PlanetRideBackReq::clear_army_guid() {
  army_guid_.Clear();
}
inline ::google::protobuf::int32 PlanetRideBackReq::army_guid(int index) const {
  return army_guid_.Get(index);
}
inline void PlanetRideBackReq::set_army_guid(int index, ::google::protobuf::int32 value) {
  army_guid_.Set(index, value);
}
inline void PlanetRideBackReq::add_army_guid(::google::protobuf::int32 value) {
  army_guid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PlanetRideBackReq::army_guid() const {
  return army_guid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PlanetRideBackReq::mutable_army_guid() {
  return &army_guid_;
}

// -------------------------------------------------------------------

// PlanetRideBackResp

// required int32 result = 1;
inline bool PlanetRideBackResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetRideBackResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetRideBackResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetRideBackResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PlanetRideBackResp::result() const {
  return result_;
}
inline void PlanetRideBackResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PlanetRideBackResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetRideBackResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetRideBackResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetRideBackResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PlanetRideBackResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* PlanetRideBackResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PlanetRideBackResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PlanetRideBackResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .PlanetUser planet_user = 3;
inline bool PlanetRideBackResp::has_planet_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanetRideBackResp::set_has_planet_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanetRideBackResp::clear_has_planet_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanetRideBackResp::clear_planet_user() {
  if (planet_user_ != NULL) planet_user_->::PlanetUser::Clear();
  clear_has_planet_user();
}
inline const ::PlanetUser& PlanetRideBackResp::planet_user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return planet_user_ != NULL ? *planet_user_ : *default_instance().planet_user_;
#else
  return planet_user_ != NULL ? *planet_user_ : *default_instance_->planet_user_;
#endif
}
inline ::PlanetUser* PlanetRideBackResp::mutable_planet_user() {
  set_has_planet_user();
  if (planet_user_ == NULL) planet_user_ = new ::PlanetUser;
  return planet_user_;
}
inline ::PlanetUser* PlanetRideBackResp::release_planet_user() {
  clear_has_planet_user();
  ::PlanetUser* temp = planet_user_;
  planet_user_ = NULL;
  return temp;
}
inline void PlanetRideBackResp::set_allocated_planet_user(::PlanetUser* planet_user) {
  delete planet_user_;
  planet_user_ = planet_user;
  if (planet_user) {
    set_has_planet_user();
  } else {
    clear_has_planet_user();
  }
}

// -------------------------------------------------------------------

// PlanetRuinsReq

// required string element_global_key = 1;
inline bool PlanetRuinsReq::has_element_global_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetRuinsReq::set_has_element_global_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetRuinsReq::clear_has_element_global_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetRuinsReq::clear_element_global_key() {
  if (element_global_key_ != &::google::protobuf::internal::kEmptyString) {
    element_global_key_->clear();
  }
  clear_has_element_global_key();
}
inline const ::std::string& PlanetRuinsReq::element_global_key() const {
  return *element_global_key_;
}
inline void PlanetRuinsReq::set_element_global_key(const ::std::string& value) {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  element_global_key_->assign(value);
}
inline void PlanetRuinsReq::set_element_global_key(const char* value) {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  element_global_key_->assign(value);
}
inline void PlanetRuinsReq::set_element_global_key(const char* value, size_t size) {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  element_global_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetRuinsReq::mutable_element_global_key() {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  return element_global_key_;
}
inline ::std::string* PlanetRuinsReq::release_element_global_key() {
  clear_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = element_global_key_;
    element_global_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlanetRuinsReq::set_allocated_element_global_key(::std::string* element_global_key) {
  if (element_global_key_ != &::google::protobuf::internal::kEmptyString) {
    delete element_global_key_;
  }
  if (element_global_key) {
    set_has_element_global_key();
    element_global_key_ = element_global_key;
  } else {
    clear_has_element_global_key();
    element_global_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 lineup = 2;
inline int PlanetRuinsReq::lineup_size() const {
  return lineup_.size();
}
inline void PlanetRuinsReq::clear_lineup() {
  lineup_.Clear();
}
inline ::google::protobuf::int32 PlanetRuinsReq::lineup(int index) const {
  return lineup_.Get(index);
}
inline void PlanetRuinsReq::set_lineup(int index, ::google::protobuf::int32 value) {
  lineup_.Set(index, value);
}
inline void PlanetRuinsReq::add_lineup(::google::protobuf::int32 value) {
  lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PlanetRuinsReq::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PlanetRuinsReq::mutable_lineup() {
  return &lineup_;
}

// -------------------------------------------------------------------

// PlanetRuinsResp

// required .PlanetRuinsResp.PlanetRuinsRet result = 1;
inline bool PlanetRuinsResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetRuinsResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetRuinsResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetRuinsResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::PlanetRuinsResp_PlanetRuinsRet PlanetRuinsResp::result() const {
  return static_cast< ::PlanetRuinsResp_PlanetRuinsRet >(result_);
}
inline void PlanetRuinsResp::set_result(::PlanetRuinsResp_PlanetRuinsRet value) {
  assert(::PlanetRuinsResp_PlanetRuinsRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PlanetRuinsResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetRuinsResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetRuinsResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetRuinsResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PlanetRuinsResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* PlanetRuinsResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PlanetRuinsResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PlanetRuinsResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .PlanetUser planet_user = 3;
inline bool PlanetRuinsResp::has_planet_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanetRuinsResp::set_has_planet_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanetRuinsResp::clear_has_planet_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanetRuinsResp::clear_planet_user() {
  if (planet_user_ != NULL) planet_user_->::PlanetUser::Clear();
  clear_has_planet_user();
}
inline const ::PlanetUser& PlanetRuinsResp::planet_user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return planet_user_ != NULL ? *planet_user_ : *default_instance().planet_user_;
#else
  return planet_user_ != NULL ? *planet_user_ : *default_instance_->planet_user_;
#endif
}
inline ::PlanetUser* PlanetRuinsResp::mutable_planet_user() {
  set_has_planet_user();
  if (planet_user_ == NULL) planet_user_ = new ::PlanetUser;
  return planet_user_;
}
inline ::PlanetUser* PlanetRuinsResp::release_planet_user() {
  clear_has_planet_user();
  ::PlanetUser* temp = planet_user_;
  planet_user_ = NULL;
  return temp;
}
inline void PlanetRuinsResp::set_allocated_planet_user(::PlanetUser* planet_user) {
  delete planet_user_;
  planet_user_ = planet_user;
  if (planet_user) {
    set_has_planet_user();
  } else {
    clear_has_planet_user();
  }
}

// -------------------------------------------------------------------

// PlanetRaidReq

// repeated int32 type_list = 1;
inline int PlanetRaidReq::type_list_size() const {
  return type_list_.size();
}
inline void PlanetRaidReq::clear_type_list() {
  type_list_.Clear();
}
inline ::google::protobuf::int32 PlanetRaidReq::type_list(int index) const {
  return type_list_.Get(index);
}
inline void PlanetRaidReq::set_type_list(int index, ::google::protobuf::int32 value) {
  type_list_.Set(index, value);
}
inline void PlanetRaidReq::add_type_list(::google::protobuf::int32 value) {
  type_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PlanetRaidReq::type_list() const {
  return type_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PlanetRaidReq::mutable_type_list() {
  return &type_list_;
}

// required string element_global_key = 2;
inline bool PlanetRaidReq::has_element_global_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetRaidReq::set_has_element_global_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetRaidReq::clear_has_element_global_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetRaidReq::clear_element_global_key() {
  if (element_global_key_ != &::google::protobuf::internal::kEmptyString) {
    element_global_key_->clear();
  }
  clear_has_element_global_key();
}
inline const ::std::string& PlanetRaidReq::element_global_key() const {
  return *element_global_key_;
}
inline void PlanetRaidReq::set_element_global_key(const ::std::string& value) {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  element_global_key_->assign(value);
}
inline void PlanetRaidReq::set_element_global_key(const char* value) {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  element_global_key_->assign(value);
}
inline void PlanetRaidReq::set_element_global_key(const char* value, size_t size) {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  element_global_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetRaidReq::mutable_element_global_key() {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  return element_global_key_;
}
inline ::std::string* PlanetRaidReq::release_element_global_key() {
  clear_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = element_global_key_;
    element_global_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlanetRaidReq::set_allocated_element_global_key(::std::string* element_global_key) {
  if (element_global_key_ != &::google::protobuf::internal::kEmptyString) {
    delete element_global_key_;
  }
  if (element_global_key) {
    set_has_element_global_key();
    element_global_key_ = element_global_key;
  } else {
    clear_has_element_global_key();
    element_global_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 lineup = 3;
inline int PlanetRaidReq::lineup_size() const {
  return lineup_.size();
}
inline void PlanetRaidReq::clear_lineup() {
  lineup_.Clear();
}
inline ::google::protobuf::int32 PlanetRaidReq::lineup(int index) const {
  return lineup_.Get(index);
}
inline void PlanetRaidReq::set_lineup(int index, ::google::protobuf::int32 value) {
  lineup_.Set(index, value);
}
inline void PlanetRaidReq::add_lineup(::google::protobuf::int32 value) {
  lineup_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PlanetRaidReq::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PlanetRaidReq::mutable_lineup() {
  return &lineup_;
}

// optional string army_key = 4;
inline bool PlanetRaidReq::has_army_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlanetRaidReq::set_has_army_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlanetRaidReq::clear_has_army_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlanetRaidReq::clear_army_key() {
  if (army_key_ != &::google::protobuf::internal::kEmptyString) {
    army_key_->clear();
  }
  clear_has_army_key();
}
inline const ::std::string& PlanetRaidReq::army_key() const {
  return *army_key_;
}
inline void PlanetRaidReq::set_army_key(const ::std::string& value) {
  set_has_army_key();
  if (army_key_ == &::google::protobuf::internal::kEmptyString) {
    army_key_ = new ::std::string;
  }
  army_key_->assign(value);
}
inline void PlanetRaidReq::set_army_key(const char* value) {
  set_has_army_key();
  if (army_key_ == &::google::protobuf::internal::kEmptyString) {
    army_key_ = new ::std::string;
  }
  army_key_->assign(value);
}
inline void PlanetRaidReq::set_army_key(const char* value, size_t size) {
  set_has_army_key();
  if (army_key_ == &::google::protobuf::internal::kEmptyString) {
    army_key_ = new ::std::string;
  }
  army_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetRaidReq::mutable_army_key() {
  set_has_army_key();
  if (army_key_ == &::google::protobuf::internal::kEmptyString) {
    army_key_ = new ::std::string;
  }
  return army_key_;
}
inline ::std::string* PlanetRaidReq::release_army_key() {
  clear_has_army_key();
  if (army_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = army_key_;
    army_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlanetRaidReq::set_allocated_army_key(::std::string* army_key) {
  if (army_key_ != &::google::protobuf::internal::kEmptyString) {
    delete army_key_;
  }
  if (army_key) {
    set_has_army_key();
    army_key_ = army_key;
  } else {
    clear_has_army_key();
    army_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 mass_level = 5;
inline bool PlanetRaidReq::has_mass_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlanetRaidReq::set_has_mass_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlanetRaidReq::clear_has_mass_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlanetRaidReq::clear_mass_level() {
  mass_level_ = 0;
  clear_has_mass_level();
}
inline ::google::protobuf::int32 PlanetRaidReq::mass_level() const {
  return mass_level_;
}
inline void PlanetRaidReq::set_mass_level(::google::protobuf::int32 value) {
  set_has_mass_level();
  mass_level_ = value;
}

// -------------------------------------------------------------------

// PlanetRaidResp

// required .PlanetRaidResp.PlanetRaidRet result = 1;
inline bool PlanetRaidResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetRaidResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetRaidResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetRaidResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::PlanetRaidResp_PlanetRaidRet PlanetRaidResp::result() const {
  return static_cast< ::PlanetRaidResp_PlanetRaidRet >(result_);
}
inline void PlanetRaidResp::set_result(::PlanetRaidResp_PlanetRaidRet value) {
  assert(::PlanetRaidResp_PlanetRaidRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PlanetRaidResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetRaidResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetRaidResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetRaidResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PlanetRaidResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* PlanetRaidResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PlanetRaidResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PlanetRaidResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .PlanetUser planet_user = 3;
inline bool PlanetRaidResp::has_planet_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanetRaidResp::set_has_planet_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanetRaidResp::clear_has_planet_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanetRaidResp::clear_planet_user() {
  if (planet_user_ != NULL) planet_user_->::PlanetUser::Clear();
  clear_has_planet_user();
}
inline const ::PlanetUser& PlanetRaidResp::planet_user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return planet_user_ != NULL ? *planet_user_ : *default_instance().planet_user_;
#else
  return planet_user_ != NULL ? *planet_user_ : *default_instance_->planet_user_;
#endif
}
inline ::PlanetUser* PlanetRaidResp::mutable_planet_user() {
  set_has_planet_user();
  if (planet_user_ == NULL) planet_user_ = new ::PlanetUser;
  return planet_user_;
}
inline ::PlanetUser* PlanetRaidResp::release_planet_user() {
  clear_has_planet_user();
  ::PlanetUser* temp = planet_user_;
  planet_user_ = NULL;
  return temp;
}
inline void PlanetRaidResp::set_allocated_planet_user(::PlanetUser* planet_user) {
  delete planet_user_;
  planet_user_ = planet_user;
  if (planet_user) {
    set_has_planet_user();
  } else {
    clear_has_planet_user();
  }
}

// -------------------------------------------------------------------

// PlanetSpeedUpReq

// required string army_key = 1;
inline bool PlanetSpeedUpReq::has_army_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetSpeedUpReq::set_has_army_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetSpeedUpReq::clear_has_army_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetSpeedUpReq::clear_army_key() {
  if (army_key_ != &::google::protobuf::internal::kEmptyString) {
    army_key_->clear();
  }
  clear_has_army_key();
}
inline const ::std::string& PlanetSpeedUpReq::army_key() const {
  return *army_key_;
}
inline void PlanetSpeedUpReq::set_army_key(const ::std::string& value) {
  set_has_army_key();
  if (army_key_ == &::google::protobuf::internal::kEmptyString) {
    army_key_ = new ::std::string;
  }
  army_key_->assign(value);
}
inline void PlanetSpeedUpReq::set_army_key(const char* value) {
  set_has_army_key();
  if (army_key_ == &::google::protobuf::internal::kEmptyString) {
    army_key_ = new ::std::string;
  }
  army_key_->assign(value);
}
inline void PlanetSpeedUpReq::set_army_key(const char* value, size_t size) {
  set_has_army_key();
  if (army_key_ == &::google::protobuf::internal::kEmptyString) {
    army_key_ = new ::std::string;
  }
  army_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetSpeedUpReq::mutable_army_key() {
  set_has_army_key();
  if (army_key_ == &::google::protobuf::internal::kEmptyString) {
    army_key_ = new ::std::string;
  }
  return army_key_;
}
inline ::std::string* PlanetSpeedUpReq::release_army_key() {
  clear_has_army_key();
  if (army_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = army_key_;
    army_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlanetSpeedUpReq::set_allocated_army_key(::std::string* army_key) {
  if (army_key_ != &::google::protobuf::internal::kEmptyString) {
    delete army_key_;
  }
  if (army_key) {
    set_has_army_key();
    army_key_ = army_key;
  } else {
    clear_has_army_key();
    army_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 2;
inline bool PlanetSpeedUpReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetSpeedUpReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetSpeedUpReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetSpeedUpReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlanetSpeedUpReq::type() const {
  return type_;
}
inline void PlanetSpeedUpReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// PlanetSpeedUpResp

// required int32 result = 1;
inline bool PlanetSpeedUpResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetSpeedUpResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetSpeedUpResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetSpeedUpResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PlanetSpeedUpResp::result() const {
  return result_;
}
inline void PlanetSpeedUpResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 type = 2;
inline bool PlanetSpeedUpResp::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetSpeedUpResp::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetSpeedUpResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetSpeedUpResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlanetSpeedUpResp::type() const {
  return type_;
}
inline void PlanetSpeedUpResp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional .UserSync user_sync = 3;
inline bool PlanetSpeedUpResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanetSpeedUpResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanetSpeedUpResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanetSpeedUpResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PlanetSpeedUpResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* PlanetSpeedUpResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PlanetSpeedUpResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PlanetSpeedUpResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .PlanetArmy army = 4;
inline bool PlanetSpeedUpResp::has_army() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlanetSpeedUpResp::set_has_army() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlanetSpeedUpResp::clear_has_army() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlanetSpeedUpResp::clear_army() {
  if (army_ != NULL) army_->::PlanetArmy::Clear();
  clear_has_army();
}
inline const ::PlanetArmy& PlanetSpeedUpResp::army() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return army_ != NULL ? *army_ : *default_instance().army_;
#else
  return army_ != NULL ? *army_ : *default_instance_->army_;
#endif
}
inline ::PlanetArmy* PlanetSpeedUpResp::mutable_army() {
  set_has_army();
  if (army_ == NULL) army_ = new ::PlanetArmy;
  return army_;
}
inline ::PlanetArmy* PlanetSpeedUpResp::release_army() {
  clear_has_army();
  ::PlanetArmy* temp = army_;
  army_ = NULL;
  return temp;
}
inline void PlanetSpeedUpResp::set_allocated_army(::PlanetArmy* army) {
  delete army_;
  army_ = army;
  if (army) {
    set_has_army();
  } else {
    clear_has_army();
  }
}

// -------------------------------------------------------------------

// PlanetShieldReq

// required int32 item_id = 1;
inline bool PlanetShieldReq::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetShieldReq::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetShieldReq::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetShieldReq::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 PlanetShieldReq::item_id() const {
  return item_id_;
}
inline void PlanetShieldReq::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// -------------------------------------------------------------------

// PlanetShieldResp

// required int32 result = 1;
inline bool PlanetShieldResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetShieldResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetShieldResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetShieldResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PlanetShieldResp::result() const {
  return result_;
}
inline void PlanetShieldResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PlanetShieldResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetShieldResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetShieldResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetShieldResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PlanetShieldResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* PlanetShieldResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PlanetShieldResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PlanetShieldResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// PlanetMoveBaseReq

// required int32 type = 1;
inline bool PlanetMoveBaseReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetMoveBaseReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetMoveBaseReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetMoveBaseReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlanetMoveBaseReq::type() const {
  return type_;
}
inline void PlanetMoveBaseReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional .PlanetPoint pos = 2;
inline bool PlanetMoveBaseReq::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetMoveBaseReq::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetMoveBaseReq::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetMoveBaseReq::clear_pos() {
  if (pos_ != NULL) pos_->::PlanetPoint::Clear();
  clear_has_pos();
}
inline const ::PlanetPoint& PlanetMoveBaseReq::pos() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pos_ != NULL ? *pos_ : *default_instance().pos_;
#else
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
#endif
}
inline ::PlanetPoint* PlanetMoveBaseReq::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::PlanetPoint;
  return pos_;
}
inline ::PlanetPoint* PlanetMoveBaseReq::release_pos() {
  clear_has_pos();
  ::PlanetPoint* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void PlanetMoveBaseReq::set_allocated_pos(::PlanetPoint* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// -------------------------------------------------------------------

// PlanetMoveBaseResp

// required .PlanetMoveBaseResp.PlanetMoveBaseRet result = 1;
inline bool PlanetMoveBaseResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetMoveBaseResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetMoveBaseResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetMoveBaseResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::PlanetMoveBaseResp_PlanetMoveBaseRet PlanetMoveBaseResp::result() const {
  return static_cast< ::PlanetMoveBaseResp_PlanetMoveBaseRet >(result_);
}
inline void PlanetMoveBaseResp::set_result(::PlanetMoveBaseResp_PlanetMoveBaseRet value) {
  assert(::PlanetMoveBaseResp_PlanetMoveBaseRet_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PlanetMoveBaseResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetMoveBaseResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetMoveBaseResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetMoveBaseResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PlanetMoveBaseResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* PlanetMoveBaseResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PlanetMoveBaseResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PlanetMoveBaseResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional .PlanetUser planet_user = 3;
inline bool PlanetMoveBaseResp::has_planet_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanetMoveBaseResp::set_has_planet_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanetMoveBaseResp::clear_has_planet_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanetMoveBaseResp::clear_planet_user() {
  if (planet_user_ != NULL) planet_user_->::PlanetUser::Clear();
  clear_has_planet_user();
}
inline const ::PlanetUser& PlanetMoveBaseResp::planet_user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return planet_user_ != NULL ? *planet_user_ : *default_instance().planet_user_;
#else
  return planet_user_ != NULL ? *planet_user_ : *default_instance_->planet_user_;
#endif
}
inline ::PlanetUser* PlanetMoveBaseResp::mutable_planet_user() {
  set_has_planet_user();
  if (planet_user_ == NULL) planet_user_ = new ::PlanetUser;
  return planet_user_;
}
inline ::PlanetUser* PlanetMoveBaseResp::release_planet_user() {
  clear_has_planet_user();
  ::PlanetUser* temp = planet_user_;
  planet_user_ = NULL;
  return temp;
}
inline void PlanetMoveBaseResp::set_allocated_planet_user(::PlanetUser* planet_user) {
  delete planet_user_;
  planet_user_ = planet_user;
  if (planet_user) {
    set_has_planet_user();
  } else {
    clear_has_planet_user();
  }
}

// -------------------------------------------------------------------

// PlanetMarkReq

// required int32 type = 1;
inline bool PlanetMarkReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetMarkReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetMarkReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetMarkReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlanetMarkReq::type() const {
  return type_;
}
inline void PlanetMarkReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string name = 2;
inline bool PlanetMarkReq::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetMarkReq::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetMarkReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetMarkReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlanetMarkReq::name() const {
  return *name_;
}
inline void PlanetMarkReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlanetMarkReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlanetMarkReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetMarkReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlanetMarkReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlanetMarkReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PlanetPoint pos = 3;
inline bool PlanetMarkReq::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanetMarkReq::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanetMarkReq::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanetMarkReq::clear_pos() {
  if (pos_ != NULL) pos_->::PlanetPoint::Clear();
  clear_has_pos();
}
inline const ::PlanetPoint& PlanetMarkReq::pos() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pos_ != NULL ? *pos_ : *default_instance().pos_;
#else
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
#endif
}
inline ::PlanetPoint* PlanetMarkReq::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::PlanetPoint;
  return pos_;
}
inline ::PlanetPoint* PlanetMarkReq::release_pos() {
  clear_has_pos();
  ::PlanetPoint* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void PlanetMarkReq::set_allocated_pos(::PlanetPoint* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// -------------------------------------------------------------------

// PlanetMarkResp

// required int32 result = 1;
inline bool PlanetMarkResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetMarkResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetMarkResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetMarkResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PlanetMarkResp::result() const {
  return result_;
}
inline void PlanetMarkResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool PlanetMarkResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetMarkResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetMarkResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetMarkResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& PlanetMarkResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* PlanetMarkResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* PlanetMarkResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void PlanetMarkResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated .PlanetMark mark_list = 3;
inline int PlanetMarkResp::mark_list_size() const {
  return mark_list_.size();
}
inline void PlanetMarkResp::clear_mark_list() {
  mark_list_.Clear();
}
inline const ::PlanetMark& PlanetMarkResp::mark_list(int index) const {
  return mark_list_.Get(index);
}
inline ::PlanetMark* PlanetMarkResp::mutable_mark_list(int index) {
  return mark_list_.Mutable(index);
}
inline ::PlanetMark* PlanetMarkResp::add_mark_list() {
  return mark_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlanetMark >&
PlanetMarkResp::mark_list() const {
  return mark_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlanetMark >*
PlanetMarkResp::mutable_mark_list() {
  return &mark_list_;
}

// -------------------------------------------------------------------

// PlanetTowerReq

// required int32 type = 1;
inline bool PlanetTowerReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetTowerReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetTowerReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetTowerReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlanetTowerReq::type() const {
  return type_;
}
inline void PlanetTowerReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string element_global_key = 2;
inline bool PlanetTowerReq::has_element_global_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetTowerReq::set_has_element_global_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetTowerReq::clear_has_element_global_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetTowerReq::clear_element_global_key() {
  if (element_global_key_ != &::google::protobuf::internal::kEmptyString) {
    element_global_key_->clear();
  }
  clear_has_element_global_key();
}
inline const ::std::string& PlanetTowerReq::element_global_key() const {
  return *element_global_key_;
}
inline void PlanetTowerReq::set_element_global_key(const ::std::string& value) {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  element_global_key_->assign(value);
}
inline void PlanetTowerReq::set_element_global_key(const char* value) {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  element_global_key_->assign(value);
}
inline void PlanetTowerReq::set_element_global_key(const char* value, size_t size) {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  element_global_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetTowerReq::mutable_element_global_key() {
  set_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    element_global_key_ = new ::std::string;
  }
  return element_global_key_;
}
inline ::std::string* PlanetTowerReq::release_element_global_key() {
  clear_has_element_global_key();
  if (element_global_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = element_global_key_;
    element_global_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlanetTowerReq::set_allocated_element_global_key(::std::string* element_global_key) {
  if (element_global_key_ != &::google::protobuf::internal::kEmptyString) {
    delete element_global_key_;
  }
  if (element_global_key) {
    set_has_element_global_key();
    element_global_key_ = element_global_key;
  } else {
    clear_has_element_global_key();
    element_global_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlanetTowerResp

// required int32 result = 1;
inline bool PlanetTowerResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetTowerResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetTowerResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetTowerResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PlanetTowerResp::result() const {
  return result_;
}
inline void PlanetTowerResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .PlanetElement element = 2;
inline bool PlanetTowerResp::has_element() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetTowerResp::set_has_element() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetTowerResp::clear_has_element() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetTowerResp::clear_element() {
  if (element_ != NULL) element_->::PlanetElement::Clear();
  clear_has_element();
}
inline const ::PlanetElement& PlanetTowerResp::element() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return element_ != NULL ? *element_ : *default_instance().element_;
#else
  return element_ != NULL ? *element_ : *default_instance_->element_;
#endif
}
inline ::PlanetElement* PlanetTowerResp::mutable_element() {
  set_has_element();
  if (element_ == NULL) element_ = new ::PlanetElement;
  return element_;
}
inline ::PlanetElement* PlanetTowerResp::release_element() {
  clear_has_element();
  ::PlanetElement* temp = element_;
  element_ = NULL;
  return temp;
}
inline void PlanetTowerResp::set_allocated_element(::PlanetElement* element) {
  delete element_;
  element_ = element;
  if (element) {
    set_has_element();
  } else {
    clear_has_element();
  }
}

// -------------------------------------------------------------------

// PlanetWangZuoTitleReq

// required int32 type = 1;
inline bool PlanetWangZuoTitleReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetWangZuoTitleReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanetWangZuoTitleReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanetWangZuoTitleReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlanetWangZuoTitleReq::type() const {
  return type_;
}
inline void PlanetWangZuoTitleReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string user_name = 2;
inline bool PlanetWangZuoTitleReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetWangZuoTitleReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanetWangZuoTitleReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanetWangZuoTitleReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& PlanetWangZuoTitleReq::user_name() const {
  return *user_name_;
}
inline void PlanetWangZuoTitleReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void PlanetWangZuoTitleReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void PlanetWangZuoTitleReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlanetWangZuoTitleReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* PlanetWangZuoTitleReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlanetWangZuoTitleReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 title = 3;
inline bool PlanetWangZuoTitleReq::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanetWangZuoTitleReq::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanetWangZuoTitleReq::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanetWangZuoTitleReq::clear_title() {
  title_ = 0;
  clear_has_title();
}
inline ::google::protobuf::int32 PlanetWangZuoTitleReq::title() const {
  return title_;
}
inline void PlanetWangZuoTitleReq::set_title(::google::protobuf::int32 value) {
  set_has_title();
  title_ = value;
}

// -------------------------------------------------------------------

// PLanetWangZuoTitleResp

// required int32 result = 1;
inline bool PLanetWangZuoTitleResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PLanetWangZuoTitleResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PLanetWangZuoTitleResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PLanetWangZuoTitleResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PLanetWangZuoTitleResp::result() const {
  return result_;
}
inline void PLanetWangZuoTitleResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 type = 2;
inline bool PLanetWangZuoTitleResp::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PLanetWangZuoTitleResp::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PLanetWangZuoTitleResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PLanetWangZuoTitleResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PLanetWangZuoTitleResp::type() const {
  return type_;
}
inline void PLanetWangZuoTitleResp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional .PlanetWangZuoTitleList title_list = 3;
inline bool PLanetWangZuoTitleResp::has_title_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PLanetWangZuoTitleResp::set_has_title_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PLanetWangZuoTitleResp::clear_has_title_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PLanetWangZuoTitleResp::clear_title_list() {
  if (title_list_ != NULL) title_list_->::PlanetWangZuoTitleList::Clear();
  clear_has_title_list();
}
inline const ::PlanetWangZuoTitleList& PLanetWangZuoTitleResp::title_list() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return title_list_ != NULL ? *title_list_ : *default_instance().title_list_;
#else
  return title_list_ != NULL ? *title_list_ : *default_instance_->title_list_;
#endif
}
inline ::PlanetWangZuoTitleList* PLanetWangZuoTitleResp::mutable_title_list() {
  set_has_title_list();
  if (title_list_ == NULL) title_list_ = new ::PlanetWangZuoTitleList;
  return title_list_;
}
inline ::PlanetWangZuoTitleList* PLanetWangZuoTitleResp::release_title_list() {
  clear_has_title_list();
  ::PlanetWangZuoTitleList* temp = title_list_;
  title_list_ = NULL;
  return temp;
}
inline void PLanetWangZuoTitleResp::set_allocated_title_list(::PlanetWangZuoTitleList* title_list) {
  delete title_list_;
  title_list_ = title_list;
  if (title_list) {
    set_has_title_list();
  } else {
    clear_has_title_list();
  }
}

// optional .PlanetWangZuoOccupyList occupy_list = 4;
inline bool PLanetWangZuoTitleResp::has_occupy_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PLanetWangZuoTitleResp::set_has_occupy_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PLanetWangZuoTitleResp::clear_has_occupy_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PLanetWangZuoTitleResp::clear_occupy_list() {
  if (occupy_list_ != NULL) occupy_list_->::PlanetWangZuoOccupyList::Clear();
  clear_has_occupy_list();
}
inline const ::PlanetWangZuoOccupyList& PLanetWangZuoTitleResp::occupy_list() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return occupy_list_ != NULL ? *occupy_list_ : *default_instance().occupy_list_;
#else
  return occupy_list_ != NULL ? *occupy_list_ : *default_instance_->occupy_list_;
#endif
}
inline ::PlanetWangZuoOccupyList* PLanetWangZuoTitleResp::mutable_occupy_list() {
  set_has_occupy_list();
  if (occupy_list_ == NULL) occupy_list_ = new ::PlanetWangZuoOccupyList;
  return occupy_list_;
}
inline ::PlanetWangZuoOccupyList* PLanetWangZuoTitleResp::release_occupy_list() {
  clear_has_occupy_list();
  ::PlanetWangZuoOccupyList* temp = occupy_list_;
  occupy_list_ = NULL;
  return temp;
}
inline void PLanetWangZuoTitleResp::set_allocated_occupy_list(::PlanetWangZuoOccupyList* occupy_list) {
  delete occupy_list_;
  occupy_list_ = occupy_list;
  if (occupy_list) {
    set_has_occupy_list();
  } else {
    clear_has_occupy_list();
  }
}

// repeated .OtherUserInfo user_list = 5;
inline int PLanetWangZuoTitleResp::user_list_size() const {
  return user_list_.size();
}
inline void PLanetWangZuoTitleResp::clear_user_list() {
  user_list_.Clear();
}
inline const ::OtherUserInfo& PLanetWangZuoTitleResp::user_list(int index) const {
  return user_list_.Get(index);
}
inline ::OtherUserInfo* PLanetWangZuoTitleResp::mutable_user_list(int index) {
  return user_list_.Mutable(index);
}
inline ::OtherUserInfo* PLanetWangZuoTitleResp::add_user_list() {
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >&
PLanetWangZuoTitleResp::user_list() const {
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::OtherUserInfo >*
PLanetWangZuoTitleResp::mutable_user_list() {
  return &user_list_;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdPlanet_2eproto__INCLUDED
