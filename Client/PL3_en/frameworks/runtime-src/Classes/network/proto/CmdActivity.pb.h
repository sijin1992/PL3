// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdActivity.proto

#ifndef PROTOBUF_CmdActivity_2eproto__INCLUDED
#define PROTOBUF_CmdActivity_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "UserSync.pb.h"
#include "Item.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CmdActivity_2eproto();
void protobuf_AssignDesc_CmdActivity_2eproto();
void protobuf_ShutdownFile_CmdActivity_2eproto();

class GetActivityListResp;
class ActivityChangeReq;
class ActivityChangeResp;
class ActivitySignInReq;
class ActivitySignInResp;
class ActivitySevenDaysReq;
class ActivitySevenDaysResp;
class ActivityFirstRechargeReq;
class ActivityFirstRechargeResp;
class ActivityRechargeReq;
class ActivityRechargeResp;
class ActivityConsumeReq;
class ActivityConsumeResp;
class ActivityCreditReturnReq;
class ActivityCreditReturnResp;
class ActivityOnlineReq;
class ActivityOnlineResp;
class ActivityPowerReq;
class ActivityPowerResp;
class ActivityGrowthFundReq;
class ActivityGrowthFundResp;
class ActivityInvestReq;
class ActivityInvestResp;
class ActivityChangeShipReq;
class ActivityChangeShipResp;
class ActivityMonthSignReq;
class ActivityMonthSignResp;
class ActivityVIPPackReq;
class ActivityVIPPackResp;
class ActivityEveryDayReq;
class ActivityEveryDayResp;
class ActivityTurntableReq;
class ActivityTurntableResp;
class ActivityAdvancedMoneyReq;
class ActivityAdvancedMoneyResp;
class ActivityExchangeItemReq;
class ActivityExchangeItemResp;

// ===================================================================

class GetActivityListResp : public ::google::protobuf::MessageLite {
 public:
  GetActivityListResp();
  virtual ~GetActivityListResp();

  GetActivityListResp(const GetActivityListResp& from);

  inline GetActivityListResp& operator=(const GetActivityListResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetActivityListResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetActivityListResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetActivityListResp* other);

  // implements Message ----------------------------------------------

  GetActivityListResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetActivityListResp& from);
  void MergeFrom(const GetActivityListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // repeated int32 id_list = 3;
  inline int id_list_size() const;
  inline void clear_id_list();
  static const int kIdListFieldNumber = 3;
  inline ::google::protobuf::int32 id_list(int index) const;
  inline void set_id_list(int index, ::google::protobuf::int32 value);
  inline void add_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id_list();

  // @@protoc_insertion_point(class_scope:GetActivityListResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_list_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static GetActivityListResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityChangeReq : public ::google::protobuf::MessageLite {
 public:
  ActivityChangeReq();
  virtual ~ActivityChangeReq();

  ActivityChangeReq(const ActivityChangeReq& from);

  inline ActivityChangeReq& operator=(const ActivityChangeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityChangeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityChangeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityChangeReq* other);

  // implements Message ----------------------------------------------

  ActivityChangeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityChangeReq& from);
  void MergeFrom(const ActivityChangeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 change_item_id = 2;
  inline bool has_change_item_id() const;
  inline void clear_change_item_id();
  static const int kChangeItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 change_item_id() const;
  inline void set_change_item_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityChangeReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_change_item_id();
  inline void clear_has_change_item_id();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 change_item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityChangeReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityChangeResp : public ::google::protobuf::MessageLite {
 public:
  ActivityChangeResp();
  virtual ~ActivityChangeResp();

  ActivityChangeResp(const ActivityChangeResp& from);

  inline ActivityChangeResp& operator=(const ActivityChangeResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityChangeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityChangeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityChangeResp* other);

  // implements Message ----------------------------------------------

  ActivityChangeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityChangeResp& from);
  void MergeFrom(const ActivityChangeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityChangeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityChangeResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivitySignInReq : public ::google::protobuf::MessageLite {
 public:
  ActivitySignInReq();
  virtual ~ActivitySignInReq();

  ActivitySignInReq(const ActivitySignInReq& from);

  inline ActivitySignInReq& operator=(const ActivitySignInReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivitySignInReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivitySignInReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivitySignInReq* other);

  // implements Message ----------------------------------------------

  ActivitySignInReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivitySignInReq& from);
  void MergeFrom(const ActivitySignInReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivitySignInReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();

  ::google::protobuf::int32 activity_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivitySignInReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivitySignInResp : public ::google::protobuf::MessageLite {
 public:
  ActivitySignInResp();
  virtual ~ActivitySignInResp();

  ActivitySignInResp(const ActivitySignInResp& from);

  inline ActivitySignInResp& operator=(const ActivitySignInResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivitySignInResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivitySignInResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivitySignInResp* other);

  // implements Message ----------------------------------------------

  ActivitySignInResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivitySignInResp& from);
  void MergeFrom(const ActivitySignInResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivitySignInResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivitySignInResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivitySevenDaysReq : public ::google::protobuf::MessageLite {
 public:
  ActivitySevenDaysReq();
  virtual ~ActivitySevenDaysReq();

  ActivitySevenDaysReq(const ActivitySevenDaysReq& from);

  inline ActivitySevenDaysReq& operator=(const ActivitySevenDaysReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivitySevenDaysReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivitySevenDaysReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivitySevenDaysReq* other);

  // implements Message ----------------------------------------------

  ActivitySevenDaysReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivitySevenDaysReq& from);
  void MergeFrom(const ActivitySevenDaysReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline ::google::protobuf::int32 task_id() const;
  inline void set_task_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivitySevenDaysReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivitySevenDaysReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivitySevenDaysResp : public ::google::protobuf::MessageLite {
 public:
  ActivitySevenDaysResp();
  virtual ~ActivitySevenDaysResp();

  ActivitySevenDaysResp(const ActivitySevenDaysResp& from);

  inline ActivitySevenDaysResp& operator=(const ActivitySevenDaysResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivitySevenDaysResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivitySevenDaysResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivitySevenDaysResp* other);

  // implements Message ----------------------------------------------

  ActivitySevenDaysResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivitySevenDaysResp& from);
  void MergeFrom(const ActivitySevenDaysResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivitySevenDaysResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivitySevenDaysResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityFirstRechargeReq : public ::google::protobuf::MessageLite {
 public:
  ActivityFirstRechargeReq();
  virtual ~ActivityFirstRechargeReq();

  ActivityFirstRechargeReq(const ActivityFirstRechargeReq& from);

  inline ActivityFirstRechargeReq& operator=(const ActivityFirstRechargeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityFirstRechargeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityFirstRechargeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityFirstRechargeReq* other);

  // implements Message ----------------------------------------------

  ActivityFirstRechargeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityFirstRechargeReq& from);
  void MergeFrom(const ActivityFirstRechargeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityFirstRechargeReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();

  ::google::protobuf::int32 activity_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityFirstRechargeReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityFirstRechargeResp : public ::google::protobuf::MessageLite {
 public:
  ActivityFirstRechargeResp();
  virtual ~ActivityFirstRechargeResp();

  ActivityFirstRechargeResp(const ActivityFirstRechargeResp& from);

  inline ActivityFirstRechargeResp& operator=(const ActivityFirstRechargeResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityFirstRechargeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityFirstRechargeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityFirstRechargeResp* other);

  // implements Message ----------------------------------------------

  ActivityFirstRechargeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityFirstRechargeResp& from);
  void MergeFrom(const ActivityFirstRechargeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityFirstRechargeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityFirstRechargeResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityRechargeReq : public ::google::protobuf::MessageLite {
 public:
  ActivityRechargeReq();
  virtual ~ActivityRechargeReq();

  ActivityRechargeReq(const ActivityRechargeReq& from);

  inline ActivityRechargeReq& operator=(const ActivityRechargeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityRechargeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityRechargeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityRechargeReq* other);

  // implements Message ----------------------------------------------

  ActivityRechargeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityRechargeReq& from);
  void MergeFrom(const ActivityRechargeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityRechargeReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityRechargeReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityRechargeResp : public ::google::protobuf::MessageLite {
 public:
  ActivityRechargeResp();
  virtual ~ActivityRechargeResp();

  ActivityRechargeResp(const ActivityRechargeResp& from);

  inline ActivityRechargeResp& operator=(const ActivityRechargeResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityRechargeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityRechargeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityRechargeResp* other);

  // implements Message ----------------------------------------------

  ActivityRechargeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityRechargeResp& from);
  void MergeFrom(const ActivityRechargeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityRechargeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityRechargeResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityConsumeReq : public ::google::protobuf::MessageLite {
 public:
  ActivityConsumeReq();
  virtual ~ActivityConsumeReq();

  ActivityConsumeReq(const ActivityConsumeReq& from);

  inline ActivityConsumeReq& operator=(const ActivityConsumeReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityConsumeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityConsumeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityConsumeReq* other);

  // implements Message ----------------------------------------------

  ActivityConsumeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityConsumeReq& from);
  void MergeFrom(const ActivityConsumeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityConsumeReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityConsumeReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityConsumeResp : public ::google::protobuf::MessageLite {
 public:
  ActivityConsumeResp();
  virtual ~ActivityConsumeResp();

  ActivityConsumeResp(const ActivityConsumeResp& from);

  inline ActivityConsumeResp& operator=(const ActivityConsumeResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityConsumeResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityConsumeResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityConsumeResp* other);

  // implements Message ----------------------------------------------

  ActivityConsumeResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityConsumeResp& from);
  void MergeFrom(const ActivityConsumeResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityConsumeResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityConsumeResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityCreditReturnReq : public ::google::protobuf::MessageLite {
 public:
  ActivityCreditReturnReq();
  virtual ~ActivityCreditReturnReq();

  ActivityCreditReturnReq(const ActivityCreditReturnReq& from);

  inline ActivityCreditReturnReq& operator=(const ActivityCreditReturnReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityCreditReturnReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityCreditReturnReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityCreditReturnReq* other);

  // implements Message ----------------------------------------------

  ActivityCreditReturnReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityCreditReturnReq& from);
  void MergeFrom(const ActivityCreditReturnReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityCreditReturnReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityCreditReturnReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityCreditReturnResp : public ::google::protobuf::MessageLite {
 public:
  ActivityCreditReturnResp();
  virtual ~ActivityCreditReturnResp();

  ActivityCreditReturnResp(const ActivityCreditReturnResp& from);

  inline ActivityCreditReturnResp& operator=(const ActivityCreditReturnResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityCreditReturnResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityCreditReturnResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityCreditReturnResp* other);

  // implements Message ----------------------------------------------

  ActivityCreditReturnResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityCreditReturnResp& from);
  void MergeFrom(const ActivityCreditReturnResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 return_credit = 3;
  inline bool has_return_credit() const;
  inline void clear_return_credit();
  static const int kReturnCreditFieldNumber = 3;
  inline ::google::protobuf::int32 return_credit() const;
  inline void set_return_credit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityCreditReturnResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_return_credit();
  inline void clear_has_return_credit();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 return_credit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityCreditReturnResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityOnlineReq : public ::google::protobuf::MessageLite {
 public:
  ActivityOnlineReq();
  virtual ~ActivityOnlineReq();

  ActivityOnlineReq(const ActivityOnlineReq& from);

  inline ActivityOnlineReq& operator=(const ActivityOnlineReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityOnlineReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityOnlineReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityOnlineReq* other);

  // implements Message ----------------------------------------------

  ActivityOnlineReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityOnlineReq& from);
  void MergeFrom(const ActivityOnlineReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityOnlineReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityOnlineReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityOnlineResp : public ::google::protobuf::MessageLite {
 public:
  ActivityOnlineResp();
  virtual ~ActivityOnlineResp();

  ActivityOnlineResp(const ActivityOnlineResp& from);

  inline ActivityOnlineResp& operator=(const ActivityOnlineResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityOnlineResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityOnlineResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityOnlineResp* other);

  // implements Message ----------------------------------------------

  ActivityOnlineResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityOnlineResp& from);
  void MergeFrom(const ActivityOnlineResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityOnlineResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityOnlineResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityPowerReq : public ::google::protobuf::MessageLite {
 public:
  ActivityPowerReq();
  virtual ~ActivityPowerReq();

  ActivityPowerReq(const ActivityPowerReq& from);

  inline ActivityPowerReq& operator=(const ActivityPowerReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityPowerReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityPowerReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityPowerReq* other);

  // implements Message ----------------------------------------------

  ActivityPowerReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityPowerReq& from);
  void MergeFrom(const ActivityPowerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityPowerReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityPowerReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityPowerResp : public ::google::protobuf::MessageLite {
 public:
  ActivityPowerResp();
  virtual ~ActivityPowerResp();

  ActivityPowerResp(const ActivityPowerResp& from);

  inline ActivityPowerResp& operator=(const ActivityPowerResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityPowerResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityPowerResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityPowerResp* other);

  // implements Message ----------------------------------------------

  ActivityPowerResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityPowerResp& from);
  void MergeFrom(const ActivityPowerResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityPowerResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityPowerResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityGrowthFundReq : public ::google::protobuf::MessageLite {
 public:
  ActivityGrowthFundReq();
  virtual ~ActivityGrowthFundReq();

  ActivityGrowthFundReq(const ActivityGrowthFundReq& from);

  inline ActivityGrowthFundReq& operator=(const ActivityGrowthFundReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityGrowthFundReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityGrowthFundReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityGrowthFundReq* other);

  // implements Message ----------------------------------------------

  ActivityGrowthFundReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityGrowthFundReq& from);
  void MergeFrom(const ActivityGrowthFundReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityGrowthFundReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityGrowthFundReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityGrowthFundResp : public ::google::protobuf::MessageLite {
 public:
  ActivityGrowthFundResp();
  virtual ~ActivityGrowthFundResp();

  ActivityGrowthFundResp(const ActivityGrowthFundResp& from);

  inline ActivityGrowthFundResp& operator=(const ActivityGrowthFundResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityGrowthFundResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityGrowthFundResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityGrowthFundResp* other);

  // implements Message ----------------------------------------------

  ActivityGrowthFundResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityGrowthFundResp& from);
  void MergeFrom(const ActivityGrowthFundResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityGrowthFundResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityGrowthFundResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityInvestReq : public ::google::protobuf::MessageLite {
 public:
  ActivityInvestReq();
  virtual ~ActivityInvestReq();

  ActivityInvestReq(const ActivityInvestReq& from);

  inline ActivityInvestReq& operator=(const ActivityInvestReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityInvestReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityInvestReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityInvestReq* other);

  // implements Message ----------------------------------------------

  ActivityInvestReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityInvestReq& from);
  void MergeFrom(const ActivityInvestReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityInvestReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityInvestReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityInvestResp : public ::google::protobuf::MessageLite {
 public:
  ActivityInvestResp();
  virtual ~ActivityInvestResp();

  ActivityInvestResp(const ActivityInvestResp& from);

  inline ActivityInvestResp& operator=(const ActivityInvestResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityInvestResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityInvestResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityInvestResp* other);

  // implements Message ----------------------------------------------

  ActivityInvestResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityInvestResp& from);
  void MergeFrom(const ActivityInvestResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // optional int32 earning = 3;
  inline bool has_earning() const;
  inline void clear_earning();
  static const int kEarningFieldNumber = 3;
  inline ::google::protobuf::int32 earning() const;
  inline void set_earning(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityInvestResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_earning();
  inline void clear_has_earning();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 earning_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityInvestResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityChangeShipReq : public ::google::protobuf::MessageLite {
 public:
  ActivityChangeShipReq();
  virtual ~ActivityChangeShipReq();

  ActivityChangeShipReq(const ActivityChangeShipReq& from);

  inline ActivityChangeShipReq& operator=(const ActivityChangeShipReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityChangeShipReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityChangeShipReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityChangeShipReq* other);

  // implements Message ----------------------------------------------

  ActivityChangeShipReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityChangeShipReq& from);
  void MergeFrom(const ActivityChangeShipReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityChangeShipReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();

  ::google::protobuf::int32 activity_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityChangeShipReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityChangeShipResp : public ::google::protobuf::MessageLite {
 public:
  ActivityChangeShipResp();
  virtual ~ActivityChangeShipResp();

  ActivityChangeShipResp(const ActivityChangeShipResp& from);

  inline ActivityChangeShipResp& operator=(const ActivityChangeShipResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityChangeShipResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityChangeShipResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityChangeShipResp* other);

  // implements Message ----------------------------------------------

  ActivityChangeShipResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityChangeShipResp& from);
  void MergeFrom(const ActivityChangeShipResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityChangeShipResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityChangeShipResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityMonthSignReq : public ::google::protobuf::MessageLite {
 public:
  ActivityMonthSignReq();
  virtual ~ActivityMonthSignReq();

  ActivityMonthSignReq(const ActivityMonthSignReq& from);

  inline ActivityMonthSignReq& operator=(const ActivityMonthSignReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityMonthSignReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityMonthSignReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityMonthSignReq* other);

  // implements Message ----------------------------------------------

  ActivityMonthSignReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityMonthSignReq& from);
  void MergeFrom(const ActivityMonthSignReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityMonthSignReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityMonthSignReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityMonthSignResp : public ::google::protobuf::MessageLite {
 public:
  ActivityMonthSignResp();
  virtual ~ActivityMonthSignResp();

  ActivityMonthSignResp(const ActivityMonthSignResp& from);

  inline ActivityMonthSignResp& operator=(const ActivityMonthSignResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityMonthSignResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityMonthSignResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityMonthSignResp* other);

  // implements Message ----------------------------------------------

  ActivityMonthSignResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityMonthSignResp& from);
  void MergeFrom(const ActivityMonthSignResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityMonthSignResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityMonthSignResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityVIPPackReq : public ::google::protobuf::MessageLite {
 public:
  ActivityVIPPackReq();
  virtual ~ActivityVIPPackReq();

  ActivityVIPPackReq(const ActivityVIPPackReq& from);

  inline ActivityVIPPackReq& operator=(const ActivityVIPPackReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityVIPPackReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityVIPPackReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityVIPPackReq* other);

  // implements Message ----------------------------------------------

  ActivityVIPPackReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityVIPPackReq& from);
  void MergeFrom(const ActivityVIPPackReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityVIPPackReq)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityVIPPackReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityVIPPackResp : public ::google::protobuf::MessageLite {
 public:
  ActivityVIPPackResp();
  virtual ~ActivityVIPPackResp();

  ActivityVIPPackResp(const ActivityVIPPackResp& from);

  inline ActivityVIPPackResp& operator=(const ActivityVIPPackResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityVIPPackResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityVIPPackResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityVIPPackResp* other);

  // implements Message ----------------------------------------------

  ActivityVIPPackResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityVIPPackResp& from);
  void MergeFrom(const ActivityVIPPackResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityVIPPackResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityVIPPackResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityEveryDayReq : public ::google::protobuf::MessageLite {
 public:
  ActivityEveryDayReq();
  virtual ~ActivityEveryDayReq();

  ActivityEveryDayReq(const ActivityEveryDayReq& from);

  inline ActivityEveryDayReq& operator=(const ActivityEveryDayReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityEveryDayReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityEveryDayReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityEveryDayReq* other);

  // implements Message ----------------------------------------------

  ActivityEveryDayReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityEveryDayReq& from);
  void MergeFrom(const ActivityEveryDayReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityEveryDayReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityEveryDayReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityEveryDayResp : public ::google::protobuf::MessageLite {
 public:
  ActivityEveryDayResp();
  virtual ~ActivityEveryDayResp();

  ActivityEveryDayResp(const ActivityEveryDayResp& from);

  inline ActivityEveryDayResp& operator=(const ActivityEveryDayResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityEveryDayResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityEveryDayResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityEveryDayResp* other);

  // implements Message ----------------------------------------------

  ActivityEveryDayResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityEveryDayResp& from);
  void MergeFrom(const ActivityEveryDayResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityEveryDayResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityEveryDayResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityTurntableReq : public ::google::protobuf::MessageLite {
 public:
  ActivityTurntableReq();
  virtual ~ActivityTurntableReq();

  ActivityTurntableReq(const ActivityTurntableReq& from);

  inline ActivityTurntableReq& operator=(const ActivityTurntableReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityTurntableReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityTurntableReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityTurntableReq* other);

  // implements Message ----------------------------------------------

  ActivityTurntableReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityTurntableReq& from);
  void MergeFrom(const ActivityTurntableReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityTurntableReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityTurntableReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityTurntableResp : public ::google::protobuf::MessageLite {
 public:
  ActivityTurntableResp();
  virtual ~ActivityTurntableResp();

  ActivityTurntableResp(const ActivityTurntableResp& from);

  inline ActivityTurntableResp& operator=(const ActivityTurntableResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityTurntableResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityTurntableResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityTurntableResp* other);

  // implements Message ----------------------------------------------

  ActivityTurntableResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityTurntableResp& from);
  void MergeFrom(const ActivityTurntableResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // required int32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // repeated .Pair get_item_list = 4;
  inline int get_item_list_size() const;
  inline void clear_get_item_list();
  static const int kGetItemListFieldNumber = 4;
  inline const ::Pair& get_item_list(int index) const;
  inline ::Pair* mutable_get_item_list(int index);
  inline ::Pair* add_get_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
      get_item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Pair >*
      mutable_get_item_list();

  // @@protoc_insertion_point(class_scope:ActivityTurntableResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();
  inline void set_has_index();
  inline void clear_has_index();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::RepeatedPtrField< ::Pair > get_item_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityTurntableResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityAdvancedMoneyReq : public ::google::protobuf::MessageLite {
 public:
  ActivityAdvancedMoneyReq();
  virtual ~ActivityAdvancedMoneyReq();

  ActivityAdvancedMoneyReq(const ActivityAdvancedMoneyReq& from);

  inline ActivityAdvancedMoneyReq& operator=(const ActivityAdvancedMoneyReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityAdvancedMoneyReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityAdvancedMoneyReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityAdvancedMoneyReq* other);

  // implements Message ----------------------------------------------

  ActivityAdvancedMoneyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityAdvancedMoneyReq& from);
  void MergeFrom(const ActivityAdvancedMoneyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activity_id() const;
  inline void set_activity_id(::google::protobuf::int32 value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityAdvancedMoneyReq)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityAdvancedMoneyReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityAdvancedMoneyResp : public ::google::protobuf::MessageLite {
 public:
  ActivityAdvancedMoneyResp();
  virtual ~ActivityAdvancedMoneyResp();

  ActivityAdvancedMoneyResp(const ActivityAdvancedMoneyResp& from);

  inline ActivityAdvancedMoneyResp& operator=(const ActivityAdvancedMoneyResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityAdvancedMoneyResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityAdvancedMoneyResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityAdvancedMoneyResp* other);

  // implements Message ----------------------------------------------

  ActivityAdvancedMoneyResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityAdvancedMoneyResp& from);
  void MergeFrom(const ActivityAdvancedMoneyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityAdvancedMoneyResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityAdvancedMoneyResp* default_instance_;
};
// -------------------------------------------------------------------

class ActivityExchangeItemReq : public ::google::protobuf::MessageLite {
 public:
  ActivityExchangeItemReq();
  virtual ~ActivityExchangeItemReq();

  ActivityExchangeItemReq(const ActivityExchangeItemReq& from);

  inline ActivityExchangeItemReq& operator=(const ActivityExchangeItemReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityExchangeItemReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityExchangeItemReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityExchangeItemReq* other);

  // implements Message ----------------------------------------------

  ActivityExchangeItemReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityExchangeItemReq& from);
  void MergeFrom(const ActivityExchangeItemReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityExchangeItemReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityExchangeItemReq* default_instance_;
};
// -------------------------------------------------------------------

class ActivityExchangeItemResp : public ::google::protobuf::MessageLite {
 public:
  ActivityExchangeItemResp();
  virtual ~ActivityExchangeItemResp();

  ActivityExchangeItemResp(const ActivityExchangeItemResp& from);

  inline ActivityExchangeItemResp& operator=(const ActivityExchangeItemResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityExchangeItemResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityExchangeItemResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityExchangeItemResp* other);

  // implements Message ----------------------------------------------

  ActivityExchangeItemResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityExchangeItemResp& from);
  void MergeFrom(const ActivityExchangeItemResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .UserSync user_sync = 2;
  inline bool has_user_sync() const;
  inline void clear_user_sync();
  static const int kUserSyncFieldNumber = 2;
  inline const ::UserSync& user_sync() const;
  inline ::UserSync* mutable_user_sync();
  inline ::UserSync* release_user_sync();
  inline void set_allocated_user_sync(::UserSync* user_sync);

  // @@protoc_insertion_point(class_scope:ActivityExchangeItemResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_user_sync();
  inline void clear_has_user_sync();

  ::UserSync* user_sync_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CmdActivity_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CmdActivity_2eproto();
  #endif
  friend void protobuf_AssignDesc_CmdActivity_2eproto();
  friend void protobuf_ShutdownFile_CmdActivity_2eproto();

  void InitAsDefaultInstance();
  static ActivityExchangeItemResp* default_instance_;
};
// ===================================================================


// ===================================================================

// GetActivityListResp

// required int32 result = 1;
inline bool GetActivityListResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetActivityListResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetActivityListResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetActivityListResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GetActivityListResp::result() const {
  return result_;
}
inline void GetActivityListResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool GetActivityListResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetActivityListResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetActivityListResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetActivityListResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& GetActivityListResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* GetActivityListResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* GetActivityListResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void GetActivityListResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// repeated int32 id_list = 3;
inline int GetActivityListResp::id_list_size() const {
  return id_list_.size();
}
inline void GetActivityListResp::clear_id_list() {
  id_list_.Clear();
}
inline ::google::protobuf::int32 GetActivityListResp::id_list(int index) const {
  return id_list_.Get(index);
}
inline void GetActivityListResp::set_id_list(int index, ::google::protobuf::int32 value) {
  id_list_.Set(index, value);
}
inline void GetActivityListResp::add_id_list(::google::protobuf::int32 value) {
  id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GetActivityListResp::id_list() const {
  return id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GetActivityListResp::mutable_id_list() {
  return &id_list_;
}

// -------------------------------------------------------------------

// ActivityChangeReq

// required int32 activity_id = 1;
inline bool ActivityChangeReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityChangeReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityChangeReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityChangeReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityChangeReq::activity_id() const {
  return activity_id_;
}
inline void ActivityChangeReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 change_item_id = 2;
inline bool ActivityChangeReq::has_change_item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityChangeReq::set_has_change_item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityChangeReq::clear_has_change_item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityChangeReq::clear_change_item_id() {
  change_item_id_ = 0;
  clear_has_change_item_id();
}
inline ::google::protobuf::int32 ActivityChangeReq::change_item_id() const {
  return change_item_id_;
}
inline void ActivityChangeReq::set_change_item_id(::google::protobuf::int32 value) {
  set_has_change_item_id();
  change_item_id_ = value;
}

// -------------------------------------------------------------------

// ActivityChangeResp

// required int32 result = 1;
inline bool ActivityChangeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityChangeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityChangeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityChangeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityChangeResp::result() const {
  return result_;
}
inline void ActivityChangeResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityChangeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityChangeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityChangeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityChangeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityChangeResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityChangeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityChangeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityChangeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivitySignInReq

// required int32 activity_id = 1;
inline bool ActivitySignInReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivitySignInReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivitySignInReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivitySignInReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivitySignInReq::activity_id() const {
  return activity_id_;
}
inline void ActivitySignInReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// -------------------------------------------------------------------

// ActivitySignInResp

// required int32 result = 1;
inline bool ActivitySignInResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivitySignInResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivitySignInResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivitySignInResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivitySignInResp::result() const {
  return result_;
}
inline void ActivitySignInResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivitySignInResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivitySignInResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivitySignInResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivitySignInResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivitySignInResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivitySignInResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivitySignInResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivitySignInResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivitySevenDaysReq

// required int32 activity_id = 1;
inline bool ActivitySevenDaysReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivitySevenDaysReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivitySevenDaysReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivitySevenDaysReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivitySevenDaysReq::activity_id() const {
  return activity_id_;
}
inline void ActivitySevenDaysReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 task_id = 2;
inline bool ActivitySevenDaysReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivitySevenDaysReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivitySevenDaysReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivitySevenDaysReq::clear_task_id() {
  task_id_ = 0;
  clear_has_task_id();
}
inline ::google::protobuf::int32 ActivitySevenDaysReq::task_id() const {
  return task_id_;
}
inline void ActivitySevenDaysReq::set_task_id(::google::protobuf::int32 value) {
  set_has_task_id();
  task_id_ = value;
}

// -------------------------------------------------------------------

// ActivitySevenDaysResp

// required int32 result = 1;
inline bool ActivitySevenDaysResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivitySevenDaysResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivitySevenDaysResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivitySevenDaysResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivitySevenDaysResp::result() const {
  return result_;
}
inline void ActivitySevenDaysResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivitySevenDaysResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivitySevenDaysResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivitySevenDaysResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivitySevenDaysResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivitySevenDaysResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivitySevenDaysResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivitySevenDaysResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivitySevenDaysResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityFirstRechargeReq

// required int32 activity_id = 1;
inline bool ActivityFirstRechargeReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityFirstRechargeReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityFirstRechargeReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityFirstRechargeReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityFirstRechargeReq::activity_id() const {
  return activity_id_;
}
inline void ActivityFirstRechargeReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// -------------------------------------------------------------------

// ActivityFirstRechargeResp

// required int32 result = 1;
inline bool ActivityFirstRechargeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityFirstRechargeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityFirstRechargeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityFirstRechargeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityFirstRechargeResp::result() const {
  return result_;
}
inline void ActivityFirstRechargeResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityFirstRechargeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityFirstRechargeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityFirstRechargeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityFirstRechargeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityFirstRechargeResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityFirstRechargeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityFirstRechargeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityFirstRechargeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityRechargeReq

// required int32 activity_id = 1;
inline bool ActivityRechargeReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityRechargeReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityRechargeReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityRechargeReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityRechargeReq::activity_id() const {
  return activity_id_;
}
inline void ActivityRechargeReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 id = 2;
inline bool ActivityRechargeReq::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityRechargeReq::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityRechargeReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityRechargeReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActivityRechargeReq::id() const {
  return id_;
}
inline void ActivityRechargeReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ActivityRechargeResp

// required int32 result = 1;
inline bool ActivityRechargeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityRechargeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityRechargeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityRechargeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityRechargeResp::result() const {
  return result_;
}
inline void ActivityRechargeResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityRechargeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityRechargeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityRechargeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityRechargeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityRechargeResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityRechargeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityRechargeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityRechargeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityConsumeReq

// required int32 activity_id = 1;
inline bool ActivityConsumeReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityConsumeReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityConsumeReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityConsumeReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityConsumeReq::activity_id() const {
  return activity_id_;
}
inline void ActivityConsumeReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 id = 2;
inline bool ActivityConsumeReq::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityConsumeReq::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityConsumeReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityConsumeReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActivityConsumeReq::id() const {
  return id_;
}
inline void ActivityConsumeReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ActivityConsumeResp

// required int32 result = 1;
inline bool ActivityConsumeResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityConsumeResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityConsumeResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityConsumeResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityConsumeResp::result() const {
  return result_;
}
inline void ActivityConsumeResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityConsumeResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityConsumeResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityConsumeResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityConsumeResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityConsumeResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityConsumeResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityConsumeResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityConsumeResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityCreditReturnReq

// required int32 activity_id = 1;
inline bool ActivityCreditReturnReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityCreditReturnReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityCreditReturnReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityCreditReturnReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityCreditReturnReq::activity_id() const {
  return activity_id_;
}
inline void ActivityCreditReturnReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 index = 2;
inline bool ActivityCreditReturnReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityCreditReturnReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityCreditReturnReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityCreditReturnReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 ActivityCreditReturnReq::index() const {
  return index_;
}
inline void ActivityCreditReturnReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// ActivityCreditReturnResp

// required int32 result = 1;
inline bool ActivityCreditReturnResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityCreditReturnResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityCreditReturnResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityCreditReturnResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityCreditReturnResp::result() const {
  return result_;
}
inline void ActivityCreditReturnResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityCreditReturnResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityCreditReturnResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityCreditReturnResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityCreditReturnResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityCreditReturnResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityCreditReturnResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityCreditReturnResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityCreditReturnResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 return_credit = 3;
inline bool ActivityCreditReturnResp::has_return_credit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActivityCreditReturnResp::set_has_return_credit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActivityCreditReturnResp::clear_has_return_credit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActivityCreditReturnResp::clear_return_credit() {
  return_credit_ = 0;
  clear_has_return_credit();
}
inline ::google::protobuf::int32 ActivityCreditReturnResp::return_credit() const {
  return return_credit_;
}
inline void ActivityCreditReturnResp::set_return_credit(::google::protobuf::int32 value) {
  set_has_return_credit();
  return_credit_ = value;
}

// -------------------------------------------------------------------

// ActivityOnlineReq

// required int32 activity_id = 1;
inline bool ActivityOnlineReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityOnlineReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityOnlineReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityOnlineReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityOnlineReq::activity_id() const {
  return activity_id_;
}
inline void ActivityOnlineReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 index = 2;
inline bool ActivityOnlineReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityOnlineReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityOnlineReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityOnlineReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 ActivityOnlineReq::index() const {
  return index_;
}
inline void ActivityOnlineReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// ActivityOnlineResp

// required int32 result = 1;
inline bool ActivityOnlineResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityOnlineResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityOnlineResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityOnlineResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityOnlineResp::result() const {
  return result_;
}
inline void ActivityOnlineResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityOnlineResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityOnlineResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityOnlineResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityOnlineResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityOnlineResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityOnlineResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityOnlineResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityOnlineResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityPowerReq

// required int32 activity_id = 1;
inline bool ActivityPowerReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityPowerReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityPowerReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityPowerReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityPowerReq::activity_id() const {
  return activity_id_;
}
inline void ActivityPowerReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 index = 2;
inline bool ActivityPowerReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityPowerReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityPowerReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityPowerReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 ActivityPowerReq::index() const {
  return index_;
}
inline void ActivityPowerReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// ActivityPowerResp

// required int32 result = 1;
inline bool ActivityPowerResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityPowerResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityPowerResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityPowerResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityPowerResp::result() const {
  return result_;
}
inline void ActivityPowerResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityPowerResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityPowerResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityPowerResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityPowerResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityPowerResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityPowerResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityPowerResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityPowerResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityGrowthFundReq

// required int32 activity_id = 1;
inline bool ActivityGrowthFundReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityGrowthFundReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityGrowthFundReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityGrowthFundReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityGrowthFundReq::activity_id() const {
  return activity_id_;
}
inline void ActivityGrowthFundReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 type = 2;
inline bool ActivityGrowthFundReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityGrowthFundReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityGrowthFundReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityGrowthFundReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ActivityGrowthFundReq::type() const {
  return type_;
}
inline void ActivityGrowthFundReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 index = 3;
inline bool ActivityGrowthFundReq::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActivityGrowthFundReq::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActivityGrowthFundReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActivityGrowthFundReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 ActivityGrowthFundReq::index() const {
  return index_;
}
inline void ActivityGrowthFundReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// ActivityGrowthFundResp

// required int32 result = 1;
inline bool ActivityGrowthFundResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityGrowthFundResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityGrowthFundResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityGrowthFundResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityGrowthFundResp::result() const {
  return result_;
}
inline void ActivityGrowthFundResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityGrowthFundResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityGrowthFundResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityGrowthFundResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityGrowthFundResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityGrowthFundResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityGrowthFundResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityGrowthFundResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityGrowthFundResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityInvestReq

// required int32 activity_id = 1;
inline bool ActivityInvestReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityInvestReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityInvestReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityInvestReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityInvestReq::activity_id() const {
  return activity_id_;
}
inline void ActivityInvestReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 type = 2;
inline bool ActivityInvestReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityInvestReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityInvestReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityInvestReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ActivityInvestReq::type() const {
  return type_;
}
inline void ActivityInvestReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 index = 3;
inline bool ActivityInvestReq::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActivityInvestReq::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActivityInvestReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActivityInvestReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 ActivityInvestReq::index() const {
  return index_;
}
inline void ActivityInvestReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// ActivityInvestResp

// required int32 result = 1;
inline bool ActivityInvestResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityInvestResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityInvestResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityInvestResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityInvestResp::result() const {
  return result_;
}
inline void ActivityInvestResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityInvestResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityInvestResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityInvestResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityInvestResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityInvestResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityInvestResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityInvestResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityInvestResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// optional int32 earning = 3;
inline bool ActivityInvestResp::has_earning() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActivityInvestResp::set_has_earning() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActivityInvestResp::clear_has_earning() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActivityInvestResp::clear_earning() {
  earning_ = 0;
  clear_has_earning();
}
inline ::google::protobuf::int32 ActivityInvestResp::earning() const {
  return earning_;
}
inline void ActivityInvestResp::set_earning(::google::protobuf::int32 value) {
  set_has_earning();
  earning_ = value;
}

// -------------------------------------------------------------------

// ActivityChangeShipReq

// required int32 activity_id = 1;
inline bool ActivityChangeShipReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityChangeShipReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityChangeShipReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityChangeShipReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityChangeShipReq::activity_id() const {
  return activity_id_;
}
inline void ActivityChangeShipReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// -------------------------------------------------------------------

// ActivityChangeShipResp

// required int32 result = 1;
inline bool ActivityChangeShipResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityChangeShipResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityChangeShipResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityChangeShipResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityChangeShipResp::result() const {
  return result_;
}
inline void ActivityChangeShipResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityChangeShipResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityChangeShipResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityChangeShipResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityChangeShipResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityChangeShipResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityChangeShipResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityChangeShipResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityChangeShipResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityMonthSignReq

// required int32 activity_id = 1;
inline bool ActivityMonthSignReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityMonthSignReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityMonthSignReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityMonthSignReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityMonthSignReq::activity_id() const {
  return activity_id_;
}
inline void ActivityMonthSignReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 type = 2;
inline bool ActivityMonthSignReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityMonthSignReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityMonthSignReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityMonthSignReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ActivityMonthSignReq::type() const {
  return type_;
}
inline void ActivityMonthSignReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 index = 3;
inline bool ActivityMonthSignReq::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActivityMonthSignReq::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActivityMonthSignReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActivityMonthSignReq::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 ActivityMonthSignReq::index() const {
  return index_;
}
inline void ActivityMonthSignReq::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// ActivityMonthSignResp

// required int32 result = 1;
inline bool ActivityMonthSignResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityMonthSignResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityMonthSignResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityMonthSignResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityMonthSignResp::result() const {
  return result_;
}
inline void ActivityMonthSignResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityMonthSignResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityMonthSignResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityMonthSignResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityMonthSignResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityMonthSignResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityMonthSignResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityMonthSignResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityMonthSignResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityVIPPackReq

// required int32 level = 1;
inline bool ActivityVIPPackReq::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityVIPPackReq::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityVIPPackReq::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityVIPPackReq::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ActivityVIPPackReq::level() const {
  return level_;
}
inline void ActivityVIPPackReq::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 type = 2;
inline bool ActivityVIPPackReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityVIPPackReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityVIPPackReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityVIPPackReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ActivityVIPPackReq::type() const {
  return type_;
}
inline void ActivityVIPPackReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ActivityVIPPackResp

// required int32 result = 1;
inline bool ActivityVIPPackResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityVIPPackResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityVIPPackResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityVIPPackResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityVIPPackResp::result() const {
  return result_;
}
inline void ActivityVIPPackResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityVIPPackResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityVIPPackResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityVIPPackResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityVIPPackResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityVIPPackResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityVIPPackResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityVIPPackResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityVIPPackResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityEveryDayReq

// required int32 activity_id = 1;
inline bool ActivityEveryDayReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityEveryDayReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityEveryDayReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityEveryDayReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityEveryDayReq::activity_id() const {
  return activity_id_;
}
inline void ActivityEveryDayReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 id = 2;
inline bool ActivityEveryDayReq::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityEveryDayReq::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityEveryDayReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityEveryDayReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActivityEveryDayReq::id() const {
  return id_;
}
inline void ActivityEveryDayReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ActivityEveryDayResp

// required int32 result = 1;
inline bool ActivityEveryDayResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityEveryDayResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityEveryDayResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityEveryDayResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityEveryDayResp::result() const {
  return result_;
}
inline void ActivityEveryDayResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityEveryDayResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityEveryDayResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityEveryDayResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityEveryDayResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityEveryDayResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityEveryDayResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityEveryDayResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityEveryDayResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityTurntableReq

// required int32 activity_id = 1;
inline bool ActivityTurntableReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityTurntableReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityTurntableReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityTurntableReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityTurntableReq::activity_id() const {
  return activity_id_;
}
inline void ActivityTurntableReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// optional int32 id = 2;
inline bool ActivityTurntableReq::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityTurntableReq::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityTurntableReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityTurntableReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActivityTurntableReq::id() const {
  return id_;
}
inline void ActivityTurntableReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ActivityTurntableResp

// required int32 result = 1;
inline bool ActivityTurntableResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityTurntableResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityTurntableResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityTurntableResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityTurntableResp::result() const {
  return result_;
}
inline void ActivityTurntableResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityTurntableResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityTurntableResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityTurntableResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityTurntableResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityTurntableResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityTurntableResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityTurntableResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityTurntableResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// required int32 index = 3;
inline bool ActivityTurntableResp::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActivityTurntableResp::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActivityTurntableResp::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActivityTurntableResp::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 ActivityTurntableResp::index() const {
  return index_;
}
inline void ActivityTurntableResp::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// repeated .Pair get_item_list = 4;
inline int ActivityTurntableResp::get_item_list_size() const {
  return get_item_list_.size();
}
inline void ActivityTurntableResp::clear_get_item_list() {
  get_item_list_.Clear();
}
inline const ::Pair& ActivityTurntableResp::get_item_list(int index) const {
  return get_item_list_.Get(index);
}
inline ::Pair* ActivityTurntableResp::mutable_get_item_list(int index) {
  return get_item_list_.Mutable(index);
}
inline ::Pair* ActivityTurntableResp::add_get_item_list() {
  return get_item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
ActivityTurntableResp::get_item_list() const {
  return get_item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Pair >*
ActivityTurntableResp::mutable_get_item_list() {
  return &get_item_list_;
}

// -------------------------------------------------------------------

// ActivityAdvancedMoneyReq

// required int32 activity_id = 1;
inline bool ActivityAdvancedMoneyReq::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityAdvancedMoneyReq::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityAdvancedMoneyReq::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityAdvancedMoneyReq::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 ActivityAdvancedMoneyReq::activity_id() const {
  return activity_id_;
}
inline void ActivityAdvancedMoneyReq::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// required int32 id = 2;
inline bool ActivityAdvancedMoneyReq::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityAdvancedMoneyReq::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityAdvancedMoneyReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityAdvancedMoneyReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActivityAdvancedMoneyReq::id() const {
  return id_;
}
inline void ActivityAdvancedMoneyReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ActivityAdvancedMoneyResp

// required int32 result = 1;
inline bool ActivityAdvancedMoneyResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityAdvancedMoneyResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityAdvancedMoneyResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityAdvancedMoneyResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityAdvancedMoneyResp::result() const {
  return result_;
}
inline void ActivityAdvancedMoneyResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityAdvancedMoneyResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityAdvancedMoneyResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityAdvancedMoneyResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityAdvancedMoneyResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityAdvancedMoneyResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityAdvancedMoneyResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityAdvancedMoneyResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityAdvancedMoneyResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}

// -------------------------------------------------------------------

// ActivityExchangeItemReq

// required int32 id = 1;
inline bool ActivityExchangeItemReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityExchangeItemReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityExchangeItemReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityExchangeItemReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActivityExchangeItemReq::id() const {
  return id_;
}
inline void ActivityExchangeItemReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ActivityExchangeItemResp

// required int32 result = 1;
inline bool ActivityExchangeItemResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityExchangeItemResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityExchangeItemResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityExchangeItemResp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActivityExchangeItemResp::result() const {
  return result_;
}
inline void ActivityExchangeItemResp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .UserSync user_sync = 2;
inline bool ActivityExchangeItemResp::has_user_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityExchangeItemResp::set_has_user_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityExchangeItemResp::clear_has_user_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityExchangeItemResp::clear_user_sync() {
  if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
  clear_has_user_sync();
}
inline const ::UserSync& ActivityExchangeItemResp::user_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_sync_ != NULL ? *user_sync_ : *default_instance().user_sync_;
#else
  return user_sync_ != NULL ? *user_sync_ : *default_instance_->user_sync_;
#endif
}
inline ::UserSync* ActivityExchangeItemResp::mutable_user_sync() {
  set_has_user_sync();
  if (user_sync_ == NULL) user_sync_ = new ::UserSync;
  return user_sync_;
}
inline ::UserSync* ActivityExchangeItemResp::release_user_sync() {
  clear_has_user_sync();
  ::UserSync* temp = user_sync_;
  user_sync_ = NULL;
  return temp;
}
inline void ActivityExchangeItemResp::set_allocated_user_sync(::UserSync* user_sync) {
  delete user_sync_;
  user_sync_ = user_sync;
  if (user_sync) {
    set_has_user_sync();
  } else {
    clear_has_user_sync();
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CmdActivity_2eproto__INCLUDED
