// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CmdUser.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CmdUser.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_CmdUser_2eproto() {
  delete AddMoneyCallBack::default_instance_;
  delete UpdateTimeStampResp::default_instance_;
  delete UpdateResReq::default_instance_;
  delete UpdateResResp::default_instance_;
  delete ChatLog::default_instance_;
  delete ChatLogList::default_instance_;
  delete GetChatLogReq::default_instance_;
  delete GetChatLogResp::default_instance_;
  delete ChatUserInfo::default_instance_;
  delete ChatReq::default_instance_;
  delete ChatResp::default_instance_;
  delete ChatMsg_t::default_instance_;
  delete ChatMsg::default_instance_;
  delete CmdClientGMReq::default_instance_;
  delete CmdClientGMResp::default_instance_;
  delete CmdGetOtherUserInfoReq::default_instance_;
  delete CmdGetOtherUserInfoResp::default_instance_;
  delete CmdGetOtherUserInfoListReq::default_instance_;
  delete CmdGetOtherUserInfoListResp::default_instance_;
  delete NewFriendUpdate::default_instance_;
  delete BeFriendUpdate::default_instance_;
  delete GetFriendsInfoReq::default_instance_;
  delete GetFriendsInfoResp::default_instance_;
  delete ApplyFriendReq::default_instance_;
  delete ApplyFriendResp::default_instance_;
  delete AcceptFriendReq::default_instance_;
  delete AcceptFriendResp::default_instance_;
  delete RemoveFriendReq::default_instance_;
  delete RemoveFriendResp::default_instance_;
  delete FriendAddTiliReq::default_instance_;
  delete FriendAddTiliResp::default_instance_;
  delete FriendAddTiliUpdate::default_instance_;
  delete FriendReadTiliReq::default_instance_;
  delete FriendReadTiliResp::default_instance_;
  delete BlackListReq::default_instance_;
  delete BlackListResp::default_instance_;
  delete TalkListReq::default_instance_;
  delete TalkListResp::default_instance_;
  delete TaskListResp::default_instance_;
  delete TaskRewardReq::default_instance_;
  delete TaskRewardResp::default_instance_;
  delete GetStrengthResp::default_instance_;
  delete AddStrengthReq::default_instance_;
  delete AddStrengthResp::default_instance_;
  delete RankReq::default_instance_;
  delete RankResp::default_instance_;
  delete ShopTimeItemListResp::default_instance_;
  delete ShopTimeItemListResp_TimeItem::default_instance_;
  delete ShopBuyReq::default_instance_;
  delete ShopBuyResp::default_instance_;
  delete ShipLotteryReq::default_instance_;
  delete ShipLotteryResp::default_instance_;
  delete IsOnlineReq::default_instance_;
  delete IsOnlineResp::default_instance_;
  delete GuideStepReq::default_instance_;
  delete GuideStepResp::default_instance_;
  delete AidAwardReq::default_instance_;
  delete AidAwardResp::default_instance_;
  delete OpenGiftReq::default_instance_;
  delete OpenGiftResp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_CmdUser_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_CmdUser_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_OtherInfo_2eproto();
  ::protobuf_AddDesc_UserInfo_2eproto();
  ::protobuf_AddDesc_UserSync_2eproto();
  ::protobuf_AddDesc_Item_2eproto();
  AddMoneyCallBack::default_instance_ = new AddMoneyCallBack();
  UpdateTimeStampResp::default_instance_ = new UpdateTimeStampResp();
  UpdateResReq::default_instance_ = new UpdateResReq();
  UpdateResResp::default_instance_ = new UpdateResResp();
  ChatLog::default_instance_ = new ChatLog();
  ChatLogList::default_instance_ = new ChatLogList();
  GetChatLogReq::default_instance_ = new GetChatLogReq();
  GetChatLogResp::default_instance_ = new GetChatLogResp();
  ChatUserInfo::default_instance_ = new ChatUserInfo();
  ChatReq::default_instance_ = new ChatReq();
  ChatResp::default_instance_ = new ChatResp();
  ChatMsg_t::default_instance_ = new ChatMsg_t();
  ChatMsg::default_instance_ = new ChatMsg();
  CmdClientGMReq::default_instance_ = new CmdClientGMReq();
  CmdClientGMResp::default_instance_ = new CmdClientGMResp();
  CmdGetOtherUserInfoReq::default_instance_ = new CmdGetOtherUserInfoReq();
  CmdGetOtherUserInfoResp::default_instance_ = new CmdGetOtherUserInfoResp();
  CmdGetOtherUserInfoListReq::default_instance_ = new CmdGetOtherUserInfoListReq();
  CmdGetOtherUserInfoListResp::default_instance_ = new CmdGetOtherUserInfoListResp();
  NewFriendUpdate::default_instance_ = new NewFriendUpdate();
  BeFriendUpdate::default_instance_ = new BeFriendUpdate();
  GetFriendsInfoReq::default_instance_ = new GetFriendsInfoReq();
  GetFriendsInfoResp::default_instance_ = new GetFriendsInfoResp();
  ApplyFriendReq::default_instance_ = new ApplyFriendReq();
  ApplyFriendResp::default_instance_ = new ApplyFriendResp();
  AcceptFriendReq::default_instance_ = new AcceptFriendReq();
  AcceptFriendResp::default_instance_ = new AcceptFriendResp();
  RemoveFriendReq::default_instance_ = new RemoveFriendReq();
  RemoveFriendResp::default_instance_ = new RemoveFriendResp();
  FriendAddTiliReq::default_instance_ = new FriendAddTiliReq();
  FriendAddTiliResp::default_instance_ = new FriendAddTiliResp();
  FriendAddTiliUpdate::default_instance_ = new FriendAddTiliUpdate();
  FriendReadTiliReq::default_instance_ = new FriendReadTiliReq();
  FriendReadTiliResp::default_instance_ = new FriendReadTiliResp();
  BlackListReq::default_instance_ = new BlackListReq();
  BlackListResp::default_instance_ = new BlackListResp();
  TalkListReq::default_instance_ = new TalkListReq();
  TalkListResp::default_instance_ = new TalkListResp();
  TaskListResp::default_instance_ = new TaskListResp();
  TaskRewardReq::default_instance_ = new TaskRewardReq();
  TaskRewardResp::default_instance_ = new TaskRewardResp();
  GetStrengthResp::default_instance_ = new GetStrengthResp();
  AddStrengthReq::default_instance_ = new AddStrengthReq();
  AddStrengthResp::default_instance_ = new AddStrengthResp();
  RankReq::default_instance_ = new RankReq();
  RankResp::default_instance_ = new RankResp();
  ShopTimeItemListResp::default_instance_ = new ShopTimeItemListResp();
  ShopTimeItemListResp_TimeItem::default_instance_ = new ShopTimeItemListResp_TimeItem();
  ShopBuyReq::default_instance_ = new ShopBuyReq();
  ShopBuyResp::default_instance_ = new ShopBuyResp();
  ShipLotteryReq::default_instance_ = new ShipLotteryReq();
  ShipLotteryResp::default_instance_ = new ShipLotteryResp();
  IsOnlineReq::default_instance_ = new IsOnlineReq();
  IsOnlineResp::default_instance_ = new IsOnlineResp();
  GuideStepReq::default_instance_ = new GuideStepReq();
  GuideStepResp::default_instance_ = new GuideStepResp();
  AidAwardReq::default_instance_ = new AidAwardReq();
  AidAwardResp::default_instance_ = new AidAwardResp();
  OpenGiftReq::default_instance_ = new OpenGiftReq();
  OpenGiftResp::default_instance_ = new OpenGiftResp();
  AddMoneyCallBack::default_instance_->InitAsDefaultInstance();
  UpdateTimeStampResp::default_instance_->InitAsDefaultInstance();
  UpdateResReq::default_instance_->InitAsDefaultInstance();
  UpdateResResp::default_instance_->InitAsDefaultInstance();
  ChatLog::default_instance_->InitAsDefaultInstance();
  ChatLogList::default_instance_->InitAsDefaultInstance();
  GetChatLogReq::default_instance_->InitAsDefaultInstance();
  GetChatLogResp::default_instance_->InitAsDefaultInstance();
  ChatUserInfo::default_instance_->InitAsDefaultInstance();
  ChatReq::default_instance_->InitAsDefaultInstance();
  ChatResp::default_instance_->InitAsDefaultInstance();
  ChatMsg_t::default_instance_->InitAsDefaultInstance();
  ChatMsg::default_instance_->InitAsDefaultInstance();
  CmdClientGMReq::default_instance_->InitAsDefaultInstance();
  CmdClientGMResp::default_instance_->InitAsDefaultInstance();
  CmdGetOtherUserInfoReq::default_instance_->InitAsDefaultInstance();
  CmdGetOtherUserInfoResp::default_instance_->InitAsDefaultInstance();
  CmdGetOtherUserInfoListReq::default_instance_->InitAsDefaultInstance();
  CmdGetOtherUserInfoListResp::default_instance_->InitAsDefaultInstance();
  NewFriendUpdate::default_instance_->InitAsDefaultInstance();
  BeFriendUpdate::default_instance_->InitAsDefaultInstance();
  GetFriendsInfoReq::default_instance_->InitAsDefaultInstance();
  GetFriendsInfoResp::default_instance_->InitAsDefaultInstance();
  ApplyFriendReq::default_instance_->InitAsDefaultInstance();
  ApplyFriendResp::default_instance_->InitAsDefaultInstance();
  AcceptFriendReq::default_instance_->InitAsDefaultInstance();
  AcceptFriendResp::default_instance_->InitAsDefaultInstance();
  RemoveFriendReq::default_instance_->InitAsDefaultInstance();
  RemoveFriendResp::default_instance_->InitAsDefaultInstance();
  FriendAddTiliReq::default_instance_->InitAsDefaultInstance();
  FriendAddTiliResp::default_instance_->InitAsDefaultInstance();
  FriendAddTiliUpdate::default_instance_->InitAsDefaultInstance();
  FriendReadTiliReq::default_instance_->InitAsDefaultInstance();
  FriendReadTiliResp::default_instance_->InitAsDefaultInstance();
  BlackListReq::default_instance_->InitAsDefaultInstance();
  BlackListResp::default_instance_->InitAsDefaultInstance();
  TalkListReq::default_instance_->InitAsDefaultInstance();
  TalkListResp::default_instance_->InitAsDefaultInstance();
  TaskListResp::default_instance_->InitAsDefaultInstance();
  TaskRewardReq::default_instance_->InitAsDefaultInstance();
  TaskRewardResp::default_instance_->InitAsDefaultInstance();
  GetStrengthResp::default_instance_->InitAsDefaultInstance();
  AddStrengthReq::default_instance_->InitAsDefaultInstance();
  AddStrengthResp::default_instance_->InitAsDefaultInstance();
  RankReq::default_instance_->InitAsDefaultInstance();
  RankResp::default_instance_->InitAsDefaultInstance();
  ShopTimeItemListResp::default_instance_->InitAsDefaultInstance();
  ShopTimeItemListResp_TimeItem::default_instance_->InitAsDefaultInstance();
  ShopBuyReq::default_instance_->InitAsDefaultInstance();
  ShopBuyResp::default_instance_->InitAsDefaultInstance();
  ShipLotteryReq::default_instance_->InitAsDefaultInstance();
  ShipLotteryResp::default_instance_->InitAsDefaultInstance();
  IsOnlineReq::default_instance_->InitAsDefaultInstance();
  IsOnlineResp::default_instance_->InitAsDefaultInstance();
  GuideStepReq::default_instance_->InitAsDefaultInstance();
  GuideStepResp::default_instance_->InitAsDefaultInstance();
  AidAwardReq::default_instance_->InitAsDefaultInstance();
  AidAwardResp::default_instance_->InitAsDefaultInstance();
  OpenGiftReq::default_instance_->InitAsDefaultInstance();
  OpenGiftResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CmdUser_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_CmdUser_2eproto_once_);
void protobuf_AddDesc_CmdUser_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_CmdUser_2eproto_once_,
                 &protobuf_AddDesc_CmdUser_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CmdUser_2eproto {
  StaticDescriptorInitializer_CmdUser_2eproto() {
    protobuf_AddDesc_CmdUser_2eproto();
  }
} static_descriptor_initializer_CmdUser_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int AddMoneyCallBack::kSidFieldNumber;
const int AddMoneyCallBack::kOrdernoFieldNumber;
const int AddMoneyCallBack::kAmountFieldNumber;
const int AddMoneyCallBack::kCurMoneyFieldNumber;
const int AddMoneyCallBack::kCurVipFieldNumber;
const int AddMoneyCallBack::kTotalMoneyFieldNumber;
const int AddMoneyCallBack::kItemIdFieldNumber;
const int AddMoneyCallBack::kBuqianFieldNumber;
const int AddMoneyCallBack::kZsykFieldNumber;
const int AddMoneyCallBack::kNewItemIdFieldNumber;
#endif  // !_MSC_VER

AddMoneyCallBack::AddMoneyCallBack()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddMoneyCallBack::InitAsDefaultInstance() {
}

AddMoneyCallBack::AddMoneyCallBack(const AddMoneyCallBack& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddMoneyCallBack::SharedCtor() {
  _cached_size_ = 0;
  sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  orderno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  amount_ = 0;
  cur_money_ = 0;
  cur_vip_ = 0;
  total_money_ = 0;
  item_id_ = 0;
  buqian_ = 0;
  zsyk_ = 0;
  new_item_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddMoneyCallBack::~AddMoneyCallBack() {
  SharedDtor();
}

void AddMoneyCallBack::SharedDtor() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (orderno_ != &::google::protobuf::internal::kEmptyString) {
    delete orderno_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AddMoneyCallBack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddMoneyCallBack& AddMoneyCallBack::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

AddMoneyCallBack* AddMoneyCallBack::default_instance_ = NULL;

AddMoneyCallBack* AddMoneyCallBack::New() const {
  return new AddMoneyCallBack;
}

void AddMoneyCallBack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_sid()) {
      if (sid_ != &::google::protobuf::internal::kEmptyString) {
        sid_->clear();
      }
    }
    if (has_orderno()) {
      if (orderno_ != &::google::protobuf::internal::kEmptyString) {
        orderno_->clear();
      }
    }
    amount_ = 0;
    cur_money_ = 0;
    cur_vip_ = 0;
    total_money_ = 0;
    item_id_ = 0;
    buqian_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    zsyk_ = 0;
    new_item_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddMoneyCallBack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string sid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_orderno;
        break;
      }

      // required string orderno = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_orderno:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_orderno()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_amount;
        break;
      }

      // required int32 amount = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_cur_money;
        break;
      }

      // required int32 cur_money = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cur_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cur_money_)));
          set_has_cur_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_cur_vip;
        break;
      }

      // required int32 cur_vip = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cur_vip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cur_vip_)));
          set_has_cur_vip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_total_money;
        break;
      }

      // required int32 total_money = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_total_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_money_)));
          set_has_total_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_item_id;
        break;
      }

      // required int32 item_id = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_buqian;
        break;
      }

      // required int32 buqian = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_buqian:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &buqian_)));
          set_has_buqian();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_zsyk;
        break;
      }

      // optional int32 zsyk = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_zsyk:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zsyk_)));
          set_has_zsyk();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_new_item_id;
        break;
      }

      // optional int32 new_item_id = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_new_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &new_item_id_)));
          set_has_new_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddMoneyCallBack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string sid = 1;
  if (has_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->sid(), output);
  }

  // required string orderno = 2;
  if (has_orderno()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->orderno(), output);
  }

  // required int32 amount = 3;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->amount(), output);
  }

  // required int32 cur_money = 4;
  if (has_cur_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->cur_money(), output);
  }

  // required int32 cur_vip = 5;
  if (has_cur_vip()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->cur_vip(), output);
  }

  // required int32 total_money = 6;
  if (has_total_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->total_money(), output);
  }

  // required int32 item_id = 7;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->item_id(), output);
  }

  // required int32 buqian = 8;
  if (has_buqian()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->buqian(), output);
  }

  // optional int32 zsyk = 10;
  if (has_zsyk()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->zsyk(), output);
  }

  // optional int32 new_item_id = 11;
  if (has_new_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->new_item_id(), output);
  }

}

int AddMoneyCallBack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string sid = 1;
    if (has_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sid());
    }

    // required string orderno = 2;
    if (has_orderno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->orderno());
    }

    // required int32 amount = 3;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->amount());
    }

    // required int32 cur_money = 4;
    if (has_cur_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cur_money());
    }

    // required int32 cur_vip = 5;
    if (has_cur_vip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cur_vip());
    }

    // required int32 total_money = 6;
    if (has_total_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->total_money());
    }

    // required int32 item_id = 7;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->item_id());
    }

    // required int32 buqian = 8;
    if (has_buqian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->buqian());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 zsyk = 10;
    if (has_zsyk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zsyk());
    }

    // optional int32 new_item_id = 11;
    if (has_new_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->new_item_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddMoneyCallBack::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddMoneyCallBack*>(&from));
}

void AddMoneyCallBack::MergeFrom(const AddMoneyCallBack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sid()) {
      set_sid(from.sid());
    }
    if (from.has_orderno()) {
      set_orderno(from.orderno());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_cur_money()) {
      set_cur_money(from.cur_money());
    }
    if (from.has_cur_vip()) {
      set_cur_vip(from.cur_vip());
    }
    if (from.has_total_money()) {
      set_total_money(from.total_money());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_buqian()) {
      set_buqian(from.buqian());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_zsyk()) {
      set_zsyk(from.zsyk());
    }
    if (from.has_new_item_id()) {
      set_new_item_id(from.new_item_id());
    }
  }
}

void AddMoneyCallBack::CopyFrom(const AddMoneyCallBack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddMoneyCallBack::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  return true;
}

void AddMoneyCallBack::Swap(AddMoneyCallBack* other) {
  if (other != this) {
    std::swap(sid_, other->sid_);
    std::swap(orderno_, other->orderno_);
    std::swap(amount_, other->amount_);
    std::swap(cur_money_, other->cur_money_);
    std::swap(cur_vip_, other->cur_vip_);
    std::swap(total_money_, other->total_money_);
    std::swap(item_id_, other->item_id_);
    std::swap(buqian_, other->buqian_);
    std::swap(zsyk_, other->zsyk_);
    std::swap(new_item_id_, other->new_item_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddMoneyCallBack::GetTypeName() const {
  return "AddMoneyCallBack";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateTimeStampResp::kResultFieldNumber;
const int UpdateTimeStampResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

UpdateTimeStampResp::UpdateTimeStampResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateTimeStampResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

UpdateTimeStampResp::UpdateTimeStampResp(const UpdateTimeStampResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateTimeStampResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateTimeStampResp::~UpdateTimeStampResp() {
  SharedDtor();
}

void UpdateTimeStampResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void UpdateTimeStampResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateTimeStampResp& UpdateTimeStampResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

UpdateTimeStampResp* UpdateTimeStampResp::default_instance_ = NULL;

UpdateTimeStampResp* UpdateTimeStampResp::New() const {
  return new UpdateTimeStampResp;
}

void UpdateTimeStampResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateTimeStampResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateTimeStampResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int UpdateTimeStampResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateTimeStampResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateTimeStampResp*>(&from));
}

void UpdateTimeStampResp::MergeFrom(const UpdateTimeStampResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void UpdateTimeStampResp::CopyFrom(const UpdateTimeStampResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateTimeStampResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void UpdateTimeStampResp::Swap(UpdateTimeStampResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateTimeStampResp::GetTypeName() const {
  return "UpdateTimeStampResp";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateResReq::kTypeFieldNumber;
#endif  // !_MSC_VER

UpdateResReq::UpdateResReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateResReq::InitAsDefaultInstance() {
}

UpdateResReq::UpdateResReq(const UpdateResReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateResReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateResReq::~UpdateResReq() {
  SharedDtor();
}

void UpdateResReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpdateResReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateResReq& UpdateResReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

UpdateResReq* UpdateResReq::default_instance_ = NULL;

UpdateResReq* UpdateResReq::New() const {
  return new UpdateResReq;
}

void UpdateResReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateResReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateResReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

}

int UpdateResReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateResReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateResReq*>(&from));
}

void UpdateResReq::MergeFrom(const UpdateResReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void UpdateResReq::CopyFrom(const UpdateResReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateResReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UpdateResReq::Swap(UpdateResReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateResReq::GetTypeName() const {
  return "UpdateResReq";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateResResp::kResultFieldNumber;
const int UpdateResResp::kUserSyncFieldNumber;
const int UpdateResResp::kCreditFieldNumber;
#endif  // !_MSC_VER

UpdateResResp::UpdateResResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateResResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

UpdateResResp::UpdateResResp(const UpdateResResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateResResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  credit_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateResResp::~UpdateResResp() {
  SharedDtor();
}

void UpdateResResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void UpdateResResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateResResp& UpdateResResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

UpdateResResp* UpdateResResp::default_instance_ = NULL;

UpdateResResp* UpdateResResp::New() const {
  return new UpdateResResp;
}

void UpdateResResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    credit_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateResResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_credit;
        break;
      }

      // optional int64 credit = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_credit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &credit_)));
          set_has_credit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateResResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional int64 credit = 3;
  if (has_credit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->credit(), output);
  }

}

int UpdateResResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int64 credit = 3;
    if (has_credit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->credit());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateResResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateResResp*>(&from));
}

void UpdateResResp::MergeFrom(const UpdateResResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_credit()) {
      set_credit(from.credit());
    }
  }
}

void UpdateResResp::CopyFrom(const UpdateResResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateResResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void UpdateResResp::Swap(UpdateResResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(credit_, other->credit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateResResp::GetTypeName() const {
  return "UpdateResResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ChatLog::kStampFieldNumber;
const int ChatLog::kChatFieldNumber;
const int ChatLog::kNicknameFieldNumber;
const int ChatLog::kGroupNameFieldNumber;
const int ChatLog::kUserNameFieldNumber;
#endif  // !_MSC_VER

ChatLog::ChatLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChatLog::InitAsDefaultInstance() {
}

ChatLog::ChatLog(const ChatLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChatLog::SharedCtor() {
  _cached_size_ = 0;
  stamp_ = 0;
  chat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChatLog::~ChatLog() {
  SharedDtor();
}

void ChatLog::SharedDtor() {
  if (chat_ != &::google::protobuf::internal::kEmptyString) {
    delete chat_;
  }
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChatLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChatLog& ChatLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ChatLog* ChatLog::default_instance_ = NULL;

ChatLog* ChatLog::New() const {
  return new ChatLog;
}

void ChatLog::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    stamp_ = 0;
    if (has_chat()) {
      if (chat_ != &::google::protobuf::internal::kEmptyString) {
        chat_->clear();
      }
    }
    if (has_nickname()) {
      if (nickname_ != &::google::protobuf::internal::kEmptyString) {
        nickname_->clear();
      }
    }
    if (has_group_name()) {
      if (group_name_ != &::google::protobuf::internal::kEmptyString) {
        group_name_->clear();
      }
    }
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChatLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 stamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stamp_)));
          set_has_stamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_chat;
        break;
      }

      // required string chat = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_chat()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_nickname;
        break;
      }

      // required string nickname = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nickname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nickname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_group_name;
        break;
      }

      // optional string group_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_user_name;
        break;
      }

      // required string user_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChatLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 stamp = 1;
  if (has_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->stamp(), output);
  }

  // required string chat = 2;
  if (has_chat()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->chat(), output);
  }

  // required string nickname = 3;
  if (has_nickname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->nickname(), output);
  }

  // optional string group_name = 4;
  if (has_group_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->group_name(), output);
  }

  // required string user_name = 5;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->user_name(), output);
  }

}

int ChatLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 stamp = 1;
    if (has_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->stamp());
    }

    // required string chat = 2;
    if (has_chat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->chat());
    }

    // required string nickname = 3;
    if (has_nickname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nickname());
    }

    // optional string group_name = 4;
    if (has_group_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_name());
    }

    // required string user_name = 5;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChatLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChatLog*>(&from));
}

void ChatLog::MergeFrom(const ChatLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stamp()) {
      set_stamp(from.stamp());
    }
    if (from.has_chat()) {
      set_chat(from.chat());
    }
    if (from.has_nickname()) {
      set_nickname(from.nickname());
    }
    if (from.has_group_name()) {
      set_group_name(from.group_name());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
  }
}

void ChatLog::CopyFrom(const ChatLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000017) != 0x00000017) return false;

  return true;
}

void ChatLog::Swap(ChatLog* other) {
  if (other != this) {
    std::swap(stamp_, other->stamp_);
    std::swap(chat_, other->chat_);
    std::swap(nickname_, other->nickname_);
    std::swap(group_name_, other->group_name_);
    std::swap(user_name_, other->user_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChatLog::GetTypeName() const {
  return "ChatLog";
}


// ===================================================================

#ifndef _MSC_VER
const int ChatLogList::kLogListFieldNumber;
#endif  // !_MSC_VER

ChatLogList::ChatLogList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChatLogList::InitAsDefaultInstance() {
}

ChatLogList::ChatLogList(const ChatLogList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChatLogList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChatLogList::~ChatLogList() {
  SharedDtor();
}

void ChatLogList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChatLogList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChatLogList& ChatLogList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ChatLogList* ChatLogList::default_instance_ = NULL;

ChatLogList* ChatLogList::New() const {
  return new ChatLogList;
}

void ChatLogList::Clear() {
  log_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChatLogList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ChatLog log_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_log_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_log_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_log_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChatLogList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ChatLog log_list = 1;
  for (int i = 0; i < this->log_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->log_list(i), output);
  }

}

int ChatLogList::ByteSize() const {
  int total_size = 0;

  // repeated .ChatLog log_list = 1;
  total_size += 1 * this->log_list_size();
  for (int i = 0; i < this->log_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->log_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChatLogList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChatLogList*>(&from));
}

void ChatLogList::MergeFrom(const ChatLogList& from) {
  GOOGLE_CHECK_NE(&from, this);
  log_list_.MergeFrom(from.log_list_);
}

void ChatLogList::CopyFrom(const ChatLogList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatLogList::IsInitialized() const {

  for (int i = 0; i < log_list_size(); i++) {
    if (!this->log_list(i).IsInitialized()) return false;
  }
  return true;
}

void ChatLogList::Swap(ChatLogList* other) {
  if (other != this) {
    log_list_.Swap(&other->log_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChatLogList::GetTypeName() const {
  return "ChatLogList";
}


// ===================================================================

#ifndef _MSC_VER
const int GetChatLogReq::kChatIdFieldNumber;
const int GetChatLogReq::kMinorFieldNumber;
#endif  // !_MSC_VER

GetChatLogReq::GetChatLogReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetChatLogReq::InitAsDefaultInstance() {
}

GetChatLogReq::GetChatLogReq(const GetChatLogReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetChatLogReq::SharedCtor() {
  _cached_size_ = 0;
  chat_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetChatLogReq::~GetChatLogReq() {
  SharedDtor();
}

void GetChatLogReq::SharedDtor() {
  if (chat_id_ != &::google::protobuf::internal::kEmptyString) {
    delete chat_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetChatLogReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetChatLogReq& GetChatLogReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

GetChatLogReq* GetChatLogReq::default_instance_ = NULL;

GetChatLogReq* GetChatLogReq::New() const {
  return new GetChatLogReq;
}

void GetChatLogReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_chat_id()) {
      if (chat_id_ != &::google::protobuf::internal::kEmptyString) {
        chat_id_->clear();
      }
    }
  }
  minor_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetChatLogReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string chat_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_chat_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_minor;
        break;
      }

      // repeated int32 minor = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_minor())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_minor())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_minor;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetChatLogReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string chat_id = 1;
  if (has_chat_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->chat_id(), output);
  }

  // repeated int32 minor = 2;
  for (int i = 0; i < this->minor_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->minor(i), output);
  }

}

int GetChatLogReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string chat_id = 1;
    if (has_chat_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->chat_id());
    }

  }
  // repeated int32 minor = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->minor_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->minor(i));
    }
    total_size += 1 * this->minor_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetChatLogReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetChatLogReq*>(&from));
}

void GetChatLogReq::MergeFrom(const GetChatLogReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  minor_.MergeFrom(from.minor_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chat_id()) {
      set_chat_id(from.chat_id());
    }
  }
}

void GetChatLogReq::CopyFrom(const GetChatLogReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetChatLogReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetChatLogReq::Swap(GetChatLogReq* other) {
  if (other != this) {
    std::swap(chat_id_, other->chat_id_);
    minor_.Swap(&other->minor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetChatLogReq::GetTypeName() const {
  return "GetChatLogReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetChatLogResp::kResultFieldNumber;
const int GetChatLogResp::kUserSyncFieldNumber;
const int GetChatLogResp::kLogListFieldNumber;
#endif  // !_MSC_VER

GetChatLogResp::GetChatLogResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetChatLogResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GetChatLogResp::GetChatLogResp(const GetChatLogResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetChatLogResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetChatLogResp::~GetChatLogResp() {
  SharedDtor();
}

void GetChatLogResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GetChatLogResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetChatLogResp& GetChatLogResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

GetChatLogResp* GetChatLogResp::default_instance_ = NULL;

GetChatLogResp* GetChatLogResp::New() const {
  return new GetChatLogResp;
}

void GetChatLogResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  log_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetChatLogResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_log_list;
        break;
      }

      // repeated .ChatLog log_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_log_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_log_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_log_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetChatLogResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .ChatLog log_list = 3;
  for (int i = 0; i < this->log_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->log_list(i), output);
  }

}

int GetChatLogResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .ChatLog log_list = 3;
  total_size += 1 * this->log_list_size();
  for (int i = 0; i < this->log_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->log_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetChatLogResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetChatLogResp*>(&from));
}

void GetChatLogResp::MergeFrom(const GetChatLogResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  log_list_.MergeFrom(from.log_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GetChatLogResp::CopyFrom(const GetChatLogResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetChatLogResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < log_list_size(); i++) {
    if (!this->log_list(i).IsInitialized()) return false;
  }
  return true;
}

void GetChatLogResp::Swap(GetChatLogResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    log_list_.Swap(&other->log_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetChatLogResp::GetTypeName() const {
  return "GetChatLogResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ChatUserInfo::kUidFieldNumber;
const int ChatUserInfo::kNicknameFieldNumber;
const int ChatUserInfo::kVipFieldNumber;
const int ChatUserInfo::kSexFieldNumber;
const int ChatUserInfo::kLevelFieldNumber;
const int ChatUserInfo::kGroupNicknameFieldNumber;
#endif  // !_MSC_VER

ChatUserInfo::ChatUserInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChatUserInfo::InitAsDefaultInstance() {
}

ChatUserInfo::ChatUserInfo(const ChatUserInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChatUserInfo::SharedCtor() {
  _cached_size_ = 0;
  uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  vip_ = 0;
  sex_ = 0;
  level_ = 0;
  group_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChatUserInfo::~ChatUserInfo() {
  SharedDtor();
}

void ChatUserInfo::SharedDtor() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (group_nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete group_nickname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChatUserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChatUserInfo& ChatUserInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ChatUserInfo* ChatUserInfo::default_instance_ = NULL;

ChatUserInfo* ChatUserInfo::New() const {
  return new ChatUserInfo;
}

void ChatUserInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uid()) {
      if (uid_ != &::google::protobuf::internal::kEmptyString) {
        uid_->clear();
      }
    }
    if (has_nickname()) {
      if (nickname_ != &::google::protobuf::internal::kEmptyString) {
        nickname_->clear();
      }
    }
    vip_ = 0;
    sex_ = 0;
    level_ = 0;
    if (has_group_nickname()) {
      if (group_nickname_ != &::google::protobuf::internal::kEmptyString) {
        group_nickname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChatUserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_nickname;
        break;
      }

      // optional string nickname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nickname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nickname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_vip;
        break;
      }

      // optional int32 vip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_vip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &vip_)));
          set_has_vip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sex;
        break;
      }

      // optional int32 sex = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_level;
        break;
      }

      // optional int32 level = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_group_nickname;
        break;
      }

      // optional string group_nickname = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group_nickname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_nickname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChatUserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->uid(), output);
  }

  // optional string nickname = 2;
  if (has_nickname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->nickname(), output);
  }

  // optional int32 vip = 3;
  if (has_vip()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->vip(), output);
  }

  // optional int32 sex = 4;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->sex(), output);
  }

  // optional int32 level = 5;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->level(), output);
  }

  // optional string group_nickname = 6;
  if (has_group_nickname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->group_nickname(), output);
  }

}

int ChatUserInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uid());
    }

    // optional string nickname = 2;
    if (has_nickname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nickname());
    }

    // optional int32 vip = 3;
    if (has_vip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->vip());
    }

    // optional int32 sex = 4;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sex());
    }

    // optional int32 level = 5;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // optional string group_nickname = 6;
    if (has_group_nickname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_nickname());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChatUserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChatUserInfo*>(&from));
}

void ChatUserInfo::MergeFrom(const ChatUserInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_nickname()) {
      set_nickname(from.nickname());
    }
    if (from.has_vip()) {
      set_vip(from.vip());
    }
    if (from.has_sex()) {
      set_sex(from.sex());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_group_nickname()) {
      set_group_nickname(from.group_nickname());
    }
  }
}

void ChatUserInfo::CopyFrom(const ChatUserInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatUserInfo::IsInitialized() const {

  return true;
}

void ChatUserInfo::Swap(ChatUserInfo* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(nickname_, other->nickname_);
    std::swap(vip_, other->vip_);
    std::swap(sex_, other->sex_);
    std::swap(level_, other->level_);
    std::swap(group_nickname_, other->group_nickname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChatUserInfo::GetTypeName() const {
  return "ChatUserInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ChatReq::kRecverFieldNumber;
const int ChatReq::kMsgFieldNumber;
const int ChatReq::kChannelFieldNumber;
const int ChatReq::kSenderFieldNumber;
const int ChatReq::kTypeFieldNumber;
const int ChatReq::kMinorFieldNumber;
#endif  // !_MSC_VER

ChatReq::ChatReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChatReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  recver_ = const_cast< ::ChatUserInfo*>(
      ::ChatUserInfo::internal_default_instance());
#else
  recver_ = const_cast< ::ChatUserInfo*>(&::ChatUserInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sender_ = const_cast< ::ChatUserInfo*>(
      ::ChatUserInfo::internal_default_instance());
#else
  sender_ = const_cast< ::ChatUserInfo*>(&::ChatUserInfo::default_instance());
#endif
}

ChatReq::ChatReq(const ChatReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChatReq::SharedCtor() {
  _cached_size_ = 0;
  recver_ = NULL;
  msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channel_ = 0;
  sender_ = NULL;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChatReq::~ChatReq() {
  SharedDtor();
}

void ChatReq::SharedDtor() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete recver_;
    delete sender_;
  }
}

void ChatReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChatReq& ChatReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ChatReq* ChatReq::default_instance_ = NULL;

ChatReq* ChatReq::New() const {
  return new ChatReq;
}

void ChatReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_recver()) {
      if (recver_ != NULL) recver_->::ChatUserInfo::Clear();
    }
    if (has_msg()) {
      if (msg_ != &::google::protobuf::internal::kEmptyString) {
        msg_->clear();
      }
    }
    channel_ = 0;
    if (has_sender()) {
      if (sender_ != NULL) sender_->::ChatUserInfo::Clear();
    }
    type_ = 0;
  }
  minor_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChatReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ChatUserInfo recver = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_recver()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_msg;
        break;
      }

      // optional string msg = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_channel;
        break;
      }

      // optional int32 channel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_sender;
        break;
      }

      // optional .ChatUserInfo sender = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sender:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sender()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_type;
        break;
      }

      // optional int32 type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_minor;
        break;
      }

      // repeated int32 minor = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 48, input, this->mutable_minor())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_minor())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_minor;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChatReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ChatUserInfo recver = 1;
  if (has_recver()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->recver(), output);
  }

  // optional string msg = 2;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->msg(), output);
  }

  // optional int32 channel = 3;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->channel(), output);
  }

  // optional .ChatUserInfo sender = 4;
  if (has_sender()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->sender(), output);
  }

  // optional int32 type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->type(), output);
  }

  // repeated int32 minor = 6;
  for (int i = 0; i < this->minor_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      6, this->minor(i), output);
  }

}

int ChatReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ChatUserInfo recver = 1;
    if (has_recver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->recver());
    }

    // optional string msg = 2;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }

    // optional int32 channel = 3;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel());
    }

    // optional .ChatUserInfo sender = 4;
    if (has_sender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sender());
    }

    // optional int32 type = 5;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated int32 minor = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->minor_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->minor(i));
    }
    total_size += 1 * this->minor_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChatReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChatReq*>(&from));
}

void ChatReq::MergeFrom(const ChatReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  minor_.MergeFrom(from.minor_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_recver()) {
      mutable_recver()->::ChatUserInfo::MergeFrom(from.recver());
    }
    if (from.has_msg()) {
      set_msg(from.msg());
    }
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_sender()) {
      mutable_sender()->::ChatUserInfo::MergeFrom(from.sender());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void ChatReq::CopyFrom(const ChatReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatReq::IsInitialized() const {

  return true;
}

void ChatReq::Swap(ChatReq* other) {
  if (other != this) {
    std::swap(recver_, other->recver_);
    std::swap(msg_, other->msg_);
    std::swap(channel_, other->channel_);
    std::swap(sender_, other->sender_);
    std::swap(type_, other->type_);
    minor_.Swap(&other->minor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChatReq::GetTypeName() const {
  return "ChatReq";
}


// ===================================================================

bool ChatResp_ChatRet_IsValid(int value) {
  switch(value) {
    case -5:
    case -4:
    case -3:
    case -2:
    case -1:
    case 0:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ChatResp_ChatRet ChatResp::OK;
const ChatResp_ChatRet ChatResp::FAIL;
const ChatResp_ChatRet ChatResp::DIRTY;
const ChatResp_ChatRet ChatResp::BLACK;
const ChatResp_ChatRet ChatResp::SELF;
const ChatResp_ChatRet ChatResp::NOMONEY;
const ChatResp_ChatRet ChatResp::ChatRet_MIN;
const ChatResp_ChatRet ChatResp::ChatRet_MAX;
const int ChatResp::ChatRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ChatResp::kResultFieldNumber;
const int ChatResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

ChatResp::ChatResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChatResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ChatResp::ChatResp(const ChatResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChatResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChatResp::~ChatResp() {
  SharedDtor();
}

void ChatResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ChatResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChatResp& ChatResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ChatResp* ChatResp::default_instance_ = NULL;

ChatResp* ChatResp::New() const {
  return new ChatResp;
}

void ChatResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChatResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ChatResp.ChatRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ChatResp_ChatRet_IsValid(value)) {
            set_result(static_cast< ::ChatResp_ChatRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChatResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ChatResp.ChatRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int ChatResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ChatResp.ChatRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChatResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChatResp*>(&from));
}

void ChatResp::MergeFrom(const ChatResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void ChatResp::CopyFrom(const ChatResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void ChatResp::Swap(ChatResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChatResp::GetTypeName() const {
  return "ChatResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ChatMsg_t::kMsgFieldNumber;
const int ChatMsg_t::kChannelFieldNumber;
const int ChatMsg_t::kSenderFieldNumber;
const int ChatMsg_t::kRecverFieldNumber;
const int ChatMsg_t::kRecvsFieldNumber;
const int ChatMsg_t::kTypeFieldNumber;
const int ChatMsg_t::kMinorFieldNumber;
#endif  // !_MSC_VER

ChatMsg_t::ChatMsg_t()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChatMsg_t::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sender_ = const_cast< ::ChatUserInfo*>(
      ::ChatUserInfo::internal_default_instance());
#else
  sender_ = const_cast< ::ChatUserInfo*>(&::ChatUserInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  recver_ = const_cast< ::ChatUserInfo*>(
      ::ChatUserInfo::internal_default_instance());
#else
  recver_ = const_cast< ::ChatUserInfo*>(&::ChatUserInfo::default_instance());
#endif
}

ChatMsg_t::ChatMsg_t(const ChatMsg_t& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChatMsg_t::SharedCtor() {
  _cached_size_ = 0;
  channel_ = 0;
  sender_ = NULL;
  recver_ = NULL;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChatMsg_t::~ChatMsg_t() {
  SharedDtor();
}

void ChatMsg_t::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete sender_;
    delete recver_;
  }
}

void ChatMsg_t::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChatMsg_t& ChatMsg_t::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ChatMsg_t* ChatMsg_t::default_instance_ = NULL;

ChatMsg_t* ChatMsg_t::New() const {
  return new ChatMsg_t;
}

void ChatMsg_t::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    channel_ = 0;
    if (has_sender()) {
      if (sender_ != NULL) sender_->::ChatUserInfo::Clear();
    }
    if (has_recver()) {
      if (recver_ != NULL) recver_->::ChatUserInfo::Clear();
    }
    type_ = 0;
  }
  msg_.Clear();
  recvs_.Clear();
  minor_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChatMsg_t::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string msg = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_msg;
        if (input->ExpectTag(16)) goto parse_channel;
        break;
      }

      // optional int32 channel = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sender;
        break;
      }

      // optional .ChatUserInfo sender = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sender:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sender()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_recver;
        break;
      }

      // optional .ChatUserInfo recver = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_recver:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_recver()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_recvs;
        break;
      }

      // repeated string recvs = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_recvs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_recvs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_recvs;
        if (input->ExpectTag(48)) goto parse_type;
        break;
      }

      // optional int32 type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_minor;
        break;
      }

      // repeated int32 minor = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 56, input, this->mutable_minor())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_minor())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_minor;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChatMsg_t::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string msg = 1;
  for (int i = 0; i < this->msg_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->msg(i), output);
  }

  // optional int32 channel = 2;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->channel(), output);
  }

  // optional .ChatUserInfo sender = 3;
  if (has_sender()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->sender(), output);
  }

  // optional .ChatUserInfo recver = 4;
  if (has_recver()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->recver(), output);
  }

  // repeated string recvs = 5;
  for (int i = 0; i < this->recvs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->recvs(i), output);
  }

  // optional int32 type = 6;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->type(), output);
  }

  // repeated int32 minor = 7;
  for (int i = 0; i < this->minor_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      7, this->minor(i), output);
  }

}

int ChatMsg_t::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 channel = 2;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel());
    }

    // optional .ChatUserInfo sender = 3;
    if (has_sender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sender());
    }

    // optional .ChatUserInfo recver = 4;
    if (has_recver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->recver());
    }

    // optional int32 type = 6;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated string msg = 1;
  total_size += 1 * this->msg_size();
  for (int i = 0; i < this->msg_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->msg(i));
  }

  // repeated string recvs = 5;
  total_size += 1 * this->recvs_size();
  for (int i = 0; i < this->recvs_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->recvs(i));
  }

  // repeated int32 minor = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->minor_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->minor(i));
    }
    total_size += 1 * this->minor_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChatMsg_t::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChatMsg_t*>(&from));
}

void ChatMsg_t::MergeFrom(const ChatMsg_t& from) {
  GOOGLE_CHECK_NE(&from, this);
  msg_.MergeFrom(from.msg_);
  recvs_.MergeFrom(from.recvs_);
  minor_.MergeFrom(from.minor_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_sender()) {
      mutable_sender()->::ChatUserInfo::MergeFrom(from.sender());
    }
    if (from.has_recver()) {
      mutable_recver()->::ChatUserInfo::MergeFrom(from.recver());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void ChatMsg_t::CopyFrom(const ChatMsg_t& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatMsg_t::IsInitialized() const {

  return true;
}

void ChatMsg_t::Swap(ChatMsg_t* other) {
  if (other != this) {
    msg_.Swap(&other->msg_);
    std::swap(channel_, other->channel_);
    std::swap(sender_, other->sender_);
    std::swap(recver_, other->recver_);
    recvs_.Swap(&other->recvs_);
    std::swap(type_, other->type_);
    minor_.Swap(&other->minor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChatMsg_t::GetTypeName() const {
  return "ChatMsg_t";
}


// ===================================================================

#ifndef _MSC_VER
const int ChatMsg::kMsgFieldNumber;
const int ChatMsg::kChannelFieldNumber;
const int ChatMsg::kSenderFieldNumber;
const int ChatMsg::kRecverFieldNumber;
const int ChatMsg::kRecvsFieldNumber;
const int ChatMsg::kTypeFieldNumber;
const int ChatMsg::kMinorFieldNumber;
#endif  // !_MSC_VER

ChatMsg::ChatMsg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChatMsg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sender_ = const_cast< ::ChatUserInfo*>(
      ::ChatUserInfo::internal_default_instance());
#else
  sender_ = const_cast< ::ChatUserInfo*>(&::ChatUserInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  recver_ = const_cast< ::ChatUserInfo*>(
      ::ChatUserInfo::internal_default_instance());
#else
  recver_ = const_cast< ::ChatUserInfo*>(&::ChatUserInfo::default_instance());
#endif
}

ChatMsg::ChatMsg(const ChatMsg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChatMsg::SharedCtor() {
  _cached_size_ = 0;
  msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channel_ = 0;
  sender_ = NULL;
  recver_ = NULL;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChatMsg::~ChatMsg() {
  SharedDtor();
}

void ChatMsg::SharedDtor() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete sender_;
    delete recver_;
  }
}

void ChatMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChatMsg& ChatMsg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ChatMsg* ChatMsg::default_instance_ = NULL;

ChatMsg* ChatMsg::New() const {
  return new ChatMsg;
}

void ChatMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msg()) {
      if (msg_ != &::google::protobuf::internal::kEmptyString) {
        msg_->clear();
      }
    }
    channel_ = 0;
    if (has_sender()) {
      if (sender_ != NULL) sender_->::ChatUserInfo::Clear();
    }
    if (has_recver()) {
      if (recver_ != NULL) recver_->::ChatUserInfo::Clear();
    }
    type_ = 0;
  }
  recvs_.Clear();
  minor_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChatMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string msg = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_channel;
        break;
      }

      // optional int32 channel = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sender;
        break;
      }

      // optional .ChatUserInfo sender = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sender:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sender()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_recver;
        break;
      }

      // optional .ChatUserInfo recver = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_recver:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_recver()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_recvs;
        break;
      }

      // repeated string recvs = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_recvs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_recvs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_recvs;
        if (input->ExpectTag(48)) goto parse_type;
        break;
      }

      // optional int32 type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_minor;
        break;
      }

      // repeated int32 minor = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 56, input, this->mutable_minor())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_minor())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_minor;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChatMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string msg = 1;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->msg(), output);
  }

  // optional int32 channel = 2;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->channel(), output);
  }

  // optional .ChatUserInfo sender = 3;
  if (has_sender()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->sender(), output);
  }

  // optional .ChatUserInfo recver = 4;
  if (has_recver()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->recver(), output);
  }

  // repeated string recvs = 5;
  for (int i = 0; i < this->recvs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->recvs(i), output);
  }

  // optional int32 type = 6;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->type(), output);
  }

  // repeated int32 minor = 7;
  for (int i = 0; i < this->minor_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      7, this->minor(i), output);
  }

}

int ChatMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string msg = 1;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }

    // optional int32 channel = 2;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel());
    }

    // optional .ChatUserInfo sender = 3;
    if (has_sender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sender());
    }

    // optional .ChatUserInfo recver = 4;
    if (has_recver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->recver());
    }

    // optional int32 type = 6;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated string recvs = 5;
  total_size += 1 * this->recvs_size();
  for (int i = 0; i < this->recvs_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->recvs(i));
  }

  // repeated int32 minor = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->minor_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->minor(i));
    }
    total_size += 1 * this->minor_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChatMsg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChatMsg*>(&from));
}

void ChatMsg::MergeFrom(const ChatMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  recvs_.MergeFrom(from.recvs_);
  minor_.MergeFrom(from.minor_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg()) {
      set_msg(from.msg());
    }
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_sender()) {
      mutable_sender()->::ChatUserInfo::MergeFrom(from.sender());
    }
    if (from.has_recver()) {
      mutable_recver()->::ChatUserInfo::MergeFrom(from.recver());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void ChatMsg::CopyFrom(const ChatMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatMsg::IsInitialized() const {

  return true;
}

void ChatMsg::Swap(ChatMsg* other) {
  if (other != this) {
    std::swap(msg_, other->msg_);
    std::swap(channel_, other->channel_);
    std::swap(sender_, other->sender_);
    std::swap(recver_, other->recver_);
    recvs_.Swap(&other->recvs_);
    std::swap(type_, other->type_);
    minor_.Swap(&other->minor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChatMsg::GetTypeName() const {
  return "ChatMsg";
}


// ===================================================================

#ifndef _MSC_VER
const int CmdClientGMReq::kCmdFieldNumber;
#endif  // !_MSC_VER

CmdClientGMReq::CmdClientGMReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CmdClientGMReq::InitAsDefaultInstance() {
}

CmdClientGMReq::CmdClientGMReq(const CmdClientGMReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CmdClientGMReq::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CmdClientGMReq::~CmdClientGMReq() {
  SharedDtor();
}

void CmdClientGMReq::SharedDtor() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CmdClientGMReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CmdClientGMReq& CmdClientGMReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

CmdClientGMReq* CmdClientGMReq::default_instance_ = NULL;

CmdClientGMReq* CmdClientGMReq::New() const {
  return new CmdClientGMReq;
}

void CmdClientGMReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_cmd()) {
      if (cmd_ != &::google::protobuf::internal::kEmptyString) {
        cmd_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CmdClientGMReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string cmd = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cmd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CmdClientGMReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string cmd = 1;
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->cmd(), output);
  }

}

int CmdClientGMReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string cmd = 1;
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cmd());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CmdClientGMReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CmdClientGMReq*>(&from));
}

void CmdClientGMReq::MergeFrom(const CmdClientGMReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
  }
}

void CmdClientGMReq::CopyFrom(const CmdClientGMReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CmdClientGMReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CmdClientGMReq::Swap(CmdClientGMReq* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CmdClientGMReq::GetTypeName() const {
  return "CmdClientGMReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CmdClientGMResp::kResultFieldNumber;
const int CmdClientGMResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

CmdClientGMResp::CmdClientGMResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CmdClientGMResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

CmdClientGMResp::CmdClientGMResp(const CmdClientGMResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CmdClientGMResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CmdClientGMResp::~CmdClientGMResp() {
  SharedDtor();
}

void CmdClientGMResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void CmdClientGMResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CmdClientGMResp& CmdClientGMResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

CmdClientGMResp* CmdClientGMResp::default_instance_ = NULL;

CmdClientGMResp* CmdClientGMResp::New() const {
  return new CmdClientGMResp;
}

void CmdClientGMResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CmdClientGMResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CmdClientGMResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int CmdClientGMResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CmdClientGMResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CmdClientGMResp*>(&from));
}

void CmdClientGMResp::MergeFrom(const CmdClientGMResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void CmdClientGMResp::CopyFrom(const CmdClientGMResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CmdClientGMResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void CmdClientGMResp::Swap(CmdClientGMResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CmdClientGMResp::GetTypeName() const {
  return "CmdClientGMResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CmdGetOtherUserInfoReq::kUserNameFieldNumber;
const int CmdGetOtherUserInfoReq::kSidFieldNumber;
const int CmdGetOtherUserInfoReq::kLineupFieldNumber;
#endif  // !_MSC_VER

CmdGetOtherUserInfoReq::CmdGetOtherUserInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CmdGetOtherUserInfoReq::InitAsDefaultInstance() {
}

CmdGetOtherUserInfoReq::CmdGetOtherUserInfoReq(const CmdGetOtherUserInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CmdGetOtherUserInfoReq::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CmdGetOtherUserInfoReq::~CmdGetOtherUserInfoReq() {
  SharedDtor();
}

void CmdGetOtherUserInfoReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CmdGetOtherUserInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CmdGetOtherUserInfoReq& CmdGetOtherUserInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

CmdGetOtherUserInfoReq* CmdGetOtherUserInfoReq::default_instance_ = NULL;

CmdGetOtherUserInfoReq* CmdGetOtherUserInfoReq::New() const {
  return new CmdGetOtherUserInfoReq;
}

void CmdGetOtherUserInfoReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
    sid_ = 0;
  }
  lineup_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CmdGetOtherUserInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_sid;
        break;
      }

      // required int32 sid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sid_)));
          set_has_sid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lineup;
        break;
      }

      // repeated int32 lineup = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lineup:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_lineup())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_lineup())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lineup;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CmdGetOtherUserInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

  // required int32 sid = 2;
  if (has_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->sid(), output);
  }

  // repeated int32 lineup = 3;
  for (int i = 0; i < this->lineup_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->lineup(i), output);
  }

}

int CmdGetOtherUserInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required int32 sid = 2;
    if (has_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sid());
    }

  }
  // repeated int32 lineup = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->lineup_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->lineup(i));
    }
    total_size += 1 * this->lineup_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CmdGetOtherUserInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CmdGetOtherUserInfoReq*>(&from));
}

void CmdGetOtherUserInfoReq::MergeFrom(const CmdGetOtherUserInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  lineup_.MergeFrom(from.lineup_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_sid()) {
      set_sid(from.sid());
    }
  }
}

void CmdGetOtherUserInfoReq::CopyFrom(const CmdGetOtherUserInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CmdGetOtherUserInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CmdGetOtherUserInfoReq::Swap(CmdGetOtherUserInfoReq* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(sid_, other->sid_);
    lineup_.Swap(&other->lineup_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CmdGetOtherUserInfoReq::GetTypeName() const {
  return "CmdGetOtherUserInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CmdGetOtherUserInfoResp::kResultFieldNumber;
const int CmdGetOtherUserInfoResp::kTypeFieldNumber;
const int CmdGetOtherUserInfoResp::kInfoFieldNumber;
#endif  // !_MSC_VER

CmdGetOtherUserInfoResp::CmdGetOtherUserInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CmdGetOtherUserInfoResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  info_ = const_cast< ::OtherUserInfo*>(
      ::OtherUserInfo::internal_default_instance());
#else
  info_ = const_cast< ::OtherUserInfo*>(&::OtherUserInfo::default_instance());
#endif
}

CmdGetOtherUserInfoResp::CmdGetOtherUserInfoResp(const CmdGetOtherUserInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CmdGetOtherUserInfoResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  type_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CmdGetOtherUserInfoResp::~CmdGetOtherUserInfoResp() {
  SharedDtor();
}

void CmdGetOtherUserInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete info_;
  }
}

void CmdGetOtherUserInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CmdGetOtherUserInfoResp& CmdGetOtherUserInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

CmdGetOtherUserInfoResp* CmdGetOtherUserInfoResp::default_instance_ = NULL;

CmdGetOtherUserInfoResp* CmdGetOtherUserInfoResp::New() const {
  return new CmdGetOtherUserInfoResp;
}

void CmdGetOtherUserInfoResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    type_ = 0;
    if (has_info()) {
      if (info_ != NULL) info_->::OtherUserInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CmdGetOtherUserInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional int32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_info;
        break;
      }

      // optional .OtherUserInfo info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CmdGetOtherUserInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // optional .OtherUserInfo info = 3;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->info(), output);
  }

}

int CmdGetOtherUserInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional .OtherUserInfo info = 3;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CmdGetOtherUserInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CmdGetOtherUserInfoResp*>(&from));
}

void CmdGetOtherUserInfoResp::MergeFrom(const CmdGetOtherUserInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_info()) {
      mutable_info()->::OtherUserInfo::MergeFrom(from.info());
    }
  }
}

void CmdGetOtherUserInfoResp::CopyFrom(const CmdGetOtherUserInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CmdGetOtherUserInfoResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void CmdGetOtherUserInfoResp::Swap(CmdGetOtherUserInfoResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(type_, other->type_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CmdGetOtherUserInfoResp::GetTypeName() const {
  return "CmdGetOtherUserInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
const int CmdGetOtherUserInfoListReq::kUserNameListFieldNumber;
const int CmdGetOtherUserInfoListReq::kSidFieldNumber;
#endif  // !_MSC_VER

CmdGetOtherUserInfoListReq::CmdGetOtherUserInfoListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CmdGetOtherUserInfoListReq::InitAsDefaultInstance() {
}

CmdGetOtherUserInfoListReq::CmdGetOtherUserInfoListReq(const CmdGetOtherUserInfoListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CmdGetOtherUserInfoListReq::SharedCtor() {
  _cached_size_ = 0;
  sid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CmdGetOtherUserInfoListReq::~CmdGetOtherUserInfoListReq() {
  SharedDtor();
}

void CmdGetOtherUserInfoListReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CmdGetOtherUserInfoListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CmdGetOtherUserInfoListReq& CmdGetOtherUserInfoListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

CmdGetOtherUserInfoListReq* CmdGetOtherUserInfoListReq::default_instance_ = NULL;

CmdGetOtherUserInfoListReq* CmdGetOtherUserInfoListReq::New() const {
  return new CmdGetOtherUserInfoListReq;
}

void CmdGetOtherUserInfoListReq::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    sid_ = 0;
  }
  user_name_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CmdGetOtherUserInfoListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string user_name_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_user_name_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_user_name_list;
        if (input->ExpectTag(16)) goto parse_sid;
        break;
      }

      // required int32 sid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sid_)));
          set_has_sid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CmdGetOtherUserInfoListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string user_name_list = 1;
  for (int i = 0; i < this->user_name_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name_list(i), output);
  }

  // required int32 sid = 2;
  if (has_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->sid(), output);
  }

}

int CmdGetOtherUserInfoListReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required int32 sid = 2;
    if (has_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sid());
    }

  }
  // repeated string user_name_list = 1;
  total_size += 1 * this->user_name_list_size();
  for (int i = 0; i < this->user_name_list_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->user_name_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CmdGetOtherUserInfoListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CmdGetOtherUserInfoListReq*>(&from));
}

void CmdGetOtherUserInfoListReq::MergeFrom(const CmdGetOtherUserInfoListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_name_list_.MergeFrom(from.user_name_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_sid()) {
      set_sid(from.sid());
    }
  }
}

void CmdGetOtherUserInfoListReq::CopyFrom(const CmdGetOtherUserInfoListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CmdGetOtherUserInfoListReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void CmdGetOtherUserInfoListReq::Swap(CmdGetOtherUserInfoListReq* other) {
  if (other != this) {
    user_name_list_.Swap(&other->user_name_list_);
    std::swap(sid_, other->sid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CmdGetOtherUserInfoListReq::GetTypeName() const {
  return "CmdGetOtherUserInfoListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CmdGetOtherUserInfoListResp::kResultFieldNumber;
const int CmdGetOtherUserInfoListResp::kTypeFieldNumber;
const int CmdGetOtherUserInfoListResp::kInfoListFieldNumber;
#endif  // !_MSC_VER

CmdGetOtherUserInfoListResp::CmdGetOtherUserInfoListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CmdGetOtherUserInfoListResp::InitAsDefaultInstance() {
}

CmdGetOtherUserInfoListResp::CmdGetOtherUserInfoListResp(const CmdGetOtherUserInfoListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CmdGetOtherUserInfoListResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CmdGetOtherUserInfoListResp::~CmdGetOtherUserInfoListResp() {
  SharedDtor();
}

void CmdGetOtherUserInfoListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CmdGetOtherUserInfoListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CmdGetOtherUserInfoListResp& CmdGetOtherUserInfoListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

CmdGetOtherUserInfoListResp* CmdGetOtherUserInfoListResp::default_instance_ = NULL;

CmdGetOtherUserInfoListResp* CmdGetOtherUserInfoListResp::New() const {
  return new CmdGetOtherUserInfoListResp;
}

void CmdGetOtherUserInfoListResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    type_ = 0;
  }
  info_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CmdGetOtherUserInfoListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional int32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_info_list;
        break;
      }

      // repeated .OtherUserInfo info_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_info_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_info_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CmdGetOtherUserInfoListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // repeated .OtherUserInfo info_list = 3;
  for (int i = 0; i < this->info_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->info_list(i), output);
  }

}

int CmdGetOtherUserInfoListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated .OtherUserInfo info_list = 3;
  total_size += 1 * this->info_list_size();
  for (int i = 0; i < this->info_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->info_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CmdGetOtherUserInfoListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CmdGetOtherUserInfoListResp*>(&from));
}

void CmdGetOtherUserInfoListResp::MergeFrom(const CmdGetOtherUserInfoListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  info_list_.MergeFrom(from.info_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void CmdGetOtherUserInfoListResp::CopyFrom(const CmdGetOtherUserInfoListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CmdGetOtherUserInfoListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < info_list_size(); i++) {
    if (!this->info_list(i).IsInitialized()) return false;
  }
  return true;
}

void CmdGetOtherUserInfoListResp::Swap(CmdGetOtherUserInfoListResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(type_, other->type_);
    info_list_.Swap(&other->info_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CmdGetOtherUserInfoListResp::GetTypeName() const {
  return "CmdGetOtherUserInfoListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int NewFriendUpdate::kSenderFieldNumber;
#endif  // !_MSC_VER

NewFriendUpdate::NewFriendUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NewFriendUpdate::InitAsDefaultInstance() {
}

NewFriendUpdate::NewFriendUpdate(const NewFriendUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NewFriendUpdate::SharedCtor() {
  _cached_size_ = 0;
  sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewFriendUpdate::~NewFriendUpdate() {
  SharedDtor();
}

void NewFriendUpdate::SharedDtor() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NewFriendUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NewFriendUpdate& NewFriendUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

NewFriendUpdate* NewFriendUpdate::default_instance_ = NULL;

NewFriendUpdate* NewFriendUpdate::New() const {
  return new NewFriendUpdate;
}

void NewFriendUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_sender()) {
      if (sender_ != &::google::protobuf::internal::kEmptyString) {
        sender_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NewFriendUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string sender = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sender()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewFriendUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string sender = 1;
  if (has_sender()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->sender(), output);
  }

}

int NewFriendUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string sender = 1;
    if (has_sender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sender());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewFriendUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NewFriendUpdate*>(&from));
}

void NewFriendUpdate::MergeFrom(const NewFriendUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sender()) {
      set_sender(from.sender());
    }
  }
}

void NewFriendUpdate::CopyFrom(const NewFriendUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewFriendUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void NewFriendUpdate::Swap(NewFriendUpdate* other) {
  if (other != this) {
    std::swap(sender_, other->sender_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NewFriendUpdate::GetTypeName() const {
  return "NewFriendUpdate";
}


// ===================================================================

#ifndef _MSC_VER
const int BeFriendUpdate::kResultFieldNumber;
#endif  // !_MSC_VER

BeFriendUpdate::BeFriendUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BeFriendUpdate::InitAsDefaultInstance() {
}

BeFriendUpdate::BeFriendUpdate(const BeFriendUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BeFriendUpdate::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BeFriendUpdate::~BeFriendUpdate() {
  SharedDtor();
}

void BeFriendUpdate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BeFriendUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BeFriendUpdate& BeFriendUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

BeFriendUpdate* BeFriendUpdate::default_instance_ = NULL;

BeFriendUpdate* BeFriendUpdate::New() const {
  return new BeFriendUpdate;
}

void BeFriendUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BeFriendUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BeFriendUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int BeFriendUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BeFriendUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BeFriendUpdate*>(&from));
}

void BeFriendUpdate::MergeFrom(const BeFriendUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void BeFriendUpdate::CopyFrom(const BeFriendUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeFriendUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BeFriendUpdate::Swap(BeFriendUpdate* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BeFriendUpdate::GetTypeName() const {
  return "BeFriendUpdate";
}


// ===================================================================

#ifndef _MSC_VER
const int GetFriendsInfoReq::kTypeFieldNumber;
const int GetFriendsInfoReq::kIndexFieldNumber;
const int GetFriendsInfoReq::kNumFieldNumber;
const int GetFriendsInfoReq::kNicknameFieldNumber;
#endif  // !_MSC_VER

GetFriendsInfoReq::GetFriendsInfoReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetFriendsInfoReq::InitAsDefaultInstance() {
}

GetFriendsInfoReq::GetFriendsInfoReq(const GetFriendsInfoReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetFriendsInfoReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  index_ = 0;
  num_ = 0;
  nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetFriendsInfoReq::~GetFriendsInfoReq() {
  SharedDtor();
}

void GetFriendsInfoReq::SharedDtor() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetFriendsInfoReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetFriendsInfoReq& GetFriendsInfoReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

GetFriendsInfoReq* GetFriendsInfoReq::default_instance_ = NULL;

GetFriendsInfoReq* GetFriendsInfoReq::New() const {
  return new GetFriendsInfoReq;
}

void GetFriendsInfoReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    index_ = 0;
    num_ = 0;
    if (has_nickname()) {
      if (nickname_ != &::google::protobuf::internal::kEmptyString) {
        nickname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetFriendsInfoReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_index;
        break;
      }

      // optional int32 index = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_num;
        break;
      }

      // optional int32 num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_nickname;
        break;
      }

      // optional string nickname = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nickname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nickname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetFriendsInfoReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional int32 index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->index(), output);
  }

  // optional int32 num = 3;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num(), output);
  }

  // optional string nickname = 4;
  if (has_nickname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->nickname(), output);
  }

}

int GetFriendsInfoReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 index = 2;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional int32 num = 3;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional string nickname = 4;
    if (has_nickname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nickname());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetFriendsInfoReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetFriendsInfoReq*>(&from));
}

void GetFriendsInfoReq::MergeFrom(const GetFriendsInfoReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_nickname()) {
      set_nickname(from.nickname());
    }
  }
}

void GetFriendsInfoReq::CopyFrom(const GetFriendsInfoReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFriendsInfoReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetFriendsInfoReq::Swap(GetFriendsInfoReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(index_, other->index_);
    std::swap(num_, other->num_);
    std::swap(nickname_, other->nickname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetFriendsInfoReq::GetTypeName() const {
  return "GetFriendsInfoReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetFriendsInfoResp::kResultFieldNumber;
const int GetFriendsInfoResp::kTypeFieldNumber;
const int GetFriendsInfoResp::kListFieldNumber;
#endif  // !_MSC_VER

GetFriendsInfoResp::GetFriendsInfoResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetFriendsInfoResp::InitAsDefaultInstance() {
}

GetFriendsInfoResp::GetFriendsInfoResp(const GetFriendsInfoResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetFriendsInfoResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetFriendsInfoResp::~GetFriendsInfoResp() {
  SharedDtor();
}

void GetFriendsInfoResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetFriendsInfoResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetFriendsInfoResp& GetFriendsInfoResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

GetFriendsInfoResp* GetFriendsInfoResp::default_instance_ = NULL;

GetFriendsInfoResp* GetFriendsInfoResp::New() const {
  return new GetFriendsInfoResp;
}

void GetFriendsInfoResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    type_ = 0;
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetFriendsInfoResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required int32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_list;
        break;
      }

      // repeated .OtherUserInfo list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetFriendsInfoResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // required int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // repeated .OtherUserInfo list = 3;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->list(i), output);
  }

}

int GetFriendsInfoResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // required int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated .OtherUserInfo list = 3;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetFriendsInfoResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetFriendsInfoResp*>(&from));
}

void GetFriendsInfoResp::MergeFrom(const GetFriendsInfoResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void GetFriendsInfoResp::CopyFrom(const GetFriendsInfoResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFriendsInfoResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < list_size(); i++) {
    if (!this->list(i).IsInitialized()) return false;
  }
  return true;
}

void GetFriendsInfoResp::Swap(GetFriendsInfoResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(type_, other->type_);
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetFriendsInfoResp::GetTypeName() const {
  return "GetFriendsInfoResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ApplyFriendReq::kRecverFieldNumber;
#endif  // !_MSC_VER

ApplyFriendReq::ApplyFriendReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ApplyFriendReq::InitAsDefaultInstance() {
}

ApplyFriendReq::ApplyFriendReq(const ApplyFriendReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ApplyFriendReq::SharedCtor() {
  _cached_size_ = 0;
  recver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ApplyFriendReq::~ApplyFriendReq() {
  SharedDtor();
}

void ApplyFriendReq::SharedDtor() {
  if (recver_ != &::google::protobuf::internal::kEmptyString) {
    delete recver_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ApplyFriendReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ApplyFriendReq& ApplyFriendReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ApplyFriendReq* ApplyFriendReq::default_instance_ = NULL;

ApplyFriendReq* ApplyFriendReq::New() const {
  return new ApplyFriendReq;
}

void ApplyFriendReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_recver()) {
      if (recver_ != &::google::protobuf::internal::kEmptyString) {
        recver_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ApplyFriendReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string recver = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_recver()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ApplyFriendReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string recver = 1;
  if (has_recver()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->recver(), output);
  }

}

int ApplyFriendReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string recver = 1;
    if (has_recver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->recver());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ApplyFriendReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ApplyFriendReq*>(&from));
}

void ApplyFriendReq::MergeFrom(const ApplyFriendReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_recver()) {
      set_recver(from.recver());
    }
  }
}

void ApplyFriendReq::CopyFrom(const ApplyFriendReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyFriendReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ApplyFriendReq::Swap(ApplyFriendReq* other) {
  if (other != this) {
    std::swap(recver_, other->recver_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ApplyFriendReq::GetTypeName() const {
  return "ApplyFriendReq";
}


// ===================================================================

bool ApplyFriendResp_ApplyFriendRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp::OK;
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp::FAIL;
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp::FRIEND;
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp::OTHER_BLACK;
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp::MY_BLACK;
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp::FIREND_FULL;
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp::SENDED;
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp::ApplyFriendRet_MIN;
const ApplyFriendResp_ApplyFriendRet ApplyFriendResp::ApplyFriendRet_MAX;
const int ApplyFriendResp::ApplyFriendRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ApplyFriendResp::kResultFieldNumber;
#endif  // !_MSC_VER

ApplyFriendResp::ApplyFriendResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ApplyFriendResp::InitAsDefaultInstance() {
}

ApplyFriendResp::ApplyFriendResp(const ApplyFriendResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ApplyFriendResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ApplyFriendResp::~ApplyFriendResp() {
  SharedDtor();
}

void ApplyFriendResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ApplyFriendResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ApplyFriendResp& ApplyFriendResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ApplyFriendResp* ApplyFriendResp::default_instance_ = NULL;

ApplyFriendResp* ApplyFriendResp::New() const {
  return new ApplyFriendResp;
}

void ApplyFriendResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ApplyFriendResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ApplyFriendResp.ApplyFriendRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ApplyFriendResp_ApplyFriendRet_IsValid(value)) {
            set_result(static_cast< ::ApplyFriendResp_ApplyFriendRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ApplyFriendResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ApplyFriendResp.ApplyFriendRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

}

int ApplyFriendResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ApplyFriendResp.ApplyFriendRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ApplyFriendResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ApplyFriendResp*>(&from));
}

void ApplyFriendResp::MergeFrom(const ApplyFriendResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ApplyFriendResp::CopyFrom(const ApplyFriendResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyFriendResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ApplyFriendResp::Swap(ApplyFriendResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ApplyFriendResp::GetTypeName() const {
  return "ApplyFriendResp";
}


// ===================================================================

#ifndef _MSC_VER
const int AcceptFriendReq::kSenderFieldNumber;
const int AcceptFriendReq::kMailGuidFieldNumber;
#endif  // !_MSC_VER

AcceptFriendReq::AcceptFriendReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AcceptFriendReq::InitAsDefaultInstance() {
}

AcceptFriendReq::AcceptFriendReq(const AcceptFriendReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AcceptFriendReq::SharedCtor() {
  _cached_size_ = 0;
  sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mail_guid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AcceptFriendReq::~AcceptFriendReq() {
  SharedDtor();
}

void AcceptFriendReq::SharedDtor() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AcceptFriendReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AcceptFriendReq& AcceptFriendReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

AcceptFriendReq* AcceptFriendReq::default_instance_ = NULL;

AcceptFriendReq* AcceptFriendReq::New() const {
  return new AcceptFriendReq;
}

void AcceptFriendReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_sender()) {
      if (sender_ != &::google::protobuf::internal::kEmptyString) {
        sender_->clear();
      }
    }
    mail_guid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AcceptFriendReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string sender = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sender()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mail_guid;
        break;
      }

      // required int32 mail_guid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mail_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mail_guid_)));
          set_has_mail_guid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AcceptFriendReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string sender = 1;
  if (has_sender()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->sender(), output);
  }

  // required int32 mail_guid = 2;
  if (has_mail_guid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->mail_guid(), output);
  }

}

int AcceptFriendReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string sender = 1;
    if (has_sender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sender());
    }

    // required int32 mail_guid = 2;
    if (has_mail_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mail_guid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AcceptFriendReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AcceptFriendReq*>(&from));
}

void AcceptFriendReq::MergeFrom(const AcceptFriendReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sender()) {
      set_sender(from.sender());
    }
    if (from.has_mail_guid()) {
      set_mail_guid(from.mail_guid());
    }
  }
}

void AcceptFriendReq::CopyFrom(const AcceptFriendReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcceptFriendReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AcceptFriendReq::Swap(AcceptFriendReq* other) {
  if (other != this) {
    std::swap(sender_, other->sender_);
    std::swap(mail_guid_, other->mail_guid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AcceptFriendReq::GetTypeName() const {
  return "AcceptFriendReq";
}


// ===================================================================

bool AcceptFriendResp_AcceptFriendRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::OK;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::FAIL;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::FRIEND;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::NO_MAIL;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::SELF;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::OTHER_BLACK;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::MY_BLACK;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::MY_FRIEND_FULL;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::OTHER_FRIEND_FULL;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::AcceptFriendRet_MIN;
const AcceptFriendResp_AcceptFriendRet AcceptFriendResp::AcceptFriendRet_MAX;
const int AcceptFriendResp::AcceptFriendRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int AcceptFriendResp::kResultFieldNumber;
#endif  // !_MSC_VER

AcceptFriendResp::AcceptFriendResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AcceptFriendResp::InitAsDefaultInstance() {
}

AcceptFriendResp::AcceptFriendResp(const AcceptFriendResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AcceptFriendResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AcceptFriendResp::~AcceptFriendResp() {
  SharedDtor();
}

void AcceptFriendResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AcceptFriendResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AcceptFriendResp& AcceptFriendResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

AcceptFriendResp* AcceptFriendResp::default_instance_ = NULL;

AcceptFriendResp* AcceptFriendResp::New() const {
  return new AcceptFriendResp;
}

void AcceptFriendResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AcceptFriendResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .AcceptFriendResp.AcceptFriendRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::AcceptFriendResp_AcceptFriendRet_IsValid(value)) {
            set_result(static_cast< ::AcceptFriendResp_AcceptFriendRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AcceptFriendResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .AcceptFriendResp.AcceptFriendRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

}

int AcceptFriendResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .AcceptFriendResp.AcceptFriendRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AcceptFriendResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AcceptFriendResp*>(&from));
}

void AcceptFriendResp::MergeFrom(const AcceptFriendResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void AcceptFriendResp::CopyFrom(const AcceptFriendResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcceptFriendResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AcceptFriendResp::Swap(AcceptFriendResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AcceptFriendResp::GetTypeName() const {
  return "AcceptFriendResp";
}


// ===================================================================

#ifndef _MSC_VER
const int RemoveFriendReq::kUserNameFieldNumber;
#endif  // !_MSC_VER

RemoveFriendReq::RemoveFriendReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RemoveFriendReq::InitAsDefaultInstance() {
}

RemoveFriendReq::RemoveFriendReq(const RemoveFriendReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RemoveFriendReq::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RemoveFriendReq::~RemoveFriendReq() {
  SharedDtor();
}

void RemoveFriendReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RemoveFriendReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RemoveFriendReq& RemoveFriendReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

RemoveFriendReq* RemoveFriendReq::default_instance_ = NULL;

RemoveFriendReq* RemoveFriendReq::New() const {
  return new RemoveFriendReq;
}

void RemoveFriendReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RemoveFriendReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RemoveFriendReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

}

int RemoveFriendReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RemoveFriendReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RemoveFriendReq*>(&from));
}

void RemoveFriendReq::MergeFrom(const RemoveFriendReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
  }
}

void RemoveFriendReq::CopyFrom(const RemoveFriendReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveFriendReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RemoveFriendReq::Swap(RemoveFriendReq* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RemoveFriendReq::GetTypeName() const {
  return "RemoveFriendReq";
}


// ===================================================================

#ifndef _MSC_VER
const int RemoveFriendResp::kResultFieldNumber;
#endif  // !_MSC_VER

RemoveFriendResp::RemoveFriendResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RemoveFriendResp::InitAsDefaultInstance() {
}

RemoveFriendResp::RemoveFriendResp(const RemoveFriendResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RemoveFriendResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RemoveFriendResp::~RemoveFriendResp() {
  SharedDtor();
}

void RemoveFriendResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RemoveFriendResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RemoveFriendResp& RemoveFriendResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

RemoveFriendResp* RemoveFriendResp::default_instance_ = NULL;

RemoveFriendResp* RemoveFriendResp::New() const {
  return new RemoveFriendResp;
}

void RemoveFriendResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RemoveFriendResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RemoveFriendResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int RemoveFriendResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RemoveFriendResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RemoveFriendResp*>(&from));
}

void RemoveFriendResp::MergeFrom(const RemoveFriendResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void RemoveFriendResp::CopyFrom(const RemoveFriendResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveFriendResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RemoveFriendResp::Swap(RemoveFriendResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RemoveFriendResp::GetTypeName() const {
  return "RemoveFriendResp";
}


// ===================================================================

#ifndef _MSC_VER
const int FriendAddTiliReq::kUserNameFieldNumber;
#endif  // !_MSC_VER

FriendAddTiliReq::FriendAddTiliReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FriendAddTiliReq::InitAsDefaultInstance() {
}

FriendAddTiliReq::FriendAddTiliReq(const FriendAddTiliReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FriendAddTiliReq::SharedCtor() {
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FriendAddTiliReq::~FriendAddTiliReq() {
  SharedDtor();
}

void FriendAddTiliReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FriendAddTiliReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FriendAddTiliReq& FriendAddTiliReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

FriendAddTiliReq* FriendAddTiliReq::default_instance_ = NULL;

FriendAddTiliReq* FriendAddTiliReq::New() const {
  return new FriendAddTiliReq;
}

void FriendAddTiliReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FriendAddTiliReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FriendAddTiliReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(), output);
  }

}

int FriendAddTiliReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FriendAddTiliReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FriendAddTiliReq*>(&from));
}

void FriendAddTiliReq::MergeFrom(const FriendAddTiliReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
  }
}

void FriendAddTiliReq::CopyFrom(const FriendAddTiliReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FriendAddTiliReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FriendAddTiliReq::Swap(FriendAddTiliReq* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FriendAddTiliReq::GetTypeName() const {
  return "FriendAddTiliReq";
}


// ===================================================================

#ifndef _MSC_VER
const int FriendAddTiliResp::kResultFieldNumber;
const int FriendAddTiliResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

FriendAddTiliResp::FriendAddTiliResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FriendAddTiliResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

FriendAddTiliResp::FriendAddTiliResp(const FriendAddTiliResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FriendAddTiliResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FriendAddTiliResp::~FriendAddTiliResp() {
  SharedDtor();
}

void FriendAddTiliResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void FriendAddTiliResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FriendAddTiliResp& FriendAddTiliResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

FriendAddTiliResp* FriendAddTiliResp::default_instance_ = NULL;

FriendAddTiliResp* FriendAddTiliResp::New() const {
  return new FriendAddTiliResp;
}

void FriendAddTiliResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FriendAddTiliResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FriendAddTiliResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int FriendAddTiliResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FriendAddTiliResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FriendAddTiliResp*>(&from));
}

void FriendAddTiliResp::MergeFrom(const FriendAddTiliResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void FriendAddTiliResp::CopyFrom(const FriendAddTiliResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FriendAddTiliResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void FriendAddTiliResp::Swap(FriendAddTiliResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FriendAddTiliResp::GetTypeName() const {
  return "FriendAddTiliResp";
}


// ===================================================================

#ifndef _MSC_VER
const int FriendAddTiliUpdate::kResultFieldNumber;
const int FriendAddTiliUpdate::kInfoFieldNumber;
#endif  // !_MSC_VER

FriendAddTiliUpdate::FriendAddTiliUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FriendAddTiliUpdate::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  info_ = const_cast< ::OtherUserInfo*>(
      ::OtherUserInfo::internal_default_instance());
#else
  info_ = const_cast< ::OtherUserInfo*>(&::OtherUserInfo::default_instance());
#endif
}

FriendAddTiliUpdate::FriendAddTiliUpdate(const FriendAddTiliUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FriendAddTiliUpdate::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FriendAddTiliUpdate::~FriendAddTiliUpdate() {
  SharedDtor();
}

void FriendAddTiliUpdate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete info_;
  }
}

void FriendAddTiliUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FriendAddTiliUpdate& FriendAddTiliUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

FriendAddTiliUpdate* FriendAddTiliUpdate::default_instance_ = NULL;

FriendAddTiliUpdate* FriendAddTiliUpdate::New() const {
  return new FriendAddTiliUpdate;
}

void FriendAddTiliUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_info()) {
      if (info_ != NULL) info_->::OtherUserInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FriendAddTiliUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_info;
        break;
      }

      // required .OtherUserInfo info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FriendAddTiliUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // required .OtherUserInfo info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->info(), output);
  }

}

int FriendAddTiliUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // required .OtherUserInfo info = 2;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FriendAddTiliUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FriendAddTiliUpdate*>(&from));
}

void FriendAddTiliUpdate::MergeFrom(const FriendAddTiliUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_info()) {
      mutable_info()->::OtherUserInfo::MergeFrom(from.info());
    }
  }
}

void FriendAddTiliUpdate::CopyFrom(const FriendAddTiliUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FriendAddTiliUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void FriendAddTiliUpdate::Swap(FriendAddTiliUpdate* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FriendAddTiliUpdate::GetTypeName() const {
  return "FriendAddTiliUpdate";
}


// ===================================================================

#ifndef _MSC_VER
const int FriendReadTiliReq::kUserNameFieldNumber;
#endif  // !_MSC_VER

FriendReadTiliReq::FriendReadTiliReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FriendReadTiliReq::InitAsDefaultInstance() {
}

FriendReadTiliReq::FriendReadTiliReq(const FriendReadTiliReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FriendReadTiliReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FriendReadTiliReq::~FriendReadTiliReq() {
  SharedDtor();
}

void FriendReadTiliReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FriendReadTiliReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FriendReadTiliReq& FriendReadTiliReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

FriendReadTiliReq* FriendReadTiliReq::default_instance_ = NULL;

FriendReadTiliReq* FriendReadTiliReq::New() const {
  return new FriendReadTiliReq;
}

void FriendReadTiliReq::Clear() {
  user_name_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FriendReadTiliReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string user_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_user_name;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FriendReadTiliReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string user_name = 1;
  for (int i = 0; i < this->user_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name(i), output);
  }

}

int FriendReadTiliReq::ByteSize() const {
  int total_size = 0;

  // repeated string user_name = 1;
  total_size += 1 * this->user_name_size();
  for (int i = 0; i < this->user_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->user_name(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FriendReadTiliReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FriendReadTiliReq*>(&from));
}

void FriendReadTiliReq::MergeFrom(const FriendReadTiliReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_name_.MergeFrom(from.user_name_);
}

void FriendReadTiliReq::CopyFrom(const FriendReadTiliReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FriendReadTiliReq::IsInitialized() const {

  return true;
}

void FriendReadTiliReq::Swap(FriendReadTiliReq* other) {
  if (other != this) {
    user_name_.Swap(&other->user_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FriendReadTiliReq::GetTypeName() const {
  return "FriendReadTiliReq";
}


// ===================================================================

#ifndef _MSC_VER
const int FriendReadTiliResp::kResultFieldNumber;
const int FriendReadTiliResp::kUserSyncFieldNumber;
const int FriendReadTiliResp::kAllTiliFieldNumber;
#endif  // !_MSC_VER

FriendReadTiliResp::FriendReadTiliResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FriendReadTiliResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

FriendReadTiliResp::FriendReadTiliResp(const FriendReadTiliResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FriendReadTiliResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  all_tili_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FriendReadTiliResp::~FriendReadTiliResp() {
  SharedDtor();
}

void FriendReadTiliResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void FriendReadTiliResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FriendReadTiliResp& FriendReadTiliResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

FriendReadTiliResp* FriendReadTiliResp::default_instance_ = NULL;

FriendReadTiliResp* FriendReadTiliResp::New() const {
  return new FriendReadTiliResp;
}

void FriendReadTiliResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    all_tili_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FriendReadTiliResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_all_tili;
        break;
      }

      // optional int32 all_tili = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_all_tili:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &all_tili_)));
          set_has_all_tili();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FriendReadTiliResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional int32 all_tili = 3;
  if (has_all_tili()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->all_tili(), output);
  }

}

int FriendReadTiliResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 all_tili = 3;
    if (has_all_tili()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->all_tili());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FriendReadTiliResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FriendReadTiliResp*>(&from));
}

void FriendReadTiliResp::MergeFrom(const FriendReadTiliResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_all_tili()) {
      set_all_tili(from.all_tili());
    }
  }
}

void FriendReadTiliResp::CopyFrom(const FriendReadTiliResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FriendReadTiliResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void FriendReadTiliResp::Swap(FriendReadTiliResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(all_tili_, other->all_tili_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FriendReadTiliResp::GetTypeName() const {
  return "FriendReadTiliResp";
}


// ===================================================================

#ifndef _MSC_VER
const int BlackListReq::kTypeFieldNumber;
const int BlackListReq::kUserNameFieldNumber;
#endif  // !_MSC_VER

BlackListReq::BlackListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BlackListReq::InitAsDefaultInstance() {
}

BlackListReq::BlackListReq(const BlackListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BlackListReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlackListReq::~BlackListReq() {
  SharedDtor();
}

void BlackListReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BlackListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BlackListReq& BlackListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

BlackListReq* BlackListReq::default_instance_ = NULL;

BlackListReq* BlackListReq::New() const {
  return new BlackListReq;
}

void BlackListReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BlackListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name;
        break;
      }

      // required string user_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BlackListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required string user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->user_name(), output);
  }

}

int BlackListReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required string user_name = 2;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlackListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BlackListReq*>(&from));
}

void BlackListReq::MergeFrom(const BlackListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
  }
}

void BlackListReq::CopyFrom(const BlackListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlackListReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BlackListReq::Swap(BlackListReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(user_name_, other->user_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BlackListReq::GetTypeName() const {
  return "BlackListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int BlackListResp::kResultFieldNumber;
#endif  // !_MSC_VER

BlackListResp::BlackListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BlackListResp::InitAsDefaultInstance() {
}

BlackListResp::BlackListResp(const BlackListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BlackListResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlackListResp::~BlackListResp() {
  SharedDtor();
}

void BlackListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BlackListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BlackListResp& BlackListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

BlackListResp* BlackListResp::default_instance_ = NULL;

BlackListResp* BlackListResp::New() const {
  return new BlackListResp;
}

void BlackListResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BlackListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BlackListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int BlackListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlackListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BlackListResp*>(&from));
}

void BlackListResp::MergeFrom(const BlackListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void BlackListResp::CopyFrom(const BlackListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlackListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BlackListResp::Swap(BlackListResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BlackListResp::GetTypeName() const {
  return "BlackListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int TalkListReq::kTypeFieldNumber;
const int TalkListReq::kUserNameFieldNumber;
#endif  // !_MSC_VER

TalkListReq::TalkListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TalkListReq::InitAsDefaultInstance() {
}

TalkListReq::TalkListReq(const TalkListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TalkListReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TalkListReq::~TalkListReq() {
  SharedDtor();
}

void TalkListReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TalkListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TalkListReq& TalkListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

TalkListReq* TalkListReq::default_instance_ = NULL;

TalkListReq* TalkListReq::New() const {
  return new TalkListReq;
}

void TalkListReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::kEmptyString) {
        user_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TalkListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name;
        break;
      }

      // required string user_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TalkListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // required string user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->user_name(), output);
  }

}

int TalkListReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required string user_name = 2;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TalkListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TalkListReq*>(&from));
}

void TalkListReq::MergeFrom(const TalkListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
  }
}

void TalkListReq::CopyFrom(const TalkListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TalkListReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TalkListReq::Swap(TalkListReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(user_name_, other->user_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TalkListReq::GetTypeName() const {
  return "TalkListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int TalkListResp::kResultFieldNumber;
#endif  // !_MSC_VER

TalkListResp::TalkListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TalkListResp::InitAsDefaultInstance() {
}

TalkListResp::TalkListResp(const TalkListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TalkListResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TalkListResp::~TalkListResp() {
  SharedDtor();
}

void TalkListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TalkListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TalkListResp& TalkListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

TalkListResp* TalkListResp::default_instance_ = NULL;

TalkListResp* TalkListResp::New() const {
  return new TalkListResp;
}

void TalkListResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TalkListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TalkListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int TalkListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TalkListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TalkListResp*>(&from));
}

void TalkListResp::MergeFrom(const TalkListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void TalkListResp::CopyFrom(const TalkListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TalkListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TalkListResp::Swap(TalkListResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TalkListResp::GetTypeName() const {
  return "TalkListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int TaskListResp::kResultFieldNumber;
const int TaskListResp::kUserSyncFieldNumber;
const int TaskListResp::kTaskListFieldNumber;
#endif  // !_MSC_VER

TaskListResp::TaskListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TaskListResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

TaskListResp::TaskListResp(const TaskListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TaskListResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskListResp::~TaskListResp() {
  SharedDtor();
}

void TaskListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void TaskListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TaskListResp& TaskListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

TaskListResp* TaskListResp::default_instance_ = NULL;

TaskListResp* TaskListResp::New() const {
  return new TaskListResp;
}

void TaskListResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  task_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TaskListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_task_list;
        break;
      }

      // repeated .TaskInfo task_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_task_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_task_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TaskListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .TaskInfo task_list = 3;
  for (int i = 0; i < this->task_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->task_list(i), output);
  }

}

int TaskListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .TaskInfo task_list = 3;
  total_size += 1 * this->task_list_size();
  for (int i = 0; i < this->task_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->task_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TaskListResp*>(&from));
}

void TaskListResp::MergeFrom(const TaskListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  task_list_.MergeFrom(from.task_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void TaskListResp::CopyFrom(const TaskListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < task_list_size(); i++) {
    if (!this->task_list(i).IsInitialized()) return false;
  }
  return true;
}

void TaskListResp::Swap(TaskListResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    task_list_.Swap(&other->task_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TaskListResp::GetTypeName() const {
  return "TaskListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int TaskRewardReq::kTaskIdFieldNumber;
const int TaskRewardReq::kOtherFieldNumber;
#endif  // !_MSC_VER

TaskRewardReq::TaskRewardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TaskRewardReq::InitAsDefaultInstance() {
}

TaskRewardReq::TaskRewardReq(const TaskRewardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TaskRewardReq::SharedCtor() {
  _cached_size_ = 0;
  task_id_ = 0;
  other_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskRewardReq::~TaskRewardReq() {
  SharedDtor();
}

void TaskRewardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TaskRewardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TaskRewardReq& TaskRewardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

TaskRewardReq* TaskRewardReq::default_instance_ = NULL;

TaskRewardReq* TaskRewardReq::New() const {
  return new TaskRewardReq;
}

void TaskRewardReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    task_id_ = 0;
    other_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TaskRewardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 task_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &task_id_)));
          set_has_task_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_other;
        break;
      }

      // optional int32 other = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_other:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &other_)));
          set_has_other();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TaskRewardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 task_id = 1;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->task_id(), output);
  }

  // optional int32 other = 2;
  if (has_other()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->other(), output);
  }

}

int TaskRewardReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 task_id = 1;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->task_id());
    }

    // optional int32 other = 2;
    if (has_other()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->other());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskRewardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TaskRewardReq*>(&from));
}

void TaskRewardReq::MergeFrom(const TaskRewardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_other()) {
      set_other(from.other());
    }
  }
}

void TaskRewardReq::CopyFrom(const TaskRewardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskRewardReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TaskRewardReq::Swap(TaskRewardReq* other) {
  if (other != this) {
    std::swap(task_id_, other->task_id_);
    std::swap(other_, other->other_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TaskRewardReq::GetTypeName() const {
  return "TaskRewardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int TaskRewardResp::kResultFieldNumber;
const int TaskRewardResp::kUserSyncFieldNumber;
const int TaskRewardResp::kTaskIdFieldNumber;
const int TaskRewardResp::kOtherFieldNumber;
#endif  // !_MSC_VER

TaskRewardResp::TaskRewardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TaskRewardResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

TaskRewardResp::TaskRewardResp(const TaskRewardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TaskRewardResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  task_id_ = 0;
  other_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskRewardResp::~TaskRewardResp() {
  SharedDtor();
}

void TaskRewardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void TaskRewardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TaskRewardResp& TaskRewardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

TaskRewardResp* TaskRewardResp::default_instance_ = NULL;

TaskRewardResp* TaskRewardResp::New() const {
  return new TaskRewardResp;
}

void TaskRewardResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    task_id_ = 0;
    other_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TaskRewardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_task_id;
        break;
      }

      // optional int32 task_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_task_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &task_id_)));
          set_has_task_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_other;
        break;
      }

      // optional int32 other = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_other:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &other_)));
          set_has_other();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TaskRewardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional int32 task_id = 3;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->task_id(), output);
  }

  // optional int32 other = 4;
  if (has_other()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->other(), output);
  }

}

int TaskRewardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional int32 task_id = 3;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->task_id());
    }

    // optional int32 other = 4;
    if (has_other()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->other());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskRewardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TaskRewardResp*>(&from));
}

void TaskRewardResp::MergeFrom(const TaskRewardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_other()) {
      set_other(from.other());
    }
  }
}

void TaskRewardResp::CopyFrom(const TaskRewardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskRewardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void TaskRewardResp::Swap(TaskRewardResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(task_id_, other->task_id_);
    std::swap(other_, other->other_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TaskRewardResp::GetTypeName() const {
  return "TaskRewardResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GetStrengthResp::kResultFieldNumber;
const int GetStrengthResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GetStrengthResp::GetStrengthResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetStrengthResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GetStrengthResp::GetStrengthResp(const GetStrengthResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetStrengthResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetStrengthResp::~GetStrengthResp() {
  SharedDtor();
}

void GetStrengthResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GetStrengthResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetStrengthResp& GetStrengthResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

GetStrengthResp* GetStrengthResp::default_instance_ = NULL;

GetStrengthResp* GetStrengthResp::New() const {
  return new GetStrengthResp;
}

void GetStrengthResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetStrengthResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetStrengthResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GetStrengthResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetStrengthResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetStrengthResp*>(&from));
}

void GetStrengthResp::MergeFrom(const GetStrengthResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GetStrengthResp::CopyFrom(const GetStrengthResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetStrengthResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GetStrengthResp::Swap(GetStrengthResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetStrengthResp::GetTypeName() const {
  return "GetStrengthResp";
}


// ===================================================================

#ifndef _MSC_VER
const int AddStrengthReq::kTypeFieldNumber;
const int AddStrengthReq::kItemFieldNumber;
#endif  // !_MSC_VER

AddStrengthReq::AddStrengthReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddStrengthReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::Pair*>(
      ::Pair::internal_default_instance());
#else
  item_ = const_cast< ::Pair*>(&::Pair::default_instance());
#endif
}

AddStrengthReq::AddStrengthReq(const AddStrengthReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddStrengthReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddStrengthReq::~AddStrengthReq() {
  SharedDtor();
}

void AddStrengthReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete item_;
  }
}

void AddStrengthReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddStrengthReq& AddStrengthReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

AddStrengthReq* AddStrengthReq::default_instance_ = NULL;

AddStrengthReq* AddStrengthReq::New() const {
  return new AddStrengthReq;
}

void AddStrengthReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_item()) {
      if (item_ != NULL) item_->::Pair::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddStrengthReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_item;
        break;
      }

      // optional .Pair item = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddStrengthReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional .Pair item = 2;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->item(), output);
  }

}

int AddStrengthReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional .Pair item = 2;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddStrengthReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddStrengthReq*>(&from));
}

void AddStrengthReq::MergeFrom(const AddStrengthReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_item()) {
      mutable_item()->::Pair::MergeFrom(from.item());
    }
  }
}

void AddStrengthReq::CopyFrom(const AddStrengthReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddStrengthReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_item()) {
    if (!this->item().IsInitialized()) return false;
  }
  return true;
}

void AddStrengthReq::Swap(AddStrengthReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(item_, other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddStrengthReq::GetTypeName() const {
  return "AddStrengthReq";
}


// ===================================================================

bool AddStrengthResp_AddStrengthRet_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const AddStrengthResp_AddStrengthRet AddStrengthResp::OK;
const AddStrengthResp_AddStrengthRet AddStrengthResp::FAIL;
const AddStrengthResp_AddStrengthRet AddStrengthResp::REQ_DATA_ERROR;
const AddStrengthResp_AddStrengthRet AddStrengthResp::NO_ITEM;
const AddStrengthResp_AddStrengthRet AddStrengthResp::ITEM_KEY_ERROR;
const AddStrengthResp_AddStrengthRet AddStrengthResp::MAX_TIMES;
const AddStrengthResp_AddStrengthRet AddStrengthResp::NO_MONEY;
const AddStrengthResp_AddStrengthRet AddStrengthResp::AddStrengthRet_MIN;
const AddStrengthResp_AddStrengthRet AddStrengthResp::AddStrengthRet_MAX;
const int AddStrengthResp::AddStrengthRet_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int AddStrengthResp::kResultFieldNumber;
const int AddStrengthResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

AddStrengthResp::AddStrengthResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AddStrengthResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

AddStrengthResp::AddStrengthResp(const AddStrengthResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AddStrengthResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddStrengthResp::~AddStrengthResp() {
  SharedDtor();
}

void AddStrengthResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void AddStrengthResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AddStrengthResp& AddStrengthResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

AddStrengthResp* AddStrengthResp::default_instance_ = NULL;

AddStrengthResp* AddStrengthResp::New() const {
  return new AddStrengthResp;
}

void AddStrengthResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AddStrengthResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .AddStrengthResp.AddStrengthRet result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::AddStrengthResp_AddStrengthRet_IsValid(value)) {
            set_result(static_cast< ::AddStrengthResp_AddStrengthRet >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AddStrengthResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .AddStrengthResp.AddStrengthRet result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int AddStrengthResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .AddStrengthResp.AddStrengthRet result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddStrengthResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AddStrengthResp*>(&from));
}

void AddStrengthResp::MergeFrom(const AddStrengthResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void AddStrengthResp::CopyFrom(const AddStrengthResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddStrengthResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void AddStrengthResp::Swap(AddStrengthResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AddStrengthResp::GetTypeName() const {
  return "AddStrengthResp";
}


// ===================================================================

bool RankReq_RankType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const RankReq_RankType RankReq::PLAYER_LEVEL;
const RankReq_RankType RankReq::PLAYER_POWER;
const RankReq_RankType RankReq::MAIN_CITY_LEVEL;
const RankReq_RankType RankReq::GROUP_POWER;
const RankReq_RankType RankReq::ARENA;
const RankReq_RankType RankReq::TRIAL;
const RankReq_RankType RankReq::RankType_MIN;
const RankReq_RankType RankReq::RankType_MAX;
const int RankReq::RankType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int RankReq::kRankTypeFieldNumber;
const int RankReq::kStartRankFieldNumber;
const int RankReq::kNeedMyFieldNumber;
#endif  // !_MSC_VER

RankReq::RankReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RankReq::InitAsDefaultInstance() {
}

RankReq::RankReq(const RankReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RankReq::SharedCtor() {
  _cached_size_ = 0;
  rank_type_ = 1;
  start_rank_ = 0;
  need_my_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RankReq::~RankReq() {
  SharedDtor();
}

void RankReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RankReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RankReq& RankReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

RankReq* RankReq::default_instance_ = NULL;

RankReq* RankReq::New() const {
  return new RankReq;
}

void RankReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rank_type_ = 1;
    start_rank_ = 0;
    need_my_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RankReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .RankReq.RankType rank_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::RankReq_RankType_IsValid(value)) {
            set_rank_type(static_cast< ::RankReq_RankType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_start_rank;
        break;
      }

      // required int32 start_rank = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_rank_)));
          set_has_start_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_need_my;
        break;
      }

      // required bool need_my = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_need_my:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &need_my_)));
          set_has_need_my();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RankReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .RankReq.RankType rank_type = 1;
  if (has_rank_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->rank_type(), output);
  }

  // required int32 start_rank = 2;
  if (has_start_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->start_rank(), output);
  }

  // required bool need_my = 3;
  if (has_need_my()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->need_my(), output);
  }

}

int RankReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .RankReq.RankType rank_type = 1;
    if (has_rank_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rank_type());
    }

    // required int32 start_rank = 2;
    if (has_start_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start_rank());
    }

    // required bool need_my = 3;
    if (has_need_my()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RankReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RankReq*>(&from));
}

void RankReq::MergeFrom(const RankReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rank_type()) {
      set_rank_type(from.rank_type());
    }
    if (from.has_start_rank()) {
      set_start_rank(from.start_rank());
    }
    if (from.has_need_my()) {
      set_need_my(from.need_my());
    }
  }
}

void RankReq::CopyFrom(const RankReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RankReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RankReq::Swap(RankReq* other) {
  if (other != this) {
    std::swap(rank_type_, other->rank_type_);
    std::swap(start_rank_, other->start_rank_);
    std::swap(need_my_, other->need_my_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RankReq::GetTypeName() const {
  return "RankReq";
}


// ===================================================================

#ifndef _MSC_VER
const int RankResp::kResultFieldNumber;
const int RankResp::kUserSyncFieldNumber;
const int RankResp::kUserRankFieldNumber;
const int RankResp::kGroupRankFieldNumber;
const int RankResp::kMyUserRankFieldNumber;
const int RankResp::kMyGroupRankFieldNumber;
#endif  // !_MSC_VER

RankResp::RankResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RankResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  my_user_rank_ = const_cast< ::OtherUserInfo*>(
      ::OtherUserInfo::internal_default_instance());
#else
  my_user_rank_ = const_cast< ::OtherUserInfo*>(&::OtherUserInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  my_group_rank_ = const_cast< ::OtherGroupInfo*>(
      ::OtherGroupInfo::internal_default_instance());
#else
  my_group_rank_ = const_cast< ::OtherGroupInfo*>(&::OtherGroupInfo::default_instance());
#endif
}

RankResp::RankResp(const RankResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RankResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  my_user_rank_ = NULL;
  my_group_rank_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RankResp::~RankResp() {
  SharedDtor();
}

void RankResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete my_user_rank_;
    delete my_group_rank_;
  }
}

void RankResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RankResp& RankResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

RankResp* RankResp::default_instance_ = NULL;

RankResp* RankResp::New() const {
  return new RankResp;
}

void RankResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_my_user_rank()) {
      if (my_user_rank_ != NULL) my_user_rank_->::OtherUserInfo::Clear();
    }
    if (has_my_group_rank()) {
      if (my_group_rank_ != NULL) my_group_rank_->::OtherGroupInfo::Clear();
    }
  }
  user_rank_.Clear();
  group_rank_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RankResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_rank;
        break;
      }

      // repeated .OtherUserInfo user_rank = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_rank:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_rank()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_rank;
        if (input->ExpectTag(34)) goto parse_group_rank;
        break;
      }

      // repeated .OtherGroupInfo group_rank = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group_rank:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_group_rank()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_group_rank;
        if (input->ExpectTag(42)) goto parse_my_user_rank;
        break;
      }

      // optional .OtherUserInfo my_user_rank = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_my_user_rank:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_my_user_rank()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_my_group_rank;
        break;
      }

      // optional .OtherGroupInfo my_group_rank = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_my_group_rank:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_my_group_rank()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RankResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .OtherUserInfo user_rank = 3;
  for (int i = 0; i < this->user_rank_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->user_rank(i), output);
  }

  // repeated .OtherGroupInfo group_rank = 4;
  for (int i = 0; i < this->group_rank_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->group_rank(i), output);
  }

  // optional .OtherUserInfo my_user_rank = 5;
  if (has_my_user_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->my_user_rank(), output);
  }

  // optional .OtherGroupInfo my_group_rank = 6;
  if (has_my_group_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->my_group_rank(), output);
  }

}

int RankResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .OtherUserInfo my_user_rank = 5;
    if (has_my_user_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->my_user_rank());
    }

    // optional .OtherGroupInfo my_group_rank = 6;
    if (has_my_group_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->my_group_rank());
    }

  }
  // repeated .OtherUserInfo user_rank = 3;
  total_size += 1 * this->user_rank_size();
  for (int i = 0; i < this->user_rank_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_rank(i));
  }

  // repeated .OtherGroupInfo group_rank = 4;
  total_size += 1 * this->group_rank_size();
  for (int i = 0; i < this->group_rank_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->group_rank(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RankResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RankResp*>(&from));
}

void RankResp::MergeFrom(const RankResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_rank_.MergeFrom(from.user_rank_);
  group_rank_.MergeFrom(from.group_rank_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_my_user_rank()) {
      mutable_my_user_rank()->::OtherUserInfo::MergeFrom(from.my_user_rank());
    }
    if (from.has_my_group_rank()) {
      mutable_my_group_rank()->::OtherGroupInfo::MergeFrom(from.my_group_rank());
    }
  }
}

void RankResp::CopyFrom(const RankResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RankResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < user_rank_size(); i++) {
    if (!this->user_rank(i).IsInitialized()) return false;
  }
  for (int i = 0; i < group_rank_size(); i++) {
    if (!this->group_rank(i).IsInitialized()) return false;
  }
  if (has_my_user_rank()) {
    if (!this->my_user_rank().IsInitialized()) return false;
  }
  if (has_my_group_rank()) {
    if (!this->my_group_rank().IsInitialized()) return false;
  }
  return true;
}

void RankResp::Swap(RankResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    user_rank_.Swap(&other->user_rank_);
    group_rank_.Swap(&other->group_rank_);
    std::swap(my_user_rank_, other->my_user_rank_);
    std::swap(my_group_rank_, other->my_group_rank_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RankResp::GetTypeName() const {
  return "RankResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ShopTimeItemListResp_TimeItem::kIdFieldNumber;
const int ShopTimeItemListResp_TimeItem::kEndTimeFieldNumber;
#endif  // !_MSC_VER

ShopTimeItemListResp_TimeItem::ShopTimeItemListResp_TimeItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShopTimeItemListResp_TimeItem::InitAsDefaultInstance() {
}

ShopTimeItemListResp_TimeItem::ShopTimeItemListResp_TimeItem(const ShopTimeItemListResp_TimeItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShopTimeItemListResp_TimeItem::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  end_time_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShopTimeItemListResp_TimeItem::~ShopTimeItemListResp_TimeItem() {
  SharedDtor();
}

void ShopTimeItemListResp_TimeItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShopTimeItemListResp_TimeItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShopTimeItemListResp_TimeItem& ShopTimeItemListResp_TimeItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ShopTimeItemListResp_TimeItem* ShopTimeItemListResp_TimeItem::default_instance_ = NULL;

ShopTimeItemListResp_TimeItem* ShopTimeItemListResp_TimeItem::New() const {
  return new ShopTimeItemListResp_TimeItem;
}

void ShopTimeItemListResp_TimeItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    end_time_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShopTimeItemListResp_TimeItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_end_time;
        break;
      }

      // required int64 end_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &end_time_)));
          set_has_end_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShopTimeItemListResp_TimeItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // required int64 end_time = 2;
  if (has_end_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->end_time(), output);
  }

}

int ShopTimeItemListResp_TimeItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required int64 end_time = 2;
    if (has_end_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->end_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShopTimeItemListResp_TimeItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShopTimeItemListResp_TimeItem*>(&from));
}

void ShopTimeItemListResp_TimeItem::MergeFrom(const ShopTimeItemListResp_TimeItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_end_time()) {
      set_end_time(from.end_time());
    }
  }
}

void ShopTimeItemListResp_TimeItem::CopyFrom(const ShopTimeItemListResp_TimeItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShopTimeItemListResp_TimeItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ShopTimeItemListResp_TimeItem::Swap(ShopTimeItemListResp_TimeItem* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(end_time_, other->end_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShopTimeItemListResp_TimeItem::GetTypeName() const {
  return "ShopTimeItemListResp.TimeItem";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ShopTimeItemListResp::kResultFieldNumber;
const int ShopTimeItemListResp::kUserSyncFieldNumber;
const int ShopTimeItemListResp::kListFieldNumber;
#endif  // !_MSC_VER

ShopTimeItemListResp::ShopTimeItemListResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShopTimeItemListResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ShopTimeItemListResp::ShopTimeItemListResp(const ShopTimeItemListResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShopTimeItemListResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShopTimeItemListResp::~ShopTimeItemListResp() {
  SharedDtor();
}

void ShopTimeItemListResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ShopTimeItemListResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShopTimeItemListResp& ShopTimeItemListResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ShopTimeItemListResp* ShopTimeItemListResp::default_instance_ = NULL;

ShopTimeItemListResp* ShopTimeItemListResp::New() const {
  return new ShopTimeItemListResp;
}

void ShopTimeItemListResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShopTimeItemListResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_list;
        break;
      }

      // repeated .ShopTimeItemListResp.TimeItem list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShopTimeItemListResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .ShopTimeItemListResp.TimeItem list = 3;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->list(i), output);
  }

}

int ShopTimeItemListResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .ShopTimeItemListResp.TimeItem list = 3;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShopTimeItemListResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShopTimeItemListResp*>(&from));
}

void ShopTimeItemListResp::MergeFrom(const ShopTimeItemListResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void ShopTimeItemListResp::CopyFrom(const ShopTimeItemListResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShopTimeItemListResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < list_size(); i++) {
    if (!this->list(i).IsInitialized()) return false;
  }
  return true;
}

void ShopTimeItemListResp::Swap(ShopTimeItemListResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShopTimeItemListResp::GetTypeName() const {
  return "ShopTimeItemListResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ShopBuyReq::kIdFieldNumber;
const int ShopBuyReq::kNumFieldNumber;
#endif  // !_MSC_VER

ShopBuyReq::ShopBuyReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShopBuyReq::InitAsDefaultInstance() {
}

ShopBuyReq::ShopBuyReq(const ShopBuyReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShopBuyReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShopBuyReq::~ShopBuyReq() {
  SharedDtor();
}

void ShopBuyReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShopBuyReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShopBuyReq& ShopBuyReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ShopBuyReq* ShopBuyReq::default_instance_ = NULL;

ShopBuyReq* ShopBuyReq::New() const {
  return new ShopBuyReq;
}

void ShopBuyReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    num_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShopBuyReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_num;
        break;
      }

      // required int32 num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShopBuyReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // required int32 num = 2;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num(), output);
  }

}

int ShopBuyReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required int32 num = 2;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShopBuyReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShopBuyReq*>(&from));
}

void ShopBuyReq::MergeFrom(const ShopBuyReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
}

void ShopBuyReq::CopyFrom(const ShopBuyReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShopBuyReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ShopBuyReq::Swap(ShopBuyReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(num_, other->num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShopBuyReq::GetTypeName() const {
  return "ShopBuyReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ShopBuyResp::kResultFieldNumber;
const int ShopBuyResp::kUserSyncFieldNumber;
const int ShopBuyResp::kReqFieldNumber;
#endif  // !_MSC_VER

ShopBuyResp::ShopBuyResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShopBuyResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::ShopBuyReq*>(
      ::ShopBuyReq::internal_default_instance());
#else
  req_ = const_cast< ::ShopBuyReq*>(&::ShopBuyReq::default_instance());
#endif
}

ShopBuyResp::ShopBuyResp(const ShopBuyResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShopBuyResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  req_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShopBuyResp::~ShopBuyResp() {
  SharedDtor();
}

void ShopBuyResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
    delete req_;
  }
}

void ShopBuyResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShopBuyResp& ShopBuyResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ShopBuyResp* ShopBuyResp::default_instance_ = NULL;

ShopBuyResp* ShopBuyResp::New() const {
  return new ShopBuyResp;
}

void ShopBuyResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
    if (has_req()) {
      if (req_ != NULL) req_->::ShopBuyReq::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShopBuyResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_req;
        break;
      }

      // optional .ShopBuyReq req = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_req:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShopBuyResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // optional .ShopBuyReq req = 3;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->req(), output);
  }

}

int ShopBuyResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

    // optional .ShopBuyReq req = 3;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShopBuyResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShopBuyResp*>(&from));
}

void ShopBuyResp::MergeFrom(const ShopBuyResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
    if (from.has_req()) {
      mutable_req()->::ShopBuyReq::MergeFrom(from.req());
    }
  }
}

void ShopBuyResp::CopyFrom(const ShopBuyResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShopBuyResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  return true;
}

void ShopBuyResp::Swap(ShopBuyResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(req_, other->req_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShopBuyResp::GetTypeName() const {
  return "ShopBuyResp";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipLotteryReq::kIdFieldNumber;
const int ShipLotteryReq::kTypeFieldNumber;
#endif  // !_MSC_VER

ShipLotteryReq::ShipLotteryReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipLotteryReq::InitAsDefaultInstance() {
}

ShipLotteryReq::ShipLotteryReq(const ShipLotteryReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipLotteryReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipLotteryReq::~ShipLotteryReq() {
  SharedDtor();
}

void ShipLotteryReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShipLotteryReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipLotteryReq& ShipLotteryReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ShipLotteryReq* ShipLotteryReq::default_instance_ = NULL;

ShipLotteryReq* ShipLotteryReq::New() const {
  return new ShipLotteryReq;
}

void ShipLotteryReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipLotteryReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required int32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipLotteryReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // required int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

}

int ShipLotteryReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipLotteryReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipLotteryReq*>(&from));
}

void ShipLotteryReq::MergeFrom(const ShipLotteryReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void ShipLotteryReq::CopyFrom(const ShipLotteryReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipLotteryReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ShipLotteryReq::Swap(ShipLotteryReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipLotteryReq::GetTypeName() const {
  return "ShipLotteryReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ShipLotteryResp::kResultFieldNumber;
const int ShipLotteryResp::kUserSyncFieldNumber;
const int ShipLotteryResp::kItemListFieldNumber;
#endif  // !_MSC_VER

ShipLotteryResp::ShipLotteryResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ShipLotteryResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

ShipLotteryResp::ShipLotteryResp(const ShipLotteryResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ShipLotteryResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShipLotteryResp::~ShipLotteryResp() {
  SharedDtor();
}

void ShipLotteryResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void ShipLotteryResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShipLotteryResp& ShipLotteryResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

ShipLotteryResp* ShipLotteryResp::default_instance_ = NULL;

ShipLotteryResp* ShipLotteryResp::New() const {
  return new ShipLotteryResp;
}

void ShipLotteryResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ShipLotteryResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_item_list;
        break;
      }

      // repeated .Item item_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShipLotteryResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .Item item_list = 3;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->item_list(i), output);
  }

}

int ShipLotteryResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .Item item_list = 3;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShipLotteryResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShipLotteryResp*>(&from));
}

void ShipLotteryResp::MergeFrom(const ShipLotteryResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void ShipLotteryResp::CopyFrom(const ShipLotteryResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShipLotteryResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < item_list_size(); i++) {
    if (!this->item_list(i).IsInitialized()) return false;
  }
  return true;
}

void ShipLotteryResp::Swap(ShipLotteryResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    item_list_.Swap(&other->item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShipLotteryResp::GetTypeName() const {
  return "ShipLotteryResp";
}


// ===================================================================

#ifndef _MSC_VER
const int IsOnlineReq::kUserNameListFieldNumber;
#endif  // !_MSC_VER

IsOnlineReq::IsOnlineReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IsOnlineReq::InitAsDefaultInstance() {
}

IsOnlineReq::IsOnlineReq(const IsOnlineReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IsOnlineReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IsOnlineReq::~IsOnlineReq() {
  SharedDtor();
}

void IsOnlineReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IsOnlineReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IsOnlineReq& IsOnlineReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

IsOnlineReq* IsOnlineReq::default_instance_ = NULL;

IsOnlineReq* IsOnlineReq::New() const {
  return new IsOnlineReq;
}

void IsOnlineReq::Clear() {
  user_name_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IsOnlineReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string user_name_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_user_name_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_user_name_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IsOnlineReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string user_name_list = 1;
  for (int i = 0; i < this->user_name_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->user_name_list(i), output);
  }

}

int IsOnlineReq::ByteSize() const {
  int total_size = 0;

  // repeated string user_name_list = 1;
  total_size += 1 * this->user_name_list_size();
  for (int i = 0; i < this->user_name_list_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->user_name_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IsOnlineReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IsOnlineReq*>(&from));
}

void IsOnlineReq::MergeFrom(const IsOnlineReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_name_list_.MergeFrom(from.user_name_list_);
}

void IsOnlineReq::CopyFrom(const IsOnlineReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IsOnlineReq::IsInitialized() const {

  return true;
}

void IsOnlineReq::Swap(IsOnlineReq* other) {
  if (other != this) {
    user_name_list_.Swap(&other->user_name_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IsOnlineReq::GetTypeName() const {
  return "IsOnlineReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IsOnlineResp::kResultFieldNumber;
const int IsOnlineResp::kUserSyncFieldNumber;
const int IsOnlineResp::kUserNameListFieldNumber;
const int IsOnlineResp::kIsOnlineListFieldNumber;
#endif  // !_MSC_VER

IsOnlineResp::IsOnlineResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IsOnlineResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

IsOnlineResp::IsOnlineResp(const IsOnlineResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IsOnlineResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IsOnlineResp::~IsOnlineResp() {
  SharedDtor();
}

void IsOnlineResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void IsOnlineResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IsOnlineResp& IsOnlineResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

IsOnlineResp* IsOnlineResp::default_instance_ = NULL;

IsOnlineResp* IsOnlineResp::New() const {
  return new IsOnlineResp;
}

void IsOnlineResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  user_name_list_.Clear();
  is_online_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IsOnlineResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_name_list;
        break;
      }

      // repeated string user_name_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_user_name_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user_name_list;
        if (input->ExpectTag(32)) goto parse_is_online_list;
        break;
      }

      // repeated bool is_online_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_online_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 32, input, this->mutable_is_online_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_is_online_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_online_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IsOnlineResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated string user_name_list = 3;
  for (int i = 0; i < this->user_name_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->user_name_list(i), output);
  }

  // repeated bool is_online_list = 4;
  for (int i = 0; i < this->is_online_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      4, this->is_online_list(i), output);
  }

}

int IsOnlineResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated string user_name_list = 3;
  total_size += 1 * this->user_name_list_size();
  for (int i = 0; i < this->user_name_list_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->user_name_list(i));
  }

  // repeated bool is_online_list = 4;
  {
    int data_size = 0;
    data_size = 1 * this->is_online_list_size();
    total_size += 1 * this->is_online_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IsOnlineResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IsOnlineResp*>(&from));
}

void IsOnlineResp::MergeFrom(const IsOnlineResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_name_list_.MergeFrom(from.user_name_list_);
  is_online_list_.MergeFrom(from.is_online_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void IsOnlineResp::CopyFrom(const IsOnlineResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IsOnlineResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void IsOnlineResp::Swap(IsOnlineResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    user_name_list_.Swap(&other->user_name_list_);
    is_online_list_.Swap(&other->is_online_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IsOnlineResp::GetTypeName() const {
  return "IsOnlineResp";
}


// ===================================================================

#ifndef _MSC_VER
const int GuideStepReq::kTypeFieldNumber;
const int GuideStepReq::kStepIndexFieldNumber;
const int GuideStepReq::kStepNumFieldNumber;
const int GuideStepReq::kTalkKeyFieldNumber;
#endif  // !_MSC_VER

GuideStepReq::GuideStepReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GuideStepReq::InitAsDefaultInstance() {
}

GuideStepReq::GuideStepReq(const GuideStepReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GuideStepReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  step_index_ = 0;
  step_num_ = 0;
  talk_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GuideStepReq::~GuideStepReq() {
  SharedDtor();
}

void GuideStepReq::SharedDtor() {
  if (talk_key_ != &::google::protobuf::internal::kEmptyString) {
    delete talk_key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GuideStepReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GuideStepReq& GuideStepReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

GuideStepReq* GuideStepReq::default_instance_ = NULL;

GuideStepReq* GuideStepReq::New() const {
  return new GuideStepReq;
}

void GuideStepReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    step_index_ = 0;
    step_num_ = 0;
    if (has_talk_key()) {
      if (talk_key_ != &::google::protobuf::internal::kEmptyString) {
        talk_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GuideStepReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_step_index;
        break;
      }

      // optional int32 step_index = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_step_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &step_index_)));
          set_has_step_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_step_num;
        break;
      }

      // optional int32 step_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_step_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &step_num_)));
          set_has_step_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_talk_key;
        break;
      }

      // optional string talk_key = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_talk_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_talk_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GuideStepReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional int32 step_index = 2;
  if (has_step_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->step_index(), output);
  }

  // optional int32 step_num = 3;
  if (has_step_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->step_num(), output);
  }

  // optional string talk_key = 4;
  if (has_talk_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->talk_key(), output);
  }

}

int GuideStepReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 step_index = 2;
    if (has_step_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->step_index());
    }

    // optional int32 step_num = 3;
    if (has_step_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->step_num());
    }

    // optional string talk_key = 4;
    if (has_talk_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->talk_key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GuideStepReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GuideStepReq*>(&from));
}

void GuideStepReq::MergeFrom(const GuideStepReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_step_index()) {
      set_step_index(from.step_index());
    }
    if (from.has_step_num()) {
      set_step_num(from.step_num());
    }
    if (from.has_talk_key()) {
      set_talk_key(from.talk_key());
    }
  }
}

void GuideStepReq::CopyFrom(const GuideStepReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuideStepReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GuideStepReq::Swap(GuideStepReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(step_index_, other->step_index_);
    std::swap(step_num_, other->step_num_);
    std::swap(talk_key_, other->talk_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GuideStepReq::GetTypeName() const {
  return "GuideStepReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GuideStepResp::kResultFieldNumber;
const int GuideStepResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

GuideStepResp::GuideStepResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GuideStepResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

GuideStepResp::GuideStepResp(const GuideStepResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GuideStepResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GuideStepResp::~GuideStepResp() {
  SharedDtor();
}

void GuideStepResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void GuideStepResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GuideStepResp& GuideStepResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

GuideStepResp* GuideStepResp::default_instance_ = NULL;

GuideStepResp* GuideStepResp::New() const {
  return new GuideStepResp;
}

void GuideStepResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GuideStepResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GuideStepResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int GuideStepResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GuideStepResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GuideStepResp*>(&from));
}

void GuideStepResp::MergeFrom(const GuideStepResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void GuideStepResp::CopyFrom(const GuideStepResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuideStepResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void GuideStepResp::Swap(GuideStepResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GuideStepResp::GetTypeName() const {
  return "GuideStepResp";
}


// ===================================================================

#ifndef _MSC_VER
const int AidAwardReq::kTypeFieldNumber;
#endif  // !_MSC_VER

AidAwardReq::AidAwardReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AidAwardReq::InitAsDefaultInstance() {
}

AidAwardReq::AidAwardReq(const AidAwardReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AidAwardReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AidAwardReq::~AidAwardReq() {
  SharedDtor();
}

void AidAwardReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AidAwardReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AidAwardReq& AidAwardReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

AidAwardReq* AidAwardReq::default_instance_ = NULL;

AidAwardReq* AidAwardReq::New() const {
  return new AidAwardReq;
}

void AidAwardReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AidAwardReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AidAwardReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

}

int AidAwardReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AidAwardReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AidAwardReq*>(&from));
}

void AidAwardReq::MergeFrom(const AidAwardReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void AidAwardReq::CopyFrom(const AidAwardReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AidAwardReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AidAwardReq::Swap(AidAwardReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AidAwardReq::GetTypeName() const {
  return "AidAwardReq";
}


// ===================================================================

#ifndef _MSC_VER
const int AidAwardResp::kResultFieldNumber;
const int AidAwardResp::kUserSyncFieldNumber;
#endif  // !_MSC_VER

AidAwardResp::AidAwardResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AidAwardResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

AidAwardResp::AidAwardResp(const AidAwardResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AidAwardResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AidAwardResp::~AidAwardResp() {
  SharedDtor();
}

void AidAwardResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void AidAwardResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AidAwardResp& AidAwardResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

AidAwardResp* AidAwardResp::default_instance_ = NULL;

AidAwardResp* AidAwardResp::New() const {
  return new AidAwardResp;
}

void AidAwardResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AidAwardResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AidAwardResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

}

int AidAwardResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AidAwardResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AidAwardResp*>(&from));
}

void AidAwardResp::MergeFrom(const AidAwardResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void AidAwardResp::CopyFrom(const AidAwardResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AidAwardResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  return true;
}

void AidAwardResp::Swap(AidAwardResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AidAwardResp::GetTypeName() const {
  return "AidAwardResp";
}


// ===================================================================

#ifndef _MSC_VER
const int OpenGiftReq::kItemIdFieldNumber;
const int OpenGiftReq::kNumFieldNumber;
#endif  // !_MSC_VER

OpenGiftReq::OpenGiftReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OpenGiftReq::InitAsDefaultInstance() {
}

OpenGiftReq::OpenGiftReq(const OpenGiftReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OpenGiftReq::SharedCtor() {
  _cached_size_ = 0;
  item_id_ = 0;
  num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenGiftReq::~OpenGiftReq() {
  SharedDtor();
}

void OpenGiftReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OpenGiftReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenGiftReq& OpenGiftReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

OpenGiftReq* OpenGiftReq::default_instance_ = NULL;

OpenGiftReq* OpenGiftReq::New() const {
  return new OpenGiftReq;
}

void OpenGiftReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    item_id_ = 0;
    num_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OpenGiftReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 item_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_num;
        break;
      }

      // required int32 num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OpenGiftReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 item_id = 1;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->item_id(), output);
  }

  // required int32 num = 2;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num(), output);
  }

}

int OpenGiftReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 item_id = 1;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->item_id());
    }

    // required int32 num = 2;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenGiftReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenGiftReq*>(&from));
}

void OpenGiftReq::MergeFrom(const OpenGiftReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
}

void OpenGiftReq::CopyFrom(const OpenGiftReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenGiftReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void OpenGiftReq::Swap(OpenGiftReq* other) {
  if (other != this) {
    std::swap(item_id_, other->item_id_);
    std::swap(num_, other->num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenGiftReq::GetTypeName() const {
  return "OpenGiftReq";
}


// ===================================================================

#ifndef _MSC_VER
const int OpenGiftResp::kResultFieldNumber;
const int OpenGiftResp::kUserSyncFieldNumber;
const int OpenGiftResp::kGetItemListFieldNumber;
#endif  // !_MSC_VER

OpenGiftResp::OpenGiftResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OpenGiftResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_sync_ = const_cast< ::UserSync*>(
      ::UserSync::internal_default_instance());
#else
  user_sync_ = const_cast< ::UserSync*>(&::UserSync::default_instance());
#endif
}

OpenGiftResp::OpenGiftResp(const OpenGiftResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OpenGiftResp::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  user_sync_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenGiftResp::~OpenGiftResp() {
  SharedDtor();
}

void OpenGiftResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_sync_;
  }
}

void OpenGiftResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenGiftResp& OpenGiftResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CmdUser_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CmdUser_2eproto();
#endif
  return *default_instance_;
}

OpenGiftResp* OpenGiftResp::default_instance_ = NULL;

OpenGiftResp* OpenGiftResp::New() const {
  return new OpenGiftResp;
}

void OpenGiftResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_user_sync()) {
      if (user_sync_ != NULL) user_sync_->::UserSync::Clear();
    }
  }
  get_item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OpenGiftResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_sync;
        break;
      }

      // optional .UserSync user_sync = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_sync:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_sync()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        break;
      }

      // repeated .Item get_item_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_get_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OpenGiftResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .UserSync user_sync = 2;
  if (has_user_sync()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->user_sync(), output);
  }

  // repeated .Item get_item_list = 3;
  for (int i = 0; i < this->get_item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->get_item_list(i), output);
  }

}

int OpenGiftResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .UserSync user_sync = 2;
    if (has_user_sync()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_sync());
    }

  }
  // repeated .Item get_item_list = 3;
  total_size += 1 * this->get_item_list_size();
  for (int i = 0; i < this->get_item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->get_item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenGiftResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenGiftResp*>(&from));
}

void OpenGiftResp::MergeFrom(const OpenGiftResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  get_item_list_.MergeFrom(from.get_item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_user_sync()) {
      mutable_user_sync()->::UserSync::MergeFrom(from.user_sync());
    }
  }
}

void OpenGiftResp::CopyFrom(const OpenGiftResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenGiftResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_user_sync()) {
    if (!this->user_sync().IsInitialized()) return false;
  }
  for (int i = 0; i < get_item_list_size(); i++) {
    if (!this->get_item_list(i).IsInitialized()) return false;
  }
  return true;
}

void OpenGiftResp::Swap(OpenGiftResp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(user_sync_, other->user_sync_);
    get_item_list_.Swap(&other->get_item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenGiftResp::GetTypeName() const {
  return "OpenGiftResp";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
